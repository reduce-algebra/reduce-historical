\section{Boolean Operators}

\begin{Concept}{boolean value}
There are no extra symbols for the truth values true
and false. Instead, \nameref{nil} and the number zero
are interpreted as truth value false in algebraic
programs (see \nameref{false}), while any different
value is considered as true (see \nameref{true}).
\end{Concept}

\begin{Operator}{EQUAL}
\index{equation}
The operator \name{equal} is an infix binary comparison
operator.  It is identical with \name{=}.  It returns \nameref{true} if its two
arguments are equal.

\begin{Syntax}
\meta{expression} \name{equal} \meta{expression}
\end{Syntax}

Equality is given between floating point numbers and integers that have
the same value.

\begin{Examples}
on rounded; \\
a := 4;                      &        A := 4 \\
b := 4.0;                    &        B := 4.0 \\
if a equal b then write "true" else write "false";
			     &        true \\
if a equal 5 then write "true" else write "false";
			     &        false \\
if a equal sqrt(16) then write "true" else write "false";
			     &        true
\end{Examples}
\begin{Comments}
Comparison operators can only be used as conditions in conditional commands
such as \name{if}\ldots\name{then} and \name{repeat}\ldots\name{until}.
\meta{equal} can also be used as a prefix operator.  However, this use
is not encouraged.
\end{Comments}
\end{Operator}


\begin{Operator}{EVENP}
The \name{evenp} logical operator returns \nameref{true} if its argument is an
even integer, and \nameref{nil} if its argument is an odd integer.  An error
message is returned if its argument is not an integer.

\begin{Syntax}
\name{evenp}\(\meta{integer}\) or \name{evenp} \meta{integer}
\end{Syntax}

\meta{integer} must evaluate to an integer.

\begin{Examples}
aa := 1782;                                             &     AA := 1782 \\
if evenp aa then yes else no;                           &     YES \\
if evenp(-3) then yes else no;                          &     NO \\
\end{Examples}

\begin{Comments}
Although you would not ordinarily enter an expression such as the last
example above, note that the negative term must be enclosed in parentheses
to be correctly parsed.  The \name{evenp} operator can only be used in
conditional statements such as \name{if}\ldots\name{then}\ldots\name{else}
or \name{while}\ldots\name{do}.
\end{Comments}
\end{Operator}

\begin{Concept}{false}
The symbol \nameref{nil} and the number zero are considered
as \nameref{boolean value} false if used in a place where
a boolean value is required. Most builtin operators return
\nameref{nil} as false value. Algebraic programs use better zero.
Note that \name{nil} is not printed when returned as result to
a top level evaluation.
\end{Concept}

\begin{Operator}{FREEOF}
The \name{freeof} logical operator returns 
\nameref{true} if its first argument does
not contain its second argument anywhere in its structure.
\begin{Syntax}
\name{freeof}\(\meta{expression},\meta{kernel}\) or
\meta{expression} \name{freeof} \meta{kernel}
\end{Syntax}

\meta{expression} can be any valid scalar REDUCE expression, \meta{kernel} must
be a kernel expression (see \name{kernel}).

\begin{Examples}
a := x + sin(y)**2 + log sin z;
			     &       A := LOG(SIN(Z)) + SIN(Y)^{2}  + X \\
if freeof(a,sin(y)) then write "free" else write "not free";
			     &       not free \\
if freeof(a,sin(x)) then write "free" else write "not free";
			     &       free \\
if a freeof sin z then write "free" else write "not free";
			     &       not free
\end{Examples}

\begin{Comments}
Logical operators can only be used in conditional expressions such as \\
\name{if}\ldots\name{then} or \name{while}\ldots\name{do}.
\end{Comments}
\end{Operator}


\begin{Operator}{LEQ}
The \name{leq} operator is a binary infix or prefix logical operator.  It
returns \nameref{true} if its first argument is less than or equal to its second
argument.  As an infix operator it is identical with \name{<=}.
\begin{Syntax}
\name{leq}\(\meta{expression},\meta{expression}\) or \meta{expression}
\name{leq} \meta{expression}

\end{Syntax}

\meta{expression} can be any valid REDUCE expression that evaluates to a
number.

\begin{Examples}
a := 15;                     &       A := 15 \\
if leq(a,25) then write "yes" else write "no";
			     &       yes \\
if leq(a,15) then write "yes" else write "no";
			     &       yes \\
if leq(a,5) then write "yes" else write "no";
			     &       no
\end{Examples}

\begin{Comments}
Logical operators can only be used in conditional statements such as \\
\name{if}\ldots\name{then}\ldots\name{else} or \name{while}\ldots\name{do}.
\end{Comments}
\end{Operator}


\begin{Operator}{LESSP}
The \name{lessp} operator is a binary infix or prefix logical operator.  It
returns \nameref{true} if its first argument is strictly less than its second
argument.  As an infix operator it is identical with \name{<}.
\begin{Syntax}
\name{lessp}\(\meta{expression},\meta{expression}\)
or \meta{expression} \name{lessp} \meta{expression}

\end{Syntax}

\meta{expression} can be any valid REDUCE expression that evaluates to a
number.

\begin{Examples}
a := 15;                     &       A := 15 \\
if lessp(a,25) then write "yes" else write "no";
			     &       yes \\
if lessp(a,15) then write "yes" else write "no";
			     &       no \\
if lessp(a,5) then write "yes" else write "no";
			     &       no
\end{Examples}

\begin{Comments}
Logical operators can only be used in conditional statements such as \\
\name{if}\ldots\name{then}\ldots\name{else} or \name{while}\ldots\name{do}.
\end{Comments}
\end{Operator}


\begin{Operator}{MEMBER}
\index{list}

\begin{Syntax}
\meta{expression} \name{member} \meta{list}
\end{Syntax}

\name{member} is an infix binary comparison operator that evaluates to
\nameref{true} if \meta{expression} is \nameref{equal} to a member of
the \nameref{list} \meta{list}.

\begin{Examples}
if a member {a,b} then 1 else 0; & 1 \\
if 1 member(1,2,3) then a else b; & a \\
if 1 member(1.0,2) then a else b; & b
\end{Examples}

\begin{Comments}
Logical operators can only be used in conditional statements such as \\
\name{if}\ldots\name{then}\ldots\name{else} or \name{while}\ldots\name{do}.
\meta{member} can also be used as a prefix operator.  However, this use
is not encouraged.  Finally, \nameref{equal} (\name{=}) is used for the test 
within the list, so expressions must be of the same type to match.
\end{Comments}

\end{Operator}


\begin{Operator}{NEQ}
The operator \name{neq} is an infix binary comparison
operator.  It returns \nameref{true} if its two
arguments are not \nameref{equal}.

\begin{Syntax}
\meta{expression} \name{neq} \meta{expression}
\end{Syntax}

An inequality is satisfied between floating point numbers and integers
that have the same value.

\begin{Examples}
on rounded; \\
a := 4;                      &        A := 4 \\
b := 4.0;                    &        B := 4.0 \\
if a neq b then write "true" else write "false";
			     &        false \\
if a neq 5 then write "true" else write "false";
			     &        true
\end{Examples}
\begin{Comments}
Comparison operators can only be used as conditions in conditional commands
such as \name{if}\ldots\name{then} and \name{repeat}\ldots\name{until}.
\meta{neq} can also be used as a prefix operator.  However, this use
is not encouraged.
\end{Comments}
\end{Operator}


\begin{Operator}{NOT}
The \name{not} operator returns \nameref{true} if its argument evaluates to
\nameref{nil}, and \name{nil} if its argument is \name{true}.
\begin{Syntax}
\name{not}\(\meta{logical expression}\)
\end{Syntax}

\begin{Examples}
if not numberp(a) then write "indeterminate" else write a;
			    &       indeterminate; \\
a := 10;                    &       A := 10 \\
if not numberp(a) then write "indeterminate" else write a;
			    &       10 \\
if not(numberp(a) and a < 0) then write "positive number";
			    &       positive number
\end{Examples}

\begin{Comments}
Logical operators can only be used in conditional statements such as \\
\name{if}\ldots\name{then}\ldots\name{else} or \name{while}\ldots\name{do}.
\end{Comments}
\end{Operator}


\begin{Operator}{NUMBERP}
The \name{numberp} operator returns \nameref{true} if its argument is a number,
and \nameref{nil} otherwise.
\begin{Syntax}
\name{numberp}\(\meta{expression}\) or \name{numberp} \meta{expression}
\end{Syntax}

\meta{expression} can be any REDUCE scalar expression.

\begin{Examples}
cc := 15.3;                 &            CC := 15.3 \\
if numberp(cc) then write "number" else write "nonnumber"; & number \\
if numberp(cb) then write "number" else write "nonnumber"; & nonnumber
\end{Examples}

\begin{Comments}
Logical operators can only be used in conditional expressions, such as \\
\name{if}\ldots\name{then}\ldots\name{else} and \name{while}\ldots\name{do}.
\end{Comments}
\end{Operator}


\begin{Operator}{ORDP}
\index{order}
The \name{ordp} logical operator returns \nameref{true} if its first argument is
ordered ahead of its second argument in canonical internal ordering, or is
identical to it.
\begin{Syntax}
\name{ordp}\(\meta{expression1},\meta{expression2}\)

\end{Syntax}


\meta{expression1} and \meta{expression2} can be any valid REDUCE scalar
expression.

\begin{Examples}
if ordp(x**2 + 1,x**3 + 3) then write "yes" else write "no";
			    &           no \\
if ordp(101,100) then write "yes" else write "no";
			    &           yes \\
if ordp(x,x) then write "yes" else write "no";
			    &           yes
\end{Examples}

\begin{Comments}
Logical operators can only be used in conditional expressions, such as \\
\name{if}\ldots\name{then}\ldots\name{else} and \name{while}\ldots\name{do}.
\end{Comments}
\end{Operator}


\begin{Operator}{PRIMEP}
\index{prime number}

\begin{Syntax}
\name{primep}\(\meta{expression}\) or \name{primep} \meta{simple\_expression}
\end{Syntax}

If \meta{expression} evaluates to a integer, \name{primep} returns 
\nameref{true} 
if \meta{expression} is a prime number and \nameref{nil} otherwise.
If \meta{expression} does not have an integer value, a type error occurs.

\begin{Examples}
if primep 3 then write "yes" else write "no"; & YES \\
if primep a then 1; & ***** A invalid as integer
\end{Examples}

\end{Operator}


\begin{Concept}{TRUE}

Any value of the boolean part of a logical expression which is neither
\nameref{nil} nor \name{0} is considered as \name{true}. Most
builtin test and compare functions return \nameref{t} for \name{true}
and \nameref{nil} for \nameindex{false}.

\begin{Examples}
if member(3,{1,2,3}) then 1 else -1;&1\\
if floor(1.7) then 1 else -1; & 1 \\
if floor(0.7) then 1 else -1; & -1\\
\end{Examples}
\end{Concept}

