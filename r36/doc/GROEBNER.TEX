\documentstyle[11pt,reduce]{article}
\title{GROEBNER: A Package for Calculating Gr\"obner Bases}
\date{}
\author{
H. Melenk \& W. Neun \\[0.05in]
Konrad--Zuse--Zentrum \\
f\"ur Informationstechnik Berlin \\
Heilbronner Strasse 10 \\
D--10711 Berlin-Wilmersdorf \\
Germany \\[0.05in]
Email:  melenk@sc.zib--berlin.de \\[0.05in]
and \\[0.05in]
H.M. M\"oller \\[0.05in]
Fernuniversit\"at Hagen \\
FB Math und Informatik\\
Postfach 940 \\
D--58084 Hagen \\
Germany\\[0.05in]
Email: Michael.Moeller@fernuni-hagen.de}

\begin{document}
\maketitle

\index{Gr\"obner Bases}
Gr\"obner bases are a valuable tool for solving problems in
connection with multivariate polynomials, such as solving systems of
algebraic equations and analyzing polynomial ideals. For a definition
of Gr\"obner bases, a survey of possible applications and further
references, see~\cite{Buchberger:85}. Examples are given in \cite{Boege:86},
in \cite{Buchberger:88} and also in the test file for this package.

\index{GROEBNER package} \index{Buchberger's Algorithm}
The GROEBNER package calculates Gr\"obner bases using the
Buchberger algorithm.  It can be used over a variety of different
coefficient domains, and for different variable and term orderings.

The current version of the package uses parts of the previous
version, written by  R. Gebauer, A.C. Hearn, H. Kredel and M.
M\"oller. The algorithms implemented in the current version are
documented in \cite{Faugere:89}, \cite{Gebauer:88},
\cite{Kredel:88a} and \cite{Giovini:91}.

\section{Compatibility}

Important modifications of the present GROEBNER package compared
with the REDUCE 3.5 GROEBNER package:
\begin{itemize}
\item The variables of the polynomial ring are now declared in the
      $TORDER$ statement together with the term order mode. The old
      style (including the variable list in the function calls)
      is still accepted, but will not be supported in future versions.
\item The term order mode $private$ has been eliminated. Instead the
      mode $matrix$ has been introduced, which allows you to
      define any compatible term order. For optimal efficiency
      a matrix can be compiled.
\item Polynomial side relations in the parameter domain are now
      considered inside the Gr\"obner calculations. You can enter
      them as ordinary $LET$ rules.
\item There is an extension $NCPOLY$  for computing with
      non--commutative ideals of solvable type. $NCPOLY$ is loaded
      as a separate module, but it uses internally the functions
      of $GROEBNER$.
\end{itemize}

\section{Background}

\subsection{Variables, Domains and Polynomials}

The various functions of the GROEBNER package manipulate
equations and/or polynomials; equations are internally
transformed into  polynomials by forming the difference of
left-hand side and right-hand side.

All manipulations take place in a ring of polynomials in some
variables $x1, \ldots , xn$ over a coefficient domain $D$:
\[
D [x1,\ldots , xn],
\]
where $D$ is a field or at least a ring without zero divisors.
The set of variables $x1,\ldots ,xn$ can be given explicitly by the
user or it is extracted automatically from the
input expressions.

All REDUCE kernels can play the role of ``variables'' in this context;
examples are

%{\small
\begin{verbatim}
X Y Z22 SIN(ALPHA) COS(ALPHA) C(1,2,3) C(1,3,2) FARINA4711
\end{verbatim}
%}

The domain $D$ is the current REDUCE domain with those kernels
adjoined that are not members of the list of variables. So the
elements of $D$ may be complicated polynomials themselves over
kernels not in the list of variables; if, however, the variables are
extracted automatically from the input expressions, $D$ is identical
with the current REDUCE domain. It is useful to regard kernels not
being members of the list of variables as ``parameters'', e.g.
\[
\begin{array}{c}
 a * x + (a - b) * y**2 \;\mbox{ with ``variables''}\ \{x,y\} \\
\mbox{and ``parameters''  $\;a\;$ and $\;b\;$}\;.
\end{array}
\]

The current version of the Buchberger algorithm has two internal
modes, a field mode and a ring mode. In the starting phase the
algorithm analyzes the domain type; if it recognizes $D$ as being a
ring it uses the ring mode, otherwise the field mode is needed.
Normally field calculations occur only if all coefficients are numbers
and if the current REDUCE domain is a field (e.g. rational numbers,
modular numbers). In general, the ring mode is faster. When no specific
REDUCE domain is selected, the ring mode is used, even if the input
formulas contain fractional coefficients: they are multiplied by their
common denominators so that they become integer polynomials.



\subsection{Term Ordering} \par
In the theory of Gr\"obner bases, the terms of polynomials are
considered as ordered. Several order modes are available in
the current package, including the basic modes:
\index{LEX ! term order} \index{GRADLEX ! term order}
\index{REVGRADLEX ! term order}

\begin{center}
LEX, GRADLEX, REVGRADLEX
\end{center}

All orderings are based on an ordering among the variables. For
each pair of variables $(a,b)$ an order relation must be defined, e.g.
``$ a\gg b $''. The greater sign $\gg$  does not represent a numerical
relation among the variables; it can be interpreted only in terms of
formula representation: ``$a$'' will be placed in front of ``$b$'' or
``$a$''  is more complicated than ``$b$''.

The sequence of variables constitutes this order base. So the notion
of
\[
\{x1,x2,x3\}
\]

as a list of variables at the same time means
\[
x1 \gg x2 \gg x3
\]
with respect to the term order.

If terms (products of powers of variables) are compared with LEX,
that term is chosen which has a greater variable or a higher degree
if the greatest variable is the first in both. With GRADLEX the sum of
all exponents (the total degree) is compared first, and if that does
not lead to a decision, the LEX method is taken for the final decision.
The REVGRADLEX method also compares the total degree first, but
afterward it uses the LEX method in the reverse direction; this is the
method originally used by Buchberger.

\example \ with $\{x,y,z\}$: \index{GROEBNER package ! example}
\[
\begin{array}{rlll}
\multicolumn{2}{l}{\hspace*{-1cm}\mbox{\bf LEX:}}\\
 x * y **3 & \gg & y ** 48 & \mbox{(heavier variable)} \\
 x**4 * y**2 & \gg  & x**3 * y**10 & \mbox{(higher degree in 1st
variable)} \vspace*{2mm} \\
\multicolumn{2}{l}{\hspace*{-1cm}\mbox{\bf GRADLEX:}} \\
  y**3 * z**4 & \gg & x**3 * y**3 & \mbox{(higher total degree)} \\
  x*z  &        \gg & y**2  & \mbox{(equal total degree)}
\vspace*{2mm}\\
\multicolumn{2}{l}{\hspace*{-1cm}\mbox{\bf
REVGRADLEX:}} \\
 y**3 * z**4 & \gg &  x**3 * y**3 & \mbox{(higher total degree)} \\
 x*z         & \ll  &  y**2       & \mbox{(equal total degree,} \\
 & & & \mbox{so reverse order of LEX)}
\end{array}
\]

The formal description of the term order modes is similar to
\cite{Kredel:88}; this description regards only the exponents of a term,
which are written as vectors of integers with $0$ for exponents of a
variable which does not occur:
\[
\begin{array}{l}
  (e) = (e1,\ldots , en) \;\mbox{ representing }\; x1**e1 \ x2**e2 \cdots
  xn**en. \\
  \deg(e) \; \mbox{ is the sum over all elements of } \;(e) \\
  (e) \gg (l) \Longleftrightarrow (e)-(l)\gg (0) = (0,\ldots ,0)
\end{array}
\]
\[
\begin{array}{rll}
\multicolumn{1}{l}{\hspace*{-.5cm}\mbox{\bf LEX:}} \\
  (e) > lex > (0) & \Longrightarrow  & e_k > 0 \mbox{ and } e_j =0
\mbox{ for }\; j=1,\ldots , k-1\vspace*{2mm} \\
\multicolumn{1}{l}{\hspace*{-.5cm}\mbox{\bf
GRADLEX:}} \\
  (e) >gl> (0)  & \Longrightarrow  & \deg(e)>0  \mbox { or } (e) >lex>
(0)\vspace*{2mm} \\
\multicolumn{1}{l}{\hspace*{-.5cm}\mbox{\bf
REVGRADLEX:}}\\
  (e) >rgl> (0) & \Longrightarrow & \deg(e)>0  \mbox{ or }(e)  <lex<
(0)
\end{array}
\]

Note that the LEX ordering is identical to the standard REDUCE
kernel ordering, when KORDER is set explicitly to the sequence of
variables.

\index{default ! term order}
LEX is the default term order mode in the GROEBNER package.

It is beyond the scope of this manual to discuss the functionality of
the term order modes. See \cite{Buchberger:88}.

The list of variables is declared as an optional parameter of the
TORDER statement (see below). If this declaration is missing
or if the empty list has been used, the variables are extracted from
the expressions automatically and the REDUCE system order defines
their sequence; this can be influenced by setting an explicit order
via the KORDER statement.

The result of a Gr\"obner calculation is algebraically correct only
with respect to the term order mode and the variable sequence
which was in effect during the calculation. This is important if
several calls to the GROEBNER package are done with the result of the
first being the input of the second call. Therefore we recommend
that you declare the variable list and the order mode explicitly.
Once declared it remains valid until you enter a new TORDER
statement. The operator GVARS helps you extract the variables
from a given set of polynomials.

\subsection{The Buchberger Algorithm}
\index{Buchberger's Algorithm}
The Buchberger algorithm of the package is based on {\sc
Gebauer/M\"oller} \cite{Gebauer:88}.
Extensions are documented in \cite{Melenk:88} and \cite{Giovini:91}.

% Chapter 2
\section{Loading of the Package}
The following command loads the package into
REDUCE (this syntax may vary according to implementation):
\begin{center}
load groebner;
\end{center}

The package contains various operators, and switches for control
over the reduction process. These are discussed in the following.

% Chapter 3
\section{The Basic Operators}

% Section 3.1
\subsection{Term Ordering Mode}

\begin{description}
\ttindex{TORDER}
\item [{\it TORDER}]($vl$,$m$,$[p_1,p_2,\ldots]$);

where $vl$ is a variable list (or the empty list if
no variables are declared explicitly),
$m$ is the name of a term ordering mode LEX, GRADLEX,
REV\-GRAD\-LEX (or another implemented mode) and
$[p_1,p_2,\ldots]$ are additional parameters for the
term ordering mode (not needed for the basic modes).

TORDER sets variable set and the term ordering mode.
The default mode is LEX. The previous description is returned
as a list with corresponding elements. Such a list can
alternatively passed as sole argument to TORDER.

If the variable list is empty or if the TORDER declaration
is omitted, the automatic variable extraction is activated.

\ttindex{GVARS}
\item[{\it GVARS}] ({\it\{exp$1$, exp$2$, $ \ldots$, exp$n$\}});

 where $\{exp1, exp2, \ldots , expn\}$ is a list of expressions or
equations.

GVARS extracts from the expressions $\{exp1, exp2, \ldots , expn\}$
the kernels, which can play the role of variables for a Gr\"obner
calculation. This can be used e.g. in a TORDER declaration.
\end{description}

\subsection{GROEBNER: Calculation of a Gr\"obner Basis}
\begin{description}
\ttindex{GROEBNER}
\item[{\it GROEBNER}] $\{exp1, exp2, \ldots , expm\}; $

where $\{exp1, exp2, \ldots , expm\}$ is a list of
expressions or equations.

GROEBNER calculates the Gr\"obner basis of the given set of
expressions with respect to the current TORDER setting.

The Gr\"obner basis $\{1\}$ means that the ideal generated by the
input polynomials is the whole polynomial ring, or equivalently, that
the input polynomials have no zeros in common.

As a side effect, the sequence of variables is stored as a REDUCE list
in the shared variable
\ttindex{gvarslast}
\begin{center}
gvarslast .
\end{center}

This is important if the variables are reordered because of optimization:
you must set them afterwards explicitly as the current variable sequence
if you want to use the Gr\"obner basis in the sequel, e.g. for a
PREDUCE call. A basis has the property ``Gr\"obner'' only with respect
to the variable sequences which had been active during its computation.
\end{description}

\example \index{GROEBNER package ! example}
\begin{verbatim}
   torder({},lex)$
   groebner{3*x**2*y + 2*x*y + y + 9*x**2 + 5*x - 3,
   2*x**3*y - x*y - y + 6*x**3 - 2*x**2 - 3*x + 3,
   x**3*y + x**2*y + 3*x**3 + 2*x**2 };

               2
     {8*X - 2*Y  + 5*Y + 3,

         3      2
      2*Y  - 3*Y  - 16*Y + 21}
\end{verbatim}


This example used the default system variable ordering, which was
$\{x,y\}$. With the other variable ordering, a different basis results:

\begin{verbatim}
   torder({y,x},lex)$
   groebner{3*x**2*y + 2*x*y + y + 9*x**2 + 5*x - 3,
   2*x**3*y - x*y - y + 6*x**3 - 2*x**2 - 3*x + 3,
   x**3*y + x**2*y + 3*x**3 + 2*x**2 };

               2
     {2*Y + 2*X  - 3*X - 6,

         3      2
      2*X  - 5*X  - 5*X}
\end{verbatim}


Another basis yet again results with a different term ordering:
\begin{verbatim}
   torder({x,y},revgradlex)$
   groebner{3*x**2*y + 2*x*y + y + 9*x**2 + 5*x - 3,
   2*x**3*y - x*y - y + 6*x**3 - 2*x**2 - 3*x + 3,
   x**3*y + x**2*y + 3*x**3 + 2*x**2 };

    2
{2*y  - 5*y - 8*x - 3,

 y*x - y + x + 3,

    2
 2*x  + 2*y - 3*x - 6}

\end{verbatim}


The operation of GROEBNER can be controlled by the following
switches:
\begin{description}
\ttindex{GROEBOPT}
\item[GROEBOPT] -- If set ON, the sequence of variables is optimized
with respect to execution speed; the algorithm involved is described
in~\cite{Boege:86}; note that the final list of variables is available in
\ttindex{GVARSLAST}
GVARSLAST.

An explicitly declared dependency supersedes the
variable optimization. For example
\begin{center}
{\it depend} $a$, $x$, $y$;
\end{center}
guarantees that $a$ will be placed in front of $x$ and $y$. So
GROEBOPT can be used even in cases where elimination of variables is
desired.

By default GROEBOPT is off, conserving the original variable
sequence.

\ttindex{GROEBFULLREDUCTION}
\item[GROEBFULLREDUCTION] -- If set off, the reduction steps during
the \linebreak[4] GROEBNER operation are limited to the pure head
term reduction; subsequent terms are reduced otherwise.

By default GROEBFULLREDUCTION is on.

\ttindex{GLTBASIS}
\item[GLTBASIS] -- If set on, the leading terms of the result basis are
extracted. They are collected in a basis of monomials, which is
available as value of the global variable with the name GLTB.

\item[GLTERMS] -- If $\{exp_1, \ldots , exp_m\} $ contain parameters
(symbols which are not member of the variable list), the share variable
{\tt GLTERMS} contains a list of expression which during the
calculation were assumed to be nonzero. A Gr\"obner basis
is valid only under the assumption that all these expressions do
not vanish.

\end{description}

The following switches control the print output of GROEBNER; by
default all these switches are set OFF and nothing is printed.
\begin{description}
\ttindex{GROEBSTAT}
\item[GROEBSTAT] -- A summary of the computation is printed
including the computing time, the number of intermediate
$H$--polynomials and the counters for the hits of the criteria.

\ttindex{TRGROEB}
\item[TRGROEB] -- Includes GROEBSTAT and the printing of the
intermediate $H$-polynomials.

\ttindex{TRGROEBS}
\item[TRGROEBS] -- Includes TRGROEB and the printing of
intermediate $S$--poly\-nomials.

\ttindex{TRGROEB1}
\item[TRGROEB1] -- The internal pairlist is printed when modified.
\end{description}

\subsection{GZERODIM?: Test of $\dim = 0$}
\begin{description}
\ttindex{GZERODIM?}
\item[{\it GZERODIM}!?] $bas$ \\
where {\it bas} is a Gr\"obner basis in the current setting.
The result is {\it NIL}, if {\it bas} is the
basis of an ideal of polynomials with more than finitely many common zeros.
If the ideal is zero dimensional, i. e. the polynomials of the ideal have only
finitely many zeros in common, the result is an integer $k$ which is the number
of these common zeros (counted with multiplicities).
\end{description}

\subsection{GDIMENSION, GINDEPENDENT\_SETS: compute dimension and
independent variables}
The following operators can be used to compute the dimension
and the independent variable sets of an ideal which has the
Gr\"obner basis {\it bas} with arbitrary term order:
\begin{description}
\ttindex{GDIMENSION}\ttindex{GINDEPENDENT\_SETS}
\ttindex{ideal dimension}\ttindex{independent sets}
\item[Gdimension]$bas$
\item[Gindependent\_sets]$bas$
{\it Gindependent\_sets} computes the maximal
left independent variable sets of the ideal, that are
the variable sets which play the role of free parameters in the
current ideal basis. Each set is a list which is a subset of the
variable list. The result is a list of these sets. For an
ideal with dimension zero the list is empty.
{\it GDimension} computes the dimension of the ideal,
which is the maximum length of the independent sets.
\end{description}
The ``Kredel-Weispfenning" algorithm is used (see \cite{Kredel:88a},
extended to general ordering in \cite{BeWei:93}.

\subsection{GLEXCONVERT: Conversion of an Arbitrary Gr\"obner Basis
into a Lexical One}
\begin{description}
\ttindex{GLEXCONVERT}
\item[{\it GLEXCONVERT}] $ \left(\{exp,\ldots , expm\} \left[,\{var1
\ldots , varn\}\right]\left[,MAXDEG=mx\right]\right.$ \\
$\left.\left[,NEWVARS=\{nv1, \ldots , nvk\}\right]\right) $ \\
where $\{exp1, \ldots , expm\}$ is a Gr\"obner basis with
$\{var1, \ldots , varn\}$ as variables in the current term order mode,
$mx$ is an integer, and
$\{nv1, \ldots , nvk\}$ is a subset of the basis variables.
For this operator the source and target variable sets must be specified
explicitly.
\end{description}

GLEXCONVERT converts a basis of a zero-dimensional ideal (finite number
of isolated solutions) from arbitrary ordering into a basis under {\it
lex} ordering. During the call of GLEXCONVERT the original ordering of
the input basis must be still active!

NEWVARS defines the new variable sequence. If omitted, the
original variable sequence is used. If only a subset of variables is
specified here, the partial ideal basis is evaluated. For the
calculation of a univariate polynomial, NEW\-VARS should be a list
with one element.

MAXDEG is an upper limit for the degrees. The algorithm stops with
an error message, if this limit is reached.

A warning occurs if the ideal is not zero dimensional.

GLEXCONVERT is an implementation of the FLGM algorithm by
\linebreak[4] {\sc Faug{\`e}re}, {\sc Gianni}, {\sc Lazard} and {\sc
Mora} \cite{Faugere:89}. Often, the calculation of a Gr\"obner basis
with a graded ordering and subsequent conversion to {\it lex} is
faster than a direct {\it lex} calculation. Additionally, GLEXCONVERT
can be used to transform a {\it lex} basis into one with different
variable sequence, and it supports the calculation of a univariate
polynomial. If the latter exists, the algorithm is even applicable in
the non zero-dimensional case, if such a polynomial exists.

\begin{verbatim}
   torder({{w,p,z,t,s,b},gradlex)

   g  :=  groebner  { f1 := 45*p + 35*s -165*b -36,
         35*p + 40*z + 25*t - 27*s, 15*w + 25*p*s +30*z -18*t
        -165*b**2, -9*w + 15*p*t  + 20*z*s,
        w*p + 2*z*t - 11*b**3, 99*w - 11*s*b +3*b**2,
        b**2 + 33/50*b + 2673/10000};

  G := {60000*W + 9500*B + 3969,

      1800*P - 3100*B - 1377,

      18000*Z + 24500*B + 10287,

      750*T - 1850*B + 81,

      200*S - 500*B - 9,
             2
      10000*B  + 6600*B + 2673}

   glexconvert(g,{w,p,z,t,s,b},maxdeg=5,newvars={w});

               2
    100000000*W  + 2780000*W + 416421

   glexconvert(g,{w,p,z,t,s,b},maxdeg=5,newvars={p});

          2
    6000*P  - 2360*P + 3051

\end{verbatim}

\subsection{GROEBNERF: Factorizing Gr\"obner Bases}

% Subsection 3.4.1
\subsubsection{Background}
If Gr\"obner bases are computed in order to solve systems of
equations or to find the common roots of systems of polynomials,
the factorizing version of the Buchberger algorithm can be used.
The theoretical background is simple: if a polynomial $p$ can be
represented as a product of two (or more) polynomials, e.g. $h= f*g$,
then $h$ vanishes if and only if one of the factors vanishes. So if
during the calculation of a Gr\"obner basis $h$ of the above form is
detected, the whole problem can be split into two (or more)
disjoint branches. Each of the branches is simpler than the complete
problem; this saves computing time and space. The result of this
type of computation is a list of (partial) Gr\"obner bases; the
solution set of the original problem is the union of the solutions of
the partial problems, ignoring the multiplicity of an individual
solution. If a branch results in a basis $\{1\}$, then there is no
common zero, i.e. no additional solution for the original problem,
contributed by this branch.

% Subsection 3.4.2
\subsubsection{GROEBNERF Call}
\ttindex{GROEBNERF}
The syntax of GROEBNERF is the same as for GROEBNER.
\[
\mbox{\it GROEBNERF}(\{exp1, exp2, \ldots , expm\}
         [,\{\},\{nz1, \ldots nzk\});
\]
where $\{exp1, exp2, \ldots , expm\} $ is a given list of expressions or
equations, and $\{nz1, \ldots nzk\}$ is
an optional list of polynomials known to be non-zero.

GROEBNERF tries to separate polynomials into individual factors and
to branch the computation in a recursive manner (factorization tree).
The result is a list of partial Gr\"obner bases. If no factorization can
be found or if all branches but one lead to the trivial basis $\{1\}$,
the result has only one basis; nevertheless it is a list of lists of
polynomials. If no solution is found, the result will be $\{\{1\}\}$.
Multiplicities (one factor with a higher power, the same partial basis
twice) are deleted as early as possible in order to speed up the
calculation. The factorizing is controlled by some switches.

As a side effect, the sequence of variables is stored as a REDUCE list in
the shared variable
\begin{center}
gvarslast .
\end{center}
If GLTBASIS is on, a corresponding list of leading term bases is
also produced and is available in the variable GLTB.

The third parameter of GROEBNERF allows one to declare some polynomials
nonzero. If any of these is found in a branch of the calculation
the branch is cancelled. This can be used to save a substantial amount
of computing time. The second parameter must be included as an
empty list if the third parameter is to be used.

\begin{verbatim}
   torder({x,y},lex)$
   groebnerf { 3*x**2*y + 2*x*y + y + 9*x**2 + 5*x = 3,
               2*x**3*y - x*y - y + 6*x**3 - 2*x**2 - 3*x = -3,
                x**3*y + x**2*y + 3*x**3 + 2*x**2 \};


       {{Y - 3,X},

                      2
    {2*Y + 2*X - 1,2*X  - 5*X - 5}}
\end{verbatim}
%}

It is obvious here that the solutions of the equations can be read
off immediately.

All switches from GROEBNER are valid for GROEBNERF as well:
\ttindex{GROEBOPT}  \ttindex{GLTBASIS}
\ttindex{GROEBFULLREDUCTION} \ttindex{GROEBSTAT} \ttindex{TRGROEB}
\ttindex{TRGROEBS} \ttindex{TRGROEB1}
\begin{center}
\begin{tabular}{l}
GROEBOPT \\
GLTBASIS \\
GROEBFULLREDUCTION \\
GROEBSTAT \\
TRGROEB \\
TRGROEBS \\
TRGROEB1
\end{tabular}
\end{center}

\subsubsection*{Additional switches for GROEBNERF:}
\begin{description}
\ttindex{GROEBRES}
\item[GROEBRES] -- If ON, a resultant is calculated under certain
circumstances (one bivariate $H$--polynomial is followed by another
one). This sometimes shortens the calculation.

By default GROEBRES is off.

\ttindex{TRGROEBR}
\item[TRGROEBR] -- All intermediate partial basis are printed when
detected.

By default TRGROEBR is off.
\end{description}
{\bf GROEBMONFAC  GROEBRESMAX  GROEBRESTRICTION} \\
\hspace*{.5cm} These variables are described in the following
paragraphs.

\subsubsection{Suppression of Monomial Factors}
The factorization in GROEBNERF is controlled by the following
\ttindex{GROEBMONFAC}
switches and variables.  The variable GROEBMONFAC is connected to
the handling of ``monomial factors''.  A monomial factor is a product
of variable powers occurring as a factor, e.g. $ x**2*y$  in  $x**3*y -
2*x**2*y**2$.  A monomial factor represents a solution of the type
``$ x = 0$  or  $y = 0$'' with a certain multiplicity.  With
GROEB\-NERF \ttindex{GROEBNERF}
the multiplicity of monomial factors is lowered to the value of the
shared variable
\ttindex{GROEBMONFAC}
\begin{center}
GROEBMONFAC
\end{center}
which by default is 1 (= monomial factors remain present, but their
multiplicity is brought down). With
\begin{center}
GROEBMONFAC := 0
\end{center}
the monomial factors are suppressed completely.


\subsubsection{Limitation on the Number of Results}
The shared variable
\ttindex{GROEBRESMAX}
\begin{center}
GROEBRESMAX
\end{center}
controls the number of partial results. Its default value is 300. If
groebresmax partial results are calculated, the calculation is
terminated.


\subsubsection{Restriction of the Solution Space}
In some applications only a subset of the complete solution set
of a given set of equations is relevant, e.g. only
nonnegative values or positive definite values for the variables.
A significant amount of computing time can be saved if
nonrelevant computation branches can be terminated early.

Positivity: If a polynomial has no (strictly) positive zero, then
every system containing it has no nonnegative or strictly positive
solution. Therefore, the Buchberger algorithm tests the coefficients of
the polynomials for equal sign if requested. For example, in $13*x +
15*y*z $ can be zero with real nonnegative values for $x, y$ and $z$
only if $x=0$ and $y=0$ or $ z=0$; this is a sort of ``factorization by
restriction''. A polynomial $13*x + 15*y*z + 20$ never can vanish
with nonnegative real variable values.

Zero point:  If any polynomial in an ideal has an absolute term, the ideal
cannot have the origin point as a common solution.

By setting the shared variable
\ttindex{GROEBRESTRICTION}
\begin{center} GROEBRESTRICTION \end{center}
GROEBNERF is informed of the type of restriction the user wants to
impose on the solutions:
\begin{center}
\begin{tabular}{l}
{\it GROEBRESTRICTION:=NONEGATIVE;} \\
\hspace*{+.5cm} only nonnegative real solutions are of
interest\vspace*{4mm} \\
{\it GROEBRESTRICTION:=POSITIVE;} \\
\hspace*{+.5cm}only nonnegative and nonzero solutions are of
interest\vspace*{4mm} \\
{\it GROEBRESTRICTION:=ZEROPOINT;} \\
\hspace*{+.5cm}only solution sets which contain the point
$\{0,0,\ldots,0\}$ are or interest.
\end{tabular}
\end{center}

If GROEBNERF detects a polynomial which formally conflicts with the
restriction, it either splits the calculation into separate branches, or,
if a violation of the restriction is determined, it cancels the actual
calculation branch.


\subsection{GREDUCE, PREDUCE: Reduction of Polynomials}


\subsubsection{Background} \label{GROEBNER:background}
Reduction of a polynomial ``p'' modulo a given sets of polynomials
``B'' is done by the reduction algorithm incorporated in the
Buchberger algorithm. Informally it can be described for
polynomials over a field as follows:
\begin{center}
\begin{tabular}{l}
loop1: \hspace*{2mm}\% head term elimination \\
\hspace*{-1cm} if there is one polynomial $b$ in $B$ such that the
leading \\ term of $p$ is a multiple of the leading term of $p$ do \\
$p := p - lt(p)/lt(b) * b$  (the leading term vanishes)\\
\hspace*{-1cm} do this loop as long as possible; \\
loop2: \hspace*{2mm} \% elimination of subsequent terms \\
\hspace*{-1cm} for each term $s$ in $p$ do \\
if there is one polynomial $b$ in $B$ such that $s$ is a\\
multiple of the leading term of $p$ do \\
$p := p - s/lt(b) * b$ (the term $s$ vanishes) \\
\hspace*{-1cm}do this loop as long as possible;
\end{tabular}
\end{center}

If the coefficients are taken from a ring without zero divisors we
cannot divide by each possible number like in the field case. But
using that in the field case,  $c*p $ is reduced to  $c*q $, if $ p $
is reduced to $ q $, for arbitrary numbers $ c $,  the reduction for
the ring case uses the least $ c $ which makes the (field) reduction
for $ c*p $ integer. The result of this reduction is returned as
(ring) reduction of $ p $ eventually after removing the content, i.e.
the greatest common divisor of the coefficients. The result of this
type of reduction is also called a pseudo reduction of $ p $.


% Subsection 3.5.2
\subsubsection{Reduction via Gr\"obner Basis Calculation}
\ttindex{GREDUCE}
\[
\mbox{\it  GREDUCE}(exp, \{exp1, exp2, \ldots , expm\}]);
\]
where {\it exp} is an expression, and $\{exp1, exp2,\ldots , expm\}$ is
a list of any number of expressions or equations.

GREDUCE first converts the list of expressions $\{exp1, \ldots ,
expn\}$ to a Gr\"obner basis, and then reduces the given expression
modulo that basis.  An error results if the list of expressions is
inconsistent. The returned value is an expression representing the
reduced polynomial. As a side effect, GREDUCE sets the variable {\it
gvarslast} in the same manner as GROEBNER does.


\subsubsection{Reduction with Respect to Arbitrary Polynomials}
\ttindex{PREDUCE}
\[
 PREDUCE(exp, \{exp1, exp2,\ldots , expm\});
\]
where $ exp $  is an expression, and $\{exp1, exp2, \ldots ,
expm \}$ is a list of any number of expressions or equations.

PREDUCE reduces the given expression modulo the set $\{exp1,
\ldots , expm\}$. If this set is a Gr\"obner basis, the obtained reduced
expression is uniquely determined. If not, then it depends on the
subsequence of the single reduction steps
(see~\ref{GROEBNER:background}). PREDUCE does not check whether
$\{exp1, exp2, \ldots , expm\}$ is a Gr\"obner basis in the actual
order. Therefore, if the expressions are a Gr\"obner basis calculated
earlier with a variable sequence given explicitly or modified by
optimization, the proper variable sequence and term order must
be activated first.

\example (PREDUCE called with a Gr\"obner basis):
\begin{verbatim}
  torder({x,y},lex);
  gb:=groebner{3*x**2*y + 2*x*y + y + 9*x**2 + 5*x - 3,
               2*x**3*y - x*y - y + 6*x**3 - 2*x**2 - 3*x + 3,
               x**3*y + x**2*y + 3*x**3 + 2*x**2}$
  preduce (5*y**2 + 2*x**2*y + 5/2*x*y + 3/2*y
             + 8*x**2 + 3/2*x - 9/2, gb);

      2
     Y
\end{verbatim}



\subsubsection{Reduction Tree}
In some case not only are the results produced by GREDUCE and
PREDUCE of interest, but the reduction process is of some value
too. If the switch
\ttindex{GROEBPROT}
\begin{center}
GROEBPROT
\end{center}
is set on, GROEBNER, GREDUCE and PREDUCE produce as a side effect a trace of
their work as a REDUCE list of equations in the shared variable
\ttindex{GROEBPROTFILE}
\begin{center}
GROEBPROTFILE.
\end{center}
Its value is a list of equations with a variable ``candidate'' playing
the role of the object to be reduced. The polynomials are cited as
``$poly1$'', ``$poly2$'', $\ldots\;$. If read as assignments, these equations
form a program which leads from the reduction input to its result.
Note that, due to the pseudo reduction with a ring as the coefficient
domain, the input coefficients may be changed by global factors.

\example \index{GROEBNER package ! example}

{\it on groebprot} \$ \\
{\it preduce} $ (5*y**2 + 2*x**2*y + 5/2*x*y + 3/2*y + 8*x**2 $ \\
\hspace*{+1cm} $+ 3/2*x - 9/2, gb);$
\begin{verbatim}
      2
     Y
\end{verbatim}
{\it groebprotfile;}
\begin{verbatim}
                  2         2                     2
    {CANDIDATE=4*X *Y + 16*X  + 5*X*Y + 3*X + 10*Y  + 3*Y - 9,

              2
     POLY1=8*X - 2*Y  + 5*Y + 3,

              3      2
     POLY2=2*Y  - 3*Y  - 16*Y + 21,
     CANDIDATE=2*CANDIDATE,
     CANDIDATE= - X*Y*POLY1 + CANDIDATE,
     CANDIDATE= - 4*X*POLY1 + CANDIDATE,
     CANDIDATE=4*CANDIDATE,

                   3
     CANDIDATE= - Y *POLY1 + CANDIDATE,
     CANDIDATE=2*CANDIDATE,

                     2
     CANDIDATE= - 3*Y *POLY1 + CANDIDATE,
     CANDIDATE=13*Y*POLY1 + CANDIDATE,
     CANDIDATE=CANDIDATE + 6*POLY1,

                     2
     CANDIDATE= - 2*Y *POLY2 + CANDIDATE,
     CANDIDATE= - Y*POLY2 + CANDIDATE,
     CANDIDATE=CANDIDATE + 6*POLY2}

 \end{verbatim}
This means
\begin{eqnarray*}
\lefteqn{
16 (5 y^2 + 2 x^2 y + \frac{5}{2} x y + \frac{3}{2} y
+ 8 x^2+ \frac{3}{2} x - \frac{9}{2})=} \\ & &
(-8 x y -32 x -2 y^3 -3 y^2 + 13 y + 6) \mbox{POLY1} \\
& & \; + (-2 y^2 -2 y + 6) \mbox{POLY2  } \; + y^2.
\end{eqnarray*}



\subsection{Tracing with GROEBNERT and PREDUCET}
Given a set of polynomials $\{f_1,\ldots ,f_k\}$ and their Gr\"obner
basis $\{g_1,\ldots ,g_l\}$, it is well known that there are matrices of
polynomials $C_{ij}$ and $D_{ji}$ such that
\[
f_i = \displaystyle{\sum\limits_j} C_{ij} g_j \;\mbox{  and  } g_j =
\displaystyle{\sum\limits_i} D_{ji} f_i
\]
and these relations are needed explicitly sometimes.
In {\sc Buchberger} \cite{Buchberger:85}, such cases are described in the
context of linear polynomial equations. The standard technique for
computing the above formulae is to perform
Gr\"obner reductions, keeping track of the
computation in terms of the input data. In the current package such
calculations are performed with (an internally hidden) cofactor
technique: the user has to assign unique names to the input
expressions and the  arithmetic combinations are done with the
expressions and with their names simultaneously. So the result is
accompanied by an expression which relates it algebraically to the
input values.

\ttindex{GROEBNERT} \ttindex{PREDUCET}
There are two complementary operators with this feature: GROEBNERT
and PREDUCET; functionally they correspond to GROEBNER and PREDUCE.
However, the sets of expressions here {\it {\bf must be}} equations
with unique single identifiers on their left side and the {\it lhs} are
interpreted as names of the expressions. Their results are
sets of equations (GROEBNERT) or equations (PREDUCET), where
a {\it lhs} is the computed value, while the {\it rhs} is its equivalent
in terms of the input names.

\example \index{GROEBNER package ! example}

We calculate the Gr\"obner basis for an ellipse (named ``$p1$'' ) and a
line (named ``$p2$'' ); $p2$ is member of the basis immediately and so
the corresponding first result element is of a very simple form; the
second member is a combination of $p1$ and $p2$ as shown on the
{\it rhs} of this equation:

\begin{verbatim}
gb1:=groebnert {p1=2*x**2+4*y**2-100,p2=2*x-y+1};

GB1 := {2*X - Y + 1=P2,
           2
        9*Y  - 2*Y - 199= - 2*X*P2 - Y*P2 + 2*P1 + P2}
\end{verbatim}

\example \index{GROEBNER package ! example}

We want to reduce the polynomial \verb+ x**2+ {\it  wrt}
the above Gr\"obner basis and need knowledge about the reduction
formula. We therefore extract the basis polynomials from $GB1$,
assign unique names to them (here $G1$, $G2$) and call PREDUCET.
The polynomial to be reduced here is introduced with the name $Q$,
which then appears on the {\it rhs} of the result. If the name for the
polynomial is omitted, its formal value is used on the right side too.

\begin{verbatim}
  gb2 := for k := 1:length gb1 collect
        mkid(g,k) = lhs part(gb1,k)$
  preducet (q=x**2,gb2);

 - 16*Y + 208= - 18*X*G1 - 9*Y*G1 + 36*Q + 9*G1 - G2
\end{verbatim}

This output means
\[
x^2 = (\frac{1}{2} x + \frac{1}{4} y - \frac{1}{4}) G1
 + \frac{1}{36} G2 + (-\frac{4}{9} y + \frac{52}{9}).
\]


\example \index{GROEBNER package ! example}

If we reduce a polynomial which is member of the ideal, we
consequently get a result with {\it lhs} zero:
\begin{verbatim}
   preducet(q=2*x**2+4*y**2-100,gb2);

   0= - 2*X*G1 - Y*G1 + 2*Q + G1 - G2
\end{verbatim}

This means
\[ Q = ( x + \frac{1}{2} y - \frac{1}{2}) G1 + \frac{1}{2} G2.
\]

With these operators the matrices $C_{ij}$ and $D_{ji}$ are available
implicitly, $D_{ji}$ as side effect of GROEBNERT, $C_{ij}$ by {\it calls}
of PREDUCET of $f_i$ {\it wrt} $\{g_j\}$. The latter by definition will
have the {\it lhs} zero and a {\it rhs} with linear $f_i$.

If $\{1\}$ is the Gr\"obner basis, the GROEBNERT calculation gives
a ``proof'', showing,  how  $1$ can be computed as combination of the
input polynomials.

\paragraph{Remark:} Compared to the non-tracing algorithms, these
operators are much more time consuming. So they are applicable
only on small sized problems.
% *** SO BESSER ??

\subsection{Gr\"obner Bases for Modules}

Given a polynomial ring, e.g. $R=Z[x_1 \cdots x_k]$ and
an integer $n>1$: the vectors with $n$ elements of $R$
form a $module$ under vector addition (= componentwise addition)
and multiplication with elements of $R$. For a submodule
given by a finite basis a Gr\"obner basis
can be computed, and the facilities of the GROEBNER package
can be used except the operators $GROEBNERF$ and $GROESOLVE$.

The vectors are encoded using auxiliary variables which represent
the unit vectors in the module. E.g. using ${v_1,v_2,v_3}$ the
module element $[x_1^2,0,x_1-x_2]$ is represented as
$x_1^2 v_1 + x_1 v_3 - x_2 v_3$. The use of ${v_1,v_2,v_3}$
as unit vectors is set up by assigning the set of auxiliary variables
to the share variable $GMODULE$, e.g.
\begin{verbatim}
   GMODULE := {V1,V2,V3};
\end{verbatim}
After this declaration all monomials built from these variables
are considered as an algebraically independent basis of a vector
space. However, you had best use them only linearly. Once $GMODULE$
has been set, the auxiliary variables automatically will be
added to the end of each variable list (if they are not yet
member there).
Example:
\begin{verbatim}
   torder({x,y,v1,v2,v3},lex)$
   gmodule := {v1,v2,v3}$
   g:=groebner{x^2*v1 + y*v2,x*y*v1 - v3,2y*v1 + y*v3};

       2
G := {X *V1 + Y*V2,

              2
      X*V3 + Y *V2,

       3
      Y *V2 - 2*V3,

      2*Y*V1 + Y*V3}

   preduce((x+y)^3*v1,g);

             1   3         2
 - X*Y*V2 - ---*Y *V3 - 3*Y *V2 + 3*Y*V3
             2

\end{verbatim}

In many cases a total degree oriented term order will be adequate
for computations in modules, e.g. for all cases where the
submodule membership is investigated. However, arranging
the auxiliary variables in an elimination oriented term order
can give interesting results. E.g.
\begin{verbatim}
   p1:=(x-1)*(x^2-x+3)$  p2:=(x-1)*(x^2+x-5)$
   gmodule := {v1,v2,v3};
   torder({v1,x,v2,v3},lex)$
   gb:=groebner {p1*v1+v2,p2*v1+v3};

GB := {30*V1*X - 30*V1 + X*V2 - X*V3 + 5*V2 - 3*V3,

        2       2
       X *V2 - X *V3 + X*V2 + X*V3 - 5*V2 - 3*V3}

   g:=coeffn(first gb,v1,1);

G := 30*(X - 1)

   c1:=coeffn(first gb,v2,1);

C1 := X + 5

   c2:=coeffn(first gb,v3,1);

C2 :=  - X - 3

   c1*p1 + c2*p2;

30*(X - 1)

\end{verbatim}
Here two polynomials
are entered as vectors $[p_1,1,0]$ and $[p_2,0,1]$. Using a term
ordering such that the first dimension ranges highest and the
other components lowest, a classical cofactor computation is
executed just as in the extended Euclidean algorithm.
Consequently the leading polynomial in the resulting
basis shows the greatest common divisor of $p_1$ and $p_2$,
found as a coefficient of $v_1$ while the coefficients
of $v_2$ and $v_3$ are the cofactors $c_1$ and $c_2$ of the polynomials
$p_1$ and $p_2$ with the relation $gcd(p_1,p_2) = c_1p_1 + c_2p_2$.


\subsection{Additional Orderings}
Besides the basic orderings, there are ordering options that are used for
special purposes.

\subsubsection{Separating the Variables into Groups }
\index{grouped ordering}
It is often desirable to separate variables
and formal parameters in a system of polynomials.
This can be done with a {\it lex} Gr\"obner
basis.  That however may be hard to compute as it does more
separation than necessary. The following orderings group the
variables into two (or more) sets, where inside each set a classical
ordering acts, while the sets are handled via their total degrees,
which are compared in elimination style. So the Gr\"obner basis will
eliminate the members of the first set, if algebraically possible.
{\it Torder} here gets an additional parameter which describe the
grouping \ttindex{TORDER}
\begin{center}{\it
\begin{tabular}{l}
TORDER ($vl$,gradlexgradlex, $n$) \\
TORDER ($vl$,gradlexrevgradlex,$n$) \\
TORDER ($vl$,lexgradlex, $n$) \\
TORDER ($vl$,lexrevgradlex, $n$)
\end{tabular}}
\end{center}
Here the integer $n$ is the number of variables in the first group
and the names combine the local ordering for the first and second
group, e.g.
\begin{center}
\begin{tabular}{llll}
\multicolumn{4}{l}{{\it lexgradlex}, 3 for $\{x_1,x_2,x_3,x_4,x_5\}$:} \\
\multicolumn{4}{l}{$x_1^{i_1}\ldots x_5^{i_5} \gg x_1^{j_1}\ldots
x_5^{j_5}$} \\
if & & & $(i_1,i_2,i_3) \gg_{lex}(j_1,j_2,j_3)$ \\
& or & & $(i_1,i_2,i_3) = (j_1,j_2,j_3)$ \\
& & and & $(i_4,i_5) \gg_{gradlex}(j_4,j_5)$
\end{tabular}
\end{center}
Note that in the second place there is no {\it lex} ordering available;
that would not make sense.

\subsubsection{Weighted Ordering}
\ttindex{TORDER} \index{weighted ordering}
The statement
\begin{center}
\begin{tabular}{cl}
{\it TORDER} &($vl$,weighted, $\{n_1,n_2,n_3  \ldots$\}) ; \\
\end{tabular}
\end{center}
establishes a graduated ordering, where the exponents are first
multiplied by the given weights. If there are less weight values than
variables, the weight 1 is added automatically. If the weighted
degree calculation is not decidable, a $lex$ comparison follows.

\subsubsection{Graded Ordering}
\ttindex{TORDER} \index{graded ordering}
The statement
\begin{center}
\begin{tabular}{cl}
{\it TORDER} &($vl$,graded, $\{n_1,n_2,n_3 \ldots\}$,$order_2$) ; \\
\end{tabular}
\end{center}
establishes a graduated ordering, where the exponents are first
multiplied by the given weights. If there are less weight values than
variables, the weight 1 is added automatically. If the weighted
degree calculation is not decidable, the term order $order_2$ specified
in the following argument(s) is used.  The ordering $graded$ is designed
primarily for use with the operator $dd\_groebner$.


\subsubsection{Matrix Ordering}
\ttindex{TORDER} \index{matrix ordering}
The statement
\begin{center}
\begin{tabular}{cl}
{\it TORDER} &($vl$,matrix, $M$) ; \\
\end{tabular}
\end{center}
where $M$ is a matrix with integer elements and row length which
corresponds to the variable number. The exponents of each monomial
form a vector; two monomials are compared by multiplying their
exponent vectors first with $M$ and comparing the resulting vector
lexicographically. E.g. the unit matrix establishes the classical
$LEX$ term order mode, a matrix with a first row of ones followed
by the rows of a unit matrix corresponds to the $GRADLEX$ ordering.

The matrix $M$ must have at least as many rows as columns; a non--square
matrix contains redundant rows. The matrix must have full rank, and
the top non--zero element of each column must be positive.

The generality of the matrix based term order has its price: the
computing time spent in the term sorting is significantly higher
than with the specialized term orders. To overcome this problem,
you can compile a matrix term order
if your REDUCE is equipped with a LISP compiler; the
compilation reduces the computing time overhead significantly.
If you set the switch $COMP$ on, any new order matrix is compiled
when any operator of the GROEBNER package accesses it for the
first time. Alternatively you can compile a matrix explicitly
\begin{verbatim}
    torder_compile(<n>,<m>);
\end{verbatim}
where $<n>$ is a name (an identifier) and $<m>$ is a term order matrix.
$torder\_compile$ transforms the matrix into a LISP program, which
is compiled by the LISP compiler when $COMP$ is on or when you
generate a fast loadable module. Later you can activate the new term
order by using the name $<n>$ in a $torder$ statement as term ordering
mode.

\subsection{Gr\"obner Bases for Graded Homogeneous Systems}

For a homogeneous system of polynomials under a term order
{\it graded}, {\it gradlex}, {\it revgradlex} or {\it weighted}
a Gr\"obner Base can be computed with limiting the grade
of the intermediate $S$--polynomials:
\begin{description}
\ttindex{dd\_groebner}
\item [{\it dd\_groebner}]($d1$,$d2$,$\{p_1,p_2,\ldots\}$);
\end{description}
where $d1$ is a non--negative integer and $d2$ is an integer
$>$ $d1$ or ``infinity". A pair of polynomials is considered
only if the grade of the lcm of their head terms is between
$d1$ and $d2$. See \cite{BeWei:93} for the mathematical background.
For the term orders {\it graded} or {\it weighted} the (first) weight
vector is used for the grade computation. Otherwise the total
degree of a term is used.

\section{Ideal Decomposition \& Equation System Solving}
Based on the elementary Gr\"obner operations, the GROEBNER package offers
additional operators, which allow the decomposition of an ideal or of a
system of equations down to the individual solutions.
% Section 4.1
\subsection{Solutions Based on Lex Type Gr\"obner Bases}
% Subsection 4.1.1
\subsubsection{GROESOLVE: Solution of a Set of Polynomial Equations}
\ttindex{GROESOLVE} \ttindex{GROEBNERF}
The GROESOLVE operator incorporates a macro algorithm;
lexical Gr\"obner bases are computed by GROEBNERF and decomposed
into simpler ones by ideal decomposition techniques; if algebraically
possible, the problem is reduced to univariate polynomials which are
solved by SOLVE; if ROUNDED is on, numerical approximations are
computed for the roots of the univariate polynomials.
\[
 GROESOLVE(\{exp1, exp2, \ldots , expm\}[,\{var1, var2, \ldots ,
varn\}]); \]
where $\{exp1, exp2,\ldots , expm\}$ is a list of any number of
expressions or equations, $\{var1, var2, \ldots , varn\}$ is an
optional list of variables.

The result is a set of subsets. The subsets contain the solutions of the
polynomial equations. If there are only finitely many solutions,
then each subset is a set of expressions of triangular type
$\{exp1, exp2,\ldots , expn\},$ where $exp1$ depends only on
$var1,$ $exp2$ depends only on $var1$ and $var2$ etc. until $expn$ which
depends on $var1,\ldots,varn.$ This allows a successive determination of
the solution components. If there are infinitely many solutions,
some subsets consist in less than $n$ expressions. By considering some
of the variables as ``free parameters'',  these subsets are usually
again of triangular type.


\example (intersections of a line with a circle):
\index{GROEBNER package ! example}

\[
GROESOLVE(\{x**2 - y**2 - a, p*x+q*y+s\},\{x,y\});
\]
%{\small
\begin{verbatim}
                   2      2    2             2    2
   {{X=(SQRT( - A*P  + A*Q  + S )*Q - P*S)/(P  - Q ),
                      2      2    2             2    2
     Y= - (SQRT( - A*P  + A*Q  + S )*P - Q*S)/(P  - Q )},
                      2      2    2             2    2
    {X= - (SQRT( - A*P  + A*Q  + S )*Q + P*S)/(P  - Q ),
                   2      2    2             2    2
     Y=(SQRT( - A*P  + A*Q  + S )*P + Q*S)/(P  - Q )}}
\end{verbatim}
%}
% Subsection 4.1.2
\subsubsection{GROEPOSTPROC: Postprocessing of a Gr\"obner Basis}
\ttindex{GROEPOSTPROC}
In many cases, it is difficult to do the general Gr\"obner processing.
If a Gr\"obner basis with a {\it lex} ordering is calculated already (e.g.,
by very individual parameter settings), the solutions can be derived
from it by a call to GROEPOSTPROC. GROESOLVE is functionally
equivalent to a call to GROEBNERF and subsequent calls to
GROEPOSTPROC for each partial basis.
\[
 GROEPOSTPROC(\{exp1, exp2, \ldots , expm\}[,\{var1, var2, \ldots ,
varn\}]);
\]
where $\{exp1, exp2, \ldots , expm\}$ is a list of any number of
expressions, \linebreak[4] $\{var1, var2, \ldots ,$ $ varn\}$ is an
optional list of variables. The expressions must be a {\it lex} Gr\"obner
basis with the given variables; the ordering must be still active.

The result is the same as with GROESOLVE.

\begin{verbatim}
groepostproc({x3**2 + x3 + x2 - 1,
              x2*x3 + x1*x3 + x3 + x1*x2 + x1 + 2,
              x2**2 + 2*x2 - 1,
              x1**2 - 2},{x3,x2,x1});

{{X3= - SQRT(2),

  X2=SQRT(2) - 1,

  X1=SQRT(2)},

 {X3=SQRT(2),

  X2= - (SQRT(2) + 1),

  X1= - SQRT(2)},

      SQRT(4*SQRT(2) + 9) - 1
 {X3=-------------------------,
                 2

  X2= - (SQRT(2) + 1),

  X1=SQRT(2)},

       - (SQRT(4*SQRT(2) + 9) + 1)
 {X3=------------------------------,
                   2

  X2= - (SQRT(2) + 1),

  X1=SQRT(2)},

      SQRT( - 4*SQRT(2) + 9) - 1
 {X3=----------------------------,
                  2

  X2=SQRT(2) - 1,

  X1= - SQRT(2)},

       - (SQRT( - 4*SQRT(2) + 9) + 1)
 {X3=---------------------------------,
                     2

  X2=SQRT(2) - 1,

  X1= - SQRT(2)}}
\end{verbatim}

% Subsection 4.1.3
\subsubsection{IDEALQUOTIENT: Quotient of an Ideal and an Expression}
\ttindex{IDEALQUOTIENT} \index{ideal quotient}
Let $I$ be an ideal and $f$ be a polynomial in the same
variables. Then the algebraic quotient is defined by
\[
I:f = \{ p \;| \; p * f \;\mbox{    member of }\; I\}\;.
\]
The ideal quotient $I:f$ contains $I$ and is obviously part of the
whole polynomial ring, i.e. contained in $\{1\}$. The case $I:f =
\{1\}$ is equivalent to $f$ being a member of  $I$. The other extremal
case, $I:f=I$, occurs, when $f$ does not vanish at any general zero of $I$.
The explanation of the notion ``general zero'' introduced by van der
Waerden, however, is beyond the aim of this manual. The operation
of GROESOLVE/GROEPOSTPROC is based on nested ideal quotient
calculations.

If $I$ is given by a basis and $f$ is given as an expression, the
quotient can be calculated by
\[
IDEALQUOTIENT (\{exp1, \ldots , expm\}, exp); \]
where $\{exp1, exp2, \ldots , expm\}$ is a list of any number of
expressions or equations, {\it exp} is a single expression or equation.

IDEALQUOTIENT calculates the algebraic quotient of the ideal $I$
with the basis  $\{exp1, exp2, \ldots , expm\}$ and {\it exp} with
respect to  the variables given or extracted.  $\{exp1, exp2, \ldots ,
expm\}$ is not necessarily a Gr\"obner basis.
The result is the Gr\"obner basis of
the quotient.

\subsection{Operators for Gr\"obner Bases in all Term Orderings}
\index{Hilbert polynomial}
In some cases where no Gr\"obner
basis with lexical ordering can be calculated, a calculation with a total
degree ordering is still possible. Then the Hilbert polynomial gives
information about the dimension of the solutions space and for finite
sets of solutions univariate polynomials can be calculated. The solutions
of the equation system then is contained in the cross product of all
solutions of all univariate polynomials.

\subsubsection{HILBERTPOLYNOMIAL: Hilbert Polynomial of an Ideal}
\ttindex{HILBERTPOLYNOMIAL}
This algorithm was contributed by {\sc Joachim Hollman}, Royal
Institute of Technology, Stockholm (private communication).

\[
HILBERTPOLYNOMIAL (\{exp1, \ldots , expm\})\;;
\]
where $\{exp1, exp2, \ldots , expm\}$ is a list of any number of
expressions or equations.

HILBERTPOLYNOMIAL calculates the Hilbert polynomial of the ideal
with basis $\{exp1, exp2, \ldots , expm\}$ with respect to the
variables given or extracted provided the given term ordering is
compatible with the degree, such as the GRADLEX- or REVGRADLEX-ordering.
The term ordering of the basis
must be active and $\{exp1, exp2,\ldots$, $ expm\}$ should be a
Gr\"obner basis with respect to this ordering. The Hilbert polynomial
gives information about the cardinality of solutions of the system
$\{exp1, exp2, \ldots , expm\}$: if the Hilbert polynomial is an
integer, the system has only a discrete set of solutions and the
polynomial is identical with the number of solutions counted with
their multiplicities. Otherwise the degree of the Hilbert
polynomial is the dimension of the solution space.

If the Hilbert polynomial is not a constant, it is constructed with the
variable ``X'' regardless of whether $x$ is member of $\{var1, var2,
\ldots , varn\}$ or not. The value of this polynomial at sufficiently
large numbers  ``X''
is the difference
of the dimension of the linear vector space of all polynomials of degree
$ \leq X $ minus the dimension of the subspace of all polynomials of
degree $\leq X $ which belong also to the ideal.

\paragraph{Remark:} The number of zeros in an ideal and the
Hilbert polynomial depend only on the leading terms of the
Gr\"obner basis. So if a subsequent Hilbert calculation is planned, the
Gr\"obner calculation should be performed with ON GLTBASIS and
the value of GLTB (or its elements in a GROEBNERF context) should be
given to HILBERTPOLYNOMIAL.  In this manner, a lot of computing time can be
saved in the case of large bases.

% Chapter 5.
\section{Calculations ``by Hand''}
The following operators support explicit calculations with
polynomials in a distributive representation at the REDUCE top level.
So they allow one to do Gr\"obner type evaluations stepwise by
separate calls. Note that the normal REDUCE arithmetic can be used
for arithmetic combinations of monomials and polynomials.

% Subsection 5.1
\subsection{Representing Polynomials in Distributive Form}
\ttindex{GSORT}
\[
 GSORT (p);
\]
where $p$ is a polynomial or a list of polynomials.

If $p$ is a single polynomial, the result is a reordered version of $p$
in the distributive representation according to the variables and the
current term order mode; if $p$ is a list, its members are converted
into distributive representation and the result is the list sorted by
the term ordering of the leading terms; zero polynomials are
eliminated from the result.

\begin{verbatim}
     torder({alpha,beta,gamma},lex);
     dip := gsort(gamma*(alpha-1)**2*(beta+1)**2);


                2     2                2
    DIP := ALPHA *BETA *GAMMA + 2*ALPHA *BETA*GAMMA

           2                     2
    + ALPHA *GAMMA - 2*ALPHA*BETA *GAMMA - 4*ALPHA*BETA*GAMMA

                           2
     - 2*ALPHA*GAMMA + BETA *GAMMA + 2*BETA*GAMMA + GAMMA

 \end{verbatim}


% Subsection 5.2
\subsection{Splitting of a Polynomial into Leading Term and Reductum}
\ttindex{GSPLIT}
\[
GSPLIT (p);
\]
where $p$ is a polynomial.

GSPLIT converts the polynomial $p$ into distributive representation
and splits it into leading monomial and reductum. The result is a list
with two elements, the leading monomial and the reductum.

\begin{verbatim}
   gslit(dip);

          2     2
    {ALPHA *BETA *GAMMA,

            2                   2                     2
     2*ALPHA *BETA*GAMMA + ALPHA *GAMMA - 2*ALPHA*BETA *GAMMA

                         2
     - 4*ALPHA*BETA*GAMMA - 2*ALPHA*GAMMA + BETA *GAMMA


     + 2*BETA*GAMMA + GAMMA}

 \end{verbatim}


\subsection{Calculation of Buchberger's S-polynomial}
\ttindex{GSPOLY}
\[
GSPOLY (p1,p2);
\]
where $p1$  and $p2$ are polynomials.

GSPOLY calculates the $S$-polynomial from $p1$  and $p2$;

Example for a complete calculation (taken from {\sc Davenport et al.}
 \cite{Davenport:88a}):
\begin{verbatim}
   torder({x,y,z},lex)$
   g1  :=  x**3*y*z - x*z**2;
   g2  :=  x*y**2*z - x*y*z;
   g3  :=  x**2*y**2 - z;$

   % first S-polynomial

   g4  :=  gspoly(g2,g3);$

       2        2
    G4 := X *Y*Z - Z

    % next S-polynomial

    p :=  gspoly(g2,g4); $

          2          2
    P := X *Y*Z - Y*Z

    % and reducing, here only by g4

    g5  :=  preduce(p,{g4});

                2    2
    G5 :=  - Y*Z  + Z

    % last S-polynomial}

    g6  :=  gspoly(g4,g5);

           2  2    3
    G6 := X *Z  - Z

    % and the final basis sorted descending

    gsort{g2,g3,g4,g5,g6};

      2  2
    {X *Y  - Z,

      2        2
     X *Y*Z - Z ,

      2  2    3
     X *Z  - Z ,

        2
     X*Y *Z - X*Y*Z,

           2    2
      - Y*Z  + Z }
 \end{verbatim}

\bibliography{groebner}
\bibliographystyle{plain}
\end{document}

