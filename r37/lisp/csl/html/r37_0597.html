<a name="lu_decom"> <title>lu_decom</title></a>
<b><a href="r37_idx.html">INDEX</a></b>
<p></p>
<p><b>LU_DECOM</b> _ _ _ _ _ _ _ _ _ _ _ _ <b>operator</b></p>

<p></p>
<p></p>

<p></p>
<p></p>
<p></p>
<h3>syntax:</h3>
<em>lu_decom</em>(&lt;matrix&gt;)
<p></p>
<p></p>
<p>
  &lt;matrix&gt; :- a
  <a href="r37_0345.html">matrix</a> containing either numeric entries or
  imaginary entries with numeric coefficients.
</p>

<p></p>
<p>
  <em>lu_decom</em>performs LU decomposition on &lt;matrix&gt;, ie: it returns
  {L,U} where L is a lower diagonal <a href="r37_0345.html">matrix</a>, U an
  upper diagonal <a href="r37_0345.html">matrix</a> and A = LU.
</p>

<p></p>
<p>Caution:</p>

<p></p>
<p>
  The algorithm used can swap the rows of &lt;matrix&gt; during the calculation.
  This means that LU does not equal &lt;matrix&gt; but a row equivalent of it.
  Due to this, <em>lu_decom</em> returns {L,U,vec}. The call
  <em>convert(meta{matrix</em>,vec)} will return the matrix that has been
  decomposed, i.e: LU = convert(&lt;matrix&gt;,vec).
</p>

<p></p>
<p></p>
<p></p>
<h3>examples:</h3>
<p></p>
<pre><TT>

K := mat((1,3,5),(-4,3,7),(8,6,4)); 


       [1   3  5]
       [        ]
  k := [-4  3  7]
       [        ]
       [8   6  4]



on rounded;

lu :=  lu_decom(K); 

  lu := {
         [8    0      0  ]
         [               ]
         [-4  6.0     0  ]
         [               ]
         [1   2.25  1.125]
         ,
         [1  0.75  0.5]
         [            ]
         [0   1    1.5]
         [            ]
         [0   0     1 ]
         ,
         [3 2 3]}



first lu * second lu; 

  [8   6.0  4.0]
  [            ]
  [-4  3.0  7.0]
  [            ]
  [1   3.0  5.0]



convert(K,third lu); 

  P := mat((i+1,i+2,i+3),(4,5,2),(1,i,0));  _ _ _ 
       [i + 1  i + 2  i + 3]
       [                   ]
  p := [  4      5      2  ]
       [                   ]
       [  1      i      0  ]


lu :=  lu_decom(P); 

  lu := {
         [  1        0                      0                ]
         [                                                   ]
         [  4     - 4*i + 5                 0                ]
         [                                                   ]
         [i + 1      3       0.414634146341*i + 2.26829268293]
         ,
         [1  i                 0                ]
         [                                      ]
         [0  1  0.19512195122*i + 0.243902439024]
         [                                      ]
         [0  0                 1                ]
         ,
         [3 2 3]}



first lu * second lu; 

  [  1      i       0   ]
  [                     ]
  [  4      5      2.0  ]
  [                     ]
  [i + 1  i + 2  i + 3.0]



convert(P,third lu); 

  [  1      i      0  ]
  [                   ]
  [  4      5      2  ]
  [                   ]
  [i + 1  i + 2  i + 3]

</TT></PRE>
<p></p>
<p></p>
<p>
  Related functions:
  <a href="r37_0581.html">cholesky</a>.
</p>

<p></p>
<p></p>
