<a name="Jordan"> <title>Jordan</title></a>
<b><a href="r37_idx.html">INDEX</a></b>
<p></p>
<p><b>JORDAN</b> _ _ _ _ _ _ _ _ _ _ _ _ <b>operator</b></p>

<p></p>
<p>
  The operator <em>jordan</em> computes the Jordan normal form J of a
  <a href="r37_0345.html">matrix</a> (A say). It returns {J,P,P^-1} where
  P*J*P^-1 = A.
</p>

<p></p>
<p></p>
<p></p>
<h3>syntax:</h3>
<em>jordan</em>(&lt;matrix&gt;)
<p></p>
<p>
  &lt;matrix&gt; :- a square
  <a href="r37_0345.html">matrix</a>.
</p>

<p></p>
<p></p>
<p>
  Field Extensions: By default, calculations are performed in the rational
  numbers. To extend this field the <em>arnum</em> package can be used. The
  package must first be loaded by load_package arnum;. The field can now be
  extended by using the defpoly command. For example, defpoly sqrt2**2-2; will
  extend the field to include the square root of 2 (now defined by sqrt2). See
  <a href="r37_0626.html">frobenius</a> for an example.
</p>

<p></p>
<p>
  Modular Arithmetic:
  <em>Jordan</em> can also be calculated in a modular base. To do this first
  type on modular;. Then setmod p; (where p is a prime) will set the modular
  base of calculation to p. By further typing on balanced_mod the answer will
  appear using a symmetric modular representation. See

  <a href="r37_0627.html">ratjordan</a> for an example.
</p>

<p></p>
<p></p>
<p></p>
<h3>examples:</h3>
<p></p>
<pre><TT>

 a := mat((1,x),(0,x));

       [1  x]
  a := [    ]
       [0  x]



 jordan(a);

  {
   [1  0]
   [    ]
   [0  x]
   ,
   [   1           x       ]
   [-------  --------------]
   [ x - 1     2           ]
   [          x  - 2*x + 1 ]
   [                       ]
   [               1       ]
   [   0        -------    ]
   [             x - 1     ]
   ,
   [x - 1   - x ]
   [            ]
   [  0    x - 1]
   }

</TT></PRE>
<p></p>
