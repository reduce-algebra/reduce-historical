
<A NAME=Jordan>

<TITLE>Jordan</TITLE></A>
<b><a href=r37_idx.html>INDEX</a></b><p><p>



<B>JORDAN</B> _ _ _  _ _ _  _ _ _  _ _ _ <B>operator</B><P>
<P>
 
The operator <em>jordan</em> computes the Jordan normal form J 
of a 
<A HREF=r37_0345.html>matrix</A> (A say). It returns {J,P,P^-1} where P*J*P^-1 =
 A. 
<P>
<P>
 <P> <H3> 
syntax: </H3>
<em>jordan</em>(&lt;matrix&gt;) 
<P>
<P>
&lt;matrix&gt; :- a square 
<A HREF=r37_0345.html>matrix</A>. 
<P>
<P>
<P>
Field Extensions: 
By default, calculations are performed in the rational numbers. To 
extend this field the <em>arnum</em> package can be used. The package must 
first be loaded by load_package arnum;. The field can now be extended 
by using the defpoly command. For example, defpoly sqrt2**2-2; will 
extend the field to include the square root of 2 (now defined by sqrt2). 
See 
<A HREF=r37_0626.html>frobenius</A> for an example. 
<P>
<P>
Modular Arithmetic: 
<em>Jordan</em> can also be calculated in a modular base. To do this 
first type on modular;. Then setmod p; (where p is a prime) will set 
the modular base of calculation to p. By further typing on balanced_mod 
the answer will appear using a symmetric modular representation. See 

<A HREF=r37_0627.html>ratjordan</A> for an example. 
<P>
<P>
 <P> <H3> 
examples: </H3>
<P><PRE><TT>

 a := mat((1,x),(0,x)); 

       [1  x]
  a := [    ]
       [0  x]



 jordan(a);

  {
   [1  0]
   [    ]
   [0  x]
   ,
   [   1           x       ]
   [-------  --------------]
   [ x - 1     2           ]
   [          x  - 2*x + 1 ]
   [                       ]
   [               1       ]
   [   0        -------    ]
   [             x - 1     ]
   ,
   [x - 1   - x ]
   [            ]
   [  0    x - 1]
   }

</TT></PRE><P>