<a name="DF"> <title>DF</title></a>
<b><a href="r37_idx.html">INDEX</a></b>
<p></p>
<p><b>DF</b> _ _ _ _ _ _ _ _ _ _ _ _ <b>operator</b></p>

<p></p>
<p></p>

<p></p>
<p>
  The <em>df</em> operator finds partial derivatives with respect to one or more
  variables.
</p>

<p></p>
<p></p>
<p></p>
<h3>syntax:</h3>
<em>df</em>(&lt;expression&gt;<em>,</em>&lt;var&gt; [<em>,</em>&lt;number&gt;]
{<em>,</em>&lt;var&gt; [ <em>,</em>&lt;number&gt;] } )
<p></p>
<p></p>
<p>
  &lt;expression&gt; can be any valid REDUCE algebraic expression. &lt;var&gt;
  must be a
  <a href="r37_0002.html">kernel</a>, and is the differentiation variable.
  &lt;number&gt; must be a non-negative integer.
</p>

<p></p>
<p></p>
<p></p>
<h3>examples:</h3>
<p></p>
<pre><TT>

df(x**2,x); 

  2*X 



df(x**2*y + sin(y),y); 

            2
  COS(Y) + X  



df((x+y)**10,z); 

  0 




df(1/x**2,x,2); 

  6
  ---
   4
  X



df(x**4*y + sin(y),y,x,3); 

  24*X 



for all x let df(tan(x),x) = sec(x)**2; 


df(tan(3*x),x); 

            2
  3*SEC(3*X)

</TT></PRE>
<p>
  An error message results if a non-kernel is entered as a different iation
  operator. If the optional number is omitted, it is assumed to be 1. See the
  declaration <a href="r37_0192.html">depend</a> to establish dependencies for
  implicit differentiation.
</p>

<p></p>
<p>
  You can define your own differentiation rules, expanding REDUCE's
  capabilities, using the
  <a href="r37_0199.html">let</a> command as shown in the last example above.
  Note that once you add your own rule for differentiating a function, it
  supersedes REDUCE's normal handling of that function for the duration of the
  REDUCE session. If you clear the rule (
  <a href="r37_0190.html">clearrules</a>), you don't get back to the previous
  rule.
</p>

<p></p>
<p></p>
<p></p>
