<a name="Jordansymbolic"> <title>Jordansymbolic</title></a>
<b><a href="r37_idx.html">INDEX</a></b>
<p></p>
<p><b>JORDANSYMBOLIC</b> _ _ _ _ _ _ _ _ _ _ _ _ <b>operator</b></p>

<p></p>
<p>
  The operator <em>jordansymbolic</em> computes the Jordan normal form J of a
  <a href="r37_0345.html">matrix</a> (A say). It returns {J,L,P,P^-1} where
  P*J*P^-1 = A. L = {ll,mm} where mm is a name and ll is a list of irreducible
  factors of p(mm).
</p>

<p></p>
<p></p>
<p></p>
<h3>syntax:</h3>
<em>jordansymbolic</em>(&lt;matrix&gt;)
<p></p>
<p>
  &lt;matrix&gt; :- a square
  <a href="r37_0345.html">matrix</a>.
</p>

<p></p>
<p></p>
<p>Field Extensions:</p>

<p></p>
<p>
  By default, calculations are performed in the rational numbers. To extend this
  field the
  <a href="r37_0634.html">arnum</a> package can be used. The package must first
  be loaded by load_package arnum;. The field can now be extended by using the
  defpoly command. For example, defpoly sqrt2**2-2; will extend the field to
  include the square root of 2 (now defined by sqrt2). See
  <a href="r37_0626.html">frobenius</a> for an example.
</p>

<p></p>
<p>Modular Arithmetic:</p>

<p></p>
<p>
  <em>jordansymbolic</em>can also be calculated in a modular base. To do this
  first type on modular;. Then setmod p; (where p is a prime) will set the
  modular base of calculation to p. By further typing on balanced_mod the answer
  will appear using a symmetric modular representation. See

  <a href="r37_0627.html">ratjordan</a> for an example.
</p>

<p></p>
<p></p>
<p></p>
<h3>examples:</h3>
<p></p>
<pre><TT>

 a := mat((1,y),(2,5*y));

       [1   y ]
  a := [      ]
       [2  5*y]



 jordansymbolic(a);

  {
   [lambda11     0    ]
   [                  ]
   [   0      lambda12]
   ,
           2
   lambda  - 5*lambda*y - lambda + 3*y,lambda,
   [lambda11 - 5*y  lambda12 - 5*y]
   [                              ]
   [      2               2       ]
   ,
   [ 2*lambda11 - 5*y - 1    5*lambda11*y - lambda11 - y + 1 ]
   [----------------------  ---------------------------------]
   [       2                              2                  ]
   [   25*y  - 2*y + 1             2*(25*y  - 2*y + 1)       ]
   [                                                         ]
   [ 2*lambda12 - 5*y - 1    5*lambda12*y - lambda12 - y + 1 ]
   [----------------------  ---------------------------------]
   [       2                              2                  ]
   [   25*y  - 2*y + 1             2*(25*y  - 2*y + 1)       ]
   }

</TT></PRE>
<p></p>
