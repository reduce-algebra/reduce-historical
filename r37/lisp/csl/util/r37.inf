This is Info file ..\util\r37.inf, produced by Makeinfo-1.55 from the
input file r37.y.


File: ..\util\r37,  Node: IDENTIFIER,  Next: KERNEL,  Up: Concepts section

   IDENTIFIER                    type

   Identifiers in REDUCE consist of one or more alphanumeric
characters, of which the first must be alphabetical. The maximum number
of characters allowed is system dependent, but is usually over 100.
However, printing is simplified if they are kept under 25 characters.

   You can also use special characters in your identifiers, but each
must be preceded by an exclamation point ! as an escape character.
Useful special characters are  # $ % ^ & * - + = ? < > ^  / ! and the
space. Note that the use of the exclamation point as a special
character requires a second exclamation point as an escape character.
The underscore _ is special in this regard. It must be preceded by an
escape character in the first position in an identifier, but is treated
like a normal letter within an identifier.

   Other characters, such as ( ) # ;  ' " can also be used if preceded
by a ! , but as they have special meanings to the Lisp reader it is
best to avoid them to avoid confusion.

   Many system identifiers have * before or after their names, or -
between words. If you accidentally pick one of these names for your own
identifier, it could have disastrous effects. For this reason it is
wise not to include * or - anywhere in your identifiers.

   You will notice that REDUCE does not use the escape characters when
it prints identifiers containing special characters; however, you still
must use them when you refer to these identifiers. Be careful when
editing statements containing escaped special characters to treat the
character and its escape as an inseparable pair.

   Identifiers are used for variable names, labels for GO TO statements,
and names of arrays, matrices, operators, and procedures. Once an
identifier is used as a matrix, array, scalar or operator identifier,
it may not be used again as a matrix, array or operator. An operator or
array identifier may later be used as a scalar without problems, but a
matrix identifier cannot be used as a scalar. All procedures are
entered into the system as operators, so the name of a procedure may
not be used as a matrix, array, or operator identifier either.


File: ..\util\r37,  Node: KERNEL,  Next: STRING,  Prev: IDENTIFIER,  Up: Concepts section

   KERNEL                    type

   A KERNEL is a form that cannot be modified further by the REDUCE
canonical simplifier. Scalar variables are always kernels. The other
important class of kernels are operators with their arguments.  Some
examples should help clarify this concept:

     ____________________________________________________________
     
             Expression                     Kernel?
     
               x                              Yes
               varname                        Yes
               cos(a)                         Yes
               log(sin(x**2))                 Yes
               a*b                            No
               (x+y)**4                       No
               matrix-identifier              No
     ____________________________________________________________
   Many REDUCE operators expect kernels among their arguments. Error
messages result from attempts to use non-kernel expressions for these
arguments.


File: ..\util\r37,  Node: STRING,  Prev: KERNEL,  Up: Concepts section

   STRING                    type

   A STRING is any collection of characters enclosed in double quotation
marks (" ). It may be used as an argument for a variety of commands and
operators, such as IN , REDERR and WRITE .

examples:

     ____________________________________________________________
     
     write "this is a string";
     
       this is a string
     
     
     write a, " ", b, " ",c,"!";
     
       A B C!
     
     ____________________________________________________________


File: ..\util\r37,  Node: Concepts section,  Next: Variables section,  Up: Top

   Concepts section

* Menu:

* IDENTIFIER::              type
* KERNEL::                  type
* STRING::                  type


File: ..\util\r37,  Node: assumptions,  Next: CARD_NO,  Up: Variables section

   ASSUMPTIONS                    variable

   After solving a linear or polynomial equation system with
parameters, the variable ASSUMPTIONS contains a list of side relations
for the parameters. The solution is valid only as long as none of these
expression is zero.

examples:

     ____________________________________________________________
     
     solve({a*x-b*y+x,y-c},{x,y});
     
            b*c
       {{x=-----,y=c}}
           a + 1
     
     
     assumptions;
     
       {a + 1}
     
     ____________________________________________________________


File: ..\util\r37,  Node: CARD_NO,  Next: E,  Prev: assumptions,  Up: Variables section

   CARD_NO                    variable

   CARD_NO  sets the total number of cards allowed in a Fortran output
statement when FORT is on. Default is 20.

examples:

     ____________________________________________________________
     
     on fort;
     
     card_no := 4;
     
       CARD_NO=4.
     
     
     z := (x + y)**15;
     
             ANS1=5005.*X**6*Y**9+3003.*X**5*Y**10+1365.*X**4*Y**
            . 11+455.*X**3*Y**12+105.*X**2*Y**13+15.*X*Y**14+Y**15
             Z=X**15+15.*X**14*Y+105.*X**13*Y**2+455.*X**12*Y**3+
            . 1365.*X**11*Y**4+3003.*X**10*Y**5+5005.*X**9*Y**6+
            . 6435.*X**8*Y**7+6435.*X**7*Y**8+ANS1
     
     ____________________________________________________________
   Twenty total cards means 19 continuation cards. You may set it for
more if your Fortran system allows more. Expressions are broken apart
in a Fortran-compatible way if they extend for more than CARD_NO
continuation cards.


File: ..\util\r37,  Node: E,  Next: EVAL_MODE,  Prev: CARD_NO,  Up: Variables section

   E                    constant

   The constant E is reserved for use as the base of the natural
logarithm. Its value is approximately 2.71828284590, which REDUCE gives
to the current decimal precision when the switch [*note ROUNDED::.] is
on.

   E may be used as an iterative variable in a [*note FOR::.] statement,
or as a local variable or a [*note PROCEDURE::.] . If E is defined as a
local variable inside the procedure, the normal definition as the base
of the natural logarithm would be suspended inside the procedure.


File: ..\util\r37,  Node: EVAL_MODE,  Next: FORT_WIDTH,  Prev: E,  Up: Variables section

   EVAL_MODE                    variable

   The system variable EVAL_MODE contains the current mode, either
[*note ALGEBRAIC::.]  or [*note SYMBOLIC::.] .

examples:

     ____________________________________________________________
     
     EVAL_MODE;
     
       ALGEBRAIC
     
     ____________________________________________________________
   Some commands do not behave the same way in algebraic and symbolic
modes.


File: ..\util\r37,  Node: FORT_WIDTH,  Next: HIGH_POW,  Prev: EVAL_MODE,  Up: Variables section

   FORT_WIDTH                    variable

   The FORT_WIDTH variable sets the number of characters in a line of
Fortran-compatible output produced when the [*note FORT::.] switch is
on.  Default is 70.

examples:

     ____________________________________________________________
     
     fort_width := 30;
     
       FORT_WIDTH := 30
     
     
     on fort;
     
     df(sin(x**3*y),x);
     
             ANS=3.*COS(X
            . **3*Y)*X**2*
            . Y
     
     ____________________________________________________________
   FORT_WIDTH includes the usually blank characters at the beginning of
the card. As you may notice above, it is conservative and makes the
lines even shorter than it was told.


File: ..\util\r37,  Node: HIGH_POW,  Next: I,  Prev: FORT_WIDTH,  Up: Variables section

   HIGH_POW                    variable

   The variable HIGH_POW is set by [*note COEFF::.] to the highest power
of the variable of interest in the given expression. You can access this
variable for use in further computation or display.

examples:

     ____________________________________________________________
     
     coeff((x+1)^5*(x*(y+3)^2)^2,x);
     
       {0,
        0,
         4       3       2
        Y  + 12*Y  + 54*Y  + 108*Y + 81,
            4       3       2
        5*(Y  + 12*Y  + 54*Y  + 108*Y + 81),
             4       3       2
        10*(Y  + 12*Y  + 54*Y  + 108*Y + 81),
             4       3       2
        10*(Y  + 12*Y  + 54*Y  + 108*Y + 81),
            4       3       2
        5*(Y  + 12*Y  + 54*Y  + 108*Y + 81),
         4       3       2
        Y  + 12*Y  + 54*Y  + 108*Y + 81}
     
     
     high_pow;
     
       7
     
     ____________________________________________________________


File: ..\util\r37,  Node: I,  Next: INFINITY,  Prev: HIGH_POW,  Up: Variables section

   I                    constant

   REDUCE knows I is the square root of -1,  and that i^2 = -1.

examples:

     ____________________________________________________________
     
     (a + b*i)*(c + d*i);
     
       A*C + A*D*I + B*C*I - B*D
     
     
     i**2;
     
       -1
     
     ____________________________________________________________
   I cannot be used as an identifier. It is all right to use I as an
index variable in a FOR loop, or as a local (SCALAR ) variable inside a
BEGIN...END block, but it loses its definition as the square root of -1
inside the block in that case.

   Only the simplest properties of i are known by REDUCE unless the
switch [*note COMPLEX::.] is turned on, which implements full complex
arithmetic in factoring, simplification, and functional values.
COMPLEX  is ordinarily off.


File: ..\util\r37,  Node: INFINITY,  Next: LOW_POW,  Prev: I,  Up: Variables section

   INFINITY                    constant

   The name INFINITY is used to represent the infinite positive number.
However, at the present time, arithmetic in terms of this operator
reflects finite arithmetic, rather than true operations on infinity.


File: ..\util\r37,  Node: LOW_POW,  Next: NIL,  Prev: INFINITY,  Up: Variables section

   LOW_POW                    variable

   The variable LOW_POW is set by [*note COEFF::.] to the lowest power
of the variable of interest in the given expression. You can access this
variable for use in further computation or display.

examples:

     ____________________________________________________________
     
     coeff((x+2*y)**6,y);
     
         6
       {X ,
            5
        12*X ,
            4
        60*X ,
             3
        160*X ,
             2
        240*X ,
        192*X,
        64}
     
     
     low_pow;
     
       0
     
     
     coeff(x**2*(x*sin(y) + 1),x);
     
     
     
       {0,0,1,SIN(Y)}
     
     
     low_pow;
     
       2
     
     ____________________________________________________________


File: ..\util\r37,  Node: NIL,  Next: PI,  Prev: LOW_POW,  Up: Variables section

   NIL                    constant

   NIL  represents the truth value false in symbolic mode, and is a
synonym for 0 in algebraic mode. It cannot be used for any other
purpose, even inside procedures or [*note FOR::.] loops.


File: ..\util\r37,  Node: PI,  Next: requirements,  Prev: NIL,  Up: Variables section

   PI                    constant

   The identifier PI is reserved for use as the circular constant.  Its
value is given by 3.14159265358..., which REDUCE gives to the current
decimal precision when REDUCE is in a floating-point mode.

   PI may be used as a looping variable in a [*note FOR::.] statement,
or as a local variable in a [*note PROCEDURE::.] . Its value in such
cases will be taken from the local environment.


File: ..\util\r37,  Node: requirements,  Next: ROOT_MULTIPLICITIES,  Prev: PI,  Up: Variables section

   REQUIREMENTS                    variable

   After an attempt to solve an inconsistent equation system with
parameters, the variable REQUIREMENTS contains a list of expressions.
These expressions define a set of conditions implicitly equated with
zero. Any solution to this system defines a setting for the parameters
sufficient to make the original system consistent.

examples:

     ____________________________________________________________
     
     solve({x-a,x-y,y-1},{x,y});
     
       {}
     
     
     requirements;
     
       {a - 1}
     
     ____________________________________________________________


File: ..\util\r37,  Node: ROOT_MULTIPLICITIES,  Next: T,  Prev: requirements,  Up: Variables section

   ROOT_MULTIPLICITIES                    variable

   The ROOT_MULTIPLICITIES variable is set to the list of the
multiplicities of the roots of an equation by the [*note SOLVE::.]
operator.

   [*note SOLVE::.] returns its solutions in a list. The multiplicities
of each solution are put in the corresponding locations of the list
ROOT_MULTIPLICITIES .


File: ..\util\r37,  Node: T,  Prev: ROOT_MULTIPLICITIES,  Up: Variables section

   T                    constant

   The constant T stands for the truth value true. It cannot be used as
a scalar variable in a [*note block::.] , as a looping variable in a
[*note FOR::.]  statement or as an [*note OPERATOR::.] name.


File: ..\util\r37,  Node: Variables section,  Next: Syntax section,  Prev: Concepts section,  Up: Top

   Variables section

* Menu:

* assumptions::             variable
* CARD_NO::                variable
* E::
* EVAL_MODE::              variable
* FORT_WIDTH::             variable
* HIGH_POW::               variable
* I::
* INFINITY::
* LOW_POW::                variable
* NIL::
* PI::
* requirements::            variable
* ROOT_MULTIPLICITIES::    variable
* T::


File: ..\util\r37,  Node: semicolon,  Next: dollar,  Up: Syntax section

   ;     SEMICOLON                    command

   The semicolon is a statement delimiter, indicating results are to be
printed when used in interactive mode.

examples:

     ____________________________________________________________
     
     (x+1)**2;
     
        2
       X  + 2*X + 1
     
     
     df(x**2 + 1,x);
     
       2*X
     
     ____________________________________________________________
   Entering a RETURN without a semicolon or dollar sign results in a
prompt on the following line. A semicolon or dollar sign can be added
at this point to execute the statement. In interactive mode, a
statement that is ended with a semicolon and RETURN has its results
printed on the screen.

   Inside a group statement << ...>> or a BEGIN ...END  block, a
semicolon or dollar sign separates individual REDUCE statements. Since
results are not printed from a block without a specific RETURN
statement, there is no difference between using the semicolon or dollar
sign. In a group statement, the last value produced is the value
returned by the group statement. Thus, if a semicolon or dollar sign is
placed between the last statement and the ending brackets, the group
statement returns the value 0 or nil, rather than the value of the last
statement.


File: ..\util\r37,  Node: dollar,  Next: percent,  Prev: semicolon,  Up: Syntax section

   $     DOLLAR                    command

   The dollar sign is a statement delimiter, indicating results are not
to be printed when used in interactive mode.

examples:

     ____________________________________________________________
     
     
     (x+1)**2$
     ____________________________________________________________
   The workspace is set to x^2 + 2x + 1  but nothing shows on the screen
     ____________________________________________________________
     
     
     
     ws;
     
        2
       X   + 2*X + 1
     
     ____________________________________________________________

   Entering a RETURN without a semicolon or dollar sign results in a
prompt on the following line. A semicolon or dollar sign can be added
at this point to execute the statement. In interactive mode, a
statement that ends with a dollar sign $ and a RETURN is executed, but
the results not printed.

   Inside a [*note group::.] statement << ...>> or a BEGIN ...END
[*note block::.] , a semicolon or dollar sign separates individual
REDUCE statements. Since results are not printed from a [*note
block::.] without a specific [*note RETURN::.] statement, there is no
difference between using the semicolon or dollar sign.

   In a group statement, the last value produced is the value returned
by the group statement. Thus, if a semicolon or dollar sign is placed
between the last statement and the ending brackets, the group statement
returns the value 0 or nil, rather than the value of the last statement.


File: ..\util\r37,  Node: percent,  Next: dot,  Prev: dollar,  Up: Syntax section

   %     PERCENT                    command

   The percent sign is used to precede comments; everything from a
percent to the end of the line is ignored.

examples:

     ____________________________________________________________
     
     
     df(x**3 + y,x);% This is a comment (Key){Return}
     
     
          2
       3*X
     
     
     int(3*x**2,x) %This is a comment; (Key){Return}
     ____________________________________________________________
   A prompt is given, waiting for the semicolon that was not detected
in the comment
     ____________________________________________________________
     ____________________________________________________________

   Statement delimiters ; and $ are not detected between a percent sign
and the end of the line.


File: ..\util\r37,  Node: dot,  Next: assign,  Prev: percent,  Up: Syntax section

   .     DOT                    operator

   The . (dot) infix binary operator adds a new item to the beginning
of an existing [*note LIST::.] . In high energy physics expressions, it
can also be used to represent the scalar product of two Lorentz
four-vectors.

syntax:

   <item> . <list>

   <item> can be any REDUCE scalar expression, including a list; <list>
must be a [*note LIST::.] to avoid producing an error message.  The dot
operator is right associative.

examples:

     ____________________________________________________________
     
     
     liss := a . {};
     
       LISS := {A}
     
     
     liss := b . liss;
     
       LISS := {B,A}
     
     
     newliss := liss . liss;
     
       NEWLISS := {{B,A},B,A}
     
     
     firstlis := a . b . {c};
     
       FIRSTLIS := {A,B,C}
     
     
     secondlis := x . y . {z};
     
       SECONDLIS := {X,Y,Z}
     
     
     for i := 1:3 sum part(firstlis,i)*part(secondlis,i);
     
     
     
       A*X + B*Y + C*Z
     
     ____________________________________________________________


File: ..\util\r37,  Node: assign,  Next: equalsign,  Prev: dot,  Up: Syntax section

   :=     ASSIGN                    operator

   The := is the assignment operator, assigning the value on the
right-hand side to the identifier or other valid expression on the
left-hand side.

syntax:

   <restricted_expression> := <expression>

   <restricted_expression> is ordinarily a single identifier, though
simple expressions may be used (see Comments below). <expression> is any
valid REDUCE expression. If <expression> is a [*note MATRIX::.]
identifier, then <restricted_expression> can be a matrix identifier
(redimensioned if necessary) which has each element set to the
corresponding elements of the identifier on the right-hand side.

examples:

     ____________________________________________________________
     
     a := x**2 + 1;
     
             2
       A := X   + 1
     
     
     a;
     
        2
       X  + 1
     
     
     first := second := third;
     
       FIRST := SECOND := THIRD
     
     
     first;
     
       THIRD
     
     
     second;
     
       THIRD
     
     
     b := for i := 1:5 product i;
     
       B := 120
     
     
     b;
     
       120
     
     
     w + (c := x + 3) + z;
     
       W + X + Z + 3
     
     
     c;
     
       X + 3
     
     
     y + b := c;
     
       Y + B := C
     
     
     y;
     
       - (B - C)
     
     ____________________________________________________________
   The assignment operator is right associative, as shown in the second
and third examples. A string of such assignments has all but the last
item set to the value of the last item. Embedding an assignment
statement in another expression has the side effect of making the
assignment, as well as causing the given replacement in the expression.

   Assignments of values to expressions rather than simple identifiers
(such as in the last example above) can also be done, subject to the
following remarks:

   (i) If the left-hand side is an identifier, an operator, or a power,
the substitution rule is added to the rule table.

   (ii) If the operators - + / appear on the left-hand side, all but
the first term of the expression is moved to the right-hand side.

   (iii) If the operator * appears on the left-hand side, any constant
terms are moved to the right-hand side, but the symbolic factors remain.

   Assignment is valid for [*note ARRAY::.] elements, but not for
entire arrays.  The assignment operator can also be used to attach
functionality to operators.

   A recursive construction such as A := A + B is allowed, but when A
is referenced again, the process of resubstitution continues until the
expression stack overflows (you get an error message).  Recursive
assignments can be done safely inside controlled loop expressions, such
as [*note FOR::.] ... or [*note REPEAT::.] ...UNTIL .


File: ..\util\r37,  Node: equalsign,  Next: replace,  Prev: assign,  Up: Syntax section

   =     EQUALSIGN                    operator

   The = operator is a prefix or infix equality comparison operator.

syntax:

   = (<expression>, <expression>)  or  <expression> = <expression>

   <expression> can be any REDUCE scalar expression.

examples:

     ____________________________________________________________
     
     a := 4;
     
       A := 4
     
     
     if =(a,10) then write "yes" else write "no";
     
     
     
       no
     
     
     b := c;
     
       B := C
     
     
     if b = c then write "yes" else write "no";
     
     
     
       yes
     
     
     on rounded;
     
     if 4.0 = 4 then write "yes" else write "no";
     
     
     
       yes
     
     ____________________________________________________________
   This logical equality operator can only be used inside a conditional
statement, such as [*note IF::.] ...THEN ...ELSE or [*note REPEAT::.]
...UNTIL . In other places the equal sign establishes an algebraic
object of type [*note EQUATION::.] .


File: ..\util\r37,  Node: replace,  Next: plussign,  Prev: equalsign,  Up: Syntax section

   =>     REPLACE                    operator

   The => operator is a binary operator used in [*note RULE::.] lists to
denote replacements.

examples:

     ____________________________________________________________
     
     operator f;
     
     let f(x) => x^2;
     
     f(x);
     
        2
       x
     
     ____________________________________________________________


File: ..\util\r37,  Node: plussign,  Next: minussign,  Prev: replace,  Up: Syntax section

   +     PLUSSIGN                    operator

   The + operator is a prefix or infix n-ary addition operator.

syntax:

   <expression> + <expression>+

   or + (<expression> ,<expression>+)

   <expression> may be any valid REDUCE expression.

examples:

     ____________________________________________________________
     
     x**4 + 4*x**2 + 17*x + 1;
     
        4      2
       X  + 4*X  + 17*X + 1
     
     
     14 + 15 + x;
     
       X + 29
     
     
     +(1,2,3,4,5);
     
       15
     
     ____________________________________________________________
   + is also valid as an addition operator for [*note MATRIX::.]
variables that are of the same dimensions and for [*note EQUATION::.] s.


File: ..\util\r37,  Node: minussign,  Next: asterisk,  Prev: plussign,  Up: Syntax section

   -     MINUSSIGN                    operator

   The - operator is a prefix or infix binary subtraction operator, as
well as the unary minus operator.

syntax:

   <expression> - <expression> or - (<expression>,<expression>)

   <expression> may be any valid REDUCE expression.

examples:

     ____________________________________________________________
     
     15 - 4;
     
       11
     
     
     x*(-5);
     
       - 5*X
     
     
     a - b - 15;
     
       A - B - 15
     
     
     -(a,4);
     
       A - 4
     
     ____________________________________________________________
   The subtraction operator is left associative, so that a - b - c is
equivalent to (a - b) - c, as shown in the third example. The
subtraction operator is also valid with [*note MATRIX::.] expressions
of the correct dimensions and with [*note EQUATION::.] s.


File: ..\util\r37,  Node: asterisk,  Next: slash,  Prev: minussign,  Up: Syntax section

   *     ASTERISK                    operator

   The * operator is a prefix or infix n-ary multiplication operator.

syntax:

   <expression> * <expression>+

   or * (<expression> ,<expression>+)

   <expression> may be any valid REDUCE expression.

examples:

     ____________________________________________________________
     
     15*3;
     
       45
     
     
     24*x*yvalue*2;
     
       48*X*YVALUE
     
     
     *(6,x);
     
       6*X
     
     
     on rounded;
     
     3*1.5*x*x*x;
     
            3
       4.5*X
     
     
     off rounded;
     
     2x**2;
     
          2
       2*X
     
     ____________________________________________________________
   REDUCE assumes you are using an implicit multiplication operator
when an identifier is preceded by a number, as shown in the last line
above. Since no valid identifiers can begin with numbers, there is no
ambiguity in making this assumption.

   The multiplication operator is also valid with [*note MATRIX::.]
expressions of the proper dimensions: matrices A and B can be
multiplied if A is n x m and B is m x p. Matrices and [*note
EQUATION::.] s can also be multiplied by scalars: the result is as if
each element was multiplied by the scalar.


File: ..\util\r37,  Node: slash,  Next: power,  Prev: asterisk,  Up: Syntax section

   /     SLASH                    operator

   The / operator is a prefix or infix binary division operator or
prefix unary [*note RECIP::.] rocal operator.

syntax:

   <expression>/ <expression> or  / <expression>

   or / (<expression>,<expression>)

   <expression> may be any valid REDUCE expression.

examples:

     ____________________________________________________________
     
     20/5;
     
       4
     
     
     100/6;
     
       50
       --
       3
     
     
     16/2/x;
     
       8
       -
       X
     
     
     /b;
     
       1
       -
       B
     
     
     /(y,5);
     
       Y
       -
       5
     
     
     on rounded;
     
     35/4;
     
       8.75
     
     
     /20;
     
       0.05
     
     ____________________________________________________________
   The division operator is left associative, so that A/B/C is
equivalent to (A/B)/C . The division operator is also valid with square
[*note MATRIX::.]  expressions of the same dimensions: With A and B
both n x n matrices and B invertible, A/B is given by A*B^-1.  Division
of a matrix by a scalar is defined, with the results being the division
of each element of the matrix by the scalar. Division of a scalar by a
matrix is defined if the matrix is invertible, and has the effect of
multiplying the scalar by the inverse of the matrix. When /  is used as
a reciprocal operator for a matrix, the inverse of the matrix is
returned if it exists.


File: ..\util\r37,  Node: power,  Next: caret,  Prev: slash,  Up: Syntax section

   **     POWER                    operator

   The ** operator is a prefix or infix binary exponentiation operator.

syntax:

   <expression> ** <expression>  or ** (<expression>,<expression>)

   <expression> may be any valid REDUCE expression.

examples:

     ____________________________________________________________
     
     x**15;
     
        15
       X
     
     
     x**y**z;
     
        Y*Z
       X
     
     
     x**(y**z);
     
         Z
        Y
       X
     
     
      **(y,4);
     
        4
       Y
     
     
     on rounded;
     
     2**pi;
     
       8.82497782708
     
     ____________________________________________________________
   The exponentiation operator is left associative, so that A**B**C is
equivalent to (A**B)**C , as shown in the second example. Note that
this is not A**(B**C) , which would be right associative.

   When [*note NAT::.] is on (the default), REDUCE output produces
raised exponents, as shown. The symbol ^ , which is the upper-case 6 on
most keyboards, may be used in the place of ** .

   A square [*note MATRIX::.] may also be raised to positive and
negative powers with the exponentiation operator (negative powers
require the matrix to be invertible). Scalar expressions and [*note
EQUATION::.] s may be raised to fractional and floating-point powers.


File: ..\util\r37,  Node: caret,  Next: geqsign,  Prev: power,  Up: Syntax section

   ^     CARET                    operator

   The ^ operator is a prefix or infix binary exponentiation operator.
It is equivalent to [*note power::.] or **.

syntax:

   <expression> ^ <expression>  or ^ (<expression>,<expression>)

   <expression> may be any valid REDUCE expression.

examples:

     ____________________________________________________________
     
     x^15;
     
        15
       X
     
     
     x^y^z;
     
        Y*Z
       X
     
     
     x^(y^z);
     
         Z
        Y
       X
     
     
     ^(y,4);
     
        4
       Y
     
     
     on rounded;
     
     2^pi;
     
       8.82497782708
     
     ____________________________________________________________
   The exponentiation operator is left associative, so that A^B^C is
equivalent to (A^B)^C , as shown in the second example. Note that this
is <not> A^(B^C) , which would be right associative.

   When [*note NAT::.] is on (the default), REDUCE output produces
raised exponents, as shown.

   A square [*note MATRIX::.] may also be raised to positive and
negative powers with the exponentiation operator (negative powers
require the matrix to be invertible). Scalar expressions and [*note
EQUATION::.] s may be raised to fractional and floating-point powers.


File: ..\util\r37,  Node: geqsign,  Next: greater,  Prev: caret,  Up: Syntax section

   >=     GEQSIGN                    operator

   >=  is an infix binary comparison operator, which returns true if
its first argument is greater than or equal to its second argument.

syntax:

   <expression> >= <expression>

   <expression> must evaluate to an integer or floating-point number.

examples:

     ____________________________________________________________
     
     if (3 >= 2) then yes;
     
       yes
     
     
     a := 15;
     
       A := 15
     
     
     if a >= 20 then big else small;
     
     
       small
     
     ____________________________________________________________
   The binary comparison operators can only be used for comparisons
between numbers or variables that evaluate to numbers. The truth values
returned by such a comparison can only be used inside programming
constructs, such as [*note IF::.] ...THEN ...ELSE or [*note REPEAT::.]
...UNTIL  or [*note WHILE::.] ...DO .


File: ..\util\r37,  Node: greater,  Next: leqsign,  Prev: geqsign,  Up: Syntax section

   >     GREATER                    operator

   The > is an infix binary comparison operator that returns  true if
its first argument is strictly greater than its second.

syntax:

   <expression> > <expression>

   <expression> must evaluate to a number, e.g., integer, rational or
floating point number.

examples:

     ____________________________________________________________
     
     on rounded;
     
     if 3.0 > 3 then write "different" else write "same";
     
     
       same
     
     
     off rounded;
     
     a := 20;
     
       A := 20
     
     
     if a > 20 then write "bigger" else write "not bigger";
     
     
       not bigger
     
     ____________________________________________________________
   The binary comparison operators can only be used for comparisons
between numbers or variables that evaluate to numbers. The truth values
returned by such a comparison can only be used inside programming
constructs, such as [*note IF::.] ...THEN ...ELSE  or [*note REPEAT::.]
...UNTIL  or [*note WHILE::.] ...DO .


File: ..\util\r37,  Node: leqsign,  Next: less,  Prev: greater,  Up: Syntax section

   <=     LEQSIGN                    operator

   <=  is an infix binary comparison operator that returns  true if its
first argument is less than or equal to its second argument.

syntax:

   <expression> <= <expression>

   <expression> must evaluate to a number, e.g., integer, rational or
floating point number.

examples:

     ____________________________________________________________
     
     a := 10;
     
       A := 10
     
     
     if a <= 10 then true;
     
       true
     
     ____________________________________________________________
   The binary comparison operators can only be used for comparisons
between numbers or variables that evaluate to numbers. The truth values
returned by such a comparison can only be used inside programming
constructs, such as [*note IF::.] ...THEN ...ELSE  or [*note REPEAT::.]
...UNTIL  or [*note WHILE::.] ...DO .


File: ..\util\r37,  Node: less,  Next: tilde,  Prev: leqsign,  Up: Syntax section

   <     LESS                    operator

   <  is an infix binary logical comparison operator that returns true
if its first argument is strictly less than its second argument.

syntax:

   <expression> < <expression>

   <expression> must evaluate to a number, e.g., integer, rational or
floating point number.

examples:

     ____________________________________________________________
     
     f := -3;
     
       F := -3
     
     
     if f < -3 then write "yes" else write "no";
     
     
       no
     
     ____________________________________________________________
   The binary comparison operators can only be used for comparisons
between numbers or variables that evaluate to numbers. The truth values
returned by such a comparison can only be used inside programming
constructs, such as [*note IF::.] ...THEN ...ELSE or [*note REPEAT::.]
...UNTIL  or [*note WHILE::.] ...DO .


File: ..\util\r37,  Node: tilde,  Next: group,  Prev: less,  Up: Syntax section

   ~     TILDE                    operator

   The ^ is used as a unary prefix operator in the left-hand sides of
[*note RULE::.] s to mark [*note Free Variable::.] s. A double tilde
marks an optional [*note Free Variable::.] .


File: ..\util\r37,  Node: group,  Next: AND,  Prev: tilde,  Up: Syntax section

   <<     GROUP                    command

   The << ...>>  command is a group statement, used to group statements
together where REDUCE expects a single statement.

syntax:

   << <statement>; <statement> OR  <statement>* >>

   <statement> may be any valid REDUCE statement or expression.

examples:

     ____________________________________________________________
     
     a := 2;
     
       A := 2
     
     
     if a < 5 then <<b := a + 10; write b>>;
     
     
       12
     
     
     <<d := c/15; f := d + 3; f**2>>;
     
     
        2
       C  + 90*C + 202
       ----------------
             225
     
     ____________________________________________________________
   The value returned from a group statement is the value of the last
individual statement executed inside it. Note that when a semicolon is
placed between the last statement and the closing brackets, 0 or  nil
is returned. Group statements are often used in the consequence
portions of [*note IF::.] ...THEN , [*note REPEAT::.] ...UNTIL , and
[*note WHILE::.] ...DO clauses. They may also be used in interactive
operation to execute several statements at one time. Statements inside
the group statement are separated by semicolons or dollar signs.


File: ..\util\r37,  Node: AND,  Next: BEGIN,  Prev: group,  Up: Syntax section

   AND                    operator

   The AND binary logical operator returns true if both of its
arguments are true.

syntax:

   <logical_expression> AND <logical_expression>

   <logical_expression> must evaluate to true or nil.

examples:

     ____________________________________________________________
     
     a := 12;
     
       A := 12
     
     
     if numberp a and a < 15 then write a**2 else write "no";
     
     
     
       144
     
     
     clear a;
     
     if numberp a and a < 15 then write a**2 else write "no";
     
     
     
       no
     
     ____________________________________________________________
   Logical operators can only be used inside conditional statements,
such as [*note WHILE::.] ...DO  or [*note IF::.] ...THEN ...ELSE . AND
examines each of its arguments in order, and quits, returning nil, on
finding an argument that is not true. An error results if it is used in
other contexts.

   AND is left associative: X AND Y AND Z is equivalent to (X AND Y)
AND Z .


File: ..\util\r37,  Node: BEGIN,  Next: block,  Prev: AND,  Up: Syntax section

   BEGIN                    command

   BEGIN  is used to start a [*note block::.] statement, which is
closed with END .

syntax:

   BEGIN <statement>;  <statement>* END

   <statement> is any valid REDUCE statement.

examples:

     ____________________________________________________________
     
     begin for i := 1:3 do write i end;
     
     
       1
       2
       3
     
     
     begin scalar n;n:=1;b:=for i:=1:4 product(x-i);return n end;
     
     
     
       1
     
     
     b;
     
        4        3        2
       X   - 10*X   + 35*X   - 50*X  + 24
     
     ____________________________________________________________
   A BEGIN ...END  block can do actions (such as WRITE ), but does not
return a value unless instructed to by a [*note RETURN::.] statement,
which must be the last statement executed in the block. It is
unnecessary to insert a semicolon before the END .

   Local variables, if any, are declared in the first statement
immediately after BEGIN , and may be defined as SCALAR, INTEGER, or
REAL . [*note ARRAY::.] variables declared within a BEGIN ...END  block
are global in every case, and [*note LET::.] statements have global
effects. A [*note LET::.] statement involving a formal parameter affects
the calling parameter that corresponds to it. [*note LET::.] statements
involving local variables make global assignments, overwriting outside
variables by the same name or creating them if they do not exist. You
can use this feature to affect global variables from procedures, but be
careful that you do not do it inadvertently.


File: ..\util\r37,  Node: block,  Next: COMMENT,  Prev: BEGIN,  Up: Syntax section

   BLOCK                    command

   A BLOCK is a sequence of statements enclosed by commands [*note
BEGIN::.] and [*note END::.] .

syntax:

   BEGIN <statement>;  <statement>* END

   For more details see [*note BEGIN::.] .


File: ..\util\r37,  Node: COMMENT,  Next: CONS,  Prev: block,  Up: Syntax section

   COMMENT                    command

   Beginning with the word COMMENT , all text until the next statement
terminator (;  or $ ) is ignored.

examples:

     ____________________________________________________________
     
     
     x := a**2 comment--a is the velocity of the particle;;
     
     
     
             2
       X := A
     
     ____________________________________________________________
   Note that the first semicolon ends the comment and the second one
terminates the original REDUCE statement.

   Multiple-line comments are often needed in interactive files. The
COMMENT  command allows a normal-looking text to accompany the REDUCE
statements in the file.


File: ..\util\r37,  Node: CONS,  Next: END,  Prev: COMMENT,  Up: Syntax section

   CONS                    operator

   The CONS operator adds a new element to the beginning of a [*note
LIST::.] . Its operation is identical to the symbol [*note dot::.]
(dot). It can be used infix or prefix.

syntax:

   CONS (<item>,<list>) or <item> CONS <list>

   <item> can be any REDUCE scalar expression, including a list; <list>
must be a list.

examples:

     ____________________________________________________________
     
     
     liss := cons(a,{b});
     
       {A,B}
     
     
     
     liss := c cons liss;
     
       {C,A,B}
     
     
     
     newliss := for each y in liss collect cons(y,list x);
     
     
     
       NEWLISS := {{C,X},{A,X},{B,X}}
     
     
     
     for each y in newliss sum (first y)*(second y);
     
     
     
       X*(A + B + C)
     
     ____________________________________________________________
   If you want to use CONS to put together two elements into a new list,
you must make the second one into a list with curly brackets or the LIST
command. You can also start with an empty list created by [] .

   The CONS operator is right associative: A CONS B CONS C is valid if
C is a list; B need not be a list. The list produced is [A,B,C] .


File: ..\util\r37,  Node: END,  Next: EQUATION,  Prev: CONS,  Up: Syntax section

   END                    command

   The command END has two main uses:

   (i) as the ending of a [*note BEGIN::.] ...END  [*note block::.] ;
and

   (ii) to end input from a file.

   In a BEGIN ...END  [*note block::.] , there need not be a delimiter
(;  or $ ) before the END , though there must be one after it, or a
right bracket matching an earlier left bracket.

   Files to be read into REDUCE should end with END; , which must be
preceded by a semicolon (usually the last character of the previous
line).  The additional semicolon avoids problems with mistakes in the
files. If you have suspended file operation by answering N to a PAUSE
command, you are still, technically speaking, "in" the file. Use END
to exit the file.

   An END at the top level of a program is ignored.


File: ..\util\r37,  Node: EQUATION,  Next: FIRST,  Prev: END,  Up: Syntax section

   EQUATION                    type

   An EQUATION is an expression where two algebraic expressions are
connected by the (infix) operator [*note EQUAL::.] or by = .  For
access to the components of an EQUATION the operators [*note LHS::.] ,
[*note RHS::.] or [*note PART::.] can be used. The evaluation of the
left-hand side of an EQUATION is controlled by the switch [*note
EVALLHSEQP::.] , while the right-hand side is evaluated
unconditionally. When an EQUATION is part of a logical expression, e.g.
in a [*note IF::.] or [*note WHILE::.] statement, the equation is
evaluated by subtracting both sides can comparing the result with zero.

   Equations occur in many contexts, e.g. as arguments of the [*note
SUB::.] operator and in the arguments and the results of the operator
[*note SOLVE::.] . An equation can be member of a [*note LIST::.] and
you may assign an equation to a variable. Elementary arithmetic is
supported for equations: if [*note EVALLHSEQP::.] is on, you may add
and subtract equations, and you can combine an equation with a scalar
expression by addition, subtraction, multiplication, division and raise
an equation to a power.

examples:

     ____________________________________________________________
     
     on evallhseqp;
     
     u:=x+y=1$
     
     v:=2x-y=0$
     
     2*u-v;
     
       - 3*y=-2
     
     
     ws/3;
     
         2
       y=--
         3
     
     ____________________________________________________________

   Important: the equation must occur in the leftmost term of such an
expression.  For other operations, e.g. taking function values of both
sides, use the [*note MAP::.]  operator.


File: ..\util\r37,  Node: FIRST,  Next: FOR,  Prev: EQUATION,  Up: Syntax section

   FIRST                    operator

   The FIRST operator returns the first element of a [*note LIST::.] .

syntax:

   FIRST (<list>) or FIRST <list>

   <list> must be a non-empty list to avoid an error message.

examples:

     ____________________________________________________________
     
     alist := {a,b,c,d};
     
       ALIST := {A,B,C,D}
     
     
     first alist;
     
       A
     
     
     blist := {x,y,{ww,aa,qq},z};
     
       BLIST := {X,Y,{WW,AA,QQ},Z}
     
     
     first third blist;
     
       WW
     
     ____________________________________________________________


File: ..\util\r37,  Node: FOR,  Next: FOREACH,  Prev: FIRST,  Up: Syntax section

   FOR                    command

   The FOR command is used for iterative loops. There are many possible
forms it can take.

     ____________________________________________________________
     
                        /                   
        /               |STEP <number> UNTIL|        
        |<var>:=<number>|                   |<number>|
     FOR|               |         :         |        |<action> <exprn>
        |                                  /        |
        |EACH <var> IN <list>                        |
                                                    /
     
      where <action> ::= DO|PRODUCT|SUM|COLLECT|JOIN.
     ____________________________________________________________
   <var> can be any valid REDUCE identifier except T or NIL , <inc>,
<start> and <stop> can be any expression that evaluates to a positive
or negative integer. <list> must be a valid [*note LIST::.] structure.
The action taken must be one of the actions shown above, each of which
is followed by a single REDUCE expression, statement or a [*note
group::.] (<< ...>> ) or [*note block::.] ([*note BEGIN::.] ...[*note
END::.] ) statement.

examples:

     ____________________________________________________________
     
     for i := 1:10 sum i;
     
     
     
       55
     
     
     for a := -2 step 3 until 6 product a;
     
     
     
       -8
     
     
     a := 3;
     
       A := 3
     
     
     for iter := 4:a do write iter;
     
     m := 0;
     
       M := 0
     
     
     for s := 10 step -1 until 3 do <<d := 10*s;m := m + d>>;
     
     m;
     
       520
     
     
     for each x in {q,r,s} sum x**2;
     
        2    2    2
       Q  + R  + S
     
     
     for i := 1:4 collect 1/i;
     
     
     
          1 1 1
       {1,-,-,-}
          2 3 4
     
     
     for i := 1:3 join list solve(x**2 + i*x + 1,x);
     
     
     
             SQRT(3)*I + 1
       {{X= --------------,
                   2
             SQRT(3)*I - 1
         X= --------------}
                   2
        {X=-1},
              SQRT(5) + 3   SQRT(5) - 3
        {X= - -----------,X=-----------}}
                   2             2
     
     ____________________________________________________________
   The behavior of each of the five action words follows:

     ____________________________________________________________
     
                                Action Word Behavior
     Keyword   Argument Type                    Action
        do    statement, command, group   Evaluates its argument once
              or block                    for each iteration of the loop,
                                          not saving results
     collect expression, statement,       Evaluates its argument once for
             command, group, block, list  each iteration of the loop,
                                          storing the results in a list
                                          which is returned by the for
                                          statement when done
      join   list or an operator which    Evaluates its argument once for
             produces a list              each iteration of the loop,
                                          appending the elements in each
                                          individual result list onto the
                                          overall result list
     product expression, statement,       Evaluates its argument once for
             command, group or block      each iteration of the loop,
                                          multiplying the results together
                                          and returning the overall product
       sum   expression, statement,       Evaluates its argument once for
             command, group or block      each iteration of the loop,
                                          adding the results together and
                                          returning the overall sum
     ____________________________________________________________
   For number-driven FOR statements, if the ending limit is smaller
than the beginning limit (larger in the case of negative steps) the
action statement is not executed at all. The iterative variable is
local to the FOR  statement, and does not affect the value of an
identifier with the same name. For list-driven FOR statements, if the
list is empty, the action statement is not executed, but no error
occurs.

   You can use nested FOR statements, with the inner FOR statement
after the action keyword. You must make sure that your inner statement
returns an expression that the outer statement can handle.


File: ..\util\r37,  Node: FOREACH,  Next: GEQ,  Prev: FOR,  Up: Syntax section

   FOREACH                    command

   FOREACH  is a synonym for the FOR EACH variant of the [*note FOR::.]
construct. It is designed to iterate down a list, and an error will
occur if a list is not used. The use of FOR EACH is preferred to
FOREACH .

syntax:

   FOREACH <variable> in <list> <action> <expression>

   where <action> ::= DO  PRODUCT  SUM  COLLECT  JOIN

examples:

     ____________________________________________________________
     
     foreach x in {q,r,s} sum x**2;
     
        2    2    2
       Q  + R  + S
     
     ____________________________________________________________


File: ..\util\r37,  Node: GEQ,  Next: GOTO,  Prev: FOREACH,  Up: Syntax section

   GEQ                    operator

   The GEQ operator is a binary infix or prefix logical operator. It
returns true if its first argument is greater than or equal to its
second argument. As an infix operator it is identical with >= .

syntax:

   GEQ (<expression>,<expression>) or <expression> GEQ  <expression>

   <expression> can be any valid REDUCE expression that evaluates to a
number.

examples:

     ____________________________________________________________
     
     a := 20;
     
       A := 20
     
     
     if geq(a,25) then write "big" else write "small";
     
     
     
       small
     
     
     if a geq 20 then write "big" else write "small";
     
     
     
       big
     
     
     if (a geq 18) then write "big" else write "small";
     
     
     
       big
     
     ____________________________________________________________
   Logical operators can only be used in conditional statements such as

   [*note IF::.] ...THEN ...ELSE  or [*note REPEAT::.] ...UNTIL .


File: ..\util\r37,  Node: GOTO,  Next: GREATERP,  Prev: GEQ,  Up: Syntax section

   GOTO                    command

   Inside a BEGIN ...END  [*note block::.] , GOTO , or preferably, GO
TO , transfers flow of control to a labeled statement.

syntax:

   GO TO <labeled_statement> or GOTO <labeled_statement>

   <labeled_statement> is of the form <label> : <statement>

examples:

     ____________________________________________________________
     
          procedure dumb(a);
             begin scalar q;
                go to lab;
                q := df(a**2 - sin(a),a);
                write q;
           lab: return a
             end;
     
     
       DUMB
     
     
     
     dumb(17);
     
       17
     
     ____________________________________________________________
   GO TO can only be used inside a BEGIN ...END [*note block::.] , and
inside the block only statements at the top level can be labeled, not
ones inside << ...>> , [*note WHILE::.] ...DO , etc.


File: ..\util\r37,  Node: GREATERP,  Next: IF,  Prev: GOTO,  Up: Syntax section

   GREATERP                    operator

   The GREATERP logical operator returns true if its first argument is
strictly greater than its second argument. As an infix operator it is
identical with > .

syntax:

   GREATERP (<expression>,<expression>) or <expression> GREATERP
<expression>

   <expression> can be any valid REDUCE expression that evaluates to a
number.

examples:

     ____________________________________________________________
     
     
     a := 20;
     
       A := 20
     
     
     if greaterp(a,25) then write "big" else write "small";
     
     
     
       small
     
     
     if a greaterp 20 then write "big" else write "small";
     
     
     
       small
     
     
     if (a greaterp 18) then write "big" else write "small";
     
     
     
       big
     
     ____________________________________________________________
   Logical operators can only be used in conditional statements such as

   [*note IF::.] ...THEN ...ELSE or [*note REPEAT::.] ...[*note
WHILE::.] .


File: ..\util\r37,  Node: IF,  Next: LIST,  Prev: GREATERP,  Up: Syntax section

   IF                    command

   The IF command is a conditional statement that executes a statement
if a condition is true, and optionally another statement if it is not.

syntax:

   IF <condition> THEN <statement>   option(ELSE  <statement>)

   <condition> must be a logical or comparison operator that evaluates
to a [*note boolean value::.] .  <statement> must be a single REDUCE
statement or a [*note group::.]  (<< ...>> ) or [*note block::.]
(BEGIN ...END ) statement.

examples:

     ____________________________________________________________
     
     if x = 5 then a := b+c else a := d+f;
     
     
     
       D + F
     
     
     x := 9;
     
       X := 9
     
     
     if numberp x and x<20 then y := sqrt(x) else write "illegal";
     
     
     
       3
     
     
     clear x;
     
     if numberp x and x<20 then y := sqrt(x) else write "illegal";
     
     
     
       illegal
     
     
     x := 12;
     
       X := 12
     
     
     a := if x < 5 then 100 else 150;
     
     
     
       A := 150
     
     
     b := u**(if x < 10 then 2);
     
     
       B := 1
     
     
     bb := u**(if x > 10 then 2);
     
     
              2
       BB := U
     
     ____________________________________________________________
   An IF statement may be used inside an assignment statement and sets
its value depending on the conditions, or used anywhere else an
expression would be valid, as shown in the last example. If there is no
ELSE  clause, the value is 0 if a number is expected, and nothing
otherwise.

   The ELSE clause may be left out if no action is to be taken if the
condition is false.

   The condition may be a compound conditional statement using [*note
AND::.] or [*note OR::.] . If a non-conditional statement, such as a
constant, is used by accident, it is assumed to have value true.

   Be sure to use [*note group::.] or [*note block::.] statements after
THEN  or ELSE .

   The IF operator is right associative. The following constructions are
examples:

   (1)

syntax:

   IF <condition> THEN IF <condition> THEN  <action> ELSE <action>

   which is equivalent to

syntax:

   IF <condition> THEN (IF  <condition>  THEN <action> ELSE <action>);

   (2)

syntax:

   IF <condition> THEN <action> ELSE IF  <condition> THEN <action> ELSE
<action>

   which is equivalent to

syntax:

   IF <condition> THEN <action> ELSE

   (IF  <condition> THEN <action>  ELSE <action>).


File: ..\util\r37,  Node: LIST,  Next: OR,  Prev: IF,  Up: Syntax section

   LIST                    operator

   The LIST operator constructs a list from its arguments.

syntax:

   LIST (<item> ,<item>*) or  LIST () to construct an empty list.

   <item> can be any REDUCE scalar expression, including another list.
Left and right curly brackets can also be used instead of the operator
LIST  to construct a list.

examples:

     ____________________________________________________________
     
     liss := list(c,b,c,{xx,yy},3x**2+7x+3,df(sin(2*x),x));
     
     
     
                                 2
       LISS := {C,B,C,{XX,YY},3*X  + 7*X + 3,2*COS(2*X)}
     
     
     length liss;
     
       6
     
     
     liss := {c,b,c,{xx,yy},3x**2+7x+3,df(sin(2*x),x)};
     
     
     
                                 2
       LISS := {C,B,C,{XX,YY},3*X  + 7*X + 3,2*COS(2*X)}
     
     
     emptylis := list();
     
       EMPTYLIS := {}
     
     
     a . emptylis;
     
       {A}
     
     ____________________________________________________________
   Lists are ordered, hierarchical structures. The elements stay where
you put them, and only change position in the list if you specifically
change them. Lists can have nested sublists to any (reasonable) level.
The [*note PART::.]  operator can be used to access elements anywhere
within a list hierarchy. The [*note LENGTH::.] operator counts the
number of top-level elements of its list argument; elements that are
themselves lists still only count as one element.


File: ..\util\r37,  Node: OR,  Next: PROCEDURE,  Prev: LIST,  Up: Syntax section

   OR                    operator

   The OR binary logical operator returns true if either one or both of
its arguments is true.

syntax:

   <logical expression> OR <logical expression>

   <logical expression> must evaluate to true or nil.

examples:

     ____________________________________________________________
     
     a := 10;
     
       A := 10
     
     
     if a<0 or a>140 then write "not a valid human age" else
        write "age = ",a;
     
     
     
     
       age = 10
     
     
     a := 200;
     
       A := 200
     
     
     if a < 0 or a > 140 then write "not a valid human age";
     
     
     
       not a valid human age
     
     ____________________________________________________________
   The OR operator is left associative: X OR Y OR Z is equivalent to (X
OR Y)  OR Z .

   Logical operators can only be used in conditional expressions, such
as

   [*note IF::.] ...THEN ...ELSE and [*note WHILE::.] ...DO .  OR
evaluates its arguments in order and quits, returning true, on finding
the first true statement.


File: ..\util\r37,  Node: PROCEDURE,  Next: REPEAT,  Prev: OR,  Up: Syntax section

   PROCEDURE                    command

   The PROCEDURE command allows you to define a mathematical operation
as a function with arguments.

syntax:

   <option> PROCEDURE <identifier>  (<arg>,<arg>+); <body>

   The <option> may be [*note ALGEBRAIC::.] or [*note SYMBOLIC::.] ,
indicating the mode under which the procedure is executed, or [*note
REAL::.] or [*note INTEGER::.] , indicating the type of answer
expected. The default is algebraic. Real or integer procedures are
subtypes of algebraic procedures; type-checking is done on the results
of integer procedures, but not on real procedures (in the current
REDUCE release). <identifier> may be any valid REDUCE identifier that
is not already a procedure name, operator, [*note ARRAY::.] or [*note
MATRIX::.] .  <arg> is a formal parameter that may be any valid REDUCE
identifier. <body> is a single statement (a [*note group::.] or [*note
block::.] statement may be used) with the desired activities in it.

examples:

     ____________________________________________________________
     
     procedure fac(n);
        if not (fixp(n) and n>=0)
          then rederr "Choose nonneg. integer only"
         else for i := 0:n-1 product i+1;
     
     
     
       FAC
     
     
     fac(0);
     
       1
     
     
     fac(5);
     
       120
     
     
     fac(-5);
     
       ***** choose nonneg. integer only
     
     ____________________________________________________________
   Procedures are automatically declared as operators upon definition.
When REDUCE has parsed the procedure definition and successfully
converted it to a form for its own use, it prints the name of the
procedure. Procedure definitions cannot be nested. Procedures can call
other procedures, or can recursively call themselves. Procedure
identifiers can be cleared as you would clear an operator. Unlike
[*note LET::.] statements, new definitions under the same procedure
name replace the previous definitions completely.

   Be careful not to use the name of a system operator for your own
procedure.  REDUCE may or may not give you a warning message. If you
redefine a system operator in your own procedure, the original function
of the system operator is lost for the remainder of the REDUCE session.

   Procedures may have none, one, or more than one parameter. A REDUCE
parameter is a formal parameter only; the use of x as a parameter in a
PROCEDURE definition has no connection with a value of x in the REDUCE
session, and the results of calling a procedure have no effect on the
value of x. If a procedure is called with x as a parameter, the current
value of x is used as specified in the computation, but is not changed
outside the procedure.  Making an assignment statement by := with a
formal parameter on the left-hand side only changes the value of the
calling parameter within the procedure.

   Using a [*note LET::.] statement inside a procedure always changes
the value globally: a LET with a formal parameter makes the change to
the calling parameter. LET statements cannot be made on local variables
inside [*note BEGIN::.] ...END  [*note block::.] S .  When [*note
CLEAR::.] statements are used on formal parameters, the calling
variables associated with them are cleared globally too.  The use of
LET or CLEAR statements inside procedures should be done with extreme
caution.

   Arrays and operators may be used as parameters to procedures. The
body of the procedure can contain statements that appropriately
manipulate these arguments. Changes are made to values of the calling
arrays or operators.  Simple expressions can also be used as arguments,
in the place of scalar variables. Matrices may not be used as arguments
to procedures.

   A procedure that has no parameters is called by the procedure name,
immediately followed by empty parentheses. The empty parentheses may be
left out when writing a procedure with no parameters, but must appear
in a call of the procedure. If this is a nuisance to you, use a [*note
LET::.] statement on the name of the procedure (i.e., LET NOARGS =
NOARGS() ) after which you can call the procedure by just its name.

   Procedures that have a single argument can leave out the parentheses
around it both in the definition and procedure call. (You can use the
parentheses if you wish.) Procedures with more than one argument must
use parentheses, with the arguments separated by commas.

   Procedures often have a BEGIN ...END  block in them. Inside the
block, local variables are declared using SCALAR , REAL or INTEGER
declarations.  The declarations must be made immediately after the word
BEGIN , and if more than one type of declaration is made, they are
separated by semicolons. REDUCE currently does no type checking on local
variables; REAL and INTEGER are treated just like SCALAR .  Actions
take place as specified in the statements inside the block statement.
Any identifiers that are not formal parameters or local variables are
treated as global variables, and activities involving these identifiers
are global in effect.

   If a return value is desired from a procedure call, a specific
[*note RETURN::.]  command must be the last statement executed before
exiting from the procedure. If no RETURN is used, a procedure returns a
zero or no value.

   Procedures are often written in a file using an editor, then the file
is input using the command [*note IN::.] . This method allows easy
changes in development, and also allows you to load the named
procedures whenever you like, by loading the files that contain them.


File: ..\util\r37,  Node: REPEAT,  Next: REST,  Prev: PROCEDURE,  Up: Syntax section

   REPEAT                    command

   The [*note REPEAT::.] command causes repeated execution of a
statement  UNTIL the given condition is found to be true. The statement
is always executed at least once.

syntax:

   REPEAT <statement> UNTIL <condition>

   <statement> can be a single statement, [*note group::.] statement, or
a BEGIN ...END  [*note block::.] . <condition> must be a logical
operator that evaluates to true or nil.

examples:

     ____________________________________________________________
     
     <<m := 4; repeat <<write 100*x*m;m := m-1>> until m = 0>>;
     
     
     
       400*X
       300*X
       200*X
       100*X
     
     
     
     <<m := -1; repeat <<write m; m := m-1>> until m <= 0>>;
     
     
     
       -1
     
     ____________________________________________________________
   REPEAT must always be followed by an UNTIL with a condition.  Be
careful not to generate an infinite loop with a condition that is never
true. In the second example, if the condition had been M = 0 , it would
never have been true since M already had value -2 when the condition
was first evaluated.


File: ..\util\r37,  Node: REST,  Next: RETURN,  Prev: REPEAT,  Up: Syntax section

   REST                    operator

   The REST operator returns a [*note LIST::.] containing all but the
first element of the list it is given.

syntax:

   REST (<list>) or REST <list>

   <list> must be a non-empty list, but need not have more than one
element.

examples:

     ____________________________________________________________
     
     alist := {a,b,c,d};
     
       ALIST := {A,B,C,D};
     
     
     rest alist;
     
       {B,C,D}
     
     
     blist := {x,y,{aa,bb,cc},z};
     
       BLIST := {X,Y,{AA,BB,CC},Z}
     
     
     second rest blist;
     
       {AA,BB,CC}
     
     
     clist := {c};
     
       CLIST := C
     
     
     rest clist;
     
       {}
     
     ____________________________________________________________


File: ..\util\r37,  Node: RETURN,  Next: REVERSE,  Prev: REST,  Up: Syntax section

   RETURN                    command

   The RETURN command causes a value to be returned from inside a BEGIN
...END  [*note block::.] .

syntax:

   BEGIN <statements> RETURN <(expression)>  END

   <statements> can be any valid REDUCE statements. The value of
<expression> is returned.

examples:

     ____________________________________________________________
     
     begin write "yes"; return a end;
     
       yes
       A
     
     
     procedure dumb(a);
       begin if numberp(a) then return a else return 10 end;
     
     
     
       DUMB
     
     
     dumb(x);
     
       10
     
     
     dumb(-5);
     
       -5
     
     
     procedure dumb2(a);
       begin c := a**2 + 2*a + 1; d := 17; c*d; return end;
     
     
       DUMB2
     
     
     dumb2(4);
     
     c;
     
       25
     
     
     d;
     
       17
     
     ____________________________________________________________
   Note in DUMB2 above that the assignments were made as requested, but
the product C*D cannot be accessed. Changing the procedure to read
RETURN C*D  would remedy this problem.

   The RETURN statement is always the last statement executed before
leaving the block. If RETURN has no argument, the block is exited but
no value is returned. A block statement does not need a RETURN ; the
statements inside terminate in their normal fashion without one.  In
that case no value is returned, although the specified actions inside
the block take place.

   The RETURN command can be used inside << ...>> [*note group::.]
statements and [*note IF::.] ...THEN ...ELSE  commands that are inside
BEGIN ...END  [*note block::.] s.  It is not valid in these
constructions that are not inside a BEGIN ...END  block. It is not
valid inside [*note FOR::.] , [*note REPEAT::.] ...UNTIL  or [*note
WHILE::.] ...DO  loops in any construction. To force early termination
from loops, the GO TO ([*note GOTO::.] ) command must be used.  When
you use nested block statements, a RETURN  from an inner block exits
returning a value to the next-outermost block, rather than all the way
to the outside.


File: ..\util\r37,  Node: REVERSE,  Next: RULE,  Prev: RETURN,  Up: Syntax section

   REVERSE                    operator

   The REVERSE operator returns a [*note LIST::.] that is the reverse
of the list it is given.

syntax:

   REVERSE (<list>) or REVERSE <list>

   <list> must be a [*note LIST::.] .

examples:

     ____________________________________________________________
     
     aa := {c,b,a,{x**2,z**3},y};
     
                      2  3
       AA := {C,B,A,{X ,Z },Y}
     
     
     reverse aa;
     
            2  3
       {Y,{X ,Z },A,B,C}
     
     
     reverse(q . reverse aa);
     
                2  3
       {C,B,A,{X ,Z },Y,Q}
     
     ____________________________________________________________
   REVERSE and [*note CONS::.] can be used together to add a new
element to the end of a list (.  adds its new element to the
beginning). The REVERSE  operator uses a noticeable amount of system
resources, especially if the list is long. If you are doing much
heavy-duty list manipulation, you should probably design your
algorithms to avoid much reversing of lists. A moderate amount of list
reversing is no problem.


File: ..\util\r37,  Node: RULE,  Next: Free Variable,  Prev: REVERSE,  Up: Syntax section

   RULE                    type

   A RULE is an instruction to replace an algebraic expression or a
part of an expression by another one.

syntax:

   <lhs> => <rhs> or <lhs> => <rhs> WHEN <cond>

   <lhs> is an algebraic expression used as search pattern and <rhs> is
an algebraic expression which replaces matches of <rhs>. => is the
operator [*note replace::.] .

   <lhs> can contain [*note Free Variable::.] s which are symbols
preceded by a tilde ^  in their leftmost position in <lhs>.  A double
tilde marks an [*note Optional Free Variable::.] .  If a rule has a
WHEN <cond> part it will fire only if the evaluation of <cond> has a
result [*note TRUE::.] . <cond> may contain references to free
variables of <lhs>.

   Rules can be collected in a [*note LIST::.] which then forms a  RULE
LIST . RULE LISTS can be used to collect algebraic knowledge for a
specific evaluation context.

   RULES and RULE LISTS are globally activated and deactivated by
[*note LET::.] , [*note FORALL::.] , [*note CLEARRULES::.] .  For a
single evaluation they can be locally activate by [*note WHERE::.] .
The active rules for an operator can be visualized by [*note
SHOWRULES::.] .

examples:

     ____________________________________________________________
     
     operator f,g,h;
     
     let f(x) => x^2;
     
     f(x);
     
        2
       x
     
     
     g_rules:={g(~n,~x)=>h(n/2,x) when evenp n,
     
     g(~n,~x)=>h((1-n)/2,x) when not evenp n}$
     
     let g_rules;
     
     g(3,x);
     
       h(-1,x)
     
     ____________________________________________________________


File: ..\util\r37,  Node: Free Variable,  Next: Optional Free Variable,  Prev: RULE,  Up: Syntax section

   FREE VARIABLE                    type

   A variable preceded by a tilde is considered as FREE VARIABLE and
stands for an arbitrary part in an algebraic form during pattern
matching. Free variables occur in the left-hand sides of [*note
RULE::.] s, in the side relations for [*note COMPACT::.] and in the
first arguments of [*note MAP::.] and [*note SELECT::.] calls. See
[*note RULE::.] for examples.

   In rules also [*note Optional Free Variable::.] s may occur.


File: ..\util\r37,  Node: Optional Free Variable,  Next: SECOND,  Prev: Free Variable,  Up: Syntax section

   OPTIONAL FREE VARIABLE                    type

   A variable preceded by a double tilde is considered as OPTIONAL FREE
VARIABLE and stands for an arbitrary part part in an algebraic form
during pattern matching. In contrast to ordinary [*note Free
Variable::.] s an operator pattern with an OPTIONAL FREE VARIABLE
matches also if the operand for the variable is missing. In such a case
the variable is bound to a neutral value.  Optional free variables can
be used as

   term in a sum: set to 0 if missing,

   factor in a product: set to 1 if missing,

   exponent: set to 1 if missing

examples:

     ____________________________________________________________
     ____________________________________________________________
   Optional free variables are allowed only in the left-hand sides of
[*note RULE::.] s.


File: ..\util\r37,  Node: SECOND,  Next: SET,  Prev: Optional Free Variable,  Up: Syntax section

   SECOND                    operator

   The SECOND operator returns the second element of a list.

syntax:

   SECOND (<list>) or SECOND <list>

   <list> must be a list with at least two elements, to avoid an error
message.

examples:

     ____________________________________________________________
     
     alist := {a,b,c,d};
     
       ALIST := {A,B,C,D}
     
     
     second alist;
     
       B
     
     
     blist := {x,{aa,bb,cc},z};
     
       BLIST := {X,{AA,BB,CC},Z}
     
     
     second second blist;
     
       BB
     
     ____________________________________________________________


File: ..\util\r37,  Node: SET,  Next: SETQ,  Prev: SECOND,  Up: Syntax section

   SET                    operator

   The SET operator is used for assignments when you want both sides of
the assignment statement to be evaluated.

syntax:

   SET (<restricted_expression>,<expression>)

   <expression> can be any REDUCE expression; <restricted_expression>
must be an identifier or an expression that evaluates to an identifier.

examples:

     ____________________________________________________________
     
     a := y;
     
       A := Y
     
     
     set(a,sin(x^2));
     
            2
       SIN(X )
     
     
     a;
     
            2
       SIN(X )
     
     
     y;
     
            2
       SIN(X )
     
     
     a := b + c;
     
       A := B + C
     
     
     set(a-c,z);
     
       Z
     
     
     b;
     
       Z
     
     ____________________________________________________________
   Using an [*note ARRAY::.] or [*note MATRIX::.] reference as the first
argument to SET has the result of setting the contents of the
designated element to SET 's second argument. You should be careful to
avoid unwanted side effects when you use this facility.


File: ..\util\r37,  Node: SETQ,  Next: THIRD,  Prev: SET,  Up: Syntax section

   SETQ                    operator

   The SETQ operator is an infix or prefix binary assignment operator.
It is identical to := .

syntax:

   SETQ (<restricted_expression>,<expression>) or

   <restricted_expression> SETQ <expression>

   <restricted expression> is ordinarily a single identifier, though
simple expressions may be used (see Comments below). <expression> can
be any valid REDUCE expression. If <expression> is a [*note MATRIX::.]
identifier, then <restricted_expression> can be a matrix identifier
(redimensioned if necessary), which has each element set to the
corresponding elements of the identifier on the right-hand side.

examples:

     ____________________________________________________________
     
     setq(b,6);
     
       B := 6
     
     
     c setq sin(x);
     
       C := SIN(X)
     
     
     w + setq(c,x+3) + z;
     
       W + X + Z + 3
     
     
     c;
     
       X + 3
     
     
     setq(a1 + a2,25);
     
       A1 + A2 := 25
     
     
     a1;
     
       - (A2 - 25)
     
     ____________________________________________________________
   Embedding a SETQ statement in an expression has the side effect of
making the assignment, as shown in the third example above.

   Assignments are generally done for identifiers, but may be done for
simple expressions as well, subject to the following remarks:

   (i) If the left-hand side is an identifier, an operator, or a power,
the rule is added to the rule table.

   (ii) If the operators - + / appear on the left-hand side, all but
the first term of the expression is moved to the right-hand side.

   (iii) If the operator * appears on the left-hand side, any constant
terms are moved to the right-hand side, but the symbolic factors remain.

   Be careful not to make a recursive SETQ assignment that is not
controlled inside a loop statement. The process of resubstitution
continues until you get a stack overflow message. SETQ can be used to
attach functionality to operators, as the := does.


File: ..\util\r37,  Node: THIRD,  Next: WHEN,  Prev: SETQ,  Up: Syntax section

   THIRD                    operator

   The THIRD operator returns the third item of a [*note LIST::.] .

syntax:

   THIRD (<list>) or THIRD <list>

   <list> must be a list containing at least three items to avoid an
error message.

examples:

     ____________________________________________________________
     
     alist := {a,b,c,d};
     
       ALIST := {A,B,C,D}
     
     
     third alist;
     
       C
     
     
     blist := {x,{aa,bb,cc},y,z};
     
       BLIST := {X,{AA,BB,CC},Y,Z};
     
     
     third second blist;
     
       CC
     
     
     third blist;
     
       Y
     
     ____________________________________________________________


File: ..\util\r37,  Node: WHEN,  Prev: THIRD,  Up: Syntax section

   WHEN                    operator

   The WHEN operator is used inside a RULE to make the execution of the
rule depend on a boolean condition which is evaluated at execution
time. For the use see [*note RULE::.] .


File: ..\util\r37,  Node: Syntax section,  Next: Arithmetic Operations section,  Prev: Variables section,  Up: Top

   Syntax section

* Menu:

* semicolon::                 ;  command
* dollar::                      command
* percent::                   %  command
* dot::                       .  operator
* assign::                    :=  operator
* equalsign::                 =  operator
* replace::                   =>  operator
* plussign::                  +  operator
* minussign::                 -  operator
* asterisk::                  *  operator
* slash::                     /  operator
* power::                     **  operator
* caret::                     ^  operator
* geqsign::                   >=  operator
* greater::                   >  operator
* leqsign::                   <=  operator
* less::                      <  operator
* tilde::                     ~  operator
* group::                     <<  command
* AND::                     operator
* BEGIN::                   command
* block::                   command
* COMMENT::                 command
* CONS::                    operator
* END::                     command
* EQUATION::                type
* FIRST::                   operator
* FOR::                     command
* FOREACH::                 command
* GEQ::                     operator
* GOTO::                    command
* GREATERP::                operator
* IF::                      command
* LIST::                    operator
* OR::                      operator
* PROCEDURE::               command
* REPEAT::                  command
* REST::                    operator
* RETURN::                  command
* REVERSE::                 operator
* RULE::                    type
* Free Variable::           type
* Optional Free Variable::  type
* SECOND::                  operator
* SET::                     operator
* SETQ::                    operator
* THIRD::                   operator
* WHEN::                    operator


File: ..\util\r37,  Node: ARITHMETIC_OPERATIONS,  Next: ABS,  Up: Arithmetic Operations section

   ARITHMETIC_OPERATIONS                    introduction

   This section considers operations defined in REDUCE that concern
numbers, or operators that can operate on numbers in addition, in most
cases, to more general expressions.


File: ..\util\r37,  Node: ABS,  Next: ADJPREC,  Prev: ARITHMETIC_OPERATIONS,  Up: Arithmetic Operations section

   ABS                    operator

   The ABS operator returns the absolute value of its argument.

syntax:

   ABS (<expression>)

   <expression> can be any REDUCE scalar expression.

examples:

     ____________________________________________________________
     
     abs(-a);
     
       ABS(A)
     
     
     abs(-5);
     
       5
     
     
     a := -10;
     
       A := -10
     
     
     abs(a);
     
       10
     
     
     abs(-a);
     
       10
     
     ____________________________________________________________
   If the argument has had no numeric value assigned to it, such as an
identifier or polynomial, ABS returns an expression involving ABS  of
its argument, doing as much simplification of the argument as it can,
such as dropping any preceding minus sign.


File: ..\util\r37,  Node: ADJPREC,  Next: ARG,  Prev: ABS,  Up: Arithmetic Operations section

   ADJPREC                    switch

   When a real number is input, it is normally truncated to the [*note
PRECISION::.]  in effect at the time the number is read. If it is
desired to keep the full precision of all numbers input, the switch
ADJPREC (for <adjust precision>) can be turned on. While on, ADJPREC
will automatically increase the precision, when necessary, to match that
of any integer or real input, and a message printed to inform the user
of the precision increase.

examples:

     ____________________________________________________________
     
     on rounded;
     
     1.23456789012345;
     
       1.23456789012
     
     
     on adjprec;
     
     1.23456789012345;
     
     *** precision increased to 15
     ____________________________________________________________


File: ..\util\r37,  Node: ARG,  Next: CEILING,  Prev: ADJPREC,  Up: Arithmetic Operations section

   ARG                    operator

   If [*note COMPLEX::.] and [*note ROUNDED::.] are on, and arg
evaluates to a complex number, ARG returns the polar angle of arg,
measured in radians. Otherwise an expression in arg is returned.

examples:

     ____________________________________________________________
     
     arg(3+4i)
     
       ARG(3 + 4*I)
     
     
     on rounded, complex;
     
     ws;
     
       0.927295218002
     
     
     arg a;
     
       ARG(A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: CEILING,  Next: CHOOSE,  Prev: ARG,  Up: Arithmetic Operations section

   CEILING                    operator

syntax:

   CEILING (<expression>)

   This operator returns the ceiling (i.e., the least integer greater
than or equal to its argument) if its argument has a numerical value.
For negative numbers, this is equivalent to [*note FIX::.] . For
non-numeric arguments, the value is an expression in the original
operator.

examples:

     ____________________________________________________________
     
     ceiling 3.4;
     
       4
     
     
     fix 3.4;
     
       3
     
     
     ceiling(-5.2);
     
       -5
     
     
     fix(-5.2);
     
       -5
     
     
     ceiling a;
     
       CEILING(A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: CHOOSE,  Next: DEG2DMS,  Prev: CEILING,  Up: Arithmetic Operations section

   CHOOSE                    operator

   CHOOSE (<m>,<m>) returns the number of ways of choosing <m> objects
from a collection of <n> distinct objects -- in other words the
binomial coefficient. If <m> and <n> are not positive integers, or m >
n, the expression is returned unchanged.  than or equal to

examples:

     ____________________________________________________________
     
     choose(2,3);
     
       3
     
     
     choose(3,2);
     
       CHOOSE(3,2)
     
     
     choose(a,b);
     
       CHOOSE(A,B)
     
     ____________________________________________________________


File: ..\util\r37,  Node: DEG2DMS,  Next: DEG2RAD,  Prev: CHOOSE,  Up: Arithmetic Operations section

   DEG2DMS                    operator

syntax:

   DEG2DMS (<expression>)

   In [*note ROUNDED::.] mode, if <expression> is a real number, the
operator DEG2DMS will interpret it as degrees, and convert it to a list
containing the equivalent degrees, minutes and seconds. In all other
cases, an expression in terms of the original operator is returned.

examples:

     ____________________________________________________________
     
     deg2dms 60;
     
       DEG2DMS(60)
     
     
     on rounded;
     
     ws;
     
       {60,0,0}
     
     
     deg2dms 42.4;
     
       {42,23,60.0}
     
     
     deg2dms a;
     
       DEG2DMS(A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: DEG2RAD,  Next: DIFFERENCE,  Prev: DEG2DMS,  Up: Arithmetic Operations section

   DEG2RAD                    operator

syntax:

   DEG2RAD (<expression>)

   In [*note ROUNDED::.] mode, if <expression> is a real number, the
operator DEG2RAD will interpret it as degrees, and convert it to the
equivalent radians. In all other cases, an expression in terms of the
original operator is returned.

examples:

     ____________________________________________________________
     
     deg2rad 60;
     
       DEG2RAD(60)
     
     
     on rounded;
     
     ws;
     
       1.0471975512
     
     
     deg2rad a;
     
       DEG2RAD(A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: DIFFERENCE,  Next: DILOG,  Prev: DEG2RAD,  Up: Arithmetic Operations section

   DIFFERENCE                    operator

   The DIFFERENCE operator may be used as either an infix or prefix
binary subtraction operator. It is identical to - as a binary operator.

syntax:

   DIFFERENCE (<expression>,<expression>) or

   <expression> DIFFERENCE <expression>  DIFFERENCE <expression>*

   <expression> can be a number or any other valid REDUCE expression.
Matrix expressions are allowed if they are of the same dimensions.

examples:

     ____________________________________________________________
     
     
     difference(10,4);
     
       6
     
     
     
     15 difference 5 difference 2;
     
       8
     
     
     
     a difference b;
     
       A - B
     
     ____________________________________________________________
   The DIFFERENCE operator is left associative, as shown in the second
example above.


File: ..\util\r37,  Node: DILOG,  Next: DMS2DEG,  Prev: DIFFERENCE,  Up: Arithmetic Operations section

   DILOG                    operator

   The DILOG operator is known to the differentiation and integration
operators, but has numeric value attached only at DILOG(0) . Dilog is
defined by

   dilog(x) = -int(log(x),x)/(x-1)

examples:

     ____________________________________________________________
     
     df(dilog(x**2),x);
     
                2
         2*LOG(X )*X
       - ------------
            2
           X   - 1
     
     
     
     int(dilog(x),x);
     
       DILOG(X)*X - DILOG(X) + LOG(X)*X - X
     
     
     
     dilog(0);
     
         2
       PI
       ----
        6
     
     ____________________________________________________________


File: ..\util\r37,  Node: DMS2DEG,  Next: DMS2RAD,  Prev: DILOG,  Up: Arithmetic Operations section

   DMS2DEG                    operator

syntax:

   DMS2DEG (<list>)

   In [*note ROUNDED::.] mode, if <list> is a list of three real
numbers, the operator DMS2DEG will interpret the list as degrees,
minutes and seconds and convert it to the equivalent degrees. In all
other cases, an expression in terms of the original operator is
returned.

examples:

     ____________________________________________________________
     
     dms2deg {42,3,7};
     
       DMS2DEG({42,3,7})
     
     
     on rounded;
     
     ws;
     
       42.0519444444
     
     
     dms2deg a;
     
       DMS2DEG(A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: DMS2RAD,  Next: FACTORIAL,  Prev: DMS2DEG,  Up: Arithmetic Operations section

   DMS2RAD                    operator

syntax:

   DMS2RAD (<list>)

   In [*note ROUNDED::.] mode, if <list> is a list of three real
numbers, the operator DMS2RAD will interpret the list as degrees,
minutes and seconds and convert it to the equivalent radians. In all
other cases, an expression in terms of the original operator is
returned.

examples:

     ____________________________________________________________
     
     dms2rad {42,3,7};
     
       DMS2RAD({42,3,7})
     
     
     on rounded;
     
     ws;
     
       0.733944887421
     
     
     dms2rad a;
     
       DMS2RAD(A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: FACTORIAL,  Next: FIX,  Prev: DMS2RAD,  Up: Arithmetic Operations section

   FACTORIAL                    operator

syntax:

   FACTORIAL (<expression>)

   If the argument of FACTORIAL is a positive integer or zero, its
factorial is returned. Otherwise the result is expressed in terms of the
original operator. For more general operations, the [*note GAMMA::.]
operator is available in the [*note Special Function Package::.] .

examples:

     ____________________________________________________________
     
     factorial 4;
     
       24
     
     
     factorial 30 ;
     
       265252859812191058636308480000000
     
     ____________________________________________________________


File: ..\util\r37,  Node: FIX,  Next: FIXP,  Prev: FACTORIAL,  Up: Arithmetic Operations section

   FIX                    operator

syntax:

   FIX (<expression>)

   The operator FIX returns the integer part of its argument, if that
argument has a numerical value. For positive numbers, this is equivalent
to [*note FLOOR::.] , and, for negative numbers, [*note CEILING::.] .
For non-numeric arguments, the value is an expression in the original
operator.

examples:

     ____________________________________________________________
     
     fix 3.4;
     
       3
     
     
     floor 3.4;
     
       3
     
     
     ceiling 3.4;
     
       4
     
     
     fix(-5.2);
     
       -5
     
     
     floor(-5.2);
     
       -6
     
     
     ceiling(-5.2);
     
       -5
     
     
     fix(a);
     
       FIX(A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: FIXP,  Next: FLOOR,  Prev: FIX,  Up: Arithmetic Operations section

   FIXP                    operator

   The FIXP logical operator returns true if its argument is an integer.

syntax:

   FIXP (<expression>) or FIXP <simple_expression>

   <expression> can be any valid REDUCE expression, <simple_expression>
must be a single identifier or begin with a prefix operator.

examples:

     ____________________________________________________________
     
     if fixp 1.5 then write "ok" else write "not";
     
     
     
       not
     
     
     if fixp(a) then write "ok" else write "not";
     
     
     
       not
     
     
     a := 15;
     
       A := 15
     
     
     if fixp(a) then write "ok" else write "not";
     
     
     
       ok
     
     ____________________________________________________________
   Logical operators can only be used inside conditional expressions
such as IF ...THEN  or WHILE ...DO .


File: ..\util\r37,  Node: FLOOR,  Next: EXPT,  Prev: FIXP,  Up: Arithmetic Operations section

   FLOOR                    operator

syntax:

   FLOOR (<expression>)

   This operator returns the floor (i.e., the greatest integer less
than or equal to its argument) if its argument has a numerical value.
For positive numbers, this is equivalent to [*note FIX::.] . For
non-numeric arguments, the value is an expression in the original
operator.

examples:

     ____________________________________________________________
     
     floor 3.4;
     
       3
     
     
     fix 3.4;
     
       3
     
     
     floor(-5.2);
     
       -6
     
     
     fix(-5.2);
     
       -5
     
     
     floor a;
     
       FLOOR(A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: EXPT,  Next: GCD,  Prev: FLOOR,  Up: Arithmetic Operations section

   EXPT                    operator

   The EXPT operator is both an infix and prefix binary exponentiation
operator. It is identical to ^ or ** .

syntax:

   EXPT (<expression>,<expression>)  or <expression> EXPT <expression>

examples:

     ____________________________________________________________
     
     a expt b;
     
        B
       A
     
     
     expt(a,b);
     
        B
       A
     
     
     (x+y) expt 4;
     
        4      3        2  2        3    4
       X  + 4*X *Y + 6*X *Y  + 4*X*Y  + Y
     
     ____________________________________________________________
   Scalar expressions may be raised to fractional and floating-point
powers.  Square matrix expressions may be raised to positive powers,
and also to negative powers if non-singular.

   EXPT is left associative. In other words, A EXPT B EXPT C is
equivalent to A EXPT (B*C) , not A EXPT (B EXPT C) , which would be
right associative.


File: ..\util\r37,  Node: GCD,  Next: LN,  Prev: EXPT,  Up: Arithmetic Operations section

   GCD                    operator

   The GCD operator returns the greatest common divisor of two
polynomials.

syntax:

   GCD (<expression>,<expression>)

   <expression> must be a polynomial (or integer), otherwise an error
occurs.

examples:

     ____________________________________________________________
     
     gcd(2*x**2 - 2*y**2,4*x + 4*y);
     
       2*(X + Y)
     
     
     gcd(sin(x),x**2 + 1);
     
       1
     
     
     gcd(765,68);
     
       17
     
     ____________________________________________________________
   The operator GCD described here provides an explicit means to find
the gcd of two expressions. The switch GCD described below simplifies
expressions by finding and canceling gcd's at every opportunity. When
the switch [*note EZGCD::.] is also on, gcd's are figured using the EZ
GCD algorithm, which is usually faster.


File: ..\util\r37,  Node: LN,  Next: LOG,  Prev: GCD,  Up: Arithmetic Operations section

   LN                    operator

syntax:

   LN (<expression>)

   <expression> can be any valid scalar REDUCE expression.

   The LN operator returns the natural logarithm of its argument.
However, unlike [*note LOG::.] , there are no algebraic rules associated
with it; it will only evaluate when [*note ROUNDED::.] is on, and the
argument is a real number.

examples:

     ____________________________________________________________
     
     ln(x);
     
       LN(X)
     
     
     ln 4;
     
       LN(4)
     
     
     ln(e);
     
       LN(E)
     
     
     df(ln(x),x);
     
       DF(LN(X),X)
     
     
     on rounded;
     
     ln 4;
     
       1.38629436112
     
     
     ln e;
     
       1
     
     ____________________________________________________________
   Because of the restricted algebraic properties of LN , users are
advised to use [*note LOG::.] whenever possible.


File: ..\util\r37,  Node: LOG,  Next: LOGB,  Prev: LN,  Up: Arithmetic Operations section

   LOG                    operator

   The LOG operator returns the natural logarithm of its argument.

syntax:

   LOG (<expression>) or LOG <expression>

   <expression> can be any valid scalar REDUCE expression.

examples:

     ____________________________________________________________
     
     log(x);
     
       LOG(X)
     
     
     log 4;
     
       LOG(4)
     
     
     log(e);
     
       1
     
     
     on rounded;
     
     log 4;
     
       1.38629436112
     
     ____________________________________________________________
   LOG returns a numeric value only when [*note ROUNDED::.] is on. In
that case, use of a negative argument for LOG results in an error
message. No error is given on a negative argument when REDUCE is not in
that mode.


File: ..\util\r37,  Node: LOGB,  Next: MAX,  Prev: LOG,  Up: Arithmetic Operations section

   LOGB                    operator

syntax:

   LOGB (<expression>,<integer>)

   <expression> can be any valid scalar REDUCE expression.

   The LOGB operator returns the logarithm of its first argument using
the second argument as base. However, unlike [*note LOG::.] , there are
no algebraic rules associated with it; it will only evaluate when
[*note ROUNDED::.]  is on, and the first argument is a real number.

examples:

     ____________________________________________________________
     
     logb(x,2);
     
       LOGB(X,2)
     
     
     logb(4,3);
     
       LOGB(4,3)
     
     
     logb(2,2);
     
       LOGB(2,2)
     
     
     df(logb(x,3),x);
     
       DF(LOGB(X,3),X)
     
     
     on rounded;
     
     logb(4,3);
     
       1.26185950714
     
     
     logb(2,2);
     
       1
     
     ____________________________________________________________


File: ..\util\r37,  Node: MAX,  Next: MIN,  Prev: LOGB,  Up: Arithmetic Operations section

   MAX                    operator

   The operator MAX is an n-ary prefix operator, which returns the
largest value in its arguments.

syntax:

   MAX (<expression>,<expression>*)

   <expression> must evaluate to a number. MAX of an empty list returns
0.

examples:

     ____________________________________________________________
     
     max(4,6,10,-1);
     
       10
     
     
     <<a := 23;b := 2*a;c := 4**2;max(a,b,c)>>;
     
     
     
       46
     
     
     max(-5,-10,-a);
     
       -5
     
     ____________________________________________________________


File: ..\util\r37,  Node: MIN,  Next: MINUS,  Prev: MAX,  Up: Arithmetic Operations section

   MIN                    operator

   The operator MIN is an n-ary prefix operator, which returns the
smallest value in its arguments.

syntax:

   MIN (<expression>,<expression>*)

   <expression> must evaluate to a number. MIN of an empty list returns
0.

examples:

     ____________________________________________________________
     
     min(-3,0,17,2);
     
       -3
     
     
     <<a := 23;b := 2*a;c := 4**2;min(a,b,c)>>;
     
     
     
       16
     
     
     min(5,10,a);
     
       5
     
     ____________________________________________________________


File: ..\util\r37,  Node: MINUS,  Next: NEXTPRIME,  Prev: MIN,  Up: Arithmetic Operations section

   MINUS                    operator

   The MINUS operator is a unary minus, returning the negative of its
argument. It is equivalent to the unary - .

syntax:

   MINUS (<expression>)

   <expression> may be any scalar REDUCE expression.

examples:

     ____________________________________________________________
     
     minus(a);
     
       - A
     
     
     minus(-1);
     
       1
     
     
     minus((x+1)**4);
     
           4      3      2
       - (X  + 4*X  + 6*X  + 4*X + 1)
     
     ____________________________________________________________


File: ..\util\r37,  Node: NEXTPRIME,  Next: NOCONVERT,  Prev: MINUS,  Up: Arithmetic Operations section

   NEXTPRIME                    operator

syntax:

   NEXTPRIME (<expression>)

   If the argument of NEXTPRIME is an integer, the least prime greater
than that argument is returned. Otherwise, a type error results.

examples:

     ____________________________________________________________
     
     nextprime 5001;
     
       5003
     
     
     nextprime(10^30);
     
       1000000000000000000000000000057
     
     
     nextprime a;
     
       ***** A invalid as integer
     
     ____________________________________________________________


File: ..\util\r37,  Node: NOCONVERT,  Next: NORM,  Prev: NEXTPRIME,  Up: Arithmetic Operations section

   NOCONVERT                    switch

   Under normal circumstances when ROUNDED is on, REDUCE converts the
number 1.0 to the integer 1. If this is not desired, the switch
NOCONVERT  can be turned on.

examples:

     ____________________________________________________________
     
     on rounded;
     
     1.0000000000001;
     
       1
     
     
     on noconvert;
     
     1.0000000000001;
     
       1.0
     
     ____________________________________________________________


File: ..\util\r37,  Node: NORM,  Next: PERM,  Prev: NOCONVERT,  Up: Arithmetic Operations section

   NORM                    operator

syntax:

   NORM (<expression>)

   If ROUNDED is on, and the argument is a real number, <norm> returns
its absolute value. If COMPLEX is also on, <norm> returns the square
root of the sum of squares of the real and imaginary parts of the
argument. In all other cases, a result is returned in terms of the
original operator.

examples:

     ____________________________________________________________
     
     norm (-2);
     
       NORM(-2)
     
     
     on rounded;
     
     ws;
     
       2.0
     
     
     norm(3+4i);
     
       NORM(4*I+3)
     
     
     on complex;
     
     ws;
     
       5.0
     
     ____________________________________________________________


File: ..\util\r37,  Node: PERM,  Next: PLUS,  Prev: NORM,  Up: Arithmetic Operations section

   PERM                    operator

syntax:

   perm(<expression1>,<expression2>)

   If <expression1> and <expression2> evaluate to positive integers,
PERM  returns the number of permutations possible in selecting
<expression1> objects from <expression2> objects.  In other cases, an
expression in the original operator is returned.

examples:

     ____________________________________________________________
     
     perm(1,1);
     
       1
     
     
     perm(3,5);
     
       60
     
     
     perm(-3,5);
     
       PERM(-3,5)
     
     
     perm(a,b);
     
       PERM(A,B)
     
     ____________________________________________________________


File: ..\util\r37,  Node: PLUS,  Next: QUOTIENT,  Prev: PERM,  Up: Arithmetic Operations section

   PLUS                    operator

   The PLUS operator is both an infix and prefix n-ary addition
operator. It exists because of the way in which REDUCE handles such
operators internally, and is not recommended for use in algebraic mode
programming. [*note plussign::.] , which has the identical effect,
should be used instead.

syntax:

   PLUS (<expression>,<expression>,<expression> *) or

   <expression> PLUS <expression> PLUS <expression>*

   <expression> can be any valid REDUCE expression, including matrix
expressions of the same dimensions.

examples:

     ____________________________________________________________
     
     a plus b plus c plus d;
     
       A + B + C + D
     
     
     4.5 plus 10;
     
       29
       --
       2
     
     
     
     plus(x**2,y**2);
     
        2    2
       X  + Y
     
     ____________________________________________________________


File: ..\util\r37,  Node: QUOTIENT,  Next: RAD2DEG,  Prev: PLUS,  Up: Arithmetic Operations section

   QUOTIENT                    operator

   The QUOTIENT operator is both an infix and prefix binary operator
that returns the quotient of its first argument divided by its second.
It is also a unary [*note RECIP::.] rocal operator. It is identical to
/ and [*note slash::.] .

syntax:

   QUOTIENT (<expression>,<expression>) or <expression> QUOTIENT
<expression> or QUOTIENT (<expression>) or QUOTIENT  <expression>

   <expression> can be any valid REDUCE scalar expression. Matrix
expressions can also be used if the second expression is invertible and
the matrices are of the correct dimensions.

examples:

     ____________________________________________________________
     
     quotient(a,x+1);
     
         A
       -----
       X + 1
     
     
     7 quotient 17;
     
       7
       --
       17
     
     
     on rounded;
     
     4.5 quotient 2;
     
       2.25
     
     
     quotient(x**2 + 3*x + 2,x+1);
     
       X + 2
     
     
     matrix m,inverse;
     
     m := mat((a,b),(c,d));
     
       M(1,1) := A;
       M(1,2) := B;
       M(2,1) := C
       M(2,2) := D
     
     
     
     inverse := quotient m;
     
                           D
       INVERSE(1,1) := ----------
                       A*D - B*C
                             B
       INVERSE(1,2) := - ----------
                         A*D - B*C
                             C
       INVERSE(2,1) := - ----------
                         A*D - B*C
                           A
       INVERSE(2,2) := ----------
                       A*D - B*C
     
     ____________________________________________________________

   The QUOTIENT operator is left associative: A QUOTIENT B QUOTIENT C
is equivalent to (A QUOTIENT B) QUOTIENT C .

   If a matrix argument to the unary QUOTIENT is not invertible, or if
the second matrix argument to the binary quotient is not invertible, an
error message is given.


File: ..\util\r37,  Node: RAD2DEG,  Next: RAD2DMS,  Prev: QUOTIENT,  Up: Arithmetic Operations section

   RAD2DEG                    operator

syntax:

   RAD2DEG (<expression>)

   In [*note ROUNDED::.] mode, if <expression> is a real number, the
operator RAD2DEG will interpret it as radians, and convert it to the
equivalent degrees. In all other cases, an expression in terms of the
original operator is returned.

examples:

     ____________________________________________________________
     
     rad2deg 1;
     
       RAD2DEG(1)
     
     
     on rounded;
     
     ws;
     
       57.2957795131
     
     
     rad2deg a;
     
       RAD2DEG(A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: RAD2DMS,  Next: RECIP,  Prev: RAD2DEG,  Up: Arithmetic Operations section

   RAD2DMS                    operator

syntax:

   RAD2DMS (<expression>)

   In [*note ROUNDED::.] mode, if <expression> is a real number, the
operator RAD2DMS will interpret it as radians, and convert it to a list
containing the equivalent degrees, minutes and seconds. In all other
cases, an expression in terms of the original operator is returned.

examples:

     ____________________________________________________________
     
     rad2dms 1;
     
       RAD2DMS(1)
     
     
     on rounded;
     
     ws;
     
       {57,17,44.8062470964}
     
     
     rad2dms a;
     
       RAD2DMS(A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: RECIP,  Next: REMAINDER,  Prev: RAD2DMS,  Up: Arithmetic Operations section

   RECIP                    operator

   RECIP  is the alphabetical name for the division operator / or
[*note slash::.] used as a unary operator. The use of / is preferred.

examples:

     ____________________________________________________________
     
     recip a;
     
       1
       -
       A
     
     
     recip 2;
     
       1
       --
       2
     
     ____________________________________________________________


File: ..\util\r37,  Node: REMAINDER,  Next: ROUND,  Prev: RECIP,  Up: Arithmetic Operations section

   REMAINDER                    operator

   The REMAINDER operator returns the remainder after its first
argument is divided by its second argument.

syntax:

   REMAINDER (<expression>,<expression>)

   <expression> can be any valid REDUCE polynomial, and is not limited
to numeric values.

examples:

     ____________________________________________________________
     
     remainder(13,6);
     
       1
     
     
     remainder(x**2 + 3*x + 2,x+1);
     
       0
     
     
     remainder(x**3 + 12*x + 4,x**2 + 1);
     
     
       11*X + 4
     
     
     remainder(sin(2*x),x*y);
     
       SIN(2*X)
     
     ____________________________________________________________
   In the default case, remainders are calculated over the integers. If
you need the remainder with respect to another domain, it must be
declared explicitly.

   If the first argument to REMAINDER contains a denominator not equal
to 1, an error occurs.


File: ..\util\r37,  Node: ROUND,  Next: SETMOD,  Prev: REMAINDER,  Up: Arithmetic Operations section

   ROUND                    operator

syntax:

   ROUND (<expression>)

   If its argument has a numerical value, ROUND rounds it to the
nearest integer. For non-numeric arguments, the value is an expression
in the original operator.

examples:

     ____________________________________________________________
     
     round 3.4;
     
       3
     
     
     round 3.5;
     
       4
     
     
     round a;
     
       ROUND(A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: SETMOD,  Next: SIGN,  Prev: ROUND,  Up: Arithmetic Operations section

   SETMOD                    command

   The SETMOD command sets the modulus value for subsequent [*note
MODULAR::.] arithmetic.

syntax:

   SETMOD <integer>

   <integer> must be positive, and greater than 1. It need not be a
prime number.

examples:

     ____________________________________________________________
     
     setmod 6;
     
       1
     
     
     on modular;
     
     16;
     
       4
     
     
     x^2 + 5x + 7;
     
        2
       X  + 5*X + 1
     
     
     x/3;
     
       X
       -
       3
     
     
     setmod 2;
     
       6
     
     
     (x+1)^4;
     
        4
       X  + 1
     
     
     x/3;
     
       X
     
     ____________________________________________________________
   SETMOD returns the previous modulus, or 1 if none has been set
before. SETMOD only has effect when [*note MODULAR::.] is on.

   Modular operations are done only on numbers such as coefficients of
polynomials, not on the exponents. The modulus need not be prime.
Attempts to divide by a power of the modulus produces an error message,
since the operation is equivalent to dividing by 0. However, dividing
by a factor of a non-prime modulus does not produce an error message.


File: ..\util\r37,  Node: SIGN,  Next: SQRT,  Prev: SETMOD,  Up: Arithmetic Operations section

   SIGN                    operator

syntax:

   SIGN <expression>

   SIGN tries to evaluate the sign of its argument. If this is possible
SIGN returns one of 1, 0 or -1. Otherwise, the result is the original
form or a simplified variant.

examples:

     ____________________________________________________________
     
             sign(-5)
     
       -1
     
     
             sign(-a^2*b)
     
       -SIGN(B)
     
     ____________________________________________________________
   Even powers of formal expressions are assumed to be positive only as
long as the switch [*note COMPLEX::.] is off.


File: ..\util\r37,  Node: SQRT,  Next: TIMES,  Prev: SIGN,  Up: Arithmetic Operations section

   SQRT                    operator

   The SQRT operator returns the square root of its argument.

syntax:

   SQRT (<expression>)

   <expression> can be any REDUCE scalar expression.

examples:

     ____________________________________________________________
     
     sqrt(16*a^3);
     
       4*SQRT(A)*A
     
     
     sqrt(17);
     
       SQRT(17)
     
     
     on rounded;
     
     sqrt(17);
     
       4.12310562562
     
     
     off rounded;
     
     sqrt(a*b*c^5*d^3*27);
     
                                                  2
       3*SQRT(D)*SQRT(C)*SQRT(B)*SQRT(A)*SQRT(3)*C *D
     
     ____________________________________________________________
   SQRT checks its argument for squared factors and removes them.

   Numeric values for square roots that are not exact integers are
given only when [*note ROUNDED::.] is on.

   Please note that SQRT(A**2) is given as A , which may be incorrect
if A eventually has a negative value. If you are programming a
calculation in which this is a concern, you can turn on the [*note
PRECISE::.]  switch, which causes the absolute value of the square root
to be returned.


File: ..\util\r37,  Node: TIMES,  Prev: SQRT,  Up: Arithmetic Operations section

   TIMES                    operator

   The TIMES operator is an infix or prefix n-ary multiplication
operator. It is identical to * .

syntax:

   <expression> TIMES <expression> TIMES <expression>*

   or TIMES (<expression>,<expression> ,<expression>*)

   <expression> can be any valid REDUCE scalar or matrix expression.
Matrix expressions must be of the correct dimensions. Compatible scalar
and matrix expressions can be mixed.

examples:

     ____________________________________________________________
     
     var1 times var2;
     
       VAR1*VAR2
     
     
     times(6,5);
     
       30
     
     
     matrix aa,bb;
     
     aa := mat((1),(2),(x))$
     
     bb := mat((0,3,1))$
     
     aa times bb times 5;
     
       [0   15    5 ]
       [            ]
       [0   30   10 ]
       [            ]
       [0  15*X  5*X]
     
     ____________________________________________________________


File: ..\util\r37,  Node: Arithmetic Operations section,  Next: Boolean Operators section,  Prev: Syntax section,  Up: Top

   Arithmetic Operations section

* Menu:

* ARITHMETIC_OPERATIONS::  introduction
* ABS::                     operator
* ADJPREC::                 switch
* ARG::                     operator
* CEILING::                 operator
* CHOOSE::                  operator
* DEG2DMS::                 operator
* DEG2RAD::                 operator
* DIFFERENCE::              operator
* DILOG::                   operator
* DMS2DEG::                 operator
* DMS2RAD::                 operator
* FACTORIAL::               operator
* FIX::                     operator
* FIXP::                    operator
* FLOOR::                   operator
* EXPT::                    operator
* GCD::                     operator
* LN::                      operator
* LOG::                     operator
* LOGB::                    operator
* MAX::                     operator
* MIN::                     operator
* MINUS::                   operator
* NEXTPRIME::               operator
* NOCONVERT::               switch
* NORM::                    operator
* PERM::                    operator
* PLUS::                    operator
* QUOTIENT::                operator
* RAD2DEG::                 operator
* RAD2DMS::                 operator
* RECIP::                   operator
* REMAINDER::               operator
* ROUND::                   operator
* SETMOD::                  command
* SIGN::                    operator
* SQRT::                    operator
* TIMES::                   operator


File: ..\util\r37,  Node: boolean value,  Next: EQUAL,  Up: Boolean Operators section

   BOOLEAN VALUE

   There are no extra symbols for the truth values true and false.
Instead, [*note NIL::.] and the number zero are interpreted as truth
value false in algebraic programs (see [*note false::.] ), while any
different value is considered as true (see [*note TRUE::.] ).


File: ..\util\r37,  Node: EQUAL,  Next: EVENP,  Prev: boolean value,  Up: Boolean Operators section

   EQUAL                    operator

   The operator EQUAL is an infix binary comparison operator. It is
identical with = . It returns [*note TRUE::.] if its two arguments are
equal.

syntax:

   <expression> EQUAL <expression>

   Equality is given between floating point numbers and integers that
have the same value.

examples:

     ____________________________________________________________
     
     on rounded;
     
     a := 4;
     
       A := 4
     
     
     b := 4.0;
     
       B := 4.0
     
     
     if a equal b then write "true" else write "false";
     
     
     
       true
     
     
     if a equal 5 then write "true" else write "false";
     
     
     
       false
     
     
     if a equal sqrt(16) then write "true" else write "false";
     
     
     
       true
     
     ____________________________________________________________
   Comparison operators can only be used as conditions in conditional
commands such as IF ...THEN  and REPEAT ...UNTIL .  <equal> can also be
used as a prefix operator. However, this use is not encouraged.


File: ..\util\r37,  Node: EVENP,  Next: false,  Prev: EQUAL,  Up: Boolean Operators section

   EVENP                    operator

   The EVENP logical operator returns [*note TRUE::.] if its argument
is an even integer, and [*note NIL::.] if its argument is an odd
integer. An error message is returned if its argument is not an integer.

syntax:

   EVENP (<integer>) or EVENP <integer>

   <integer> must evaluate to an integer.

examples:

     ____________________________________________________________
     
     aa := 1782;
     
       AA := 1782
     
     
     if evenp aa then yes else no;
     
       YES
     
     
     if evenp(-3) then yes else no;
     
       NO
     
     ____________________________________________________________
   Although you would not ordinarily enter an expression such as the
last example above, note that the negative term must be enclosed in
parentheses to be correctly parsed. The EVENP operator can only be used
in conditional statements such as IF ...THEN ...ELSE or WHILE ...DO .


File: ..\util\r37,  Node: false,  Next: FREEOF,  Prev: EVENP,  Up: Boolean Operators section

   FALSE

   The symbol [*note NIL::.] and the number zero are considered as
[*note boolean value::.] false if used in a place where a boolean value
is required. Most builtin operators return [*note NIL::.]  as false
value. Algebraic programs use better zero.  Note that NIL is not
printed when returned as result to a top level evaluation.


File: ..\util\r37,  Node: FREEOF,  Next: LEQ,  Prev: false,  Up: Boolean Operators section

   FREEOF                    operator

   The FREEOF logical operator returns [*note TRUE::.]  if its first
argument does not contain its second argument anywhere in its structure.

syntax:

   FREEOF (<expression>,<kernel>) or <expression> FREEOF <kernel>

   <expression> can be any valid scalar REDUCE expression, <kernel> must
be a kernel expression (see KERNEL ).

examples:

     ____________________________________________________________
     
     a := x + sin(y)**2 + log sin z;
     
     
     
                                2
       A := LOG(SIN(Z)) + SIN(Y)   + X
     
     
     if freeof(a,sin(y)) then write "free" else write "not free";
     
     
     
       not free
     
     
     if freeof(a,sin(x)) then write "free" else write "not free";
     
     
     
       free
     
     
     if a freeof sin z then write "free" else write "not free";
     
     
     
       not free
     
     ____________________________________________________________
   Logical operators can only be used in conditional expressions such as

   IF ...THEN  or WHILE ...DO .


File: ..\util\r37,  Node: LEQ,  Next: LESSP,  Prev: FREEOF,  Up: Boolean Operators section

   LEQ                    operator

   The LEQ operator is a binary infix or prefix logical operator. It
returns [*note TRUE::.] if its first argument is less than or equal to
its second argument. As an infix operator it is identical with <= .

syntax:

   LEQ (<expression>,<expression>) or <expression> LEQ  <expression>

   <expression> can be any valid REDUCE expression that evaluates to a
number.

examples:

     ____________________________________________________________
     
     a := 15;
     
       A := 15
     
     
     if leq(a,25) then write "yes" else write "no";
     
     
     
       yes
     
     
     if leq(a,15) then write "yes" else write "no";
     
     
     
       yes
     
     
     if leq(a,5) then write "yes" else write "no";
     
     
     
       no
     
     ____________________________________________________________
   Logical operators can only be used in conditional statements such as

   IF ...THEN ...ELSE  or WHILE ...DO .


File: ..\util\r37,  Node: LESSP,  Next: MEMBER,  Prev: LEQ,  Up: Boolean Operators section

   LESSP                    operator

   The LESSP operator is a binary infix or prefix logical operator. It
returns [*note TRUE::.] if its first argument is strictly less than its
second argument. As an infix operator it is identical with < .

syntax:

   LESSP (<expression>,<expression>) or <expression> LESSP <expression>

   <expression> can be any valid REDUCE expression that evaluates to a
number.

examples:

     ____________________________________________________________
     
     a := 15;
     
       A := 15
     
     
     if lessp(a,25) then write "yes" else write "no";
     
     
     
       yes
     
     
     if lessp(a,15) then write "yes" else write "no";
     
     
     
       no
     
     
     if lessp(a,5) then write "yes" else write "no";
     
     
     
       no
     
     ____________________________________________________________
   Logical operators can only be used in conditional statements such as

   IF ...THEN ...ELSE  or WHILE ...DO .


File: ..\util\r37,  Node: MEMBER,  Next: NEQ,  Prev: LESSP,  Up: Boolean Operators section

   MEMBER                    operator

syntax:

   <expression> MEMBER <list>

   MEMBER is an infix binary comparison operator that evaluates to
[*note TRUE::.]  if <expression> is [*note EQUAL::.] to a member of the
[*note LIST::.] <list>.

examples:

     ____________________________________________________________
     
     if a member {a,b} then 1 else 0;
     
       1
     
     
     if 1 member(1,2,3) then a else b;
     
       a
     
     
     if 1 member(1.0,2) then a else b;
     
       b
     
     ____________________________________________________________
   Logical operators can only be used in conditional statements such as

   IF ...THEN ...ELSE  or WHILE ...DO .  <member> can also be used as a
prefix operator. However, this use is not encouraged. Finally, [*note
EQUAL::.] (= ) is used for the test within the list, so expressions
must be of the same type to match.


File: ..\util\r37,  Node: NEQ,  Next: NOT,  Prev: MEMBER,  Up: Boolean Operators section

   NEQ                    operator

   The operator NEQ is an infix binary comparison operator. It returns
[*note TRUE::.] if its two arguments are not [*note EQUAL::.] .

syntax:

   <expression> NEQ <expression>

   An inequality is satisfied between floating point numbers and
integers that have the same value.

examples:

     ____________________________________________________________
     
     on rounded;
     
     a := 4;
     
       A := 4
     
     
     b := 4.0;
     
       B := 4.0
     
     
     if a neq b then write "true" else write "false";
     
     
     
       false
     
     
     if a neq 5 then write "true" else write "false";
     
     
     
       true
     
     ____________________________________________________________
   Comparison operators can only be used as conditions in conditional
commands such as IF ...THEN  and REPEAT ...UNTIL .  <neq> can also be
used as a prefix operator. However, this use is not encouraged.


File: ..\util\r37,  Node: NOT,  Next: NUMBERP,  Prev: NEQ,  Up: Boolean Operators section

   NOT                    operator

   The NOT operator returns [*note TRUE::.] if its argument evaluates to
[*note NIL::.] , and NIL if its argument is TRUE .

syntax:

   NOT (<logical expression>)

examples:

     ____________________________________________________________
     
     if not numberp(a) then write "indeterminate" else write a;
     
     
     
       indeterminate;
     
     
     a := 10;
     
       A := 10
     
     
     if not numberp(a) then write "indeterminate" else write a;
     
     
     
       10
     
     
     if not(numberp(a) and a < 0) then write "positive number";
     
     
     
       positive number
     
     ____________________________________________________________
   Logical operators can only be used in conditional statements such as

   IF ...THEN ...ELSE  or WHILE ...DO .


File: ..\util\r37,  Node: NUMBERP,  Next: ORDP,  Prev: NOT,  Up: Boolean Operators section

   NUMBERP                    operator

   The NUMBERP operator returns [*note TRUE::.] if its argument is a
number, and [*note NIL::.] otherwise.

syntax:

   NUMBERP (<expression>) or NUMBERP <expression>

   <expression> can be any REDUCE scalar expression.

examples:

     ____________________________________________________________
     
     cc := 15.3;
     
       CC := 15.3
     
     
     if numberp(cc) then write "number" else write "nonnumber";
     
     
       number
     
     
     if numberp(cb) then write "number" else write "nonnumber";
     
     
       nonnumber
     
     ____________________________________________________________
   Logical operators can only be used in conditional expressions, such
as

   IF ...THEN ...ELSE  and WHILE ...DO .


File: ..\util\r37,  Node: ORDP,  Next: PRIMEP,  Prev: NUMBERP,  Up: Boolean Operators section

   ORDP                    operator

   The ORDP logical operator returns [*note TRUE::.] if its first
argument is ordered ahead of its second argument in canonical internal
ordering, or is identical to it.

syntax:

   ORDP (<expression1>,<expression2>)

   <expression1> and <expression2> can be any valid REDUCE scalar
expression.

examples:

     ____________________________________________________________
     
     if ordp(x**2 + 1,x**3 + 3) then write "yes" else write "no";
     
     
     
       no
     
     
     if ordp(101,100) then write "yes" else write "no";
     
     
     
       yes
     
     
     if ordp(x,x) then write "yes" else write "no";
     
     
     
       yes
     
     ____________________________________________________________
   Logical operators can only be used in conditional expressions, such
as

   IF ...THEN ...ELSE  and WHILE ...DO .


File: ..\util\r37,  Node: PRIMEP,  Next: TRUE,  Prev: ORDP,  Up: Boolean Operators section

   PRIMEP                    operator

syntax:

   PRIMEP (<expression>) or PRIMEP <simple_expression>

   If <expression> evaluates to a integer, PRIMEP returns [*note
TRUE::.] if <expression> is a prime number and [*note NIL::.] otherwise.
If <expression> does not have an integer value, a type error occurs.

examples:

     ____________________________________________________________
     
     if primep 3 then write "yes" else write "no";
     
     
       YES
     
     
     if primep a then 1;
     
       ***** A invalid as integer
     
     ____________________________________________________________


File: ..\util\r37,  Node: TRUE,  Prev: PRIMEP,  Up: Boolean Operators section

   TRUE

   Any value of the boolean part of a logical expression which is
neither [*note NIL::.]  nor 0 is considered as TRUE . Most builtin test
and compare functions return [*note T::.] for TRUE and [*note NIL::.]
for FALSE .

examples:

     ____________________________________________________________
     
     if member(3,{1,2,3}) then 1 else -1;
     
     
       1
     
     
     if floor(1.7) then 1 else -1;
     
       1
     
     
     if floor(0.7) then 1 else -1;
     
       -1
     
     ____________________________________________________________


File: ..\util\r37,  Node: Boolean Operators section,  Next: General Commands section,  Prev: Arithmetic Operations section,  Up: Top

   Boolean Operators section

* Menu:

* boolean value::           concept
* EQUAL::                   operator
* EVENP::                   operator
* false::                   concept
* FREEOF::                  operator
* LEQ::                     operator
* LESSP::                   operator
* MEMBER::                  operator
* NEQ::                     operator
* NOT::                     operator
* NUMBERP::                 operator
* ORDP::                    operator
* PRIMEP::                  operator
* TRUE::                    concept


File: ..\util\r37,  Node: BYE,  Next: CONT,  Up: General Commands section

   BYE                    command

   The BYE command ends the REDUCE session, returning control to the
program (e.g., the operating system) that called REDUCE. When you are at
the top level, the BYE command exits REDUCE. QUIT is a synonym for BYE .


File: ..\util\r37,  Node: CONT,  Next: DISPLAY,  Prev: BYE,  Up: General Commands section

   CONT                    command

   The command CONT returns control to an interactive file after a
[*note PAUSE::.]  command that has been answered with N .

examples:

     ____________________________________________________________
     ____________________________________________________________
   Suppose you are in the middle of an interactive file.
     ____________________________________________________________
     
     
     
     
       factorize(x**2 + 17*x + 60);
     
     
     
     
       {{X + 12,1},{X + 5,1}}
     
     
        pause;
     
       Cont? (Y or N)
     
     
     n
     
     saveas results;
     
     factor1 := first results;
     
       FACTOR1 := {X + 12,1}
     
     
     factor2 := second results;
     
       FACTOR2 := {X + 5,1}
     
     
     cont;
     ____________________________________________________________
    the file resumes
     ____________________________________________________________
     
     
     ____________________________________________________________

   A [*note PAUSE::.] allows you to enter your own REDUCE commands,
change switch values, inquire about results, or other such activities.
When you wish to resume operation of the interactive file, use CONT .


File: ..\util\r37,  Node: DISPLAY,  Next: LOAD_PACKAGE,  Prev: CONT,  Up: General Commands section

   DISPLAY                    command

   When given a numeric argument <n>, DISPLAY prints the <n> most
recent input statements, identified by prompt numbers. If an empty pair
of parentheses is given, or if <n> is greater than the current number
of statements, all the input statements since the beginning of the
session are printed.

syntax:

   DISPLAY (<n>) or DISPLAY ()

   <n> should be a positive integer. However, if it is a real number,
the truncated integer value is used, and if a non-numeric argument is
used, all the input statements are printed.

   The statements are displayed in upper case, with lines split at
semicolons or dollar signs, as they are in editing. If long files have
been input during the session, the DISPLAY command is slow to format
these for printing.


File: ..\util\r37,  Node: LOAD_PACKAGE,  Next: PAUSE,  Prev: DISPLAY,  Up: General Commands section

   LOAD_PACKAGE                    command

   The LOAD_PACKAGE command is used to load REDUCE packages, such as
GENTRAN  that are not automatically loaded by the system.

syntax:

   LOAD_PACKAGE " <package_name>"

   A package is only loaded once; subsequent calls of LOAD_PACKAGE for
the same package name are ignored.


File: ..\util\r37,  Node: PAUSE,  Next: QUIT,  Prev: LOAD_PACKAGE,  Up: General Commands section

   PAUSE                    command

   The PAUSE command, given in an interactive file, stops operation and
asks if you want to continue or not.

examples:

     ____________________________________________________________
     ____________________________________________________________
   An interactive file is running, and at some point you see the
question
     ____________________________________________________________
     
     
                                        Cont? (Y or N)
     ____________________________________________________________
   If you type
     ____________________________________________________________
     
     
     y(Key){Return}
     ____________________________________________________________
   the file continues to run until the next pause or the end.
     ____________________________________________________________
     
     ____________________________________________________________
   If you type
     ____________________________________________________________
     
     
     n(Key){Return}
     ____________________________________________________________
   you will get a numbered REDUCE prompt, and be allowed to enter and
execute any REDUCE statements. If you later wish to continue with the
file, type
     ____________________________________________________________
     
     
     cont;
     ____________________________________________________________
   and the file resumes.
     ____________________________________________________________
     ____________________________________________________________

   To use PAUSE in your own interactive files, type

   PAUSE; in the file wherever you want it.

   PAUSE does not allow you to continue without typing either Y or N .
Its use is to slow down scrolling of interactive files, or to let you
change parameters or switch settings for the calculations.

   If you have stopped an interactive file at a PAUSE, and do not wish
to resume the file, type END; . This does not end the REDUCE session,
but stops input from the file. A second END; ends the REDUCE session.
However, if you have pauses from more than one file stacked up, an END;
brings you back to the top level, not the file directly above.

   A PAUSE typed from the terminal has no effect.


File: ..\util\r37,  Node: QUIT,  Next: RECLAIM,  Prev: PAUSE,  Up: General Commands section

   QUIT                    command

   The QUIT command ends the REDUCE session, returning control to the
program (e.g., the operating system) that called REDUCE. When you are at
the top level, the QUIT command exits REDUCE. [*note BYE::.] is a
synonym for QUIT .


File: ..\util\r37,  Node: RECLAIM,  Next: REDERR,  Prev: QUIT,  Up: General Commands section

   RECLAIM                    operator

   REDUCE's memory is in a storage structure called a heap. As REDUCE
statements execute, chunks of memory are used up. When these chunks are
no longer needed, they remain idle. When the memory is almost full, the
system executes a garbage collection, reclaiming space that is no
longer needed, and putting all the free space at one end. Depending on
the size of the image REDUCE is using, garbage collection needs to be
done more or less often. A larger image means fewer but longer garbage
collections.  Regardless of memory size, if you ask REDUCE to do
something ridiculous, like FACTORIAL(2000) , it may garbage collect
many times.


File: ..\util\r37,  Node: REDERR,  Next: RETRY,  Prev: RECLAIM,  Up: General Commands section

   REDERR                    command

   The REDERR command allows you to print an error message from inside
a [*note PROCEDURE::.] or a [*note block::.] statement.  The
calculation is gracefully terminated.

syntax:

   REDERR <message>

   <message> is an error message, usually inside double quotation marks
(a [*note STRING::.] ).

examples:

     ____________________________________________________________
     
     procedure fac(n);
        if not (fixp(n) and n>=0)
          then  rederr "Choose nonneg. integer only"
         else for i := 0:n-1 product i+1;
     
     
       fac
     
     
     fac a;
     
                ***** Choose nonneg. integer only
     
     
     fac 5;
     
       120
     
     ____________________________________________________________
   The above procedure finds the factorial of its argument.  If n is
not a positive integer or 0, an error message is returned.

   If your procedure is executed in a file, the usual error message is
printed, followed by CONT? (Y OR N) , just as any other error does from
a file. Although the procedure is gracefully terminated, any switch
settings or variable assignments you made before the error occurred are
not undone. If you need to clean up such items before exiting, use a
group statement, with the REDERR  command as its last statement.


File: ..\util\r37,  Node: RETRY,  Next: SAVEAS,  Prev: REDERR,  Up: General Commands section

   RETRY                    command

   The RETRY command allows you to retry the latest statement that
resulted in an error message.

examples:

     ____________________________________________________________
     
     matrix a;
     
     det a;
     
       ***** Matrix A not set
     
     
     a := mat((1,2),(3,4));
     
       A(1,1) := 1
       A(1,2) := 2
       A(2,1) := 3
       A(2,2) := 4
     
     
     retry;
     
       -2
     
     ____________________________________________________________
   RETRY remembers only the most recent statement that resulted in an
error message. It allows you to stop and fix something obvious, then
continue on your way without retyping the original command.


File: ..\util\r37,  Node: SAVEAS,  Next: SHOWTIME,  Prev: RETRY,  Up: General Commands section

   SAVEAS                    command

   The SAVEAS command saves the current workspace under the name of its
argument.

syntax:

   SAVEAS <identifier>

   <identifier> can be any valid REDUCE identifier.

examples:

     ____________________________________________________________
     ____________________________________________________________
   (The numbered prompts are shown below, unlike in most examples)
     ____________________________________________________________
     
     
     1: solve(x^2-3);
     
       {x=sqrt(3),x= - sqrt(3)}
     
     
     2: saveas rts(0)$
     
     3: rts(0);
     
       {x=sqrt(3),x= - sqrt(3)}
     
     ____________________________________________________________

   SAVEAS works only for the current workspace, the last algebraic
expression produced by REDUCE. This allows you to save a result that you
did not assign to an identifier when you originally typed the input.
For access to previous output use [*note WS::.] .


File: ..\util\r37,  Node: SHOWTIME,  Next: WRITE,  Prev: SAVEAS,  Up: General Commands section

   SHOWTIME                    command

   The SHOWTIME command prints the elapsed system time since the last
call of this command or since the beginning of the session, if it has
not been called before.

examples:

     ____________________________________________________________
     
     showtime;
     
       Time: 1020 ms
     
     
     factorize(x^4 - 8x^4 + 8x^2 - 136x - 153);
     
     
     
               2
       {X - 9,X  + 17,X + 1}
     
     
     showtime;
     
       Time: 920 ms
     
     ____________________________________________________________
   The time printed is either the elapsed cpu time or the elapsed wall
clock time, depending on your system. SHOWTIME allows you to see the
system time resources REDUCE uses in its calculations. Your time
readings will of course vary from this example according to the system
you use.


File: ..\util\r37,  Node: WRITE,  Prev: SHOWTIME,  Up: General Commands section

   WRITE                    command

   The WRITE command explicitly writes its arguments to the output
device (terminal or file).

syntax:

   WRITE <item>,<item>*

   <item> can be an expression, an assignment or a [*note STRING::.]
enclosed in double quotation marks (" ).

examples:

     ____________________________________________________________
     
     write a, sin x, "this is a string";
     
     
       ASIN(X)this is a string
     
     
     write a," ",sin x," this is a string";
     
     
       A SIN(X) this is a string
     
     
     if not numberp(a) then write "the symbol ",a;
     
     
     
       the symbol A
     
     
     array m(10);
     
     for i := 1:5 do write m(i) := 2*i;
     
     
       M(1) := 2
       M(2) := 4
       M(3) := 6
       M(4) := 8
       M(5) := 10
     
     
     m(4);
     
       8
     
     ____________________________________________________________
   The items specified by a single WRITE statement print on a single
line unless they are too long. A printed line is always ended with a
carriage return, so the next item printed starts a new line.

   When an assignment statement is printed, the assignment is also
made. This allows you to get feedback on filling slots in an array with
a [*note FOR::.]  statement, as shown in the last example above.


File: ..\util\r37,  Node: General Commands section,  Next: Algebraic Operators section,  Prev: Boolean Operators section,  Up: Top

   General Commands section

* Menu:

* BYE::                     command
* CONT::                    command
* DISPLAY::                 command
* LOAD_PACKAGE::           command
* PAUSE::                   command
* QUIT::                    command
* RECLAIM::                 operator
* REDERR::                  command
* RETRY::                   command
* SAVEAS::                  command
* SHOWTIME::                command
* WRITE::                   command


File: ..\util\r37,  Node: APPEND,  Next: ARBINT,  Up: Algebraic Operators section

   APPEND                    operator

   The APPEND operator constructs a new [*note LIST::.] from the
elements of its two arguments (which must be lists).

syntax:

   APPEND (<list>,<list>)

   <list> must be a list, though it may be the empty list ([] ).  Any
arguments beyond the first two are ignored.

examples:

     ____________________________________________________________
     
     alist := {1,2,{a,b}};
     
       ALIST := {1,2,{A,B}}
     
     
     blist := {3,4,5,sin(y)};
     
       BLIST := {3,4,5,SIN(Y)}
     
     
     append(alist,blist);
     
       {1,2,{A,B},3,4,5,SIN(Y)}
     
     
     append(alist,{});
     
       {1,2,{A,B}}
     
     
     append(list z,blist);
     
       {Z,3,4,5,SIN(Y)}
     
     ____________________________________________________________
   The new list consists of the elements of the second list appended to
the elements of the first list. You can APPEND new elements to the
beginning or end of an existing list by putting the new element in a
list (use curly braces or the operator LIST ). This is particularly
helpful in an iterative loop.


File: ..\util\r37,  Node: ARBINT,  Next: ARBCOMPLEX,  Prev: APPEND,  Up: Algebraic Operators section

   ARBINT                    operator

   The operator ARBINT is used to express arbitrary integer parts of an
expression, e.g. in the result of [*note SOLVE::.] when [*note
ALLBRANCH::.]  is on.

examples:

     ____________________________________________________________
     
     
     solve(log(sin(x+3)),x);
     
       {X=2*ARBINT(1)*PI - ASIN(1) - 3,
        X=2*ARBINT(1)*PI + ASIN(1) + PI - 3}
     
     ____________________________________________________________


File: ..\util\r37,  Node: ARBCOMPLEX,  Next: ARGLENGTH,  Prev: ARBINT,  Up: Algebraic Operators section

   ARBCOMPLEX                    operator

   The operator ARBCOMPLEX is used to express arbitrary scalar parts of
an expression, e.g. in the result of [*note SOLVE::.] when the solution
is parametric in one of the variable.

examples:

     ____________________________________________________________
     
     
     solve({x+3=y-2z,y-3x=0},{x,y,z});
     
     
          2*ARBCOMPLEX(1) + 3
       {X=-------------------,
                   2
           3*ARBCOMPLEX(1) + 3
         Y=-------------------,
                    2
         Z=ARBCOMPLEX(1)}
     
     ____________________________________________________________


File: ..\util\r37,  Node: ARGLENGTH,  Next: COEFF,  Prev: ARBCOMPLEX,  Up: Algebraic Operators section

   ARGLENGTH                    operator

   The operator ARGLENGTH returns the number of arguments of the
top-level operator in its argument.

syntax:

   ARGLENGTH (<expression>)

   <expression> can be any valid REDUCE algebraic expression.

examples:

     ____________________________________________________________
     
     arglength(a + b + c + d);
     
       4
     
     
     arglength(a/b/c);
     
       2
     
     
     arglength(log(sin(df(r**3*x,x))));
     
     
       1
     
     ____________________________________________________________
   In the first example, + is an n-ary operator, so the number of terms
is returned. In the second example, since / is a binary operator, the
argument is actually (a/b)/c, so there are two terms at the top level.
In the last example, no matter how deeply the operators are nested,
there is still only one argument at the top level.


File: ..\util\r37,  Node: COEFF,  Next: COEFFN,  Prev: ARGLENGTH,  Up: Algebraic Operators section

   COEFF                    operator

   The COEFF operator returns the coefficients of the powers of the
specified variable in the given expression, in a [*note LIST::.] .

syntax:

   COEFF (<expression>, <variable>)

   <expression> is expected to be a polynomial expression, not a
rational expression. Rational expressions are accepted when the switch
[*note RATARG::.]  is on. <variable> must be a kernel. The results are
returned in a list.

examples:

     ____________________________________________________________
     
     coeff((x+y)**3,x);
     
         3     2
       {Y  ,3*Y  ,3*Y,1}
     
     
     coeff((x+2)**4 + sin(x),x);
     
       {SIN(X) + 16,32,24,8,1}
     
     
     high_pow;
     
       4
     
     
     low_pow;
     
       0
     
     
     ab := x**9 + sin(x)*x**7 + sqrt(y);
     
     
     
                               7     9
       AB := SQRT(Y) + SIN(X)*X   + X
     
     
     coeff(ab,x);
     
       {SQRT(Y),0,0,0,0,0,0,SIN(X),0,1}
     
     ____________________________________________________________
   The variables [*note HIGH_POW::.] and [*note LOW_POW::.] are set to
the highest and lowest powers of the variable, respectively, appearing
in the expression.

   The coefficients are put into a list, with the coefficient of the
lowest (constant) term first. You can use the usual list access methods
(FIRST , SECOND , THIRD , REST , LENGTH , and PART ) to extract them.
If a power does not appear in the expression, the corresponding element
of the list is zero. Terms involving functions of the specified
variable but not including powers of it (for example in the expression
X**4 + 3*X**2 + TAN(X) ) are placed in the constant term.

   Since the COEFF command deals with the expanded form of the
expression, you may get unexpected results when [*note EXP::.] is off,
or when [*note FACTOR::.]  or [*note IFACTOR::.] are on.

   If you want only a specific coefficient rather than all of them, use
the [*note COEFFN::.]  operator.


File: ..\util\r37,  Node: COEFFN,  Next: CONJ,  Prev: COEFF,  Up: Algebraic Operators section

   COEFFN                    operator

   The COEFFN operator takes three arguments: an expression, a kernel,
and a non-negative integer. It returns the coefficient of the kernel to
that integer power, appearing in the expression.

syntax:

   COEFFN (<expression>,<kernel>,<integer>)

   <expression> must be a polynomial, unless [*note RATARG::.] is on
which allows rational expressions. <kernel> must be a kernel, and
<integer> must be a non-negative integer.

examples:

     ____________________________________________________________
     
     
     ff := x**7 + sin(y)*x**5 + y**4 + x + 7;
     
     
                     5     7         4
       FF := SIN(Y)*X   + X   + X + Y   + 7
     
     
     coeffn(ff,x,5);
     
       SIN(Y)
     
     
     coeffn(ff,z,3);
     
       0
     
     
     coeffn(ff,y,0);
     
               5     7
       SIN(Y)*X   + X   + X + 7
     
     
     
     rr := 1/y**2+y**3+sin(y);
     
                     2     5
             SIN(Y)*Y   + Y   + 1
       RR := --------------------
                       2
                      Y
     
     
     on ratarg;
     
     
     coeffn(rr,y,-2);
     
       ***** -2 invalid as COEFFN index
     
     
     
     coeffn(rr,y,5);
     
       1
       ---
        2
       Y
     
     ____________________________________________________________
   If the given power of the kernel does not appear in the expression,
COEFFN  returns 0. Negative powers are never detected, even if they
appear in the expression and [*note RATARG::.] are on. COEFFN with an
integer argument of 0 returns any terms in the expression that do not
contain the given kernel.


File: ..\util\r37,  Node: CONJ,  Next: CONTINUED_FRACTION,  Prev: COEFFN,  Up: Algebraic Operators section

   CONJ                    operator

syntax:

   CONJ (<expression>) or CONJ <simple_expression>

   This operator returns the complex conjugate of an expression, if that
argument has an numerical value. A non-numerical argument is returned as
an expression in the operators [*note REPART::.] and [*note IMPART::.] .

examples:

     ____________________________________________________________
     
     conj(1+i);
     
       1-I
     
     
     conj(a+i*b);
     
       REPART(A) - REPART(B)*I - IMPART(A)*I - IMPART(B)
     
     ____________________________________________________________


File: ..\util\r37,  Node: CONTINUED_FRACTION,  Next: DECOMPOSE,  Prev: CONJ,  Up: Algebraic Operators section

   CONTINUED_FRACTION                    operator

syntax:

   CONTINUED_FRACTION (<num>) or CONTINUED_FRACTION ( <num>,<size>)

   This operator approximates the real number <num> ( [*note
RATIONAL::.] number, [*note ROUNDED::.] number) into a continued
fraction. The result is a list of two elements: the first one is the
rational value of the approximation, the second one is the list of
terms of the continued fraction which represents the same value
according to the definition T0 +1/(T1 + 1/(T2 + ...)) .  Precision: the
second optional parameter <size> is an upper bound for the absolute
value of the result denominator. If omitted, the approximation is
performed up to the current system precision.

examples:

     ____________________________________________________________
     
     continued_fraction pi;
     
     
        1146408
       {-------,{3,7,15,1,292,1,1,1,2,1}}
        364913
     
     
     continued_fraction(pi,100);
     
     
        22
       {--,{3,7}}
        7
     
     ____________________________________________________________


File: ..\util\r37,  Node: DECOMPOSE,  Next: DEG,  Prev: CONTINUED_FRACTION,  Up: Algebraic Operators section

   DECOMPOSE                    operator

   The DECOMPOSE operator takes a multivariate polynomial as argument,
and returns an expression and a [*note LIST::.] of [*note EQUATION::.]
s from which the original polynomial can be found by composition.

syntax:

   DECOMPOSE (<expression>) or DECOMPOSE  <simple_expression>

examples:

     ____________________________________________________________
     
     decompose(x^8-88*x^7+2924*x^6-43912*x^5+263431*x^4-
               218900*x^3+65690*x^2-7700*x+234)
     
     
     
        2                  2            2
       U  + 35*U + 234, U=V  + 10*V, V=X  - 22*X
     
     
          decompose(u^2+v^2+2u*v+1)
     
        2
       W   + 1, W=U + V
     
     ____________________________________________________________
   Unlike factorization, this decomposition is not unique. Further
details can be found in V.S. Alagar, M.Tanh, <Fast Polynomial
Decomposition>, Proc. EUROCAL 1985, pp 150-153 (Springer) and J. von zur
Gathen, <Functional> <Decomposition of Polynomials: the Tame Case>, J.
Symbolic Computation (1990) 9, 281-299.


File: ..\util\r37,  Node: DEG,  Next: DEN,  Prev: DECOMPOSE,  Up: Algebraic Operators section

   DEG                    operator

   The operator DEG returns the highest degree of its variable argument
found in its expression argument.

syntax:

   DEG (<expression>,<kernel>)

   <expression> is expected to be a polynomial expression, not a
rational expression. Rational expressions are accepted when the switch
[*note RATARG::.]  is on. <variable> must be a [*note KERNEL::.] . The
results are returned in a list.

examples:

     ____________________________________________________________
     
     
     deg((x+y)**5,x);
     
       5
     
     
     
     deg((a+b)*(c+2*d)**2,d);
     
       2
     
     
     
     deg(x**2 + cos(y),sin(x));
     
     
     deg((x**2 + sin(x))**5,sin(x));
     
       5
     
     ____________________________________________________________


File: ..\util\r37,  Node: DEN,  Next: DF,  Prev: DEG,  Up: Algebraic Operators section

   DEN                    operator

   The DEN operator returns the denominator of its argument.

syntax:

   DEN (<expression>)

   <expression> is ordinarily a rational expression, but may be any
valid scalar REDUCE expression.

examples:

     ____________________________________________________________
     
     
     a := x**3 + 3*x**2 + 12*x;
     
                2
       A := X*(X   + 3*X + 12)
     
     
     
     b := 4*x*y + x*sin(x);
     
       B := X*(SIN(X) + 4*Y)
     
     
     
     den(a/b);
     
       SIN(X) + 4*Y
     
     
     
     den(aa/4 + bb/5);
     
       20
     
     
     
     den(100/6);
     
       3
     
     
     
     den(sin(x));
     
       1
     
     ____________________________________________________________
   DEN returns the denominator of the expression after it has been
simplified by REDUCE. As seen in the examples, this includes putting
sums of rational expressions over a common denominator, and reducing
common factors where possible. If the expression does not have any
other denominator, 1 is returned.

   Switch settings, such as [*note MCD::.] or [*note RATIONAL::.] ,
have an effect on the denominator of an expression.


File: ..\util\r37,  Node: DF,  Next: EXPAND_CASES,  Prev: DEN,  Up: Algebraic Operators section

   DF                    operator

   The DF operator finds partial derivatives with respect to one or
more variables.

syntax:

   DF (<expression>, <var>          [, <number>]  , <var> [ , <number>]
)

   <expression> can be any valid REDUCE algebraic expression. <var>
must be a [*note KERNEL::.] , and is the differentiation variable.
<number> must be a non-negative integer.

examples:

     ____________________________________________________________
     
     
     df(x**2,x);
     
       2*X
     
     
     
     df(x**2*y + sin(y),y);
     
                 2
       COS(Y) + X
     
     
     
     df((x+y)**10,z);
     
       0
     
     
     
     
     df(1/x**2,x,2);
     
       6
       ---
        4
       X
     
     
     
     df(x**4*y + sin(y),y,x,3);
     
       24*X
     
     
     
     for all x let df(tan(x),x) = sec(x)**2;
     
     
     df(tan(3*x),x);
     
                 2
       3*SEC(3*X)
     
     ____________________________________________________________
   An error message results if a non-kernel is entered as a
differentiation operator. If the optional number is omitted, it is
assumed to be 1.  See the declaration [*note DEPEND::.] to establish
dependencies for implicit differentiation.

   You can define your own differentiation rules, expanding REDUCE's
capabilities, using the [*note LET::.] command as shown in the last
example above. Note that once you add your own rule for differentiating
a function, it supersedes REDUCE's normal handling of that function for
the duration of the REDUCE session. If you clear the rule ([*note
CLEARRULES::.] ), you don't get back to the previous rule.


File: ..\util\r37,  Node: EXPAND_CASES,  Next: EXPREAD,  Prev: DF,  Up: Algebraic Operators section

   EXPAND_CASES                    operator

   When a [*note ROOT_OF::.] form in a result of [*note SOLVE::.] has
been converted to a [*note ONE_OF::.] form, EXPAND_CASES can be used to
convert this into form corresponding to the normal explicit results of
[*note SOLVE::.] . See [*note ROOT_OF::.] .


File: ..\util\r37,  Node: EXPREAD,  Next: FACTORIZE,  Prev: EXPAND_CASES,  Up: Algebraic Operators section

   EXPREAD                    operator

syntax:

   EXPREAD ()

   EXPREAD reads one well-formed expression from the current input
buffer and returns its value.

examples:

     ____________________________________________________________
     
     expread(); a+b;
     
       A + B
     
     ____________________________________________________________


File: ..\util\r37,  Node: FACTORIZE,  Next: HYPOT,  Prev: EXPREAD,  Up: Algebraic Operators section

   FACTORIZE                    operator

   The FACTORIZE operator factors a given expression into a list of
factor,power pairs.

syntax:

   FACTORIZE (<expression>)

   <expression> should be a polynomial, otherwise an error will result.

examples:

     ____________________________________________________________
     
     
     fff := factorize(x^3 - y^3);
     
              2          2
                       {{X  + X*Y + Y ,1},{X - Y,1}}
     
     
     fac1 := first fff;
     
                  2          2
       FAC1 := {{X  + X*Y + Y ,1}
     
     
     factorize(x^15 - 1);
     
            8    7    6    5    4
        {{ X  - X  + X  - X  + X  - X + 1,1},
          4    3    2
        {X  + X  + X  + X + 1,1},
          2
        {X  + X + 1,1},
        {X - 1,1}}
     
     
     lastone := part(ws,length ws);
     
             LASTONE := {X - 1,1}
     
     
     setmod 2;
     
       1
     
     
     on modular;
     
     factorize(x^15 - 1);
     
          4    3    2
       {{X  + X  + X  + X + 1,1},
          4    3
        {X  + X  + 1,1},
          4
        {X  + X + 1,1},
           2
        { X  + X + 1,1},
        {X + 1,1}}
     
     ____________________________________________________________
   The FACTORIZE command returns the factor,power pairs as a [*note
LIST::.] .  You can therefore use the usual list access methods ([*note
FIRST::.] , [*note SECOND::.] , [*note THIRD::.] , [*note REST::.] ,
[*note LENGTH::.] and [*note PART::.] ) to extract these pairs.

   If the <expression> given to FACTORIZE is an integer, it will be
factored into its prime components. To factor any integer factor of a
non-numerical expression, the switch [*note IFACTOR::.] should be
turned on.  Its default is off. [*note IFACTOR::.] has effect only when
factoring is explicitly done by FACTORIZE , not when factoring is
automatically done with the [*note FACTOR::.] switch. If full
factorization is not needed the switch [*note LIMITEDFACTORS::.] allows
you to reduce the computing time of calls to FACTORIZE .

   Factoring can be done in a modular domain by calling FACTORIZE when
[*note MODULAR::.]  is on. You can set the modulus with the [*note
SETMOD::.] command. The last example above shows factoring modulo 2.

   For general comments on factoring, see comments under the switch
[*note FACTOR::.] .


File: ..\util\r37,  Node: HYPOT,  Next: IMPART,  Prev: FACTORIZE,  Up: Algebraic Operators section

   HYPOT                    operator

syntax:

   hypot(<expression>,<expression>)

   If ROUNDED is on, and the two arguments evaluate to numbers, this
operator returns the square root of the sums of the squares of the
arguments in a manner that avoids intermediate overflow. In other cases,
an expression in the original operator is returned.

examples:

     ____________________________________________________________
     
     hypot(3,4);
     
       HYPOT(3,4)
     
     
     on rounded;
     
     ws;
     
       5.0
     
     
     hypot(a,b);
     
       HYPOT(A,B)
     
     ____________________________________________________________


File: ..\util\r37,  Node: IMPART,  Next: INT,  Prev: HYPOT,  Up: Algebraic Operators section

   IMPART                    operator

syntax:

   IMPART (<expression>) or IMPART <simple_expression>

   This operator returns the imaginary part of an expression, if that
argument has an numerical value. A non-numerical argument is returned as
an expression in the operators [*note REPART::.] and IMPART .

examples:

     ____________________________________________________________
     
     impart(1+i);
     
       1
     
     
     impart(a+i*b);
     
       REPART(B) + IMPART(A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: INT,  Next: INTERPOL,  Prev: IMPART,  Up: Algebraic Operators section

   INT                    operator

   The INT operator performs analytic integration on a variety of
functions.

syntax:

   INT (<expression>,<kernel>)

   <expression> can be any scalar expression. involving polynomials, log
functions, exponential functions, or tangent or arctangent expressions.
INT  attempts expressions involving error functions, dilogarithms and
other trigonometric expressions. Integrals involving algebraic
extensions (such as square roots) may not succeed. <kernel> must be a
REDUCE [*note KERNEL::.] .

examples:

     ____________________________________________________________
     
     int(x**3 + 3,x);
     
           3
       X*(X  + 12)
       -----------
            4
     
     
     
     int(sin(x)*exp(2*x),x);
     
     
          2*X
         E   *(COS(X) - 2*SIN(X))
       - ------------------------
                    5
     
     
     int(1/(x^2-2),x);
     
     
       SQRT(2)*(LOG( - SQRT(2) + X) - LOG(SQRT(2) + X))
       ------------------------------------------------
                              4
     
     
     int(sin(x)/(4 + cos(x)**2),x);
     
     
              COS(X)
         ATAN(------)
                2
       - ------------
              2
     
     
     
     int(1/sqrt(x^2-x),x);
     
           SQRT(X)*SQRT(X - 1)
       INT(-------------------,X)
                   2
                  X -X
     
     ____________________________________________________________
   Note that REDUCE couldn't handle the last integral with its default
integrator, since the integrand involves a square root. However, the
integral can be found using the [*note ALGINT::.] package.
Alternatively, you could add a rule using the [*note LET::.] statement
to evaluate this integral.

   The arbitrary constant of integration is not shown. Definite
integrals can be found by evaluating the result at the limits of
integration (use [*note ROUNDED::.] ) and subtracting the lower from
the higher. Evaluation can be easily done by the [*note SUB::.]
operator.

   When INT cannot find an integral it returns an expression involving
formal INT expressions unless the switch [*note FAILHARD::.]  has been
set. If not all of the expression can be integrated, the switch [*note
NOLNR::.] controls whether a partially integrated result should be
returned or not.


File: ..\util\r37,  Node: INTERPOL,  Next: LCOF,  Prev: INT,  Up: Algebraic Operators section

   INTERPOL                    operator

   INTERPOL  generates an interpolation polynomial.

syntax:

   interpol(<values>,<variable>,<points>)

   <values> and <points> are [*note LIST::.] s of equal length and
<variable> is an algebraic expression (preferably a [*note KERNEL::.] ).
The interpolation polynomial is generated in the given variable of
degree length(<values>)-1. The unique polynomial F is defined by the
property that for corresponding elements V of <values> and P  of
<points> the relation F(P)=V holds.

examples:

     ____________________________________________________________
     
     f := for i:=1:4 collect(i**3-1);
     
       F := 0,7,26,63
     
     
     p := {1,2,3,4};
     
       P := 1,2,3,4
     
     
     interpol(f,x,p);
     
        3
       X  - 1
     
     ____________________________________________________________
   The Aitken-Neville interpolation algorithm is used which guarantees a
stable result even with rounded numbers and an ill-conditioned problem.


File: ..\util\r37,  Node: LCOF,  Next: LENGTH,  Prev: INTERPOL,  Up: Algebraic Operators section

   LCOF                    operator

   The LCOF operator returns the leading coefficient of a given
expression with respect to a given variable.

syntax:

   LCOF (<expression>,<kernel>)

   <expression> is ordinarily a polynomial. If [*note RATARG::.] is on,
a rational expression may also be used, otherwise an error results.
<kernel> must be a [*note KERNEL::.] .

examples:

     ____________________________________________________________
     
     lcof((x+2*y)**5,y);
     
       32
     
     
     lcof((x + y*sin(x))**2 + cos(x)*sin(x)**2,sin(x));
     
     
     
             2
       COS(X)  + Y
     
     
     lcof(x**2 + 3*x + 17,y);
     
        2
       X  + 3*X + 17
     
     ____________________________________________________________
   If the kernel does not appear in the expression, LCOF returns the
expression.


File: ..\util\r37,  Node: LENGTH,  Next: LHS,  Prev: LCOF,  Up: Algebraic Operators section

   LENGTH                    operator

   The LENGTH operator returns the number of items in a [*note LIST::.]
, the number of terms in an expression, or the dimensions of an array
or matrix.

syntax:

   LENGTH (<expr>) or LENGTH <expr>

   <expr> can be a list structure, an array, a matrix, or a scalar
expression.

examples:

     ____________________________________________________________
     
     alist := {a,b,{ww,xx,yy,zz}};
     
       ALIST := {A,B,{WW,XX,YY,ZZ}}
     
     
     length alist;
     
       3
     
     
     length third alist;
     
       4
     
     
     dlist := {d};
     
       DLIST := {D}
     
     
     length rest dlist;
     
       0
     
     
     matrix mmm(4,5);
     
     length mmm;
     
       {4,5}
     
     
     array aaa(5,3,2);
     
     length aaa;
     
       {6,4,3}
     
     
     eex := (x+3)**2/(x-y);
     
               2
              X  + 6*X + 9
       EEX := ------------
                 X - Y
     
     
     length eex;
     
       5
     
     ____________________________________________________________
   An item in a list that is itself a list only counts as one item. An
error message will be printed if LENGTH is called on a matrix which has
not had its dimensions set. The LENGTH of an array includes the zeroth
element of each dimension, showing the full number of elements
allocated. (Declaring an array A with n elements allocates
A(0),A(1),...,A(n).) The LENGTH  of an expression is the total number
of additive terms appearing in the numerator and denominator of the
expression. Note that subtraction of a term is represented internally
as addition of a negative term.


File: ..\util\r37,  Node: LHS,  Next: LIMIT,  Prev: LENGTH,  Up: Algebraic Operators section

   LHS                    operator

   The LHS operator returns the left-hand side of an [*note
EQUATION::.] , such as those returned in a list by [*note SOLVE::.] .

syntax:

   LHS (<equation>) or LHS <equation>

   <equation> must be an equation of the form

   LEFT-HAND SIDE = RIGHT-HAND SIDE .

examples:

     ____________________________________________________________
     
     polly := (x+3)*(x^4+2x+1);
     
                 5      4      2
       POLLY := X  + 3*X  + 2*X  + 7*X + 3
     
     
     pollyroots := solve(polly,x);
     
       POLLYROOTS := {X=ROOT F(X3 - X2 + X + 1,X ,
                            O                   )
                      X=-1,
                      X=-3}
     
     
     variable := lhs first pollyroots;
     
       VARIABLE := X
     
     ____________________________________________________________


File: ..\util\r37,  Node: LIMIT,  Next: LPOWER,  Prev: LHS,  Up: Algebraic Operators section

   LIMIT                    operator

   LIMITS is a fast limit package for REDUCE for functions which are
continuous except for computable poles and singularities, based on some
earlier work by Ian Cohen and John P. Fitch. The Truncated Power Series
package is used for non-critical points, at which the value of the
function is the constant term in the expansion around that point.
l'Hopital's rule is used in critical cases, with preprocessing of 1-1
forms and reformatting of product forms in order to apply l'Hopital's
rule. A limited amount of bounded arithmetic is also employed where
applicable.

syntax:

   LIMIT (<expr>,<var>,<limpoint>) or

   LIMIT!+ (<expr>,<var>,<limpoint>) or

   LIMIT!- (<expr>,<var>,<limpoint>)

   where <expr> is an expression depending of the variable <var> (a
[*note KERNEL::.] ) and <limpoint> is the limit point.  If the limit
depends upon the direction of approach to the <limpoint>, the operators
LIMIT!+ and LIMIT!- may be used.

examples:

     ____________________________________________________________
     
     limit(x*cot(x),x,0);
     
       0
     
     
     limit((2x+5)/(3x-2),x,infinity);
     
       2
       --
       3
     
     ____________________________________________________________


File: ..\util\r37,  Node: LPOWER,  Next: LTERM,  Prev: LIMIT,  Up: Algebraic Operators section

   LPOWER                    operator

   The LPOWER operator returns the leading power of an expression with
respect to a kernel. 1 is returned if the expression does not depend on
the kernel.

syntax:

   LPOWER (<expression>,<kernel>)

   <expression> is ordinarily a polynomial. If [*note RATARG::.] is on,
a rational expression may also be used, otherwise an error results.
<kernel> must be a [*note KERNEL::.] .

examples:

     ____________________________________________________________
     
     lpower((x+2*y)**6,y);
     
        6
       Y
     
     
     lpower((x + cos(x))**8 + df(x**2,x),cos(x));
     
     
     
             8
       COS(X)
     
     
     lpower(x**3 + 3*x,y);
     
       1
     
     ____________________________________________________________


File: ..\util\r37,  Node: LTERM,  Next: MAINVAR,  Prev: LPOWER,  Up: Algebraic Operators section

   LTERM                    operator

   The LTERM operator returns the leading term of an expression with
respect to a kernel. The expression is returned if it does not depend on
the kernel.

syntax:

   LTERM (<expression>,<kernel>)

   <expression> is ordinarily a polynomial. If [*note RATARG::.] is on,
a rational expression may also be used, otherwise an error results.
<kernel> must be a [*note KERNEL::.] .

examples:

     ____________________________________________________________
     
     lterm((x+2*y)**6,y);
     
           6
       64*Y
     
     
     lterm((x + cos(x))**8 + df(x**2,x),cos(x));
     
     
     
             8
       COS(X)
     
     
     lterm(x**3 + 3*x,y);
     
        3
       X  + 3X
     
     ____________________________________________________________


File: ..\util\r37,  Node: MAINVAR,  Next: MAP,  Prev: LTERM,  Up: Algebraic Operators section

   MAINVAR                    operator

   The MAINVAR operator returns the main variable (in the system's
internal representation) of its argument.

syntax:

   MAINVAR (<expression>)

   <expression> is usually a polynomial, but may be any valid REDUCE
scalar expression. In the case of a rational function, the main variable
of the numerator is returned. The main variable returned is a [*note
KERNEL::.] .

examples:

     ____________________________________________________________
     
     test := (a + b + c)**2;
     
                2                    2            2
       TEST := A  + 2*A*B + 2*A*C + B  + 2*B*C + C
     
     
     mainvar(test);
     
       A
     
     
     korder c,b,a;
     
     mainvar(test);
     
       C
     
     
     mainvar(2*cos(x)**2);
     
       COS(X)
     
     
     mainvar(17);
     
       0
     
     ____________________________________________________________
   The main variable is the first variable in the canonical ordering of
kernels. Generally, alphabetically ordered functions come first, then
alphabetically ordered identifiers (variables). Numbers come last, and
as far as MAINVAR is concerned belong in the family 0 . The canonical
ordering can be changed by the declaration [*note KORDER::.] , as shown
above.


File: ..\util\r37,  Node: MAP,  Next: MKID,  Prev: MAINVAR,  Up: Algebraic Operators section

   MAP                    operator

   The MAP operator applies a uniform evaluation pattern to all members
of a composite structure: a [*note MATRIX::.] , a [*note LIST::.] or
the arguments of an [*note OPERATOR::.] expression.  The evaluation
pattern can be a unary procedure, an operator, or an algebraic
expression with one free variable.

syntax:

   MAP (<function>,<object>)

   <object> is a list, a matrix or an operator expression.

   <function> is the name of an operator for a single argument: the
operator is evaluated once with each element of <object> as its single
argument,

   or an algebraic expression with exactly one [*note Free Variable::.]
, that is a variable preceded by the tilde symbol: the expression  is
evaluated for each element of <object> where the element is
substituted for the free variable,

   or a replacement [*note RULE::.] of the form

syntax:

   VAR => REP

   where <var> is a variable (a <kernel> without subscript)  and <rep>
is an expression which contains <var>.   Here REP is evaluated for each
element of <object> where  the element is substituted for VAR . VAR may
be  optionally preceded by a tilde.

   The rule form for <function> is needed when more than one free
variable occurs.

examples:

     ____________________________________________________________
     
     map(abs,{1,-2,a,-a});
     
       1,2,abs(a),abs(a)
     
     
     map(int(~w,x), mat((x^2,x^5),(x^4,x^5)));
     
     
               [  3     6 ]
               [ x     x  ]
               [----  ----]
               [ 3     6  ]
               [          ]
               [  5     6 ]
               [ x     x  ]
               [----  ----]
             [ 5     6  ]
     
     
     map(~w*6, x^2/3 = y^3/2 -1);
     
          2     3
       2*x =3*(y -2)
     
     ____________________________________________________________
   You can use MAP in nested expressions. It is not allowed to apply
MAP for a non-composed object, e.g. an identifier or a number.


File: ..\util\r37,  Node: MKID,  Next: NPRIMITIVE,  Prev: MAP,  Up: Algebraic Operators section

   MKID                    command

   The MKID command constructs an identifier, given a stem and an
identifier or an integer.

syntax:

   MKID (<stem>,<leaf>)

   <stem> can be any valid REDUCE identifier that does not include
escaped special characters. <leaf> may be an integer, including one
given by a local variable in a [*note FOR::.] loop, or any other legal
group of characters.

examples:

     ____________________________________________________________
     
     mkid(x,3);
     
       X3
     
     
     factorize(x^15 - 1);
     
       {X - 1,
         2
        X  + X + 1,
         4    3    2
        X  + X  + X  + X + 1,
         8    7    5    4    3
        X  - X  + X  - X  + X   - X + 1}
     
     
     
     for i := 1:length ws do write set(mkid(f,i),part(ws,i));
     
     
     
        8    7    5    4    3
       X  - X  + X  - X  + X  - X + 1
        4    3    2
       X  + X  + X  + X + 1
        2
       X  + X + 1
       X - 1
     
     ____________________________________________________________
   You can use MKID to construct identifiers from inside procedures.
This allows you to handle an unknown number of factors, or deal with
variable amounts of data. It is particularly helpful to attach
identifiers to the answers returned by FACTORIZE and SOLVE .


File: ..\util\r37,  Node: NPRIMITIVE,  Next: NUM,  Prev: MKID,  Up: Algebraic Operators section

   NPRIMITIVE                    operator

syntax:

   NPRIMITIVE (<expression>) or NPRIMITIVE  <simple_expression>

   This operator returns the numerically-primitive part of any scalar
expression. In other words, any overall integer factors in the
expression are removed.

examples:

     ____________________________________________________________
     
     nprimitive((2x+2y)^2);
     
        2            2
       X  + 2*X*Y + Y
     
     
     nprimitive(3*a*b*c);
     
       3*A*B*C
     
     ____________________________________________________________


File: ..\util\r37,  Node: NUM,  Next: ODESOLVE,  Prev: NPRIMITIVE,  Up: Algebraic Operators section

   NUM                    operator

   The NUM operator returns the numerator of its argument.

syntax:

   NUM (<expression>) or NUM <simple_expression>

   <expression> can be any valid REDUCE scalar expression.

examples:

     ____________________________________________________________
     
     num(100/6);
     
       50
     
     
     num(a/5 + b/6);
     
       6*A + 5*B
     
     
     num(sin(x));
     
       SIN(X)
     
     ____________________________________________________________
   NUM returns the numerator of the expression after it has been
simplified by REDUCE. As seen in the examples, this includes putting
sums of rational expressions over a common denominator, and reducing
common factors where possible. If the expression is not a rational
expression, it is returned unchanged.


File: ..\util\r37,  Node: ODESOLVE,  Next: ONE_OF,  Prev: NUM,  Up: Algebraic Operators section

   ODESOLVE                    operator

   The ODESOLVE package is a solver for ordinary differential
equations. At the present time it has still limited capabilities:

   1. it can handle only a single scalar equation presented as an
algebraic expression or equation, and

   2. it can solve only first-order equations of simple types, linear
equations with constant coefficients and Euler equations.

   These solvable types are exactly those for which Lie symmetry
techniques give no useful information.

syntax:

   ODESOLVE (<expr>,<var1>,<var2>)

   <expr> is a single scalar expression such that <expr>=0 is the
ordinary differential equation (ODE for short) to be solved, or is an
equivalent [*note EQUATION::.] .

   <var1> is the name of the dependent variable, <var2> is the name of
the independent variable.

   A differential in <expr> is expressed using the [*note DF::.]
operator. Note that in most cases you must declare explicitly <var1> to
depend of <var2> using a [*note DEPEND::.] declaration - otherwise the
derivative might be evaluated to zero on input to ODESOLVE .

   The returned value is a list containing the equation giving the
general solution of the ODE (for simultaneous equations this will be a
list of equations eventually). It will contain occurrences of the
operator ARBCONST for the arbitrary constants in the general solution.
The arguments of ARBCONST should be new.  A counter !!ARBCONST is used
to arrange this.

examples:

     ____________________________________________________________
     
     depend y,x;
     
     % A first-order linear equation, with an initial condition
     
     ode:=df(y,x) + y * sin x/cos x - 1/cos x$
     
     odesolve(ode,y,x);
     
       {y=arbconst(1)*cos(x) + sin(x)}
     
     ____________________________________________________________


File: ..\util\r37,  Node: ONE_OF,  Next: PART,  Prev: ODESOLVE,  Up: Algebraic Operators section

   ONE_OF                    type

   The operator ONE_OF is used to represent an indefinite choice of one
element from a finite set of objects.

examples:

     ____________________________________________________________
     
     x=one_of{1,2,5}
     ____________________________________________________________
   this equation encodes that x can take one of the values 1,2 or 5
     ____________________________________________________________
     
     ____________________________________________________________

   REDUCE generates a ONE_OF form in cases when an implicit ROOT_OF
expression could be converted to an explicit solution set.  A ONE_OF
form can be converted to a SOLVE solution using [*note EXPAND_CASES::.]
. See [*note ROOT_OF::.] .


File: ..\util\r37,  Node: PART,  Next: PF,  Prev: ONE_OF,  Up: Algebraic Operators section

   PART                    operator

   The operator PART permits the extraction of various parts or
operators of expressions and [*note LIST::.] S .

syntax:

   PART (<expression,integer>,<integer>*)

   <expression> can be any valid REDUCE expression or a list, integer
may be an expression that evaluates to a positive or negative integer
or 0. A positive integer <n> picks up the n th term, counting from the
first term toward the end. A negative integer n picks up the n th term,
counting from the back toward the front. The integer 0 picks up the
operator (which is LIST when the expression is a [*note LIST::.] ).

examples:

     ____________________________________________________________
     
     part((x + y)**5,4);
     
           2  3
       10*X *Y
     
     
     part((x + y)**5,4,2);
     
        2
       X
     
     
     part((x + y)**5,4,2,1);
     
       X
     
     
     part((x + y)**5,0);
     
       PLUS
     
     
     part((x + y)**5,-5);
     
             4
       5*X *Y
     
     
     part((x + y)**5,4) := sin(x);
     
        5      4         3  2                 4    5
       X  + 5*X *Y + 10*X *Y  + SIN(X) + 5*X*Y  + Y
     
     
     alist := {x,y,{aa,bb,cc},x**2*sqrt(y)};
     
     
                                             2
                              ALIST := {X,Y,{AA,BB,CC},SQRT(Y)*X }
     
     
     part(alist,3,2);
     
       BB
     
     
     part(alist,4,0);
     
       TIMES
     
     ____________________________________________________________
   Additional integer arguments after the first one examine the terms
recursively, as shown above. In the third line, the fourth term is
picked from the original polynomial, 10x^2y^3, then the second term
from that, x^2, and finally the first component, x. If an integer's
absolute value is too large for the appropriate expression, a message
is given.

   PART works on the form of the expression as printed, or as it would
have been printed at that point of the calculation, bearing in mind the
current switch settings. It is important to realize that the switch
settings change the operation of PART . [*note PRI::.] must be on when
PART  is used.

   When PART is used on a polynomial expression that has minus signs,
the +  is always returned as the top-level operator. The minus is found
as a unary operator attached to the negative term.

   PART can also be used to change the relevant part of the expression
or list as shown in the sixth example line. The PART operator returns
the changed expression, though original expression is not changed. You
can also use PART to change the operator.


File: ..\util\r37,  Node: PF,  Next: PROD,  Prev: PART,  Up: Algebraic Operators section

   PF                    operator

syntax:

   pf(<expression>,<variable>)

   PF transforms <expression> into a [*note LIST::.] of partial fraction
s with respect to the main variable, <variable>. PF does a complete
partial fraction decomposition, and as the algorithms used are fairly
unsophisticated (factorization and the extended Euclidean algorithm),
the code may be unacceptably slow in complicated cases.

examples:

     ____________________________________________________________
     
     pf(2/((x+1)^2*(x+2)),x);
     
           2    -2        2
             {-----,-----,------------}
         X + 2 X + 1  2
                     X  + 2*X + 1
     
     
     off exp;
     
     pf(2/((x+1)^2*(x+2)),x);
     
     
          2    - 2     2
       {-----,-----,--------}
        X + 2 X + 1        2
                    (X + 1)
     
     
     for each j in ws sum j;
     
              2
       ----------------
                     2
       ( + 2)*(X + 1)
     
     ____________________________________________________________

   If you want the denominators in factored form, turn [*note EXP::.]
off, as shown in the second example above. As shown in the final
example, the [*note FOR::.]  EACH construct can be used to recombine
the terms.  Alternatively, one can use the operations on lists to
extract any desired term.


File: ..\util\r37,  Node: PROD,  Next: REDUCT,  Prev: PF,  Up: Algebraic Operators section

   PROD                    operator

   The operator PROD returns the indefinite or definite product of a
given expression.

syntax:

   PROD (<expr>,<k>[,<lolim> [,<uplim> ]])

   where <expr> is the expression to be multiplied, <k> is the control
variable (a [*note KERNEL::.] ), and <lolim> and <uplim> uplim are the
optional lower and upper limits. If <uplim> is not supplied the upper
limit is taken as <k>. The Gosper algorithm is used. If there is no
closed form solution, the operator returns the input unchanged.

examples:

     ____________________________________________________________
     
     prod(k/(k-2),k);
     
       k*( - k + 1)
     
     ____________________________________________________________


File: ..\util\r37,  Node: REDUCT,  Next: REPART,  Prev: PROD,  Up: Algebraic Operators section

   REDUCT                    operator

   The REDUCT operator returns the remainder of its expression after the
leading term with respect to the kernel in the second argument is
removed.

syntax:

   REDUCT (<expression>,<kernel>)

   <expression> is ordinarily a polynomial. If [*note RATARG::.] is on,
a rational expression may also be used, otherwise an error results.
<kernel> must be a [*note KERNEL::.] .

examples:

     ____________________________________________________________
     
     reduct((x+y)**3,x);
     
             2            2
       Y*(3*X  + 3*X*Y + Y )
     
     
     reduct(x + sin(x)**3,sin(x));
     
       X
     
     
     reduct(x + sin(x)**3,y);
     
       0
     
     ____________________________________________________________
   If the expression does not contain the kernel, REDUCT returns 0.


File: ..\util\r37,  Node: REPART,  Next: RESULTANT,  Prev: REDUCT,  Up: Algebraic Operators section

   REPART                    operator

syntax:

   REPART (<expression>) or REPART <simple_expression>

   This operator returns the real part of an expression, if that
argument has an numerical value. A non-numerical argument is returned
as an expression in the operators REPART and [*note IMPART::.] .

examples:

     ____________________________________________________________
     
     repart(1+i);
     
       1
     
     
     repart(a+i*b);
     
       REPART(A) - IMPART(B)
     
     ____________________________________________________________


File: ..\util\r37,  Node: RESULTANT,  Next: RHS,  Prev: REPART,  Up: Algebraic Operators section

   RESULTANT                    operator

   The RESULTANT operator computes the resultant of two polynomials with
respect to a given variable. If the resultant is 0, the polynomials have
a root in common.

syntax:

   RESULTANT (<expression>,<expression>,<kernel>)

   <expression> must be a polynomial containing <kernel> ; <kernel>
must be a [*note KERNEL::.] .

examples:

     ____________________________________________________________
     
     resultant(x**2 + 2*x + 1,x+1,x);
     
       0
     
     
     resultant(x**2 + 2*x + 1,x-3,x);
     
       16
     
     
     resultant(z**3 + z**2 + 5*z + 5,
               z**4 - 6*z**3 + 16*z**2 - 30*z + 55,
               z);
     
     
       0
     
     
     resultant(x**3*y + 4*x*y + 10,y**2 + 6*y + 4,y);
     
     
        6       5        4        3        2
       Y  + 18*Y  + 120*Y  + 360*Y  + 480*Y  + 288*Y + 64
     
     ____________________________________________________________
   The resultant is the determinant of the Sylvester matrix, formed
from the coefficients of the two polynomials in the following way:

   Given two polynomials:

     ____________________________________________________________
     
         n       n-1
      a x  + a1 x     + ... + an
     
     ____________________________________________________________
   and

     ____________________________________________________________
     
         m       m-1
      b x  + b1 x     + ... + bm
     
     ____________________________________________________________
   form the (m+n)x(m+n-1) Sylvester matrix by the following means:

     ____________________________________________________________
     
        0.......0 a  a1 .......... an
        0....0 a  a1 .......... an  0
            .    .   .   .
        a0 a1 .......... an 0.......0
        0.......0 b  b1 .......... bm
        0....0 b  b1 .......... bm  0
            .    .   .   .
        b  b1 .......... bm 0.......0
     
     ____________________________________________________________
   If the determinant of this matrix is 0, the two polynomials have a
common root. Finding the resultant of large expressions is
time-consuming, due to the time needed to find a large determinant.

   The sign conventions RESULTANT uses are those given in the article,
"Computing in Algebraic Extensions," by R. Loos, appearing in <Computer
Algebra-Symbolic and Algebraic Computation>, 2nd ed., edited by B.
Buchberger, G.E. Collins and R. Loos, and published by Springer-Verlag,
1983.  These are:

     ____________________________________________________________
     
       resultant(p(x),q(x),x) = (-1)^{deg p(x)*deg q(x)} * resultant(q(x),p(x),x),
       resultant(a,p(x),x)    = a^{deg p(x)},
       resultant(a,b,x)       = 1
     ____________________________________________________________
   where p(x) and q(x) are polynomials which have x as a variable, and
a and b are free of x.

   Error messages are given if RESULTANT is given a non-polynomial
expression, or a non-kernel variable.


File: ..\util\r37,  Node: RHS,  Next: ROOT_OF,  Prev: RESULTANT,  Up: Algebraic Operators section

   RHS                    operator

   The RHS operator returns the right-hand side of an [*note
EQUATION::.] , such as those returned in a [*note LIST::.] by [*note
SOLVE::.] .

syntax:

   RHS (<equation>) or RHS <equation>

   <equation> must be an equation of the form left-hand side =
right-hand side.

examples:

     ____________________________________________________________
     
     roots := solve(x**2 + 6*x*y + 5x + 3y**2,x);
     
     
                                   2
                          SQRT(24*Y  + 60*Y + 25) + 6*Y + 5
           ROOTS := {X= - ---------------------------------,
                                          2
                                  2
                         SQRT(24*Y  + 60*Y + 25) - 6*Y - 5
                      X= ---------------------------------}
                                         2
     
     
     root1 := rhs first roots;
     
                           2
                  SQRT(24*Y  + 60*Y + 25) + 6*Y + 5
       ROOT1 := - ---------------------------------
                                  2
     
     
     root2 := rhs second roots;
     
                         2
                SQRT(24*Y  + 60*Y + 25) - 6*Y - 5
       ROOT2 := ----------------------------------
                                2
     
     ____________________________________________________________
   An error message is given if RHS is applied to something other than
an equation.


File: ..\util\r37,  Node: ROOT_OF,  Next: SELECT,  Prev: RHS,  Up: Algebraic Operators section

   ROOT_OF                    operator

   When the operator [*note SOLVE::.] is unable to find an explicit
solution or if that solution would be too complicated, the result is
presented as formal root expression using the internal operator ROOT_OF
and a new local variable. An expression with a top level ROOT_OF is
implicitly a list with an unknown number of elements since we can't
always know how many solutions an equation has. If a substitution is
made into such an expression, closed form solutions can emerge. If this
occurs, the ROOT_OF construct is replaced by an operator [*note
ONE_OF::.] . At this point it is of course possible to transform the
result if the original SOLVE operator expression into a standard SOLVE
solution. To effect this, the operator [*note EXPAND_CASES::.] can be
used.

examples:

     ____________________________________________________________
     
     solve(a*x^7-x^2+1,x);
     
                      7     2
       {x=root_of(a*x_  - x_  + 1,x_)}
     
     
     sub(a=0,ws);
     
       {x=one_of(1,-1)}
     
     
     expand_cases ws;
     
       x=1,x=-1
     
     ____________________________________________________________
   The components of ROOT_OF and ONE_OF expressions can be processed as
usual with operators [*note ARGLENGTH::.] and [*note PART::.] .  A
higher power of a ROOT_OF expression with a polynomial as first
argument is simplified by using the polynomial as a side relation.


File: ..\util\r37,  Node: SELECT,  Next: SHOWRULES,  Prev: ROOT_OF,  Up: Algebraic Operators section

   SELECT                    operator

   The SELECT operator extracts from a list or from the arguments of an
n-ary operator elements corresponding to a boolean predicate. The
predicate pattern can be a unary procedure, an operator or an algebraic
expression with one [*note Free Variable::.] .

syntax:

   SELECT (<function>,<object>)

   <object> is a [*note LIST::.] .

   <function> is the name of an operator for a single argument: the
operator  is evaluated once with each element of <object> as its single
argument,

   or an algebraic expression with exactly one [*note Free Variable::.]
, that is a variable preceded by the tilde symbol: the expression  is
evaluated for each element of <object> where the element is
substituted for the free variable,

   or a replacement [*note RULE::.] of the form

syntax:

   VAR => REP

   where <var> is a variable (a <kernel> without subscript)  and <rep>
is an expression which contains <var>.   Here REP is evaluated for each
element of <object> where  the element is substituted for VAR . VAR may
be  optionally preceded by a tilde.

   The rule form for <function> is needed when more than one free
variable occurs. The evaluation result of <function> is interpreted as
[*note boolean value::.] corresponding to the conventions of REDUCE.
The result value is built with the leading operator of the input
expression.

examples:

     ____________________________________________________________
     
       select( ~w>0 , {1,-1,2,-3,3})
     
       {1,2,3}
     
     
       q:=(part((x+y)^5,0):=list)
     
       select(evenp deg(~w,y),q);
     
         5      3   2       4
       {x  ,10*x  *y  ,5*x*y  }
     
     
       select(evenp deg(~w,x),2x^2+3x^3+4x^4);
     
     
         2   4
       2x +4x
     
     ____________________________________________________________


File: ..\util\r37,  Node: SHOWRULES,  Next: SOLVE,  Prev: SELECT,  Up: Algebraic Operators section

   SHOWRULES                    operator

syntax:

   SHOWRULES (<expression>) or  SHOWRULES <simple_expression>

   SHOWRULES returns in [*note RULE::.] -LIST form any [*note
OPERATOR::.]  rules associated with its argument.

examples:

     ____________________________________________________________
     
     showrules log;
     
       {LOG(E) => 1,
        LOG(1) => 0,
             ~X
        LOG(E   ) => ~X,
                          1
        DF(LOG(~X),~X) => --}
                          ~X
     
     ____________________________________________________________
   Such rules can then be manipulated further as with any [*note
LIST::.] . For example RHS FIRST WS;  has the value 1.

   An operator may have properties that cannot be displayed in such a
form, such as the fact it is an [*note ODD::.] function, or has a
definition defined as a procedure.


File: ..\util\r37,  Node: SOLVE,  Next: SORT,  Prev: SHOWRULES,  Up: Algebraic Operators section

   SOLVE                    operator

   The SOLVE operator solves a single algebraic [*note EQUATION::.] or a
system of simultaneous equations.

syntax:

   SOLVE (<expression> [ , <kernel>]) or

   SOLVE (<expression>,... [ , <kernel> ,...] )

   If the number of equations equals the number of distinct kernels, the
optional kernel argument(s) may be omitted. <expression> is either a
scalar expression or an [*note EQUATION::.] .  When more than one
expression is given, the [*note LIST::.] of expressions is surrounded
by curly braces.  The optional list of [*note KERNEL::.] s follows,
also in curly braces.

examples:

     ____________________________________________________________
     
     sss := solve(x^2 + 7);
     
       Unknown: X
       SSS := {X= - SQRT(7)*I,
               X=SQRT(7)*I}
     
     
     rhs first sss;
     
       - SQRT(7)*I
     
     
     solve(sin(x^2*y),y);
     
          2*ARBINT(1)*PI
       {Y=---------------
                 2
                X
          PI*(2*ARBINT(1) + 1)
        Y=--------------------}
                    2
                   X
     
     
     off allbranch;
     
     solve(sin(x**2*y),y);
     
       {Y=0}
     
     
     solve({3x + 5y = -4,2*x + y = -10},{x,y});
     
     
     
              22   46
       {{X= - --,Y=--}}
              7    7
     
     
     solve({x + a*y + z,2x + 5},{x,y});
     
     
     
              5      2*Z - 5
       {{X= - -,Y= - -------}}
              2        2*A
     
     
     ab := (x+2)^2*(x^6 + 17x + 1);
     
     
              8      7      6       3       2
       AB := X  + 4*X  + 4*X  + 17*X  + 69*X  + 72*X + 4
     
     
     www := solve(ab,x);
     
       {X=ROOT F(X6 + 17*X + 1),X=-2}
              O
     
     
     root_multiplicities;
     
       {1,2}
     
     ____________________________________________________________
   Results of the SOLVE operator are returned as [*note EQUATION::.] S
in a [*note LIST::.] .  You can use the usual list access methods
([*note FIRST::.] , [*note SECOND::.] , [*note THIRD::.] , [*note
REST::.] and [*note PART::.] ) to extract the desired equation, and
then use the operators [*note RHS::.] and [*note LHS::.]  to access the
right-hand or left-hand expression of the equation. When SOLVE is
unable to solve an equation, it returns the unsolved part as the
argument of ROOT_OF , with the variable renamed to avoid confusion, as
shown in the last example above.

   For one equation, SOLVE uses square-free factorization, roots of
unity, and the known inverses of the [*note LOG::.] , [*note SIN::.] ,
[*note COS::.] , [*note ACOS::.] , [*note ASIN::.] , and exponentiation
operators. The quadratic, cubic and quartic formulas are used if
necessary, but these are applied only when the switch [*note
FULLROOTS::.]  is set on; otherwise or when no closed form is available
the result is returned as [*note ROOT_OF::.]  expression. The switch
[*note TRIGFORM::.] determines which type of cubic and quartic formula
is used.  The multiplicity of each solution is given in a list as the
system variable [*note ROOT_MULTIPLICITIES::.] . For systems of
simultaneous linear equations, matrix inversion is used. For nonlinear
systems, the Groebner basis method is used.

   Linear equation system solving is influenced by the switch [*note
CRAMER::.] .

   Singular systems can be solved when the switch [*note
SOLVESINGULAR::.] is on, which is the default setting. An empty list is
returned the system of equations is inconsistent. For a linear
inconsistent system with parameters the variable [*note
requirements::.] constraints conditions for the system to become
consistent.

   For a solvable linear and polynomial system with parameters the
variable [*note assumptions::.] contains a list side relations for the
parameters: the solution is valid only as long as none of these
expressions is zero.

   If the switch [*note VAROPT::.] is on (default), the system
rearranges the variable sequence for minimal computation time. Without
VAROPT the user supplied variable sequence is maintained.

   If the solution has free variables (dimension of the solution is
greater than zero), these are represented by [*note ARBCOMPLEX::.]
expressions as long as the switch [*note ARBVARS::.] is on (default).
Without ARBVARS  no explicit equations are generated for free variables.

related:

   [*note ALLBRANCH::.] switch

   [*note ARBVARS::.]  switch

   [*note assumptions::.]  variable

   [*note FULLROOTS::.]  switch

   [*note requirements::.]  variable

   [*note ROOTS::.]  operator

   [*note ROOT_OF::.]  operator

   [*note TRIGFORM::.]  switch

   [*note VAROPT::.]  switch


File: ..\util\r37,  Node: SORT,  Next: STRUCTR,  Prev: SOLVE,  Up: Algebraic Operators section

   SORT                    operator

   The SORT operator sorts the elements of a list according to an
arbitrary comparison operator.

syntax:

   SORT (<lst>,<comp>)

   <lst> is a [*note LIST::.] of algebraic expressions.  <comp> is a
comparison operator which defines a partial ordering among the members
of <lst>. <comp> may be one of the builtin comparison operators like <
([*note LESSP::.] ), <= ([*note LEQ::.] ) etc., or <comp> may be the
name of a comparison procedure.  Such a procedure has two arguments,
and it returns [*note TRUE::.]  if the first argument ranges before the
second one, and 0 or [*note NIL::.] otherwise.  The result of SORT is a
new list which contains the elements of <lst> in a sequence
corresponding to <comp>.

examples:

     ____________________________________________________________
     
      procedure ce(a,b);
     
        if evenp a and not evenp b then 1 else 0;
     
     for i:=1:10 collect random(50)$
     
     sort(ws,>=);
     
       {41,38,33,30,28,25,20,17,8,5}
     
     
     sort(ws,<);
     
       {5,8,17,20,25,28,30,33,38,41}
     
     
     sort(ws,ce);
     
       {8,20,28,30,38,5,17,25,33,41}
     
     
       procedure cd(a,b);
     
       if deg(a,x)>deg(b,x) then 1 else
     
       if deg(a,x)<deg(b,x) then 0 else
     
       if deg(a,y)>deg(b,y) then 1 else 0;
     
     sort({x^2,y^2,x*y},cd);
     
         2      2
       {x ,x*y,y }
     
     ____________________________________________________________


File: ..\util\r37,  Node: STRUCTR,  Next: SUB,  Prev: SORT,  Up: Algebraic Operators section

   STRUCTR                    operator

   The STRUCTR operator breaks its argument expression into named
subexpressions.

syntax:

   STRUCTR (<expression> [,<identifier>[,<identifier> ...]])

   <expression> may be any valid REDUCE scalar expression.
<identifier> may be any valid REDUCE IDENTIFIER . The first identifier
is the stem for subexpression names, the second is the name to be
assigned to the structured expression.

examples:

     ____________________________________________________________
     
     structr(sqrt(x**2 + 2*x) + sin(x**2*z));
     
     
       ANS1 + ANS2
           where
                            2
               ANS2 := SIN(X *Z)
                                  1/2
               ANS1 := ((X + 2)*X)
     
     
     ans3;
     
       ANS3
     
     
     on fort;
     
     structr((x+1)**5 + tan(x*y*z),var,aa);
     
     
       VAR1=TAN(X*Y*Z)
       AA=VAR1+X**5+5.*X**4+10.*X**3+10.X**2+5.*X+1
     
     ____________________________________________________________
   The second argument to STRUCTR is optional. If it is not given, the
default stem ANS is used by REDUCE to construct names for the
subexpression. The names are only for display purposes: REDUCE does not
store the names and their values unless the switch [*note
SAVESTRUCTR::.] is on.

   If a third argument is given, the structured expression as a whole
is named by this argument, when [*note FORT::.] is on. The expression
is not stored under this name. You can send these structured Fortran
expressions to a file with the OUT  command.


File: ..\util\r37,  Node: SUB,  Next: SUM,  Prev: STRUCTR,  Up: Algebraic Operators section

   SUB                    operator

   The SUB operator substitutes a new expression for a kernel in an
expression.

syntax:

   SUB (<kernel>= <expression>          ,<kernel>= <expression>*,
  <expression>) or

   SUB (<kernel>= <expression>*,          <kernel>= EXPRESSION
,<expression>)

   <kernel> must be a [*note KERNEL::.] , <expression> can be any REDUCE
scalar expression.

examples:

     ____________________________________________________________
     
     sub(x=3,y=4,(x+y)**3);
     
       343
     
     
     x;
     
       X
     
     
     sub({cos=sin,sin=cos},cos a+sin b)
     
     
       COS(B) + SIN(A)
     
     ____________________________________________________________
   Note in the second example that operators can be replaced using the
SUB  operator.


File: ..\util\r37,  Node: SUM,  Next: WS,  Prev: SUB,  Up: Algebraic Operators section

   SUM                    operator

   The operator SUM returns the indefinite or definite summation of a
given expression.

syntax:

   SUM (<expr>,<k>[,<lolim> [,<uplim> ]])

   where <expr> is the expression to be added, <k> is the control
variable (a [*note KERNEL::.] ), and <lolim> and <uplim> are the
optional lower and upper limits. If <uplim> is not supplied the upper
limit is taken as <k>. The Gosper algorithm is used. If there is no
closed form solution, the operator returns the input unchanged.

examples:

     ____________________________________________________________
     
     sum(4n**3,n);
     
        2    2
       n  *(n   + 2*n + 1)
     
     
     sum(2a+2k*r,k,0,n-1);
     
       n*(2*a + n*r - r)
     
     ____________________________________________________________


File: ..\util\r37,  Node: WS,  Prev: SUM,  Up: Algebraic Operators section

   WS                    operator

   The WS operator alone returns the last result; WS with a number
argument returns the results of the REDUCE statement executed after
that numbered prompt.

syntax:

   WS or WS (<number>)

   <number> must be an integer between 1 and the current REDUCE prompt
number.

examples:

     ____________________________________________________________
     ____________________________________________________________
   (In the following examples, unlike most others, the numbered prompt
is shown.)
     ____________________________________________________________
     
     
     1: df(sin y,y);
     
       COS(Y)
     
     
     2: ws^2;
     
             2
       COS(Y)
     
     
     3: df(ws 1,y);
     
       -SIN(Y)
     
     ____________________________________________________________

   WS and WS ( <number>)  can be used anywhere the expression they
stand for can be used. Calling a number for which no result was
produced, such as a switch setting, will give an error message.

   The current workspace always contains the results of the last REDUCE
command that produced an expression, even if several input statements
that do not produce expressions have intervened. For example, if you do
a differentiation, producing a result expression, then change several
switches, the operator WS; returns the results of the differentiation.
The current workspace (WS ) can also be used inside files, though the
numbered workspace contains only the IN command that input the file.

   There are three history lists kept in your REDUCE session. The first
stores raw input, suitable for the statement editor. The second stores
parsed input, ready to execute and accessible by [*note INPUT::.] . The
third stores results, when they are produced by statements, which are
accessible by the WS < n> operator. If your session is very long,
storage space begins to fill up with these expressions, so it is a good
idea to end the session once in a while, saving needed expressions to
files with the [*note SAVEAS::.] and [*note OUT::.] commands.

   An error message is given if a reference number has not yet been
used.


File: ..\util\r37,  Node: Algebraic Operators section,  Next: Declarations section,  Prev: General Commands section,  Up: Top

   Algebraic Operators section

* Menu:

* APPEND::                  operator
* ARBINT::                  operator
* ARBCOMPLEX::              operator
* ARGLENGTH::               operator
* COEFF::                   operator
* COEFFN::                  operator
* CONJ::                    operator
* CONTINUED_FRACTION::      operator
* DECOMPOSE::               operator
* DEG::                     operator
* DEN::                     operator
* DF::                      operator
* EXPAND_CASES::           operator
* EXPREAD::                 operator
* FACTORIZE::               operator
* HYPOT::                   operator
* IMPART::                  operator
* INT::                     operator
* INTERPOL::                operator
* LCOF::                    operator
* LENGTH::                  operator
* LHS::                     operator
* LIMIT::                   operator
* LPOWER::                  operator
* LTERM::                   operator
* MAINVAR::                 operator
* MAP::                     operator
* MKID::                    command
* NPRIMITIVE::              operator
* NUM::                     operator
* ODESOLVE::                operator
* ONE_OF::                 type
* PART::                    operator
* PF::                      operator
* PROD::                    operator
* REDUCT::                  operator
* REPART::                  operator
* RESULTANT::               operator
* RHS::                     operator
* ROOT_OF::                operator
* SELECT::                  operator
* SHOWRULES::               operator
* SOLVE::                   operator
* SORT::                    operator
* STRUCTR::                 operator
* SUB::                     operator
* SUM::                     operator
* WS::                      operator


File: ..\util\r37,  Node: ALGEBRAIC,  Next: ANTISYMMETRIC,  Up: Declarations section

   ALGEBRAIC                    command

   The ALGEBRAIC command changes REDUCE's mode of operation to
algebraic. When ALGEBRAIC is used as an operator (with an argument
inside parentheses) that argument is evaluated in algebraic mode, but
REDUCE's mode is not changed.

examples:

     ____________________________________________________________
     
     algebraic;
     
     symbolic;
     
       NIL
     
     
     algebraic(x**2);
     
        2
       X
     
     
     x**2;
     
         ***** The symbol X has no value.
     
     ____________________________________________________________
   REDUCE's symbolic mode does not know about most algebraic commands.
Error messages in this mode may also depend on the particular Lisp used
for the REDUCE implementation.


File: ..\util\r37,  Node: ANTISYMMETRIC,  Next: ARRAY,  Prev: ALGEBRAIC,  Up: Declarations section

   ANTISYMMETRIC                    declaration

   When an operator is declared ANTISYMMETRIC , its arguments are
reordered to conform to the internal ordering of the system. If an odd
number of argument interchanges are required to do this ordering, the
sign of the expression is changed.

syntax:

   ANTISYMMETRIC <identifier>, <identifier>*

   <identifier> is an identifier that has been declared as an operator.

examples:

     ____________________________________________________________
     
     operator m,n;
     
     antisymmetric m,n;
     
     m(x,n(1,2));
     
       - M( - N(2,1),X)
     
     
     operator p;
     
     antisymmetric p;
     
     p(a,b,c);
     
       P(A,B,C)
     
     
     p(b,a,c);
     
       - P(A,B,C)
     
     ____________________________________________________________
   If <identifier> has not been declared an operator, the flag
ANTISYMMETRIC  is still attached to it. When <identifier> is
subsequently used as an operator, the message DECLARE <identifier>
OPERATOR? (Y OR N) is printed. If the user replies Y , the
antisymmetric property of the operator is used.

   Note in the first example, identifiers are customarily ordered
alphabetically, while numbers are ordered from largest to smallest.
The operators may have any desired number of arguments (less than 128).


File: ..\util\r37,  Node: ARRAY,  Next: CLEAR,  Prev: ANTISYMMETRIC,  Up: Declarations section

   ARRAY                    declaration

   The ARRAY declaration declares a list of identifiers to be of type
ARRAY , and sets all their entries to 0.

syntax:

   ARRAY <identifier>(<dimensions>)  , <identifier>(<dimensions>)*

   <identifier> may be any valid REDUCE identifier. If the identifier
was already an array, a warning message is given that the array has been
redefined. <dimensions> are of form  <integer>,<integer>*.

examples:

     ____________________________________________________________
     
     array a(2,5),b(3,3,3),c(200);
     
     array a(3,5);
     
       *** ARRAY A REDEFINED
     
     
     a(3,4);
     
       0
     
     
     length a;
     
       {4,6}
     
     ____________________________________________________________
   Arrays are always global, even if defined inside a procedure or block
statement. Their status as an array remains until the variable is reset
by [*note CLEAR::.] . Arrays may not have the same names as operators,
procedures or scalar variables.

   Array elements are referred to by the usual notation: A(I,J) returns
the jth element of the ith row. The [*note assign::.] ment operator :=
is used to put values into the array. Arrays as a whole cannot be
subject to assignment by [*note LET::.] or := ; the assignment operator
:= is only valid for individual elements.

   When you use [*note LET::.] on an array element, the contents of that
element become the argument to LET . Thus, if the element contains a
number or some other expression that is not a valid argument for this
command, you get an error message. If the element contains an
identifier, the identifier has the substitution rule attached to it
globally. The same behavior occurs with [*note CLEAR::.] . If the array
element contains an identifier or simple_expression, it is cleared. Do
<not> use CLEAR to try to set an array element to 0. Because of the
side effects of either LET or CLEAR , it is unwise to apply either of
these to array elements.

   Array indices always start with 0, so that the declaration ARRAY A(5)
sets aside 6 units of space, indexed from 0 through 5, and initializes
them to 0. The [*note LENGTH::.] command returns a list of the true
number of elements in each dimension.


File: ..\util\r37,  Node: CLEAR,  Next: CLEARRULES,  Prev: ARRAY,  Up: Declarations section

   CLEAR                    command

   The CLEAR command is used to remove assignments or remove
substitution rules from any expression.

syntax:

   CLEAR <identifier>,<identifier>+ or

   <let-type statement> CLEAR <identifier>

   <identifier> can be any SCALAR , [*note MATRIX::.] , or [*note
ARRAY::.] variable or [*note PROCEDURE::.]  name. <let-type statement>
can be any general or specific [*note LET::.] statement (see below in
Comments).

examples:

     ____________________________________________________________
     
     array a(2,3);
     
     a(2,2) := 15;
     
       A(2,2) := 15
     
     
     clear a;
     
     a(2,2);
     
       Declare A operator? (Y or N)
     
     
     let x = y + z;
     
     sin(x);
     
       SIN(Y + Z)
     
     
     clear x;
     
     sin(x);
     
       SIN(X)
     
     
     let x**5 = 7;
     
     clear x;
     
     x**5;
     
       7
     
     
     clear x**5;
     
     x**5;
     
        5
       X
     
     ____________________________________________________________
   Although it is not a good idea, operators of the same name but taking
different numbers of arguments can be defined. Using a CLEAR statement
on any of these operators clears every one with the same name, even if
the number of arguments is different.

   The CLEAR command is used to "forget" matrices, arrays, operators
and scalar variables, returning their identifiers to the pristine state
to be used for other purposes. When CLEAR is applied to array elements,
the contents of the array element becomes the argument for CLEAR .
Thus, you get an error message if the element contains a number, or
some other expression that is not a legal argument to CLEAR . If the
element contains an identifier, it is cleared.  When clear is applied
to matrix elements, an error message is returned if the element
evaluates to a number, otherwise there is no effect. Do  not try to use
CLEAR to set array or matrix elements to 0.  You will not be pleased
with the results.

   If you are trying to clear power or product substitution rules made
with either [*note LET::.] or [*note FORALL::.] ...LET , you must
reproduce the rule, exactly as you typed it with the same arguments, up
to but not including the equal sign, using the word CLEAR instead of
the word LET . This is shown in the last example. Any other type of LET
or FORALL ...LET  substitution can be cleared with just the variable
or operator name. [*note MATCH::.] behaves the same as [*note LET::.]
in this situation. There is a more complicated example under [*note
FORALL::.] .


File: ..\util\r37,  Node: CLEARRULES,  Next: DEFINE,  Prev: CLEAR,  Up: Declarations section

   CLEARRULES                    command

syntax:

   CLEARRULES <list>,<list>+

   The operator CLEARRULES is used to remove previously defined [*note
RULE::.]  lists from the system. <list> can be an explicit rule list,
or evaluate to a rule list.

examples:

     ____________________________________________________________
     
     trig1 := {cos(~x)*cos(~y) => (cos(x+y)+cos(x-y))/2,
               cos(~x)*sin(~y) => (sin(x+y)-sin(x-y))/2,
               sin(~x)*sin(~y) => (cos(x-y)-cos(x+y))/2,
               cos(~x)^2       => (1+cos(2*x))/2,
               sin(~x)^2       => (1-cos(2*x))/2}$
     
     let trig1;
     cos(a)*cos(b);
     
       COS(A - B) + COS(A + B)
       -----------------------
                  2
     
     
     clearrules trig1;
     cos(a)*cos(b);
     
       COS(A)*COS(B)
     
     ____________________________________________________________


File: ..\util\r37,  Node: DEFINE,  Next: DEPEND,  Prev: CLEARRULES,  Up: Declarations section

   DEFINE                    command

   The command DEFINE allows you to supply a new name for an identifier
or replace it by any valid REDUCE expression.

syntax:

   DEFINE <identifier>= <substitution>  , <identifier>= <substitution>*

   <identifier> is any valid REDUCE identifier, <substitution> can be a
number, an identifier, an operator, a reserved word, or an expression.

examples:

     ____________________________________________________________
     
     
     define is= :=, xx=y+z;
     
     
     a is 10;
     
       A := 10
     
     
     
     xx**2;
     
        2             2
       Y   + 2*Y*Z + Z
     
     
     
     xx := 10;
     
       Y + Z := 10
     
     ____________________________________________________________
   The renaming is done at the input level, and therefore takes
precedence over any other replacement or substitution declared for the
same identifier.  It remains in effect until the end of the REDUCE
session. Be careful with it, since you cannot easily undo it without
ending the session.


File: ..\util\r37,  Node: DEPEND,  Next: EVEN,  Prev: DEFINE,  Up: Declarations section

   DEPEND                    declaration

   DEPEND  declares that its first argument depends on the rest of its
arguments.

syntax:

   DEPEND <kernel>, <kernel>+

   <kernel> must be a legal variable name or a prefix operator (see
[*note KERNEL::.] ).

examples:

     ____________________________________________________________
     
     
     depend y,x;
     
     
     df(y**2,x);
     
       2*DF(Y,X)*Y
     
     
     
     depend z,cos(x),y;
     
     
     df(sin(z),cos(x));
     
       COS(Z)*DF(Z,COS(X))
     
     
     
     df(z**2,x);
     
       2*DF(Z,X)*Z
     
     
     
     nodepend z,y;
     
     
     df(z**2,x);
     
       2*DF(Z,X)*Z
     
     
     
     cc := df(y**2,x);
     
       CC := 2*DF(Y,X)*Y
     
     
     
     y := tan x;
     
       Y := TAN(X);
     
     
     
     cc;
     
                       2
       2*TAN(X)*(TAN(X)   + 1)
     
     ____________________________________________________________
   Dependencies can be removed by using the declaration [*note
NODEPEND::.] .  The differentiation operator uses this information, as
shown in the examples above. Linear operators also use knowledge of
dependencies (see [*note LINEAR::.] ). Note that dependencies can be
nested: Having declared y to depend on x, and z to depend on y, we see
that the chain rule was applied to the derivative of a function of z
with respect to x. If the explicit function of the dependency is later
entered into the system, terms with DF(Y,X) , for example, are expanded
when they are displayed again, as shown in the last example. The
boolean operator [*note FREEOF::.] allows you to check the dependency
between two algebraic objects.


File: ..\util\r37,  Node: EVEN,  Next: FACTOR declaration,  Prev: DEPEND,  Up: Declarations section

   EVEN                    declaration

syntax:

   EVEN <identifier>,<identifier>*

   This declaration is used to declare an operator even in its first
argument. Expressions involving an operator declared in this manner are
transformed if the first argument contains a minus sign. Any other
arguments are not affected.

examples:

     ____________________________________________________________
     
             even f;
     
             f(-a)
     
       F(A)
     
     
             f(-a,-b)
     
       F(A,-B)
     
     ____________________________________________________________


File: ..\util\r37,  Node: FACTOR declaration,  Next: FORALL,  Prev: EVEN,  Up: Declarations section

   FACTOR                    declaration

   When a kernel is declared by FACTOR , all terms involving fixed
powers of that kernel are printed as a product of the fixed powers and
the rest of the terms.

syntax:

   FACTOR <kernel> , <kernel>*

   <kernel> must be a [*note KERNEL::.] or a [*note LIST::.] of KERNEL
s.

examples:

     ____________________________________________________________
     
     a := (x + y + z)**2;
     
             2                    2            2
       A := X  + 2*X*Y + 2*X*Z + Y  + 2*Y*Z + Z
     
     
     factor y;
     
     a;
     
        2                  2            2
       Y  + 2*Y*(X + Z) + X  + 2*X*Z + Z
     
     
     factor sin(x);
     
     c := df(sin(x)**4*x**2*z,x);
     
                    4               3         2
       C := 2*SIN(X) *X*Z + 4*SIN(X) *COS(X)*X *Z
     
     
     remfac sin(x);
     
     c;
     
               3
       2*SIN(X) *X*Z*(2*COS(X)*X + SIN(X))
     
     ____________________________________________________________
   Use the FACTOR declaration to display variables of interest so that
you can see their powers more clearly, as shown in the example. Remove
this special treatment with the declaration [*note REMFAC::.] . The
FACTOR  declaration is only effective when the switch [*note PRI::.] is
on.

   The FACTOR declaration is not a factoring command; to factor
expressions use the [*note FACTOR::.] switch or the [*note
FACTORIZE::.] command.

   The FACTOR declaration is helpful in such cases as Taylor polynomials
where the explicit powers of the variable are expected at the top
level, not buried in various factored forms.

   Note that FACTOR does not affect the order of its arguments. You
should also use [*note ORDER::.] if this is important.


File: ..\util\r37,  Node: FORALL,  Next: INFIX,  Prev: FACTOR declaration,  Up: Declarations section

   FORALL                    command

   The FORALL or (preferably) FOR ALL command is used as a modifier for
[*note LET::.] statements, indicating the universal applicability of
the rule, with possible qualifications.

syntax:

   FOR ALL <identifier>,<identifier>* LET <let statement>

   or

   FOR ALL <identifier>,<identifier>*  SUCH THAT <condition> LET <let
statement>

   <identifier> may be any valid REDUCE identifier, <let statement> can
be an operator, a product or power, or a group or block statement.
<condition> must be a logical or comparison operator returning true or
false.

examples:

     ____________________________________________________________
     
     for all x let f(x) = sin(x**2);
     
     
       Declare F operator ? (Y or N)
     
     
     y
     
     f(a);
     
            2
       SIN(A )
     
     
     operator pos;
     
     for all x such that x>=0 let pos(x) = sqrt(x + 1);
     
     pos(5);
     
       SQRT(6)
     
     
     pos(-5);
     
       POS(-5)
     
     
     clear pos;
     
     pos(5);
     
       Declare POS operator ? (Y or N)
     
     
     for all a such that numberp a let x**a = 1;
     
     x**4;
     
       1
     
     
     clear x**a;
     
       *** X**A not found
     
     
     for all a  clear x**a;
     
     x**4;
     
       1
     
     
     for all a such that numberp a clear x**a;
     
     x**4;
     
        4
       X
     
     ____________________________________________________________
   Substitution rules defined by FOR ALL or FOR ALL ...SUCH THAT
commands that involve products or powers are cleared by reproducing the
command, with exactly the same variable names used, up to but not
including the equal sign, with [*note CLEAR::.] replacing LET , as
shown in the last example. Other substitutions involving variables or
operator names can be cleared with just the name, like any other
variable.

   The [*note MATCH::.] command can also be used in product and power
substitutions.  The syntax of its use and clearing is exactly like LET
. A MATCH substitution only replaces the term if it is exactly like the
pattern, for example MATCH X**5 = 1 replaces only terms of X**5 and not
terms of higher powers.

   It is easier to declare your potential operator before defining the
FOR ALL  rule, since the system will ask you to declare it an operator
anyway. Names of declared arrays or matrices or scalar variables are
invalid as operator names, to avoid ambiguity. Either FOR ALL ...LET
statements or procedures are often used to define operators. One
difference is that procedures implement "call by value" meaning that
assignments involving their formal parameters do not change the calling
variables that replace them. If you use assignment statements on the
formal parameters in a FOR ALL ...LET  statement, the effects are seen
in the calling variables. Be careful not to redefine a system operator
unless you mean it: the statement FOR ALL X LET SIN(X)=0; has exactly
that effect, and the usual definition for sin(x) has been lost for the
remainder of the REDUCE session.


File: ..\util\r37,  Node: INFIX,  Next: INTEGER,  Prev: FORALL,  Up: Declarations section

   INFIX                    declaration

   INFIX  declares identifiers to be infix operators.

syntax:

   INFIX <identifier>,<identifier>*

   <identifier> can be any valid REDUCE identifier, which has not
already been declared an operator, array or matrix, and is not reserved
by the system.

examples:

     ____________________________________________________________
     
     infix aa;
     
     for all x,y let aa(x,y) = cos(x)*cos(y) - sin(x)*sin(y);
     
     x aa y;
     
       COS(X)*COS(Y) - SIN(X)*SIN(Y)
     
     
     pi/3 aa pi/2;
     
         SQRT(3)
       - -------
            2
     
     
     aa(pi,pi);
     
       1
     
     ____________________________________________________________
   A [*note LET::.] statement must be used to attach functionality to
the operator. Note that the operator is defined in prefix form in the
LET statement.  After its definition, the operator may be used in
either prefix or infix mode. The above operator aa finds the cosine of
the sum of two angles by the formula

   cos(x+y) = cos(x)*cos(y) - sin(x)*sin(y).

   Precedence may be attached to infix operators with the [*note
PRECEDENCE::.]  declaration.

   User-defined infix operators may be used in prefix form. If they are
used in infix form, a space must be left on each side of the operator
to avoid ambiguity. Infix operators are always binary.


File: ..\util\r37,  Node: INTEGER,  Next: KORDER,  Prev: INFIX,  Up: Declarations section

   INTEGER                    declaration

   The INTEGER declaration must be made immediately after a [*note
BEGIN::.]  (or other variable declaration such as [*note REAL::.] and
[*note SCALAR::.] ) and declares local integer variables. They are
initialized to 0.

syntax:

   INTEGER <identifier>,<identifier>*

   <identifier> may be any valid REDUCE identifier, except T  or NIL .

   Integer variables remain local, and do not share values with
variables of the same name outside the [*note BEGIN::.] ...END  block.
When the block is finished, the variables are removed. You may use the
words [*note REAL::.]  or [*note SCALAR::.] in the place of INTEGER .
INTEGER  does not indicate typechecking by the current REDUCE; it is
only for your own information. Declaration statements must immediately
follow the BEGIN , without a semicolon between BEGIN and the first
variable declaration.

   Any variables used inside BEGIN ...END  blocks that were not
declared SCALAR , REAL or INTEGER are global, and any change made to
them inside the block affects their global value. Any [*note ARRAY::.]
or [*note MATRIX::.] declared inside a block is always global.


File: ..\util\r37,  Node: KORDER,  Next: LET,  Prev: INTEGER,  Up: Declarations section

   KORDER                    declaration

   The KORDER declaration changes the internal canonical ordering of
kernels.

syntax:

   KORDER <kernel>, <kernel>*

   <kernel> must be a REDUCE [*note KERNEL::.] or a [*note LIST::.] of
KERNEL s.

   The declaration KORDER changes the internal ordering, but not the
print ordering, so the effects cannot be seen on output. However, in
some calculations, the order of the variables can have significant
effects on the time and space demands of a calculation. If you are
doing a demanding calculation with several kernels, you can experiment
with changing the canonical ordering to improve behavior.

   The first kernel in the argument list is given the highest priority,
the second gets the next highest, and so on. Kernels not named in a
KORDER  ordering otherwise. A new KORDER declaration replaces the
previous one. To return to canonical ordering, use the command KORDER
NIL .

   To change the print ordering, use the declaration [*note ORDER::.] .


File: ..\util\r37,  Node: LET,  Next: LINEAR,  Prev: KORDER,  Up: Declarations section

   LET                    command

   The LET command defines general or specific substitution rules.

syntax:

   LET <identifier> = <expression>,<identifier> =  <expression>*

   <identifier> can be any valid REDUCE identifier except an array, and
in some cases can be an expression; <expression> can be any valid REDUCE
expression.

examples:

     ____________________________________________________________
     
     let a = sin(x);
     
     b := a;
     
       B := SIN X;
     
     
     let c = a;
     
     exp(a);
     
        SIN(X)
       E
     
     
     a := x**2;
     
             2
       A := X
     
     
     exp(a);
     
         2
        X
       E
     
     
     exp(b);
     
        SIN(X)
       E
     
     
     exp(c);
     
         2
        X
       E
     
     
     let m + n = p;
     
     (m + n)**5;
     
        5
       P
     
     
     operator h;
     
     let h(u,v) = u - v;
     
     h(u,v);
     
       U - V
     
     
     h(x,y);
     
       H(X,Y)
     
     
     array q(10);
     
     let q(1) = 15;
     
       ***** Substitution for 0 not allowed
     
     ____________________________________________________________
   The LET command is also used to activate a RULE SETS .

syntax:

   LET <list>,<list>+

   <list> can be an explicit [*note RULE::.] LIST , or evaluate to a
rule list.

examples:

     ____________________________________________________________
     
     trig1 := {cos(~x)*cos(~y) => (cos(x+y)+cos(x-y))/2,
               cos(~x)*sin(~y) => (sin(x+y)-sin(x-y))/2,
               sin(~x)*sin(~y) => (cos(x-y)-cos(x+y))/2,
               cos(~x)^2       => (1+cos(2*x))/2,
               sin(~x)^2       => (1-cos(2*x))/2}$
     
     let trig1;
     cos(a)*cos(b);
     
       COS(A - B) + COS(A + B)
       ------------------------
                  2
     
     ____________________________________________________________
   A LET command returns no value, though the substitution rule is
entered. Assignment rules made by [*note assign::.] and LET rules are
at the same level, and cancel each other. There is a difference in their
operation, however, as shown in the first example: a LET assignment
tracks the changes in what it is assigned to, while a := assignment is
fixed at the value it originally had.

   The use of expressions as left-hand sides of LET statements is a
little complicated. The rules of operation are:

   (i) Expressions of the form A*B = C do not change A, B or C, but set
A*B to C.

   (ii) Expressions of the form A+B = C substitute C - B for A, but do
not change B or C.

   (iii) Expressions of the form A-B = C substitute B + C for A, but do
not change B or C.

   (iv) Expressions of the form A/B = C substitute B*C for A, but do
not change B or C.

   (v) Expressions of the form A**N = C substitute C for A**N in every
expression of a power of A to N or greater. An asymptotic command such
as A**N = 0 sets all terms involving A to powers greater than or equal
to N to 0. Finite fields may be generated by requiring modular
arithmetic (the [*note MODULAR::.] switch) and defining the primitive
polynomial via a LET statement.

   LET substitutions involving expressions are cleared by using the
[*note CLEAR::.] command with exactly the same expression.

   Note when a simple LET statement is used to assign functionality to
an operator, it is valid only for the exact identifiers used. For the
use of the LET  command to attach more general functionality to an
operator, see [*note FORALL::.] .

   Arrays as a whole cannot be arguments to LET statements, but
matrices as a whole can be legal arguments, provided both arguments are
matrices. However, it is important to note that the two matrices are
then linked. Any change to an element of one matrix changes the
corresponding value in the other. Unless you want this behavior, you
should not use LET  for matrices. The assignment operator [*note
assign::.] can be used for non-tracking assignments, avoiding the side
effects. Matrices are redimensioned as needed in LET statements.

   When array or matrix elements are used as the left-hand side of LET
statements, the contents of that element is used as the argument. When
the contents is a number or some other expression that is not a valid
left-hand side for LET , you get an error message. If the contents is an
identifier or simple expression, the LET rule is globally attached to
that identifier, and is in effect not only inside the array or matrix,
but everywhere. Because of such unwanted side effects, you should not
use LET with array or matrix elements. The assignment operator :=  can
be used to put values into array or matrix elements without the side
effects.

   Local variables declared inside BEGIN ...END  blocks cannot be used
as the left-hand side of LET statements. However, [*note BEGIN::.]
...END  blocks themselves can be used as the right-hand side of LET
statements. The construction:

syntax:

   FOR ALL <vars>  LET <operator>(<vars>)= <block>

   is an alternative to the

syntax:

   PROCEDURE <name>(<vars>); <block>

   construction. One important difference between the two constructions
is that the <vars> as formal parameters to a procedure have their
global values protected against change by the procedure, while the
<vars> of a LET  statement are changed globally by its actions.

   Be careful in using a construction such as LET X = X + 1 except
inside a controlled loop statement. The process of resubstitution
continues until a stack overflow message is given.

   The LET statement may be used to make global changes to variables
from inside procedures. If X is a formal parameter to a procedure, the
command LET X =  ... makes the change to the calling variable.  For
example, if a procedure was defined by
     ____________________________________________________________
     
             procedure f(x,y);
             let x = 15;
     ____________________________________________________________

   and the procedure was called as
     ____________________________________________________________
     
             f(a,b);
     ____________________________________________________________

   A would have its value changed to 15. Be careful when using LET
statements inside procedures to avoid unwanted side effects.

   It is also important to be careful when replacing LET statements with
other LET statements. The overlapping of these substitutions can be
unpredictable. Ordinarily the latest-entered rule is the first to be
applied.  Sometimes the previous rule is superseded completely; other
times it stays around as a special case. The order of entering a set of
related LET expressions is very important to their eventual behavior.
The best approach is to assume that the rules will be applied in an
arbitrary order.


File: ..\util\r37,  Node: LINEAR,  Next: LINELENGTH,  Prev: LET,  Up: Declarations section

   LINEAR                    declaration

   An operator can be declared linear in its first argument over powers
of its second argument by the declaration LINEAR.

syntax:

   LINEAR <operator>, <operator>*

   <operator> must have been declared to be an operator. Be careful not
to use a system operator name, because this command may change its
definition.  The operator being declared must have at least two
arguments, and the second one must be a [*note KERNEL::.] .

examples:

     ____________________________________________________________
     
     operator f;
     
     linear f;
     
     f(0,x);
     
       0
     
     
     f(-y,x);
     
       - F(1,X)*Y
     
     
     f(y+z,x);
     
       F(1,X)*(Y + Z)
     
     
     f(y*z,x);
     
       F(1,X)*Y*Z
     
     
     depend z,x;
     
     f(y*z,x);
     
       F(Z,X)*Y
     
     
     f(y/z,x);
     
         1
       F(-,X)*Y
         Z
     
     
     depend y,x;
     
     f(y/z,x);
     
         Y
       F(-,X)
         Z
     
     
     nodepend z,x;
     
     f(y/z,x);
     
       F(Y,X)
       ------
         Z
     
     
     f(2*e**sin(x),x);
     
            SIN(X)
       2*F(E      ,X)
     
     ____________________________________________________________
   Even when the operator has not had its functionality attached, it
exhibits linear properties as shown in the examples. Notice the
difference when dependencies are added. Dependencies are also in effect
when the operator's first argument contains its second, as in the last
line above.

   For a fully-developed example of the use of linear operators, refer
to the article in the <Journal of Computational Physics>, Vol. 14
(1974), pp.  301-317, "Analytic Computation of Some Integrals in Fourth
Order Quantum Electrodynamics," by J.A. Fox and A.C. Hearn. The article
includes the complete listing of REDUCE procedures used for this work.


File: ..\util\r37,  Node: LINELENGTH,  Next: LISP,  Prev: LINEAR,  Up: Declarations section

   LINELENGTH                    declaration

   The LINELENGTH declaration sets the length of the output line.
Default is 80.

syntax:

   LINELENGTH <expression>

   To change the linelength, <expression> must evaluate to a positive
integer less than 128 (although this varies from system to system), and
should not be less than 20 or so for proper operation.

   LINELENGTH returns the previous linelength. If you want the current
linelength value, but not change it, say LINELENGTH NIL .


File: ..\util\r37,  Node: LISP,  Next: LISTARGP,  Prev: LINELENGTH,  Up: Declarations section

   LISP                    command

   The LISP command changes REDUCE's mode of operation to symbolic. When
LISP  is followed by an expression, that expression is evaluated in
symbolic mode, but REDUCE's mode is not changed. This command is
equivalent to [*note SYMBOLIC::.] .

examples:

     ____________________________________________________________
     
     lisp;
     
       NIL
     
     
     car '(a b c d e);
     
       A
     
     
     algebraic;
     
     c := (lisp car '(first second))**2;
     
     
     
                 2
       C := FIRST
     
     ____________________________________________________________


File: ..\util\r37,  Node: LISTARGP,  Next: NODEPEND,  Prev: LISP,  Up: Declarations section

   LISTARGP                    declaration

syntax:

   LISTARGP <operator>, <operator>*

   If an operator other than those specifically defined for lists is
given a single argument that is a [*note LIST::.] , then the result of
this operation will be a list in which that operator is applied to each
element of the list.  This process can be inhibited for a specific
operator, or list of operators, by using the declaration LISTARGP .

examples:

     ____________________________________________________________
     
     log {a,b,c};
     
       LOG(A),LOG(B),LOG(C)
     
     
     listargp log;
     
     log {a,b,c};
     
       LOG(A,B,C)
     
     ____________________________________________________________
   It is possible to inhibit such distribution globally by turning on
the switch [*note LISTARGS::.] . In addition, if an operator has more
than one argument, no such distribution occurs, so LISTARGP has no
effect.


File: ..\util\r37,  Node: NODEPEND,  Next: MATCH,  Prev: LISTARGP,  Up: Declarations section

   NODEPEND                    declaration

   The NODEPEND declaration removes the dependency declared with [*note
DEPEND::.] .

syntax:

   NODEPEND <dep-kernel>,<kernel>+

   <dep-kernel> must be a kernel that has had a dependency declared
upon the one or more other kernels that are its other arguments.

examples:

     ____________________________________________________________
     
     depend y,x,z;
     
     df(sin y,x);
     
       COS(Y)*DF(Y,X)
     
     
     df(sin y,x,z);
     
       COS(Y)*DF(Y,X,Z) - DF(Y,X)*DF(Y,Z)*SIN(Y)
     
     
     nodepend y,z;
     
     df(sin y,x);
     
       COS(Y)*DF(Y,X)
     
     
     df(sin y,x,z);
     
       0
     
     ____________________________________________________________
   A warning message is printed if the dependency had not been declared
by DEPEND .


File: ..\util\r37,  Node: MATCH,  Next: NONCOM,  Prev: NODEPEND,  Up: Declarations section

   MATCH                    command

   The MATCH command is similar to the [*note LET::.] command, except
that it matches only explicit powers in substitution.

syntax:

   MATCH <expr> = <expression>,<expr>  = <expression>*

   <expr> is generally a term involving powers, and is limited by the
rules for the [*note LET::.] command. <expression> may be any valid
REDUCE scalar expression.

examples:

     ____________________________________________________________
     
     match c**2*a**2 = d;
     (a+c)**4;
     
        4       3          3    4
       A   + 4*A *C + 4*A*C  + C  + 6*D
     
     
     match a+b = c;
     
     a + 2*b;
     
       B + C
     
     
     (a + b + c)**2;
     
        2     2               2
       A   - B   + 2*B*C + 3*C
     
     
     clear a+b;
     
     (a + b + c)**2;
     
         2                    2            2
       A   + 2*A*B + 2*A*C + B  + 2*B*C + C
     
     
     let p*r = s;
     
     match p*q = ss;
     
     (a + p*r)**2;
     
        2            2
       A  + 2*A*S + S
     
     
     (a + p*q)**2;
     
        2              2  2
       A   + 2*A*SS + P *Q
     
     ____________________________________________________________
   Note in the last example that A + B has been explicitly matched
after the squaring was done, replacing each single power of A by C - B
. This kind of substitution, although following the rules, is confusing
and could lead to unrecognizable results. It is better to use MATCH
with explicit powers or products only. MATCH should not be used inside
procedures for the same reasons that LET should not be.

   Unlike [*note LET::.] substitutions, MATCH substitutions are executed
after all other operations are complete. The last example shows the
difference. MATCH commands can be cleared by using [*note CLEAR::.] ,
with exactly the expression that the original MATCH took.  MATCH
commands can also be done more generally with FOR ALL or [*note
FORALL::.] ...SUCH THAT  commands.


File: ..\util\r37,  Node: NONCOM,  Next: NONZERO,  Prev: MATCH,  Up: Declarations section

   NONCOM                    declaration

   NONCOM  declares that already-declared operators are noncommutative
under multiplication.

syntax:

   NONCOM <operator>,<operator>*

   <operator> must have been declared an [*note OPERATOR::.] , or a
warning message is given.

examples:

     ____________________________________________________________
     
     operator f,h;
     
     noncom f;
     
     f(a)*f(b) - f(b)*f(a);
     
       F(A)*F(B) - F(B)*F(A)
     
     
     h(a)*h(b) - h(b)*h(a);
     
       0
     
     
     operator comm;
     
     for all x,y such that x neq y and ordp(x,y)
             let f(x)*f(y) = f(y)*f(x) + comm(x,y);
     
     
     f(1)*f(2);
     
       F(1)*F(2)
     
     
     f(2)*f(1);
     
       COMM(2,1) + F(1)*F(2)
     
     ____________________________________________________________
   The last example introduces the commutator of f(x) and f(y) for all
x and y. The equality check is to prevent an infinite loop. The
operator f can have other functionality attached to it if desired, or it
can remain an indeterminate operator.


File: ..\util\r37,  Node: NONZERO,  Next: ODD,  Prev: NONCOM,  Up: Declarations section

   NONZERO                    declaration

syntax:

   NONZERO <identifier>,<identifier>*

   If an [*note OPERATOR::.] F is declared [*note ODD::.] , then F(0)
is replaced by zero unless F is also declared non zero by the
declaration NONZERO .

examples:

     ____________________________________________________________
     
             odd f;
     
             f(0)
     
       0
     
     
             nonzero f;
     
             f(0)
     
       F(0)
     
     ____________________________________________________________


File: ..\util\r37,  Node: ODD,  Next: OFF,  Prev: NONZERO,  Up: Declarations section

   ODD                    declaration

syntax:

   ODD <identifier>,<identifier>*

   This declaration is used to declare an operator odd in its first
argument. Expressions involving an operator declared in this manner are
transformed if the first argument contains a minus sign. Any other
arguments are not affected.

examples:

     ____________________________________________________________
     
             odd f;
     
             f(-a)
     
       -F(A)
     
     
             f(-a,-b)
     
       -F(A,-B)
     
     
             f(a,-b)
     
       F(A,-B)
     
     ____________________________________________________________

   If say F is declared odd, then F(0) is replaced by zero unless F is
also declared non zero by the declaration [*note NONZERO::.] .


File: ..\util\r37,  Node: OFF,  Next: ON,  Prev: ODD,  Up: Declarations section

   OFF                    command

   The OFF command is used to turn switches off.

syntax:

   OFF <switch>,<switch>*

   <switch> can be any SWITCH name. There is no problem if the switch
is already off. If the switch name is mistyped, an error message is
given.


File: ..\util\r37,  Node: ON,  Next: OPERATOR,  Prev: OFF,  Up: Declarations section

   ON                    command

   The ON command is used to turn switches on.

syntax:

   ON <switch>,<switch>*

   <switch> can be any SWITCH name. There is no problem if the switch
is already on. If the switch name is mistyped, an error message is
given.


File: ..\util\r37,  Node: OPERATOR,  Next: ORDER,  Prev: ON,  Up: Declarations section

   OPERATOR                    declaration

   Use the OPERATOR declaration to declare your own operators.

syntax:

   OPERATOR <identifier>,<identifier>*

   <identifier> can be any valid REDUCE identifier, which is not the
name of a [*note MATRIX::.] , [*note ARRAY::.] , scalar variable or
previously-defined operator.

examples:

     ____________________________________________________________
     
     operator dis,fac;
     
     let dis(~x,~y) = sqrt(x^2 + y^2);
     
     dis(1,2);
     
       SQRT(5)
     
     
     dis(a,10);
     
             2
       SQRT(A  + 100)
     
     
     on rounded;
     
     dis(1.5,7.2);
     
       7.35459040329
     
     
     let fac(~n) = if n=0 then 1
                    else if not(fixp n and n>0)
                     then rederr "choose non-negative integer"
                    else for i := 1:n product i;
     
     
     fac(5);
     
       120
     
     
     fac(-2);
     
       ***** choose non-negative integer
     
     ____________________________________________________________
   The first operator is the Euclidean distance metric, the distance of
point (x,y) from the origin. The second operator is the factorial.

   Operators can have various properties assigned to them; they can be
declared [*note INFIX::.] , [*note LINEAR::.] , [*note SYMMETRIC::.] ,
[*note ANTISYMMETRIC::.] , or [*note NONCOM::.] MUTATIVE .  The default
operator is prefix, nonlinear, and commutative.  Precedence can also be
assigned to operators using the declaration [*note PRECEDENCE::.] .

   Functionality is assigned to an operator by a [*note LET::.]
statement or a [*note FORALL::.] ...LET  statement, (or possibly by a
procedure with the name of the operator). Be careful not to redefine a
system operator by accident. REDUCE permits you to redefine system
operators, giving you a warning message that the operator was already
defined. This flexibility allows you to add mathematical rules that do
what you want them to do, but can produce odd or erroneous behavior if
you are not careful.

   You can declare operators from inside [*note PROCEDURE::.] s, as
long as they are not local variables. Operators defined inside
procedures are global.  A formal parameter may be declared as an
operator, and has the effect of declaring the calling variable as the
operator.


File: ..\util\r37,  Node: ORDER,  Next: PRECEDENCE,  Prev: OPERATOR,  Up: Declarations section

   ORDER                    declaration

   The ORDER declaration changes the order of precedence of kernels for
display purposes only.

syntax:

   ORDER <identifier>,<identifier>*

   <kernel> must be a valid [*note KERNEL::.] or [*note OPERATOR::.]
name complete with argument or a [*note LIST::.] of such objects.

examples:

     ____________________________________________________________
     
     x + y + z + cos(a);
     
       COS(A) + X + Y + Z
     
     
     order z,y,x,cos(a);
     
     x + y + z + cos(a);
     
       Z + Y + X + COS(A)
     
     
     (x + y)**2;
     
        2            2
       Y  + 2*Y*X + X
     
     
     order nil;
     
     (z + cos(z))**2;
     
             2                 2
       COS(Z)  + 2*COS(Z)*Z + Z
     
     ____________________________________________________________
   ORDER affects the printing order of the identifiers only; internal
order is unchanged. Change internal order of evaluation with the
declaration [*note KORDER::.] . You can use ORDER to feature variables
or functions you are particularly interested in.

   Declarations made with ORDER are cumulative: kernels in new order
declarations are ordered behind those in previous declarations, and
previous declarations retain their relative order. Of course, specific
kernels named in new declarations are removed from previous ones and
given the new priority. Return to the standard canonical printing order
with the statement ORDER NIL .

   The print order specified by ORDER commands is not in effect if the
switch [*note PRI::.] is off.


File: ..\util\r37,  Node: PRECEDENCE,  Next: PRECISION,  Prev: ORDER,  Up: Declarations section

   PRECEDENCE                    declaration

   The PRECEDENCE declaration attaches a precedence to an infix
operator.

syntax:

   PRECEDENCE <operator>,<known_operator>

   <operator> should have been declared an operator but may be a REDUCE
identifier that is not already an operator, array, or matrix.
<known_operator> must be a system infix operator or have had its
precedence already declared.

examples:

     ____________________________________________________________
     
     operator f,h;
     
     precedence f,+;
     
     precedence h,*;
     
     a + f(1,2)*c;
     
       (1 F 2)*C + A
     
     
     a + h(1,2)*c;
     
       1 H 2*C + A
     
     
     a*1 f 2*c;
     
       A F 2*C
     
     
     a*1 h 2*c;
     
       1 H 2*A*C
     
     ____________________________________________________________
   The operator whose precedence is being declared is inserted into the
infix operator precedence list at the next higher place than
<known_operator>.

   Attaching a precedence to an operator has the side effect of
declaring the operator to be infix. If the identifier argument for
PRECEDENCE has not been declared to be an operator, an attempt to use
it causes an error message. After declaring it to be an operator, it
becomes an infix operator with the precedence previously given. Infix
operators may be used in prefix form; if they are used in infix form, a
space must be left on each side of the operator to avoid ambiguity.
Declared infix operators are always binary.

   To see the infix operator precedence list, enter symbolic mode and
type PRECLIS!*; . The lowest precedence operator is listed first.

   All prefix operators have precedence higher than infix operators.


File: ..\util\r37,  Node: PRECISION,  Next: PRINT_PRECISION,  Prev: PRECEDENCE,  Up: Declarations section

   PRECISION                    declaration

   The PRECISION declaration sets the number of decimal places used when
[*note ROUNDED::.]  is on. Default is system dependent, and normally
about 12.

syntax:

   PRECISION (<integer>) or PRECISION <integer>

   <integer> must be a positive integer. When <integer> is 0, the
current precision is displayed, but not changed. There is no upper
limit, but precision of greater than several hundred causes
unpleasantly slow operation on numeric calculations.

examples:

     ____________________________________________________________
     
     on rounded;
     
     7/9;
     
       0.777777777778
     
     
     precision 20;
     
       20
     
     
     7/9;
     
       0.77777777777777777778
     
     
     sin(pi/4);
     
       0.7071067811865475244
     
     ____________________________________________________________
   Trailing zeroes are dropped, so sometimes fewer than 20 decimal
places are printed as in the last example. Turn on the switch [*note
FULLPREC::.] if you want to print all significant digits. The [*note
ROUNDED::.] mode carries calculations to two more places than given by
PRECISION , and rounds off.


File: ..\util\r37,  Node: PRINT_PRECISION,  Next: REAL,  Prev: PRECISION,  Up: Declarations section

   PRINT_PRECISION                    declaration

syntax:

   PRINT_PRECISION (<integer>)  or PRINT_PRECISION <integer>

   In [*note ROUNDED::.] mode, numbers are normally printed to the
specified precision. If the user wishes to print such numbers with less
precision, the printing precision can be set by the declaration
PRINT_PRECISION .

examples:

     ____________________________________________________________
     
     on rounded;
     
     1/3;
     
       0.333333333333
     
     
     print_precision 5;
     
     1/3
     
       0.33333
     
     ____________________________________________________________


File: ..\util\r37,  Node: REAL,  Next: REMFAC,  Prev: PRINT_PRECISION,  Up: Declarations section

   REAL                    declaration

   The REAL declaration must be made immediately after a [*note
BEGIN::.]  (or other variable declaration such as [*note INTEGER::.]
and [*note SCALAR::.] ) and declares local integer variables. They are
initialized to zero.

syntax:

   REAL <identifier>,<identifier>*

   <identifier> may be any valid REDUCE identifier, except T  or NIL .

   Real variables remain local, and do not share values with variables
of the same name outside the [*note BEGIN::.] ...END  block. When the
block is finished, the variables are removed. You may use the words
[*note INTEGER::.]  or [*note SCALAR::.] in the place of REAL .  REAL
does not indicate typechecking by the current REDUCE; it is only for
your own information. Declaration statements must immediately follow
the BEGIN , without a semicolon between BEGIN and the first variable
declaration.

   Any variables used inside a BEGIN ...END  [*note block::.] that were
not declared SCALAR , REAL or INTEGER are global, and any change made
to them inside the block affects their global value. Any [*note
ARRAY::.] or [*note MATRIX::.] declared inside a block is always global.


File: ..\util\r37,  Node: REMFAC,  Next: SCALAR,  Prev: REAL,  Up: Declarations section

   REMFAC                    declaration

   The REMFAC declaration removes the special factoring treatment of its
arguments that was declared with [*note FACTOR::.] .

syntax:

   REMFAC <kernel>,<kernel>+

   <kernel> must be a [*note KERNEL::.] or [*note OPERATOR::.] name that
was declared as special with the [*note FACTOR::.] declaration.


File: ..\util\r37,  Node: SCALAR,  Next: SCIENTIFIC_NOTATION,  Prev: REMFAC,  Up: Declarations section

   SCALAR                    declaration

   The SCALAR declaration must be made immediately after a [*note
BEGIN::.]  (or other variable declaration such as [*note INTEGER::.]
and [*note REAL::.] ) and declares local scalar variables. They are
initialized to 0.

syntax:

   SCALAR <identifier>,<identifier>*

   <identifier> may be any valid REDUCE identifier, except T or NIL .

   Scalar variables remain local, and do not share values with
variables of the same name outside the [*note BEGIN::.] ...END  [*note
block::.] .  When the block is finished, the variables are removed. You
may use the words [*note REAL::.] or [*note INTEGER::.] in the place of
SCALAR .  REAL  and INTEGER do not indicate typechecking by the current
REDUCE; they are only for your own information. Declaration statements
must immediately follow the BEGIN , without a semicolon between BEGIN
and the first variable declaration.

   Any variables used inside BEGIN ...END  blocks that were not
declared SCALAR , REAL or INTEGER are global, and any change made to
them inside the block affects their global value. Arrays declared
inside a block are always global.


File: ..\util\r37,  Node: SCIENTIFIC_NOTATION,  Next: SHARE,  Prev: SCALAR,  Up: Declarations section

   SCIENTIFIC_NOTATION                    declaration

syntax:

   SCIENTIFIC_NOTATION (<m>) or SCIENTIFIC_NOTATION (<m>,<n>)

   <m> and <n> are positive integers.  SCIENTIFIC_NOTATION  controls
the output format of floating point numbers. At the default settings,
any number with five or less digits before the decimal point is printed
in a fixed-point notation, e.g., 12345.6. Numbers with more than five
digits are printed in scientific notation, e.g., 1.234567E+5.
Similarly, by default, any number with eleven or more zeros after the
decimal point is printed in scientific notation.

   When SCIENTIFIC_NOTATION is called with the numerical argument  m a
number with more than m digits before the decimal point, or m or more
zeros after the decimal point, is printed in scientific notation. When
SCIENTIFIC_NOTATION is called with a list <m>,<n>, a number with more
than m digits before the decimal point, or n or more zeros after the
decimal point is printed in scientific notation.

examples:

     ____________________________________________________________
     
     
     on rounded;
     
     
     12345.6;
     
       12345.6
     
     
     
     123456.5;
     
       1.234565e+5
     
     
     
     0.00000000000000012;
     
       1.2e-16
     
     
     
     scientific_notation 20;
     
       5,11
     
     
     
     5: 123456.7;
     
       123456.7
     
     
     
     0.00000000000000012;
     
       0.00000000000000012
     
     ____________________________________________________________


File: ..\util\r37,  Node: SHARE,  Next: SYMBOLIC,  Prev: SCIENTIFIC_NOTATION,  Up: Declarations section

   SHARE                    declaration

   The SHARE declaration allows access to its arguments by both
algebraic and symbolic modes.

syntax:

   SHARE <identifier>,<identifier>*

   <identifier> can be any valid REDUCE identifier.

   Programming in [*note SYMBOLIC::.] as well as algebraic mode allows
you a wider range of techniques than just algebraic mode alone.
Expressions do not cross the boundary since they have different
representations, unless the SHARE declaration is used. For more
information on using symbolic mode, see the <REDUCE User's Manual>, and
the <Standard Lisp Report>.

   You should be aware that a previously-declared array is destroyed by
the SHARE  declaration. Scalar variables retain their values. You can
share a declared [*note MATRIX::.] that has not yet been dimensioned so
that it can be used by both modes. Values that are later put into the
matrix are accessible from symbolic mode too, but not by the usual
matrix reference mechanism. In symbolic mode, a matrix is stored as a
list whose first element is [*note MAT::.] , and whose next elements
are the rows of the matrix stored as lists of the individual elements.
Access in symbolic mode is by the operators [*note FIRST::.] , [*note
SECOND::.] , [*note THIRD::.] and [*note REST::.] .


File: ..\util\r37,  Node: SYMBOLIC,  Next: SYMMETRIC,  Prev: SHARE,  Up: Declarations section

   SYMBOLIC                    command

   The SYMBOLIC command changes REDUCE's mode of operation to symbolic.
When SYMBOLIC is followed by an expression, that expression is
evaluated in symbolic mode, but REDUCE's mode is not changed. It is
equivalent to the [*note LISP::.] command.

examples:

     ____________________________________________________________
     
     symbolic;
     
       NIL
     
     
     cdr '(a b c);
     
       (B C)
     
     
     algebraic;
     
     x + symbolic car '(y z);
     
       X + Y
     
     ____________________________________________________________


File: ..\util\r37,  Node: SYMMETRIC,  Next: TR,  Prev: SYMBOLIC,  Up: Declarations section

   SYMMETRIC                    declaration

   When an operator is declared SYMMETRIC , its arguments are reordered
to conform to the internal ordering of the system.

syntax:

   SYMMETRIC <identifier>,<identifier>*

   <identifier> is an identifier that has been declared an operator.

examples:

     ____________________________________________________________
     
     operator m,n;
     
     symmetric m,n;
     
     m(y,a,sin(x));
     
       M(SIN(X),A,Y)
     
     
     n(z,m(b,a,q));
     
       N(M(A,B,Q),Z)
     
     ____________________________________________________________
   If <identifier> has not been declared to be an operator, the flag
SYMMETRIC  is still attached to it. When <identifier> is subsequently
used as an operator, the message DECLARE <identifier>  OPERATOR ? (Y OR
N) is printed. If the user replies Y , the symmetric property of the
operator is used.


File: ..\util\r37,  Node: TR,  Next: UNTR,  Prev: SYMMETRIC,  Up: Declarations section

   TR                    declaration

   The TR declaration is used to trace system or user-written
procedures.  It is only useful to those with a good knowledge of both
Lisp and the internal formats used by REDUCE.

syntax:

   TR <name>,<name>*

   <name> is the name of a REDUCE system procedure or one of your own
procedures.

examples:

     ____________________________________________________________
     ____________________________________________________________
   The system procedure PREPSQ is traced,  which prepares REDUCE
standard forms for printing by converting them to a Lisp prefix form.
     ____________________________________________________________
     
     
     tr prepsq;
     
       (PREPSQ)
     
     
     x**2 + y;
     
       PREPSQ entry:
         Arg 1: (((((X . 2) . 1) ((Y . 1) . 1)) . 1)
       PREPSQ return value = (PLUS (EXPT X 2) Y)
       PREPSQ entry:
         Arg 1: (1 . 1)
       PREPSQ return value = 1
        2
       X  + Y
     
     
     untr prepsq;
     
       (PREPSQ)
     
     ____________________________________________________________

   This example is for a PSL-based system; the above format will vary if
other Lisp systems are used.

   When a procedure is traced, the first lines show entry to the
procedure and the arguments it is given. The value returned by the
procedure is printed upon exit. If you are tracing several procedures,
with a call to one of them inside the other, the inner trace will be
indented showing procedure nesting. There are no trace options.
However, the format of the trace depends on the underlying Lisp system
used. The trace can be removed with the command [*note UNTR::.] . Note
that TRACE , below, is a matrix operator, while TR does procedure
tracing.


File: ..\util\r37,  Node: UNTR,  Next: VARNAME,  Prev: TR,  Up: Declarations section

   UNTR                    declaration

   The UNTR declaration is used to remove a trace from system or
user-written procedures declared with [*note TR::.] . It is only useful
to those with a good knowledge of both Lisp and the internal formats
used by REDUCE.

syntax:

   UNTR <name>,<name>*

   <name> is the name of a REDUCE system procedure or one of your own
procedures that has previously been the argument of a TR declaration.


File: ..\util\r37,  Node: VARNAME,  Next: WEIGHT,  Prev: UNTR,  Up: Declarations section

   VARNAME                    declaration

   The declaration VARNAME instructs REDUCE to use its argument as the
default Fortran (when [*note FORT::.] is on) or [*note STRUCTR::.]
identifier and identifier stem, rather than using ANS .

syntax:

   VARNAME <identifier>

   <identifier> can be any combination of one or more alphanumeric
characters. Try to avoid REDUCE reserved words.

examples:

     ____________________________________________________________
     
     varname ident;
     
       IDENT
     
     
     on fort;
     
     x**2 + 1;
     
       IDENT=X**2+1.
     
     
     off fort,exp;
     
     structr(((x+y)**2 + z)**3);
     
             3
       IDENT2
           where
                              2
              IDENT2 := IDENT1  + Z
       IDENT1 := X + Y
     
     ____________________________________________________________
   [*note EXP::.] was turned off so that [*note STRUCTR::.] could show
the structure. If EXP had been on, the expression would have been
expanded into a polynomial.


File: ..\util\r37,  Node: WEIGHT,  Next: WHERE,  Prev: VARNAME,  Up: Declarations section

   WEIGHT                    command

   The WEIGHT command is used to attach weights to kernels for
asymptotic constraints.

syntax:

   WEIGHT <kernel> = <number>

   <kernel> must be a REDUCE [*note KERNEL::.] , <number> must be a
positive integer, not 0.

examples:

     ____________________________________________________________
     
     a := (x+y)**4;
     
             4      3        2  2        3    4
       A := X  + 4*X *Y + 6*X *Y  + 4*X*Y  + Y
     
     
     weight x=2,y=3;
     
     wtlevel 8;
     
     a;
     
        4
       X
     
     
     wtlevel 10;
     
     a;
     
        2     2             2
       X *(6*Y  + 4*X*Y  + X )
     
     
     int(x**2,x);
     
       ***** X invalid as KERNEL
     
     ____________________________________________________________
   Weights and [*note WTLEVEL::.] are used for asymptotic constraints,
where higher-order terms are considered insignificant.

   Weights are originally equivalent to 0 until set by a WEIGHT
command. To remove a weight from a kernel, use the [*note CLEAR::.]
command. Weights once assigned cannot be changed without clearing the
identifier. Once a weight is assigned to a kernel, it is no longer a
kernel and cannot be used in any REDUCE commands or operators that
require kernels, until the weight is cleared. Note that terms are
ordered by greatest weight.

   The weight level of the system is set by [*note WTLEVEL::.] ,
initially at 2. Since no kernels have weights, no effect from WTLEVEL
can be seen. Once you assign weights to kernels, you must set WTLEVEL
correctly for the desired operation. When weighted variables appear in a
term, their weights are summed for the total weight of the term (powers
of variables multiply their weights). When a term exceeds the weight
level of the system, it is discarded from the result expression.


File: ..\util\r37,  Node: WHERE,  Next: WHILE,  Prev: WEIGHT,  Up: Declarations section

   WHERE                    operator

   The WHERE operator provides an infix notation for one-time
substitutions for kernels in expressions.

syntax:

   <expression> WHERE <kernel>  = <expression>  ,<kernel> =
<expression>*

   <expression> can be any REDUCE scalar expression, <kernel> must be a
[*note KERNEL::.] . Alternatively a [*note RULE::.] or a RULE LIST can
be a member of the right-hand part of a WHERE expression.

examples:

     ____________________________________________________________
     
     x**2 + 17*x*y + 4*y**2 where x=1,y=2;
     
     
       51
     
     
     for i := 1:5 collect x**i*q where q= for j := 1:i product j;
     
     
     
             2    3     4      5
       {X,2*X ,6*X ,24*X ,120*X }
     
     
     x**2 + y + z where z=y**3,y=3;
     
        2    3
       X  + Y  + 3
     
     ____________________________________________________________
   Substitution inside a WHERE expression has no effect upon the values
of the kernels outside the expression. The WHERE operator has the
lowest precedence of all the infix operators, which are lower than
prefix operators, so that the substitutions apply to the entire
expression preceding the WHERE operator. However, WHERE is applied
before command keywords such as THEN , REPEAT , or DO .

   A [*note RULE::.] or a RULE SET in the right-hand part of the WHERE
expression act as if the rules were activated by [*note LET::.]
immediately before the evaluation of the expression and deactivated by
[*note CLEARRULES::.] immediately afterwards.

   WHERE gives you a natural notation for auxiliary variables in
expressions. As the second example shows, the substitute expression can
be a command to be evaluated. The substitute assignments are made in
parallel, rather than sequentially, as the last example shows. The
expression resulting from the first round of substitutions is not
reexamined to see if any further such substitutions can be made.  WHERE
can also be used to define auxiliary variables in [*note PROCEDURE::.]
definitions.


File: ..\util\r37,  Node: WHILE,  Next: WTLEVEL,  Prev: WHERE,  Up: Declarations section

   WHILE                    command

   The WHILE command causes a statement to be repeatedly executed until
a given condition is true. If the condition is initially false, the
statement is not executed at all.

syntax:

   WHILE <condition> DO <statement>

   <condition> is given by a logical operator, <statement> must be a
single REDUCE statement, or a [*note group::.] (<< ...>> ) or [*note
BEGIN::.] ...END  [*note block::.] .

examples:

     ____________________________________________________________
     
     a := 10;
     
       A := 10
     
     
     while a <= 12 do <<write a; a := a + 1>>;
     
     
     
       10
     
     
                                               11
     
                                               12
     
     while a < 5 do <<write a; a := a + 1>>;
     
     
     
           nothing is printed
     
     ____________________________________________________________


File: ..\util\r37,  Node: WTLEVEL,  Prev: WHILE,  Up: Declarations section

   WTLEVEL                    command

   In conjunction with [*note WEIGHT::.] , WTLEVEL is used to implement
asymptotic constraints. Its default value is 2.

syntax:

   WTLEVEL <expression>

   To change the weight level, <expression> must evaluate to a positive
integer that is the greatest weight term to be retained in expressions
involving kernels with weight assignments. WTLEVEL returns the new
weight level. If you want the current weight level, but not change it,
say WTLEVEL NIL .

examples:

     ____________________________________________________________
     
     (x+y)**4;
     
     
        4      3        2  2        3    4
       X  + 4*X *Y + 6*X *Y  + 4*X*Y  + Y
     
     
     weight x=2,y=3;
     
     wtlevel 8;
     
     (x+y)**4;
     
        4
       X
     
     
     wtlevel 10;
     
     (x+y)**4;
     
        2     2            2
       X *(6*Y  + 4*X*Y + X )
     
     
     int(x**2,x);
     
       ***** X invalid as KERNEL
     
     ____________________________________________________________
   WTLEVEL is used in conjunction with the command [*note WEIGHT::.] to
enable asymptotic constraints. Weight of a term is computed by
multiplying the weights of each variable in it by the power to which it
has been raised, and adding the resulting weights for each variable. If
the weight of the term is greater than WTLEVEL , the term is dropped
from the expression, and not used in any further computation involving
the expression.

   Once a weight has been attached to a [*note KERNEL::.] , it is no
longer recognized by the system as a kernel, though still a variable.
It cannot be used in REDUCE commands and operators that need kernels.
The weight attachment can be undone with a [*note CLEAR::.] command.
WTLEVEL can be changed as desired.


File: ..\util\r37,  Node: Declarations section,  Next: Input and Output section,  Prev: Algebraic Operators section,  Up: Top

   Declarations section

* Menu:

* ALGEBRAIC::               command
* ANTISYMMETRIC::           declaration
* ARRAY::                   declaration
* CLEAR::                   command
* CLEARRULES::              command
* DEFINE::                  command
* DEPEND::                  declaration
* EVEN::                    declaration
* FACTOR declaration::      declaration
* FORALL::                  command
* INFIX::                   declaration
* INTEGER::                 declaration
* KORDER::                  declaration
* LET::                     command
* LINEAR::                  declaration
* LINELENGTH::              declaration
* LISP::                    command
* LISTARGP::                declaration
* NODEPEND::                declaration
* MATCH::                   command
* NONCOM::                  declaration
* NONZERO::                 declaration
* ODD::                     declaration
* OFF::                     command
* ON::                      command
* OPERATOR::                declaration
* ORDER::                   declaration
* PRECEDENCE::              declaration
* PRECISION::               declaration
* PRINT_PRECISION::        declaration
* REAL::                    declaration
* REMFAC::                  declaration
* SCALAR::                  declaration
* SCIENTIFIC_NOTATION::    declaration
* SHARE::                   declaration
* SYMBOLIC::                command
* SYMMETRIC::               declaration
* TR::                      declaration
* UNTR::                    declaration
* VARNAME::                 declaration
* WEIGHT::                  command
* WHERE::                   operator
* WHILE::                   command
* WTLEVEL::                 command


File: ..\util\r37,  Node: IN,  Next: INPUT,  Up: Input and Output section

   IN                    command

   The IN command takes a list of file names and inputs each file into
the system.

syntax:

   IN <filename>,<filename>*

   <filename> must be in the current directory, or be a valid pathname.
If the file name is not an identifier, double quote marks (" ) are
needed around the file name.

   A message is given if the file cannot be found, or has a mistake in
it.

   Ending the command with a semicolon causes the file to be echoed to
the screen; ending it with a dollar sign does not echo the file. If you
want some but not all of a file echoed, turn the switch [*note ECHO::.]
on or off in the file.

   An efficient way to develop procedures in REDUCE is to write them
into a file using a system editor of your choice, and then input the
files into an active REDUCE session. REDUCE reparses the procedure as
it takes information from the file, overwriting the previous procedure
definition. When it accepts the procedure, it echoes its name to the
screen.  Data can also be input to the system from files.

   Files to be read in should always end in [*note END::.] ; to avoid
end-of-file problems. Note that this is an additional END; to any
ending procedures in the file.


File: ..\util\r37,  Node: INPUT,  Next: OUT,  Prev: IN,  Up: Input and Output section

   INPUT                    command

   The INPUT command returns the input expression to the REDUCE numbered
prompt that is its argument.

syntax:

   INPUT (<number>) or INPUT <number>

   <number> must be between 1 and the current REDUCE prompt number.

   An expression brought back by INPUT can be reexecuted with new
values or switch settings, or used as an argument in another expression.
The command [*note WS::.] brings back the results of a numbered REDUCE
statement. Two lists contain every input and every output statement
since the beginning of the session. If your session is very long,
storage space begins to fill up with these expressions, so it is a good
idea to end the session once in a while, saving needed expressions to
files with the [*note SAVEAS::.]  and [*note OUT::.] commands.

   Switch settings and [*note LET::.] statements can also be reexecuted
by using INPUT .

   An error message is given if a number is called for that has not yet
been used.


File: ..\util\r37,  Node: OUT,  Next: SHUT,  Prev: INPUT,  Up: Input and Output section

   OUT                    command

   The OUT command directs output to the filename that is its argument,
until another OUT changes the output file, or [*note SHUT::.] closes it.

syntax:

   OUT <filename> or OUT " <pathname> " or OUT T

   <filename> must be in the current directory, or be a valid complete
file description for your system. If the file name is not in the
current directory, quote marks are needed around the file name.  If the
file already exists, a message is printed allowing you to decide
whether to supersede the contents of the file with new material.

   To restore output to the terminal, type OUT T , or [*note SHUT::.]
the file. When you use OUT T , the file remains available, and if you
open it again (with another OUT ), new material is appended rather than
overwriting.

   To write a file using OUT that can be input at a later time, the
switch [*note NAT::.] must be turned off, so that the standard linear
form is saved that can be read in by [*note IN::.] . If NAT is on,
exponents are printed on the line above the expression, which causes
trouble when REDUCE tries to read the file.

   There is a slight complication if you are using the OUT command from
inside a file to create another file. The [*note ECHO::.] switch is
normally off at the top-level and on while reading files (so you can
see what is being read in). If you create a file using OUT at the
top-level, the result lines are printed into the file as you want them.
But if you create such a file from inside a file, the ECHO switch is
on, and every line is echoed, first as you typed it, then as REDUCE
parsed it, and then once more for the file. Therefore, when you create
a file from a file, you need to turn ECHO off explicitly before the OUT
command, and turn it back on when you SHUT the created file, so your
executing file echoes as it should. This behavior also means that as you
watch the file execute, you cannot see the lines that are being put into
the OUT file. As soon as you turn ECHO on, you can see output again.


File: ..\util\r37,  Node: SHUT,  Prev: OUT,  Up: Input and Output section

   SHUT                    command

   The SHUT command closes output files.

syntax:

   SHUT <filename>,<filename>*

   <filename> must have been a file opened by [*note OUT::.] .

   A file that has been opened by [*note OUT::.] must be SHUT before it
is brought in by [*note IN::.] . Files that have been opened by OUT
should always be SHUT before the end of the REDUCE session, to avoid
either loss of information or the printing of extraneous information
into the file.  In most systems, terminating a session by [*note
BYE::.] closes all open output files.


File: ..\util\r37,  Node: Input and Output section,  Next: Elementary Functions section,  Prev: Declarations section,  Up: Top

   Input and Output section

* Menu:

* IN::                      command
* INPUT::                   command
* OUT::                     command
* SHUT::                    command


File: ..\util\r37,  Node: ACOS,  Next: ACOSH,  Up: Elementary Functions section

   ACOS                    operator

   The ACOS operator returns the arccosine of its argument.

syntax:

   ACOS (<expression>) or ACOS <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     acos(ab);
     
       ACOS(AB)
     
     
     acos 15;
     
       ACOS(15)
     
     
     df(acos(x*y),x);
     
                2  2
       SQRT( - X *Y  + 1)*Y
       --------------------
             2  2
            X *Y  - 1
     
     
     on rounded;
     
     res := acos(sqrt(2)/2);
     
       RES := 0.785398163397
     
     
     res-pi/4;
     
       0
     
     ____________________________________________________________
   An explicit numeric value is not given unless the switch [*note
ROUNDED::.] is on and the argument has an absolute numeric value less
than or equal to 1.


File: ..\util\r37,  Node: ACOSH,  Next: ACOT,  Prev: ACOS,  Up: Elementary Functions section

   ACOSH                    operator

   ACOSH  represents the hyperbolic arccosine of its argument. It takes
an arbitrary scalar expression as its argument. The derivative of ACOSH
is known to the system. Numerical values may also be found by turning
on the switch [*note ROUNDED::.] .

syntax:

   ACOSH (<expression>) or ACOSH <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     acosh a;
     
       ACOSH(A)
     
     
     acosh(0);
     
       ACOSH(0)
     
     
     df(acosh(a**2),a);
     
               4
       2*SQRT(A  - 1)*A
       ----------------
             4
            A  - 1
     
     
     int(acosh(x),x);
     
       INT(ACOSH(X),X)
     
     ____________________________________________________________
   You may attach functionality by defining ACOSH to be the inverse of
COSH . This is done by the commands
     ____________________________________________________________
     
             put('cosh,'inverse,'acosh);
             put('acosh,'inverse,'cosh);
     ____________________________________________________________

   You can write a procedure to attach integrals or other functions to
ACOSH . You may wish to add a check to see that its argument is
properly restricted.


File: ..\util\r37,  Node: ACOT,  Next: ACOTH,  Prev: ACOSH,  Up: Elementary Functions section

   ACOT                    operator

   ACOT  represents the arccotangent of its argument. It takes an
arbitrary scalar expression as its argument. The derivative of ACOT  is
known to the system. Numerical values may also be found by turning on
the switch [*note ROUNDED::.] .

syntax:

   ACOT (<expression>) or ACOT <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.  You can add
functionality yourself with LET and procedures.


File: ..\util\r37,  Node: ACOTH,  Next: ACSC,  Prev: ACOT,  Up: Elementary Functions section

   ACOTH                    operator

   ACOTH  represents the inverse hyperbolic cotangent of its argument.
It takes an arbitrary scalar expression as its argument. The derivative
of ACOTH is known to the system. Numerical values may also be found by
turning on the switch [*note ROUNDED::.] .

syntax:

   ACOTH (<expression>) or ACOTH <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name. You can add
functionality yourself with LET and procedures.


File: ..\util\r37,  Node: ACSC,  Next: ACSCH,  Prev: ACOTH,  Up: Elementary Functions section

   ACSC                    operator

   The ACSC operator returns the arccosecant of its argument.

syntax:

   ACSC (<expression>) or ACSC <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     acsc(ab);
     
       ACSC(AB)
     
     
     acsc 15;
     
       ACSC(15)
     
     
     df(acsc(x*y),x);
     
              2  2
       -SQRT(X *Y  - 1)
       ----------------
            2  2
        X*(X *Y  - 1)
     
     
     on rounded;
     
     res := acsc(2/sqrt(3));
     
       RES := 1.0471975512
     
     
     res-pi/3;
     
       0
     
     ____________________________________________________________
   An explicit numeric value is not given unless the switch ROUNDED is
on and the argument has an absolute numeric value less than or equal to
1.


File: ..\util\r37,  Node: ACSCH,  Next: ASEC,  Prev: ACSC,  Up: Elementary Functions section

   ACSCH                    operator

   The ACSCH operator returns the hyperbolic arccosecant of its
argument.

syntax:

   ACSCH (<expression>) or ACSCH <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     acsch(ab);
     
       ACSCH(AB)
     
     
     acsch 15;
     
       ACSCH(15)
     
     
     df(acsch(x*y),x);
     
              2  2
       -SQRT(X *Y  + 1)
       ----------------
            2  2
        X*(X *Y  + 1)
     
     
     on rounded;
     
     res := acsch(3);
     
       RES := 0.327450150237
     
     ____________________________________________________________
   An explicit numeric value is not given unless the switch ROUNDED is
on and the argument has an absolute numeric value less than or equal to
1.


File: ..\util\r37,  Node: ASEC,  Next: ASECH,  Prev: ACSCH,  Up: Elementary Functions section

   ASEC                    operator

   The ASEC operator returns the arccosecant of its argument.

syntax:

   ASEC (<expression>) or ASEC <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     asec(ab);
     
       ASEC(AB)
     
     
     asec 15;
     
       ASEC(15)
     
     
     df(asec(x*y),x);
     
             2  2
       SQRT(X *Y  - 1)
       ---------------
            2  2
        X*(X *Y  - 1)
     
     
     on rounded;
     
     res := asec sqrt(2);
     
       RES := 0.785398163397
     
     
     res-pi/4;
     
       0
     
     ____________________________________________________________
   An explicit numeric value is not given unless the switch ROUNDED is
on and the argument has an absolute numeric value greater or equal to 1.


File: ..\util\r37,  Node: ASECH,  Next: ASIN,  Prev: ASEC,  Up: Elementary Functions section

   ASECH                    operator

   ASECH  represents the hyperbolic arccosecant of its argument. It
takes an arbitrary scalar expression as its argument. The derivative of
ASECH  is known to the system. Numerical values may also be found by
turning on the switch [*note ROUNDED::.] .

syntax:

   ASECH (<expression>) or ASECH <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     asech a;
     
       ASECH(A)
     
     
     asech(1);
     
       0
     
     
     df(acosh(a**2),a);
     
                 4
       2*SQRT(- A  + 1)
       ----------------
              4
          A*(A  - 1)
     
     
     int(asech(x),x);
     
       INT(ASECH(X),X)
     
     ____________________________________________________________
   You may attach functionality by defining ASECH to be the inverse of
SECH . This is done by the commands
     ____________________________________________________________
     
             put('sech,'inverse,'asech);
             put('asech,'inverse,'sech);
     ____________________________________________________________

   You can write a procedure to attach integrals or other functions to
ASECH . You may wish to add a check to see that its argument is
properly restricted.


File: ..\util\r37,  Node: ASIN,  Next: ASINH,  Prev: ASECH,  Up: Elementary Functions section

   ASIN                    operator

   The ASIN operator returns the arcsine of its argument.

syntax:

   ASIN (<expression>) or ASIN <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     asin(givenangle);
     
       ASIN(GIVENANGLE)
     
     
     asin(5);
     
       ASIN(5)
     
     
     df(asin(2*x),x);
     
                      2
         2*SQRT( - 4*X  + 1))
       - --------------------
                  2
               4*X  - 1
     
     
     on rounded;
     
     asin .5;
     
       0.523598775598
     
     
     asin(sqrt(3));
     
       ASIN(1.73205080757)
     
     
     asin(sqrt(3)/2);
     
       1.04719755120
     
     ____________________________________________________________
   A numeric value is not returned by ASIN unless the switch ROUNDED
is on and its argument has an absolute value less than or equal to 1.


File: ..\util\r37,  Node: ASINH,  Next: ATAN,  Prev: ASIN,  Up: Elementary Functions section

   ASINH                    operator

   The ASINH operator returns the hyperbolic arcsine of its argument.
The derivative of ASINH and some simple transformations are known to
the system.

syntax:

   ASINH (<expression>) or ASINH <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     asinh d;
     
       ASINH(D)
     
     
     asinh(1);
     
       ASINH(1)
     
     
     df(asinh(2*x),x);
     
                 2
       2*SQRT(4*X  + 1))
       -----------------
              2
           4*X  + 1
     
     ____________________________________________________________
   You may attach further functionality by defining ASINH to be the
inverse of SINH . This is done by the commands
     ____________________________________________________________
     
             put('sinh,'inverse,'asinh);
             put('asinh,'inverse,'sinh);
     ____________________________________________________________

   A numeric value is not returned by ASINH unless the switch ROUNDED
is on and its argument evaluates to a number.


File: ..\util\r37,  Node: ATAN,  Next: ATANH,  Prev: ASINH,  Up: Elementary Functions section

   ATAN                    operator

   The ATAN operator returns the arctangent of its argument.

syntax:

   ATAN (<expression>) or ATAN <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     atan(middle);
     
       ATAN(MIDDLE)
     
     
     on rounded;
     
     atan 45;
     
       1.54857776147
     
     
     off rounded;
     
     int(atan(x),x);
     
                          2
       2*ATAN(X)*X - LOG(X  + 1)
       -------------------------
                   2
     
     
     df(atan(y**2),y);
     
        2*Y
       -------
        4
       Y  + 1
     
     ____________________________________________________________
   A numeric value is not returned by ATAN unless the switch [*note
ROUNDED::.]  is on and its argument evaluates to a number.


File: ..\util\r37,  Node: ATANH,  Next: ATAN2,  Prev: ATAN,  Up: Elementary Functions section

   ATANH                    operator

   The ATANH operator returns the hyperbolic arctangent of its argument.
The derivative of ASINH and some simple transformations are known to
the system.

syntax:

   ATANH (<expression>) or ATANH <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     atanh aa;
     
       ATANH(AA)
     
     
     atanh(1);
     
       ATANH(1)
     
     
     df(atanh(x*y),y);
     
          - X
       ----------
        2  2
       X *Y  - 1
     
     ____________________________________________________________
   A numeric value is not returned by ASINH unless the switch ROUNDED
is on and its argument evaluates to a number.  You may attach
additional functionality by defining ATANH to be the inverse of TANH .
This is done by the commands

     ____________________________________________________________
     
             put('tanh,'inverse,'atanh);
             put('atanh,'inverse,'tanh);
     ____________________________________________________________


File: ..\util\r37,  Node: ATAN2,  Next: COS,  Prev: ATANH,  Up: Elementary Functions section

   ATAN2                    operator

syntax:

   ATAN2 (<expression>,<expression>)

   <expression> is any valid scalar REDUCE expression. In [*note
ROUNDED::.]  mode, if a numerical value exists, ATAN2 returns the
principal value of the arc tangent of the second argument divided by
the first in the range [-pi,+pi] radians, using the signs of both
arguments to determine the quadrant of the return value. An expression
in terms of ATAN2 is returned in other cases.

examples:

     ____________________________________________________________
     
     atan2(3,2);
     
       ATAN2(3,2);
     
     
     on rounded;
     
     atan2(3,2);
     
       0.982793723247
     
     
     atan2(a,b);
     
       ATAN2(A,B);
     
     
     atan2(1,0);
     
       1.57079632679
     
     ____________________________________________________________
   ATAN2 returns a numeric value only if [*note ROUNDED::.] is on. Then
ATAN2  is calculated to the current degree of floating point precision.


File: ..\util\r37,  Node: COS,  Next: COSH,  Prev: ATAN2,  Up: Elementary Functions section

   COS                    operator

   The COS operator returns the cosine of its argument.

syntax:

   COS (<expression>) or COS <simple_expression>

   <expression> is any valid scalar REDUCE expression,
<simple_expression> is a single identifier or begins with a prefix
operator name.

examples:

     ____________________________________________________________
     
     
     
     cos abc;
     
       COS(ABC)
     
     
     
     cos(pi);
     
       -1
     
     
     
     cos 4;
     
       COS(4)
     
     
     
     on rounded;
     
     
     cos(4);
     
       - 0.653643620864
     
     
     
     cos log 5;
     
       - 0.0386319699339
     
     ____________________________________________________________
   COS returns a numeric value only if [*note ROUNDED::.] is on. Then
the cosine is calculated to the current degree of floating point
precision.


File: ..\util\r37,  Node: COSH,  Next: COT,  Prev: COS,  Up: Elementary Functions section

   COSH                    operator

   The COSH operator returns the hyperbolic cosine of its argument.
The derivative of COSH and some simple transformations are known to the
system.

syntax:

   COSH (<expression>) or COSH <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     
     cosh b;
     
       COSH(B)
     
     
     
     cosh(0);
     
       1
     
     
     
     df(cosh(x*y),x);
     
       SINH(X*Y)*Y
     
     
     
     int(cosh(x),x);
     
       SINH(X)
     
     ____________________________________________________________
   You may attach further functionality by defining its inverse (see
[*note ACOSH::.] ).  A numeric value is not returned by COSH unless the
switch [*note ROUNDED::.]  is on and its argument evaluates to a number.


File: ..\util\r37,  Node: COT,  Next: COTH,  Prev: COSH,  Up: Elementary Functions section

   COT                    operator

   COT  represents the cotangent of its argument. It takes an arbitrary
scalar expression as its argument. The derivative of ACOT and some
simple properties are known to the system.

syntax:

   COT (<expression>) or COT <simple_expression>

   <expression> may be any scalar REDUCE expression. <simple_expression>
must be a single identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     cot(a)*tan(a);
     
       COT(A)*TAN(A))
     
     
     cot(1);
     
       COT(1)
     
     
     df(cot(2*x),x);
     
                    2
       - 2*(COT(2*X)   + 1)
     
     ____________________________________________________________
   Numerical values of expressions involving COT may be found by
turning on the switch [*note ROUNDED::.] .


File: ..\util\r37,  Node: COTH,  Next: CSC,  Prev: COT,  Up: Elementary Functions section

   COTH                    operator

   The COTH operator returns the hyperbolic cotangent of its argument.
The derivative of COTH and some simple transformations are known to the
system.

syntax:

   COTH (<expression>) or COTH <simple_expression>

   <expression> may be any scalar REDUCE expression. <simple_expression>
must be a single identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     df(coth(x*y),x);
     
                     2
       - Y*(COTH(X*Y)   - 1)
     
     
     
     coth acoth z;
     
       Z
     
     ____________________________________________________________
   You can write [*note LET::.] statements and procedures to add further
functionality to COTH if you wish. Numerical values of expressions
involving COTH may also be found by turning on the switch [*note
ROUNDED::.] .


File: ..\util\r37,  Node: CSC,  Next: CSCH,  Prev: COTH,  Up: Elementary Functions section

   CSC                    operator

   The CSC operator returns the cosecant of its argument.  The
derivative of CSC and some simple transformations are known to the
system.

syntax:

   CSC (<expression>) or CSC <simple_expression>

   <expression> may be any scalar REDUCE expression. <simple_expression>
must be a single identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     
     csc(q)*sin(q);
     
       CSC(Q)*SIN(Q)
     
     
     
     df(csc(x*y),x);
     
       -COT(X*Y)*CSC(X*Y)*Y
     
     ____________________________________________________________
   You can write [*note LET::.] statements and procedures to add further
functionality to CSC if you wish. Numerical values of expressions
involving CSC may also be found by turning on the switch [*note
ROUNDED::.] .


File: ..\util\r37,  Node: CSCH,  Next: ERF,  Prev: CSC,  Up: Elementary Functions section

   CSCH                    operator

   The COSH operator returns the hyperbolic cosecant of its argument.
The derivative of CSCH and some simple transformations are known to the
system.

syntax:

   CSCH (<expression>) or CSCH <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     
     csch b;
     
       CSCH(B)
     
     
     
     csch(0);
     
       0
     
     
     
     df(csch(x*y),x);
     
       - COTH(X*Y)*CSCH(X*Y)*Y
     
     
     
     int(csch(x),x);
     
       INT(CSCH(X),X)
     
     ____________________________________________________________
   A numeric value is not returned by CSCH unless the switch [*note
ROUNDED::.]  is on and its argument evaluates to a number.


File: ..\util\r37,  Node: ERF,  Next: EXP,  Prev: CSCH,  Up: Elementary Functions section

   ERF                    operator

   The ERF operator represents the error function, defined by

   erf(x) = (2/sqrt(pi))*int(e^(-x^2),x)

   A limited number of its properties are known to the system,
including the fact that it is an odd function. Its derivative is known,
and from this, some integrals may be computed. However, a complete
integration procedure for this operator is not currently included.

examples:

     ____________________________________________________________
     
     erf(0);
     
       0
     
     
     erf(-a);
     
       - ERF(A)
     
     
     df(erf(x**2),x);
     
       4*SQRT(PI)*X
       ------------
            4
           X
          E  *PI
     
     
     
     int(erf(x),x);
     
         2
        X
       E  *ERF(X)*PI*X + SQRT(PI)
       ---------------------------
                   2
                  X
                 E  *PI
     
     ____________________________________________________________


File: ..\util\r37,  Node: EXP,  Next: SEC,  Prev: ERF,  Up: Elementary Functions section

   EXP                    operator

   The EXP operator returns E raised to the power of its argument.

syntax:

   EXP (<expression>) or EXP <simple_expression>

   <expression> can be any valid REDUCE scalar expression.
<simple_expression> must be a single identifier or begin with a prefix
operator.

examples:

     ____________________________________________________________
     
     exp(sin(x));
     
        SIN X
       E
     
     
     exp(11);
     
        11
       E
     
     
     on rounded;
     
     exp sin(pi/3);
     
       2.37744267524
     
     ____________________________________________________________
   Numeric values are returned only when ROUNDED is on.  The single
letter E with the exponential operator ^ or **  may be substituted for
EXP without change of function.


File: ..\util\r37,  Node: SEC,  Next: SECH,  Prev: EXP,  Up: Elementary Functions section

   SEC                    operator

   The SEC operator returns the secant of its argument.

syntax:

   SEC (<expression>) or SEC <simple_expression>

   <expression> is any valid scalar REDUCE expression,
<simple_expression> is a single identifier or begins with a prefix
operator name.

examples:

     ____________________________________________________________
     
     
     
     sec abc;
     
       SEC(ABC)
     
     
     
     sec(pi);
     
       -1
     
     
     
     sec 4;
     
       SEC(4)
     
     
     
     on rounded;
     
     
     sec(4);
     
       - 1.52988565647
     
     
     
     sec log 5;
     
       - 25.8852966005
     
     ____________________________________________________________
   SEC returns a numeric value only if [*note ROUNDED::.] is on. Then
the secant is calculated to the current degree of floating point
precision.


File: ..\util\r37,  Node: SECH,  Next: SIN,  Prev: SEC,  Up: Elementary Functions section

   SECH                    operator

   The SECH operator returns the hyperbolic secant of its argument.

syntax:

   SECH (<expression>) or SECH <simple_expression>

   <expression> is any valid scalar REDUCE expression,
<simple_expression> is a single identifier or begins with a prefix
operator name.

examples:

     ____________________________________________________________
     
     sech abc;
     
       SECH(ABC)
     
     
     
     sech(0);
     
       1
     
     
     
     sech 4;
     
       SECH(4)
     
     
     
     on rounded;
     
     
     sech(4);
     
       0.0366189934737
     
     
     
     sech log 5;
     
       0.384615384615
     
     ____________________________________________________________
   SECH returns a numeric value only if [*note ROUNDED::.] is on. Then
the expression is calculated to the current degree of floating point
precision.


File: ..\util\r37,  Node: SIN,  Next: SINH,  Prev: SECH,  Up: Elementary Functions section

   SIN                    operator

   The SIN operator returns the sine of its argument.

syntax:

   SIN (<expression>) or SIN <simple_expression>

   <expression> is any valid scalar REDUCE expression,
<simple_expression> is a single identifier or begins with a prefix
operator name.

examples:

     ____________________________________________________________
     
     sin aa;
     
       SIN(AA)
     
     
     sin(pi/2);
     
       1
     
     
     on rounded;
     
     sin 3;
     
       0.14112000806
     
     
     sin(pi/2);
     
       1.0
     
     ____________________________________________________________
   SIN returns a numeric value only if ROUNDED is on.  Then the sine is
calculated to the current degree of floating point precision.  The
argument in this case is assumed to be in radians.


File: ..\util\r37,  Node: SINH,  Next: TAN,  Prev: SIN,  Up: Elementary Functions section

   SINH                    operator

   The SINH operator returns the hyperbolic sine of its argument.  The
derivative of SINH and some simple transformations are known to the
system.

syntax:

   SINH (<expression>) or SINH <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     
     sinh b;
     
       SINH(B)
     
     
     
     sinh(0);
     
       0
     
     
     df(sinh(x**2),x);
     
               2
       2*COSH(X )*X
     
     
     int(sinh(4*x),x);
     
       COSH(4*X)
       ---------
           4
     
     
     on rounded;
     
     sinh 4;
     
       27.2899171971
     
     ____________________________________________________________
   You may attach further functionality by defining its inverse (see
[*note ASINH::.] ).  A numeric value is not returned by SINH unless the
switch [*note ROUNDED::.]  is on and its argument evaluates to a number.


File: ..\util\r37,  Node: TAN,  Next: TANH,  Prev: SINH,  Up: Elementary Functions section

   TAN                    operator

   The TAN operator returns the tangent of its argument.

syntax:

   TAN (<expression>) or TAN <simple_expression>

   <expression> is any valid scalar REDUCE expression,
<simple_expression> is a single identifier or begins with a prefix
operator name.

examples:

     ____________________________________________________________
     
     tan a;
     
       TAN(A)
     
     
     tan(pi/5);
     
           PI
       TAN(--)
           5
     
     
     on rounded;
     tan(pi/5);
     
       0.726542528005
     
     ____________________________________________________________
   TAN returns a numeric value only if ROUNDED is on. Then the tangent
is calculated to the current degree of floating point accuracy.

   When [*note ROUNDED::.] is on, no check is made to see if the
argument of TAN is a multiple of pi/2, for which the tangent goes to
positive or negative infinity.  (Of course, since REDUCE uses a
fixed-point representation of pi/2, it produces a large but not
infinite number.) You need to make a check for multiples of pi/2 in any
program you use that might possibly ask for the tangent of such a
quantity.


File: ..\util\r37,  Node: TANH,  Prev: TAN,  Up: Elementary Functions section

   TANH                    operator

   The TANH operator returns the hyperbolic tangent of its argument.
The derivative of TANH and some simple transformations are known to the
system.

syntax:

   TANH (<expression>) or TANH <simple_expression>

   <expression> may be any scalar REDUCE expression, not an array,
matrix or vector expression. <simple_expression> must be a single
identifier or begin with a prefix operator name.

examples:

     ____________________________________________________________
     
     tanh b;
     
       TANH(B)
     
     
     tanh(0);
     
       0
     
     
     df(tanh(x*y),x);
     
                      2
       Y*( - TANH(X*Y)  + 1)
     
     
     int(tanh(x),x);
     
            2*X
       LOG(E    + 1) - X
     
     
     on rounded; tanh 2;
     
       0.964027580076
     
     ____________________________________________________________
   You may attach further functionality by defining its inverse (see
[*note ATANH::.] ).  A numeric value is not returned by TANH unless the
switch [*note ROUNDED::.]  is on and its argument evaluates to a number.


File: ..\util\r37,  Node: Elementary Functions section,  Next: General Switches section,  Prev: Input and Output section,  Up: Top

   Elementary Functions section

* Menu:

* ACOS::                    operator
* ACOSH::                   operator
* ACOT::                    operator
* ACOTH::                   operator
* ACSC::                    operator
* ACSCH::                   operator
* ASEC::                    operator
* ASECH::                   operator
* ASIN::                    operator
* ASINH::                   operator
* ATAN::                    operator
* ATANH::                   operator
* ATAN2::                   operator
* COS::                     operator
* COSH::                    operator
* COT::                     operator
* COTH::                    operator
* CSC::                     operator
* CSCH::                    operator
* ERF::                     operator
* EXP::                     operator
* SEC::                     operator
* SECH::                    operator
* SIN::                     operator
* SINH::                    operator
* TAN::                     operator
* TANH::                    operator


File: ..\util\r37,  Node: SWITCHES,  Next: ALGINT,  Up: General Switches section

   SWITCHES                    introduction

   Switches are set on or off using the commands [*note ON::.] or
[*note OFF::.] , respectively.  The default setting of the switches
described in this section is [*note OFF::.]  unless stated otherwise.


File: ..\util\r37,  Node: ALGINT,  Next: ALLBRANCH,  Prev: SWITCHES,  Up: General Switches section

   ALGINT                    switch

   When the ALGINT switch is on, the algebraic integration module (which
must be loaded from the REDUCE library) is used for integration.

   Loading ALGINT from the library automatically turns on the ALGINT
switch. An error message will be given if ALGINT is turned on when the
ALGINT has not been loaded from the library.


File: ..\util\r37,  Node: ALLBRANCH,  Next: ALLFAC,  Prev: ALGINT,  Up: General Switches section

   ALLBRANCH                    switch

   When ALLBRANCH is on, the operator [*note SOLVE::.] selects all
branches of solutions.  When ALLBRANCH is off, it selects only the
principal branches. Default is ON .

examples:

     ____________________________________________________________
     
     
     solve(log(sin(x+3)),x);
     
       {X=2*ARBINT(1)*PI - ASIN(1) - 3,
        X=2*ARBINT(1)*PI + ASIN(1) + PI - 3}
     
     
     off allbranch;
     
     solve(log(sin(x+3)),x);
     
       X=ASIN(1) - 3
     
     ____________________________________________________________
   [*note ARBINT::.] (1) indicates an arbitrary integer, which is given
a unique identifier by REDUCE, showing that there are infinitely many
solutions of this type. When ALLBRANCH is off, the single canonical
solution is given.


File: ..\util\r37,  Node: ALLFAC,  Next: ARBVARS,  Prev: ALLBRANCH,  Up: General Switches section

   ALLFAC                    switch

   The ALLFAC switch, when on, causes REDUCE to factor out automatically
common products in the output of expressions. Default is ON .

examples:

     ____________________________________________________________
     
     x + x*y**3 + x**2*cos(z);
     
                      3
       X*(COS(Z)*X + Y   + 1)
     
     
     off allfac;
     
     x + x*y**3 + x**2*cos(z);
     
               2      3
       COS(Z)*X  + X*Y   + X
     
     ____________________________________________________________
   The ALLFAC switch has no effect when PRI is off. Although the switch
setting stays as it was, printing behavior is as if it were off.


File: ..\util\r37,  Node: ARBVARS,  Next: BALANCED_MOD,  Prev: ALLFAC,  Up: General Switches section

   ARBVARS                    switch

   When ARBVARS is on, the solutions of singular or underdetermined
systems of equations are presented in terms of arbitrary complex
variables (see [*note ARBCOMPLEX::.] ). Otherwise, the solution is
parametrized in terms of some of the input variables. Default is ON .

examples:

     ____________________________________________________________
     
     solve({2x + y,4x + 2y},{x,y});
     
              arbcomplex(1)
       {{x= - -------------,y=arbcomplex(1)}}
                    2
     
     
     solve({sqrt(x)+ y**3-1},{x,y});
     
     
                                 6       3
                        {{y=arbcomplex(2),x=y   - 2*y   + 1}}
     
     
     off arbvars;
     
     solve({2x + y,4x + 2y},{x,y});
     
              y
       {{x= - -}}
              2
     
     
     solve({sqrt(x)+ y**3-1},{x,y});
     
     
                 6       3
                        {{x=y   - 2*y   + 1}}
     
     ____________________________________________________________
   With ARBVARS off, the return value [[]] means that the equations
given to [*note SOLVE::.] imply no relation among the input variables.


File: ..\util\r37,  Node: BALANCED_MOD,  Next: BFSPACE,  Prev: ARBVARS,  Up: General Switches section

   BALANCED_MOD                    switch

   [*note MODULAR::.]  numbers are normally produced in the range
[0,...<n>), where <n> is the current modulus. With BALANCED_MOD on, the
range [-<n>/2,<n>/2], or more precisely [-floor((<n>-1)/2),
ceiling((<n>-1)/2)], is used instead.

examples:

     ____________________________________________________________
     
     setmod 7;
     
       1
     
     
     on modular;
     
     4;
     
       4
     
     
     on balanced_mod;
     
     4;
     
       -3
     
     ____________________________________________________________


File: ..\util\r37,  Node: BFSPACE,  Next: COMBINEEXPT,  Prev: BALANCED_MOD,  Up: General Switches section

   BFSPACE                    switch

   Floating point numbers are normally printed in a compact notation
(either fixed point or in scientific notation if [*note
SCIENTIFIC_NOTATION::.] has been used). In some (but not all) cases, it
helps comprehensibility if spaces are inserted in the number at regular
intervals. The switch BFSPACE , if on, will cause a blank to be
inserted in the number after every five characters.

examples:

     ____________________________________________________________
     
     on rounded;
     
     1.2345678;
     
       1.2345678
     
     
     on bfspace;
     
     1.2345678;
     
       1.234 5678
     
     ____________________________________________________________

   BFSPACE is normally off.


File: ..\util\r37,  Node: COMBINEEXPT,  Next: COMBINELOGS,  Prev: BFSPACE,  Up: General Switches section

   COMBINEEXPT                    switch

   REDUCE is in general poor at surd simplification. However, when the
switch COMBINEEXPT is on, the system attempts to combine exponentials
whenever possible.

examples:

     ____________________________________________________________
     
     3^(1/2)*3^(1/3)*3^(1/6);
     
                1/3  1/6
       SQRT(3)*3   *3
     
     
     on combineexpt;
     
     ws;
     
       1
     
     ____________________________________________________________


File: ..\util\r37,  Node: COMBINELOGS,  Next: COMP,  Prev: COMBINEEXPT,  Up: General Switches section

   COMBINELOGS                    switch

   In many cases it is desirable to expand product arguments of
logarithms, or collect a sum of logarithms into a single logarithm.
Since these are inverse operations, it is not possible to provide rules
for doing both at the same time and preserve the REDUCE concept of
idempotent evaluation.  As an alternative, REDUCE provides two switches
[*note EXPANDLOGS::.] and COMBINELOGS  to carry out these operations.

examples:

     ____________________________________________________________
     
     on expandlogs;
     
     log(x*y);
     
       LOG(X) + LOG(Y)
     
     
     on combinelogs;
     
     ws;
     
       LOG(X*Y)
     
     ____________________________________________________________

   At the present time, it is possible to have both switches on at once,
which could lead to infinite recursion. However, an expression is
switched from one form to the other in this case. Users should not rely
on this behavior, since it may change in the next release.


File: ..\util\r37,  Node: COMP,  Next: COMPLEX,  Prev: COMBINELOGS,  Up: General Switches section

   COMP                    switch

   When COMP is on, any succeeding function definitions are compiled
into a faster-running form. Default is OFF .

examples:

     ____________________________________________________________
     ____________________________________________________________
   The following procedure finds Fibonacci numbers recursively.  Create
a new file "refib" in your current directory with the following lines
in it:
     ____________________________________________________________
     
     
     procedure refib(n);
        if fixp n and n >= 0 then
          if n <= 1 then 1
            else refib(n-1) + refib(n-2)
         else rederr "nonnegative integer only";
     
     end;
     
     ____________________________________________________________
   Now load REDUCE and run the following:
     ____________________________________________________________
     
     
     on time;
     
       Time: 100 ms
     
     
     
     in "refib"$
     
       Time: 0 ms
     
     
     
     
     
       REFIB
     
     
     
     
     
       Time: 260 ms
     
     
     
     
     
       Time: 20 ms
     
     
     
     refib(80);
     
       37889062373143906
     
     
     
     
     
       Time: 14840 ms
     
     
     
     on comp;
     
       Time: 80 ms
     
     
     
     in "refib"$
     
       Time: 20 ms
     
     
     
     
     
       REFIB
     
     
     
     
     
       Time: 640 ms
     
     
     
     refib(80);
     
       37889062373143906
     
     
     
     
     
       Time: 10940 ms
     
     ____________________________________________________________

   Note that the compiled procedure runs faster. Your time messages will
differ depending upon which system you have. Compiled functions remain
so for the duration of the REDUCE session, and are then lost. They must
be recompiled if wanted in another session. With the switch [*note
TIME::.] on as shown above, the CPU time used in executing the command
is returned in milliseconds. Be careful not to leave COMP on unless you
want it, as it makes the processing of procedures much slower.


File: ..\util\r37,  Node: COMPLEX,  Next: CREF,  Prev: COMP,  Up: General Switches section

   COMPLEX                    switch

   When the COMPLEX switch is on, full complex arithmetic is used in
simplification, function evaluation, and factorization. Default is OFF .

examples:

     ____________________________________________________________
     
     
     factorize(a**2 + b**2);
     
          2     2
       {{A   + B ,1}}
     
     
     on complex;
     
     
     factorize(a**2 + b**2);
     
       {{A + I*B,1},{A - I*B,1}}
     
     
     
     (x**2 + y**2)/(x + i*y);
     
       X - I*Y
     
     
     
     on rounded;
     
           *** Domain mode COMPLEX changed to COMPLEX_FLOAT
     
     
     
     sqrt(-17);
     
       4.12310562562*I
     
     
     
     log(7*i);
     
       1.94591014906 + 1.57079632679*I
     
     ____________________________________________________________
   Complex floating-point can be done by turning on [*note ROUNDED::.]
in addition to COMPLEX . With COMPLEX off however, REDUCE knows that i
is the square root of -1 but will not carry out more complicated
complex operations. If you want complex denominators cleared by
multiplication by their conjugates, turn on the switch [*note
RATIONALIZE::.] .


File: ..\util\r37,  Node: CREF,  Next: CRAMER,  Prev: COMPLEX,  Up: General Switches section

   CREF                    switch

   The switch CREF invokes the CREF cross-reference program that
processes a set of procedure definitions to produce a summary of their
entry points, undefined procedures, non-local variables and so on. The
program will also check that procedures are called with a consistent
number of arguments, and print a diagnostic message otherwise.

   The output is alphabetized on the first seven characters of each
function name.

   To invoke the cross-reference program, CREF is first turned on.
This causes the program to load and the cross-referencing process to
begin. After all the required definitions are loaded, turning CREF off
will cause a cross-reference listing to be produced.

   Algebraic procedures in REDUCE are treated as if they were symbolic,
so that algebraic constructs will actually appear as calls to symbolic
functions, such as AEVAL .


File: ..\util\r37,  Node: CRAMER,  Next: DEFN,  Prev: CREF,  Up: General Switches section

   CRAMER                    switch

   When the CRAMER switch is on, [*note MATRIX::.] inversion and linear
equation solving (operator [*note SOLVE::.] ) is done by Cramer's rule,
through exterior multiplication. Default is OFF .

examples:

     ____________________________________________________________
     
     on time;
     
       Time: 80 ms
     
     
     off output;
     
       Time: 100 ms
     
     
     mm := mat((a,b,c,d,f),(a,a,c,f,b),(b,c,a,c,d), (c,c,a,b,f),
               (d,a,d,e,f));
     
     
       Time: 300 ms
     
     
     inverse := 1/mm;
     
       Time: 18460 ms
     
     
     on cramer;
     
       Time: 80 ms
     
     
     cramersinv := 1/mm;
     
       Time: 9260 ms
     
     ____________________________________________________________
   Your time readings will vary depending on the REDUCE version you use.
After you invert the matrix, turn on [*note OUTPUT::.] and ask for one
of the elements of the inverse matrix, such as CRAMERSINV(3,2) , so that
you can see the size of the expressions produced.

   Inversion of matrices and the solution of linear equations with dense
symbolic entries in many variables is generally considerably faster with
CRAMER  on. However, inversion of numeric-valued matrices is slower.
Consider the matrices you're inverting before deciding whether to turn
CRAMER on or off. A substantial portion of the time in matrix inversion
is given to formatting the results for printing. To save this time,
turn OUTPUT off, as shown in this example or terminate the expression
with a dollar sign instead of a semicolon. The results are still
available to you in the workspace associated with your prompt number,
or you can assign them to an identifier for further use.


File: ..\util\r37,  Node: DEFN,  Next: DEMO,  Prev: CRAMER,  Up: General Switches section

   DEFN                    switch

   When the switch DEFN is on, the Standard Lisp equivalent of the
input statement or procedure is printed, but not evaluated. Default is
OFF .

examples:

     ____________________________________________________________
     
     
     on defn;
     
     
     17/3;
     
       (AEVAL (LIST 'QUOTIENT 17 3))
     
     
     
     df(sin(x),x,2);
     
     
       (AEVAL (LIST 'DF (LIST 'SIN 'X) 'X 2))
     
     
     procedure coshval(a);
        begin scalar g;
           g := (exp(a) + exp(-a))/2;
           return g
        end;
     
     
       (AEVAL
         (PROGN
           (FLAG '(COSHVAL) 'OPFN)
           (DE COSHVAL (A)
             (PROG (G)
               (SETQ G
                 (AEVAL
                    (LIST
                       'QUOTIENT
                       (LIST
                          'PLUS
                          (LIST 'EXP A)
                          (LIST 'EXP (LIST 'MINUS A)))
                       2)))
              (RETURN G)))) )
     
     
     
     coshval(1);
     
       (AEVAL (LIST 'COSHVAL 1))
     
     
     
     off defn;
     
     
     coshval(1);
     
       Declare COSHVAL operator? (Y or N)
     
     
     
     n
     
     procedure coshval(a);
        begin scalar g;
           g := (exp(a) + exp(-a))/2;
           return g
        end;
     
     
       COSHVAL
     
     
     
     on rounded;
     
     
     coshval(1);
     
       1.54308063482
     
     ____________________________________________________________
   The above function COSHVAL finds the hyperbolic cosine (cosh) of its
argument. When DEFN is on, you can see the Standard Lisp equivalent of
the function, but it is not entered into the system as shown by the
message DECLARE COSHVAL OPERATOR? . It must be reentered with DEFN  off
to be recognized. This procedure is used as an example; a more
efficient procedure would eliminate the unnecessary local variable with
     ____________________________________________________________
     
           procedure coshval(a);
              (exp(a) + exp(-a))/2;
     ____________________________________________________________


File: ..\util\r37,  Node: DEMO,  Next: DFPRINT,  Prev: DEFN,  Up: General Switches section

   DEMO                    switch

   The DEMO switch is used for interactive files, causing the system to
pause after each command in the file until you type a RETURN .  Default
is OFF .

   The switch DEMO has no effect on top level interactive statements.
Use it when you want to slow down operations in a file so you can see
what is happening.

   You can either include the ON DEMO command in the file, or enter it
from the top level before bringing in any file. Unlike the [*note
PAUSE::.]  command, ON DEMO does not permit you to interrupt the file
for questions of your own.


File: ..\util\r37,  Node: DFPRINT,  Next: DIV,  Prev: DEMO,  Up: General Switches section

   DFPRINT                    switch

   When DFPRINT is on, expressions in the differentiation operator
[*note DF::.]  are printed in a more "natural" notation, with the
differentiation variables appearing as subscripts. In addition, if the
switch [*note NOARG::.] is on (the default), the arguments of the
differentiated operator are suppressed.

examples:

     ____________________________________________________________
     
     operator f;
     
     df(f x,x);
     
       DF(F(X),X);
     
     
     on dfprint;
     
     ws;
     
       F
        X
     
     
     df(f(x,y),x,y);
     
       F
        Y
     
     
     off noarg;
     
     ws;
     
       F(X,Y)
             X
     
     ____________________________________________________________


File: ..\util\r37,  Node: DIV,  Next: ECHO,  Prev: DFPRINT,  Up: General Switches section

   DIV                    switch

   When DIV is on, the system divides any simple factors found in the
denominator of an expression into the numerator. Default is OFF .

examples:

     ____________________________________________________________
     
     
     on div;
     
     
     a := x**2/y**2;
     
             2   -2
       A := X  *Y
     
     
     
     b := a/(3*z);
     
            1  2   -2    -1
       B := -*X  *Y    *Z
            3
     
     
     
     off div;
     
     
     a;
     
        2
       X
       ---
        2
       Y
     
     
     
     b;
     
          2
         X
       -------
          2
       3*Y  *Z
     
     ____________________________________________________________
   The DIV switch only has effect when the [*note PRI::.] switch is on.
When PRI is off, regardless of the setting of DIV , the printing
behavior is as if DIV were off.


File: ..\util\r37,  Node: ECHO,  Next: ERRCONT,  Prev: DIV,  Up: General Switches section

   ECHO                    switch

   The ECHO switch is normally off for top-level entry, and on when
files are brought in. If ECHO is turned on at the top level, your input
statements are echoed to the screen (thus appearing twice). Default OFF
(but note default ON for files).

   If you want to display certain portions of a file and not others,
use the commands OFF ECHO and ON ECHO inside the file. If you want no
display of the file, use the input command

   IN  filename$

   rather than using the semicolon delimiter.

   Be careful when you use commands within a file to generate another
file.  Since ECHO is on for files, the output file echoes input
statements (unlike its behavior from the top level). You should
explicitly turn off ECHO  when writing output, and turn it back on when
you're done.


File: ..\util\r37,  Node: ERRCONT,  Next: EVALLHSEQP,  Prev: ECHO,  Up: General Switches section

   ERRCONT                    switch

   When the ERRCONT switch is on, error conditions do not stop file
execution. Error messages will be printed whether ERRCONT is on or off.

   Default is OFF .

   The following describes what happens when an error occurs in a file
under each setting of ERRCONT and INT :

   Both off: Message is printed and parsing continues, but no further
statements are executed; no commands from keyboard accepted except bye
or end;

   ERRCONT off, INT on: Message is printed, and you are asked if you
wish to continue. (This is the default behavior);

   ERRCONT on, INT off: Message is printed, and file continues to
execute without pause;

   Both on: Message is printed, and file continues to execute without
pause.


File: ..\util\r37,  Node: EVALLHSEQP,  Next: EXP switch,  Prev: ERRCONT,  Up: General Switches section

   EVALLHSEQP                    switch

   Under normal circumstances, the right-hand-side of an [*note
EQUATION::.] is evaluated but not the left-hand-side. This also applies
to any substitutions made by the [*note SUB::.] operator. If both sides
are to be evaluated, the switch EVALLHSEQP should be turned on.


File: ..\util\r37,  Node: EXP switch,  Next: EXPANDLOGS,  Prev: EVALLHSEQP,  Up: General Switches section

   EXP                    switch

   When the EXP switch is on, powers and products of expressions are
expanded. Default is ON .

examples:

     ____________________________________________________________
     
     (x+1)**3;
     
        3      2
       X  + 3*X  + 3*X + 1
     
     
     (a + b*i)*(c + d*i);
     
       A*C + A*D*I + B*C*I - B*D
     
     
     off exp;
     
     (x+1)**3;
     
              3
       (X + 1)
     
     
     (a + b*i)*(c + d*i);
     
       (A + B*I)*(C + D*I)
     
     
     length((x+1)**2/(y+1));
     
       2
     
     ____________________________________________________________
   Note that REDUCE knows that i^2 = -1.  When EXP is off, equivalent
expressions may not simplify to the same form, although zero
expressions still simplify to zero. Several operators that expect a
polynomial argument behave differently when EXP is off, such as [*note
LENGTH::.] . Be cautious about leaving EXP off.


File: ..\util\r37,  Node: EXPANDLOGS,  Next: EZGCD,  Prev: EXP switch,  Up: General Switches section

   EXPANDLOGS                    switch

   In many cases it is desirable to expand product arguments of
logarithms, or collect a sum of logarithms into a single logarithm.
Since these are inverse operations, it is not possible to provide rules
for doing both at the same time and preserve the REDUCE concept of
idempotent evaluation.  As an alternative, REDUCE provides two switches
EXPANDLOGS and [*note COMBINELOGS::.]  to carry out these operations.
Both are off by default.

examples:

     ____________________________________________________________
     
     on expandlogs;
     
     log(x*y);
     
       LOG(X) + LOG(Y)
     
     
     on combinelogs;
     
     ws;
     
       LOG(X*Y)
     
     ____________________________________________________________

   At the present time, it is possible to have both switches on at once,
which could lead to infinite recursion. However, an expression is
switched from one form to the other in this case. Users should not rely
on this behavior, since it may change in the next release.


File: ..\util\r37,  Node: EZGCD,  Next: FACTOR,  Prev: EXPANDLOGS,  Up: General Switches section

   EZGCD                    switch

   When EZGCD and [*note GCD::.] are on, greatest common divisors are
computed using the EZ GCD algorithm that uses modular arithmetic (and is
usually faster). Default is OFF .

   As a side effect of the gcd calculation, the expressions involved are
factored, though not the heavy-duty factoring of [*note FACTORIZE::.] .
The EZ GCD algorithm was introduced in a paper by J. Moses and D.Y.Y.
Yun in <Proceedings of the ACM>, 1973, pp. 159-166.

   Note that the [*note GCD::.] switch must also be on for EZGCD to have
effect.


File: ..\util\r37,  Node: FACTOR,  Next: FAILHARD,  Prev: EZGCD,  Up: General Switches section

   FACTOR                    switch

   When the FACTOR switch is on, input expressions and results are
automatically factored.

examples:

     ____________________________________________________________
     
     
     on factor;
     
     
     aa := 3*x**3*a + 6*x**2*y*a + 3*x**3*b + 6*x**2*y*b
     
     + x*y*a + 2*y**2*a + x*y*b + 2*y**2*b;
     
     
     
                         2
       AA := (A + B)*(3*X  + Y)*(X + 2*Y)
     
     
     off factor;
     
     aa;
     
            3        2                  2         3        2
       3*A*X  + 6*A*X *Y + A*X*Y + 2*A*Y   + 3*B*X  + 6*B*X *Y
     
     
     + B*X*Y + 2*B*Y^{2}
     
     on factor;
     
     ab := x**2 - 2;
     
              2
       AB := X  - 2
     
     ____________________________________________________________
   REDUCE factors univariate and multivariate polynomials with integer
coefficients, finding any factors that also have integer coefficients.
The factoring is done by reducing multivariate problems to univariate
ones with symbolic coefficients, and then solving the univariate ones
modulo small primes. The results of these calculations are merged to
determine the factors of the original polynomial. The factorizer
normally selects evaluation points and primes using a random number
generator.  Thus, the detailed factoring behavior may be different each
time any particular problem is tackled.

   When the FACTOR switch is turned on, the [*note EXP::.] switch is
turned off, and when the FACTOR switch is turned off, the [*note
EXP::.]  switch is turned on, whether it was on previously or not.

   When the switch [*note TRFAC::.] is on, informative messages are
generated at each call to the factorizer. The [*note TRALLFAC::.]
switch causes the production of a more verbose trace message. It takes
precedence over TRFAC  if they are both on.

   To factor a polynomial explicitly and store the results, use the
operator [*note FACTORIZE::.] .


File: ..\util\r37,  Node: FAILHARD,  Next: FORT,  Prev: FACTOR,  Up: General Switches section

   FAILHARD                    switch

   When the FAILHARD switch is on, the integration operator [*note
INT::.] terminates with an error message if the integral cannot be done
in closed terms.  Default is off.

   Use the FAILHARD switch when you are dealing with complicated
integrals and want to know immediately if REDUCE was unable to handle
them. The integration operator sometimes returns a formal integration
form that is more complicated than the original expression, when it is
unable to complete the integration.


File: ..\util\r37,  Node: FORT,  Next: FORTUPPER,  Prev: FAILHARD,  Up: General Switches section

   FORT                    switch

   When FORT is on, output is given Fortran-compatible syntax. Default
is OFF .

examples:

     ____________________________________________________________
     
     on fort;
     
     df(sin(7*x + y),x);
     
       ANS=7.*COS(7*X+Y)
     
     
     on rounded;
     
     b := log(sin(pi/5 + n*pi));
     
                    B=LOG(SIN(3.14159265359*N+0.628318530718))
     
     ____________________________________________________________
   REDUCE results can be written to a file (using [*note OUT::.] ) and
used as data by Fortran programs when FORT is in effect. FORT knows
about correct statement length, continuation characters, defining a
symbol when it is first used, and other Fortran details.

   The [*note GENTRAN::.] package offers many more possibilities than
the FORT  switch. It produces Fortran (or C or Ratfor) code from REDUCE
procedures or structured specifications, including facilities for
producing double precision output.


File: ..\util\r37,  Node: FORTUPPER,  Next: FULLPREC,  Prev: FORT,  Up: General Switches section

   FORTUPPER                    switch

   When FORTUPPER is on, any Fortran-style output appears in upper case.
Default is OFF .

examples:

     ____________________________________________________________
     
     on fort;
     
     df(sin(7*x + y),x);
     
       ans=7.*cos(7*x+y)
     
     
     on fortupper;
     
     df(sin(7*x + y),x);
     
       ANS=7.*COS(7*X+Y)
     
     ____________________________________________________________


File: ..\util\r37,  Node: FULLPREC,  Next: FULLROOTS,  Prev: FORTUPPER,  Up: General Switches section

   FULLPREC                    switch

   Trailing zeroes of rounded numbers to the full system precision are
normally not printed. If this information is needed, for example to get
a more understandable indication of the accuracy of certain data, the
switch FULLPREC  can be turned on.

examples:

     ____________________________________________________________
     
     on rounded;
     
     1/2;
     
       0.5
     
     
     on fullprec;
     
     ws;
     
       0.500000000000
     
     ____________________________________________________________
   This is just an output options which neither influences the accuracy
of the computation nor does it give additional information about the
precision of the results.  See also [*note SCIENTIFIC_NOTATION::.] .


File: ..\util\r37,  Node: FULLROOTS,  Next: GC,  Prev: FULLPREC,  Up: General Switches section

   FULLROOTS                    switch

   Since roots of cubic and quartic polynomials can often be very
messy, a switch FULLROOTS controls the production of results in closed
form. [*note SOLVE::.] will apply the formulas for explicit forms for
degrees 3 and 4 only if FULLROOTS  is ON . Otherwise the result forms
are built using [*note ROOT_OF::.] . Default is OFF .


File: ..\util\r37,  Node: GC,  Next: GCD switch,  Prev: FULLROOTS,  Up: General Switches section

   GC                    switch

   With the GC switch, you can turn the garbage collection messages on
or off. The form of the message depends on the particular Lisp used for
the REDUCE implementation.

   See [*note RECLAIM::.] for an explanation of garbage collection.
REDUCE does garbage collection when needed even if you have turned the
notices off.


File: ..\util\r37,  Node: GCD switch,  Next: HORNER,  Prev: GC,  Up: General Switches section

   GCD                    switch

   When GCD is on, common factors in numerators and denominators of
expressions are canceled. Default is OFF .

examples:

     ____________________________________________________________
     
     
     (2*(f*h)**2 - f**2*g*h - (f*g)**2 - f*h**3 + f*h*g**2
        - h**4 + g*h**3)/(f**2*h - f**2*g - f*h**2 + 2*f*g*h
        - f*g**2 - g*h**2 + g**2*h);
     
     
        2  2    2          2  2      2        3      3    4
       F *G  + F *G*H - 2*F *H  - F*G *H + F*H  - G*H  + H
       ----------------------------------------------------
         2      2        2                2    2        2
        F *G - F *H + F*G  - 2*F*G*H + F*H  - G *H + G*H
     
     
     on gcd;
     
     ws;
     
                      2
       F*G + 2*F*H + H
       ----------------
            F + G
     
     
     e2 := a*c + a*d + b*c + b*d;
     
       E2 := A*C + A*D + B*C + B*D
     
     
     off exp;
     
     e2;
     
       (A + B)*(C + D)
     
     ____________________________________________________________
   Even with GCD off, a check is automatically made for common variable
and numerical products in the numerators and denominators of expression,
and the appropriate cancellations made. Thus the example demonstrating
the use of GCD is somewhat complicated. Note when [*note EXP::.] is off,
GCD  has the side effect of factoring the expression.


File: ..\util\r37,  Node: HORNER,  Next: IFACTOR,  Prev: GCD switch,  Up: General Switches section

   HORNER                    switch

   When the HORNER switch is on, polynomial expressions are printed in
Horner's form for faster and safer numerical evaluation. Default is OFF
. The leading variable of the expression is selected as Horner
variable. To select the Horner variable explicitly use the [*note
KORDER::.]  declaration.

examples:

     ____________________________________________________________
     
     on horner;
     
     (13p-4q)^3;
     
                3            2
       ( - 64)*q   + p*(624*q   + p*(( - 2028)*q + p*2197))
     
     
     korder q;
     
     ws;
     
             3                  2
       2197*p   + q*(( - 2028)*p   + q*(624*p + q*(-64)))
     
     ____________________________________________________________


File: ..\util\r37,  Node: IFACTOR,  Next: INT switch,  Prev: HORNER,  Up: General Switches section

   IFACTOR                    switch

   When the IFACTOR switch is on, any integer terms appearing as a
result of the [*note FACTORIZE::.] command are factored themselves into
primes. Default is OFF . If the argument of FACTORIZE is an integer,
IFACTOR  has no effect, since the integer is always factored.

examples:

     ____________________________________________________________
     
     factorize(4*x**2 + 28*x + 48);
     
       {{4,1},{X + 4,1},{X + 3,1}}
     
     
     factorize(22587);
     
       {{3,1},{7529,1}}
     
     
     on ifactor;
     
     factorize(4*x**2 + 28*x + 48);
     
       {{2,2},{X + 4,1},{X + 3,1}}
     
     
     factorize(22587);
     
       {{3,1},{7529,1}}
     
     ____________________________________________________________
   Constant terms that appear within nonconstant polynomial factors are
not factored.

   The IFACTOR switch affects only factoring done specifically with
[*note FACTORIZE::.] , not on factoring done automatically when the
[*note FACTOR::.]  switch is on.


File: ..\util\r37,  Node: INT switch,  Next: INTSTR,  Prev: IFACTOR,  Up: General Switches section

   INT                    switch

   The INT switch specifies an interactive mode of operation. Default
ON .

   There is no reason to turn INT off during interactive calculations,
since there are no benefits to be gained. If you do have INT off while
inputting a file, and REDUCE finds an error, it prints the message
"Continuing with parsing only." In this state, REDUCE accepts only
[*note END::.] ;  or [*note BYE::.] ; from the keyboard; everything
else is ignored, even the command ON INT .


File: ..\util\r37,  Node: INTSTR,  Next: LCM,  Prev: INT switch,  Up: General Switches section

   INTSTR                    switch

   If INTSTR (for "internal structure") is on, arguments of an operator
are printed in a more structured form.

examples:

     ____________________________________________________________
     
     operator f;
     
     f(2x+2y);
     
       F(2*X + 2*Y)
     
     
     on intstr;
     
     ws;
     
       F(2*(X + Y))
     
     ____________________________________________________________


File: ..\util\r37,  Node: LCM,  Next: LESSSPACE,  Prev: INTSTR,  Up: General Switches section

   LCM                    switch

   The LCM switch instructs REDUCE to compute the least common multiple
of denominators whenever rational expressions occur. Default is ON .

examples:

     ____________________________________________________________
     
     off lcm;
     
     z := 1/(x**2 - y**2) + 1/(x-y)**2;
     
     
     
                   2*X*(X - Y)
       Z := -------------------------
             4      3          3    4
            X  - 2*X *Y + 2*X*Y  - Y
     
     
     on lcm;
     
     z;
     
              2*X*(X - Y)
       -------------------------
        4      3          3    4
       X  - 2*X *Y + 2*X*Y  - Y
     
     
     zz := 1/(x**2 - y**2) + 1/(x-y)**2;
     
     
     
                      2*X
       ZZ := ---------------------
              3    2        2    3
             X  - X *Y - X*Y  + Y
     
     
     on gcd;
     
     z;
     
                2*X
       ----------------------
        3    2        2    3
       X  - X *Y - X*Y  + Y
     
     ____________________________________________________________
   Note that LCM has effect only when rational expressions are first
combined. It does not examine existing structures for simplifications on
display. That is shown above when z is entered with LCM  off. It
remains unsimplified even after LCM is turned back on. However, a new
variable containing the same expression is simplified on entry. The
switch [*note GCD::.] does examine existing structures, as shown in the
last example line above.

   Full greatest common divisor calculations become expensive if work
with large rational expressions is required. A considerable savings of
time can be had if a full gcd check is made only when denominators are
combined, and only a partial check for numerators. This is the effect
of the LCM switch.


File: ..\util\r37,  Node: LESSSPACE,  Next: LIMITEDFACTORS,  Prev: LCM,  Up: General Switches section

   LESSSPACE                    switch

   You can turn on the switch LESSSPACE if you want fewer blank lines
in your output.


File: ..\util\r37,  Node: LIMITEDFACTORS,  Next: LIST switch,  Prev: LESSSPACE,  Up: General Switches section

   LIMITEDFACTORS                    switch

   To get limited factorization in cases where it is too expensive to
use full multivariate polynomial factorization, the switch
LIMITEDFACTORS  can be turned on. In that case, only "inexpensive"
factoring operations, such as square-free factorization, will be used
when [*note FACTORIZE::.] is called.

examples:

     ____________________________________________________________
     
     a := (y-x)^2*(y^3+2x*y+5)*(y^2-3x*y+7)$
     
     factorize a;
     
                   2
       {- 3*X*Y + Y  + 7,1}
                 3
       {2*X*Y + Y  + 5,1},
       {X - Y,2}}
     
     
     on limitedfactors;
     
     factorize a;
     
             2  2        4        3          5      3      2
       {- 6*X *Y  - 3*X*Y  + 2*X*Y  - X*Y + Y  + 7*Y  + 5*Y  + 35,1},
       {X - Y,2}}
     
     ____________________________________________________________


File: ..\util\r37,  Node: LIST switch,  Next: LISTARGS,  Prev: LIMITEDFACTORS,  Up: General Switches section

   LIST                    switch

   The LIST switch causes REDUCE to print each term in any sum on
separate lines.

examples:

     ____________________________________________________________
     
     x**2*(y**2 + 2*y) + x*(y**2 + z)/(2*a);
     
     
     
                 2              2
       X*(2*A*X*Y  + 4*A*X*Y + Y  +Z)
       ------------------------------
                    2*A
     
     
     on list;
     
     ws;
     
                  2
       (X*(2*A*X*Y
         + 4*A*X*Y
            2
         + Y
         + Z))/(2*A)
     
     ____________________________________________________________


File: ..\util\r37,  Node: LISTARGS,  Next: MCD,  Prev: LIST switch,  Up: General Switches section

   LISTARGS                    switch

   If an operator other than those specifically defined for lists is
given a single argument that is a list, then the result of this
operation will be a list in which that operator is applied to each
element of the list.  This process can be inhibited globally by turning
on the switch LISTARGS .

examples:

     ____________________________________________________________
     
     log {a,b,c};
     
       LOG(A),LOG(B),LOG(C)
     
     
     on listargs;
     
     log {a,b,c};
     
       LOG(A,B,C)
     
     ____________________________________________________________
   It is possible to inhibit such distribution for a specific operator
by using the declaration [*note LISTARGP::.] . In addition, if an
operator has more than one argument, no such distribution occurs, so
LISTARGS has no effect.


File: ..\util\r37,  Node: MCD,  Next: MODULAR,  Prev: LISTARGS,  Up: General Switches section

   MCD                    switch

   When MCD is on, sums and differences of rational expressions are put
on a common denominator. Default is ON .

examples:

     ____________________________________________________________
     
     a/(x+1) + b/5;
     
       5*A + B*X + B
       -------------
         5*(X + 1)
     
     
     off mcd;
     
     a/(x+1) + b/5;
     
              -1
       (X + 1)  *A + 1/5*B
     
     
     1/6 + 1/7;
     
       13/42
     
     ____________________________________________________________
   Even with MCD off, rational expressions involving only numbers are
still put over a common denominator.

   Turning MCD off is useful when explicit negative powers are needed,
or if no greatest common divisor calculations are desired, or when
differentiating complicated rational expressions. Results when MCD is
off are no longer in canonical form, and expressions equivalent to zero
may not simplify to 0. Some operations, such as factoring cannot be done
while MCD is off. This option should therefore be used with some
caution. Turning MCD off is most valuable in intermediate parts of a
complicated calculation, and should be turned back on for the last
stage.


File: ..\util\r37,  Node: MODULAR,  Next: MSG,  Prev: MCD,  Up: General Switches section

   MODULAR                    switch

   When MODULAR is on, polynomial coefficients are reduced by the
modulus set by [*note SETMOD::.] . If no modulus has been set, MODULAR
has no effect.

examples:

     ____________________________________________________________
     
     setmod 2;
     
       1
     
     
     on modular;
     
     (x+y)**2;
     
        2    2
       X  + Y
     
     
     145*x**2 + 20*x**3 + 17 + 15*x*y;
     
     
     
        2
       X  + X*Y + 1
     
     ____________________________________________________________
   Modular operations are only conducted on the coefficients, not the
exponents. The modulus is not restricted to being prime. When the
modulus is prime, division by a number not relatively prime to the
modulus results in a <Zero divisor> error message. When the modulus is
a composite number, division by a power of the modulus results in an
error message, but division by an integer which is a factor of the
modulus does not.  The representation of modular number can be
influenced by [*note BALANCED_MOD::.] .


File: ..\util\r37,  Node: MSG,  Next: MULTIPLICITIES,  Prev: MODULAR,  Up: General Switches section

   MSG                    switch

   When MSG is off, the printing of warning messages is suppressed.
Error messages are still printed.

   Warning messages include those about redimensioning an [*note
ARRAY::.] or declaring an [*note OPERATOR::.] where one is expected.


File: ..\util\r37,  Node: MULTIPLICITIES,  Next: NAT,  Prev: MSG,  Up: General Switches section

   MULTIPLICITIES                    switch

   When [*note SOLVE::.] is applied to a set of equations with multiple
roots, solution multiplicities are normally stored in the global
variable [*note ROOT_MULTIPLICITIES::.]  rather than the solution list.
If you want the multiplicities explicitly displayed, the switch
MULTIPLICITIES should be turned on. In this case, ROOT_MULTIPLICITIES
has no value.

examples:

     ____________________________________________________________
     
     solve(x^2=2x-1,x);
     
       X=1
     
     
     root_multiplicities;
     
       2
     
     
     on multiplicities;
     
     solve(x^2=2x-1,x);
     
       X=1,X=1
     
     
     root_multiplicities;
     
     ____________________________________________________________


File: ..\util\r37,  Node: NAT,  Next: NERO,  Prev: MULTIPLICITIES,  Up: General Switches section

   NAT                    switch

   When NAT is on, output is printed to the screen in natural form, with
raised exponents. NAT should be turned off when outputting expressions
to a file for future input. Default is ON .

examples:

     ____________________________________________________________
     
     (x + y)**3;
     
        3      2          2    3
       X  + 3*X *Y + 3*X*Y  + Y
     
     
     off nat;
     
     (x + y)**3;
     
       X**3 + 3*X**2*Y + 3*X*Y**2 + Y**3$
     
     
     on fort;
     
     (x + y)**3;
     
       ANS=X**3+3.*X**2*Y+3.*X*Y**2+Y**3
     
     ____________________________________________________________
   With NAT off, a dollar sign is printed at the end of each expression.
An output file written with NAT off is ready to be read into REDUCE
using the command [*note IN::.] .


File: ..\util\r37,  Node: NERO,  Next: NOARG,  Prev: NAT,  Up: General Switches section

   NERO                    switch

   When NERO is on, zero assignments (such as matrix elements) are not
printed.

examples:

     ____________________________________________________________
     
     matrix a;
     a := mat((1,0),(0,1));
     
       A(1,1) := 1
       A(1,2) := 0
       A(2,1) := 0
       A(2,2) := 1
     
     
     on nero;
     
     a;
     
       MAT(1,1) := 1
       MAT(2,2) := 1
     
     
     a(1,2);
     ____________________________________________________________
   nothing is printed.
     ____________________________________________________________
     
     
     
     b := 0;
     ____________________________________________________________
   nothing is printed.
     ____________________________________________________________
     
     
     
     off nero;
     
     b := 0;
     
       B := 0
     
     ____________________________________________________________

   NERO is often used when dealing with large sparse matrices, to avoid
being overloaded with zero assignments.


File: ..\util\r37,  Node: NOARG,  Next: NOLNR,  Prev: NERO,  Up: General Switches section

   NOARG                    switch

   When [*note DFPRINT::.] is on, expressions in the differentiation
operator [*note DF::.]  are printed in a more "natural" notation, with
the differentiation variables appearing as subscripts. When NOARG is on
(the default), the arguments of the differentiated operator are also
suppressed.

examples:

     ____________________________________________________________
     
     operator f;
     
     df(f x,x);
     
       DF(F(X),X);
     
     
     on dfprint;
     
     ws;
     
       F
        X
     
     
     off noarg;
     
     ws;
     
       F(X)
           X
     
     ____________________________________________________________


File: ..\util\r37,  Node: NOLNR,  Next: NOSPLIT,  Prev: NOARG,  Up: General Switches section

   NOLNR                    switch

   When NOLNR is on, the linear properties of the integration operator
[*note INT::.]  are suppressed if the integral cannot be found in
closed terms.

   REDUCE uses the linear properties of integration to attempt to break
down an integral into manageable pieces. If an integral cannot be found
in closed terms, these pieces are returned. When the NOLNR switch is
off, as many of the pieces as possible are integrated. When it is on,
if any piece fails, the rest of them remain unevaluated.


File: ..\util\r37,  Node: NOSPLIT,  Next: NUMVAL,  Prev: NOLNR,  Up: General Switches section

   NOSPLIT                    switch

   Under normal circumstances, the printing routines try to break an
expression across lines at a natural point. This is a fairly expensive
process. If you are not overly concerned about where the end-of-line
breaks come, you can speed up the printing of expressions by turning
off the switch NOSPLIT . This switch is normally on.


File: ..\util\r37,  Node: NUMVAL,  Next: OUTPUT,  Prev: NOSPLIT,  Up: General Switches section

   NUMVAL                    switch

   With [*note ROUNDED::.] on, elementary functions with numerical
arguments will return a numerical answer where appropriate. If you wish
to inhibit this evaluation, NUMVAL should be turned off. It is normally
on.

examples:

     ____________________________________________________________
     
     on rounded;
     
     cos 3.4;
     
       - 0.966798192579
     
     
     off numval;
     
     cos 3.4;
     
       COS(3.4)
     
     ____________________________________________________________


File: ..\util\r37,  Node: OUTPUT,  Next: OVERVIEW,  Prev: NUMVAL,  Up: General Switches section

   OUTPUT                    switch

   When OUTPUT is off, no output is printed from any REDUCE calculation.
The calculations have their usual effects other than printing. Default
is ON .

   Turn output OFF if you do not wish to see output when executing
large files, or to save the time REDUCE spends formatting large
expressions for display. Results are still available with [*note WS::.]
, or in their assigned variables.


File: ..\util\r37,  Node: OVERVIEW,  Next: PERIOD,  Prev: OUTPUT,  Up: General Switches section

   OVERVIEW                    switch

   When OVERVIEW is on, the amount of detail reported by the factorizer
switches [*note TRFAC::.] and [*note TRALLFAC::.] is reduced.


File: ..\util\r37,  Node: PERIOD,  Next: PRECISE,  Prev: OVERVIEW,  Up: General Switches section

   PERIOD                    switch

   When PERIOD is on, periods are added after integers in
Fortran-compatible output (when [*note FORT::.] is on). There is no
effect when FORT is off. Default is ON .


File: ..\util\r37,  Node: PRECISE,  Next: PRET,  Prev: PERIOD,  Up: General Switches section

   PRECISE                    switch

   When the PRECISE switch is on, simplification of roots of even
powers returns absolute values, a more precise answer mathematically.
Default is ON .

examples:

     ____________________________________________________________
     
     sqrt(x**2);
     
       X
     
     
     (x**2)**(1/4);
     
       SQRT(X)
     
     
     on precise;
     
     sqrt(x**2);
     
       ABS(X)
     
     
     (x**2)**(1/4);
     
       SQRT(ABS(X))
     
     ____________________________________________________________
   In many types of mathematical work, simplification of powers and
surds can proceed by the fastest means of simplifying the exponents
arithmetically.  When it is important to you that the positive root be
returned, turn PRECISE  on. One situation where this is important is
when graphing square-root expressions such as sqrt(x^2+y^2) to avoid a
spike caused by REDUCE simplifying sqrt(y^2) to y when x is zero.


File: ..\util\r37,  Node: PRET,  Next: PRI,  Prev: PRECISE,  Up: General Switches section

   PRET                    switch

   When PRET is on, input is printed in standard REDUCE format and then
evaluated.

examples:

     ____________________________________________________________
     
     on pret;
     
      (x+1)^3;
     
        (x + 1)**3;
        3      2
       X  + 3*X  + 3*X + 1
     
     
     
     procedure fac(n);
        if not (fixp(n) and n>=0)
          then rederr "Choose nonneg. integer only"
         else for i := 0:n-1 product i+1;
     
     
       procedure fac n;
          if not (fixp n and n>=0)
            then rederr "Choose nonneg. integer only"
           else for i := 0:n - 1 product i + 1;
       FAC
     
     
     
     fac 5;
     
       fac 5;
       120
     
     ____________________________________________________________
   Note that all input is converted to lower case except strings (which
keep the same case) all operators with a single argument have had the
parentheses removed, and all infix operators have had a space added on
each side. In addition, syntactical constructs like IF ...THEN ...ELSE
are printed in a standard format.


File: ..\util\r37,  Node: PRI,  Next: RAISE,  Prev: PRET,  Up: General Switches section

   PRI                    switch

   When PRI is on, the declarations [*note ORDER::.] and [*note
FACTOR::.] can be used, and the switches [*note ALLFAC::.] , [*note
DIV::.] , [*note RAT::.] , and [*note REVPRI::.] take effect when they
are on. Default is ON .

   Printing of expressions is faster with PRI off. The expressions are
then returned in one standard form, without any of the display options
that can be used to feature or display various parts of the expression.
You can also gain insight into REDUCE's representation of expressions
with PRI  off.


File: ..\util\r37,  Node: RAISE,  Next: RAT,  Prev: PRI,  Up: General Switches section

   RAISE                    switch

   When RAISE is on, lower case letters are automatically converted to
upper case on input. RAISE is normally on.

   This conversion affects the internal representation of the letter,
and is independent of the case with which a letter is printed, which is
normally lower case.


File: ..\util\r37,  Node: RAT,  Next: RATARG,  Prev: RAISE,  Up: General Switches section

   RAT                    switch

   When the RAT switch is on, and kernels have been selected to display
with the [*note FACTOR::.] declaration, the denominator is printed with
each term rather than one common denominator at the end of an
expression.

examples:

     ____________________________________________________________
     
     (x+1)/x + x**2/sin y;
     
     
                            3
       SIN(Y)*X + SIN(Y) + X
       ---------------------- factor x;
              SIN(Y)*X
     
     
     (x+1)/x + x**2/sin y;
     
     
        3
       X  + X*SIN(Y) + SIN(Y)
       ---------------------- on rat;
              X*SIN(Y)
     
     
     (x+1)/x + x**2/sin y;
     
     
          2
         X           -1
       ------ + 1 + X
       SIN(Y)
     
     ____________________________________________________________
   The RAT switch only has effect when the [*note PRI::.] switch is on.
When PRI is off, regardless of the setting of RAT , the printing
behavior is as if RAT were off. RAT only has effect upon the display of
expressions, not their internal form.


File: ..\util\r37,  Node: RATARG,  Next: RATIONAL,  Prev: RAT,  Up: General Switches section

   RATARG                    switch

   When RATARG is on, rational expressions can be given to operators
such as [*note COEFF::.] and [*note LTERM::.] that normally require
polynomials in one of their arguments. When RATARG is off, rational
expressions cause an error message.

examples:

     ____________________________________________________________
     
     aa := x/y**2 + 1/x + y/x**2;
     
     
              3      2    3
             X  + X*Y  + Y
       AA := --------------
                  2  2
                 X *Y
     
     
     coeff(aa,x);
     
              3      2    3
             X  + X*Y  + Y
       ***** -------------- invalid as POLYNOMIAL
                  2  2
                 X *Y
     
     
     on ratarg;
     
     coeff(aa,x);
     
     
        Y  1      1
       {--,--,0,-----}
         2  2    2  2
        X  X    X *Y
     
     ____________________________________________________________


File: ..\util\r37,  Node: RATIONAL,  Next: RATIONALIZE,  Prev: RATARG,  Up: General Switches section

   RATIONAL                    switch

   When RATIONAL is on, polynomial expressions with rational
coefficients are produced.

examples:

     ____________________________________________________________
     
     x/2 + 3*y/4;
     
       2*X + 3*Y
       ---------
           4
     
     
     (x**2 + 5*x + 17)/2;
     
        2
       X  + 5*X + 17
       -------------
             2
     
     
     on rational;
     
     x/2 + 3y/4;
     
       1      3
       -*(X + -*Y)
       2      2
     
     
     (x**2 + 5*x + 17)/2;
     
       1   2
       -*(X  + 5*X + 17)
       2
     
     ____________________________________________________________
   By using RATIONAL , polynomial expressions with rational
coefficients can be used in some commands that expect polynomials. With
RATIONAL  off, such a polynomial becomes a rational expression, with
denominator the least common multiple of the denominators of the
rational number coefficients.


File: ..\util\r37,  Node: RATIONALIZE,  Next: RATPRI,  Prev: RATIONAL,  Up: General Switches section

   RATIONALIZE                    switch

   When the RATIONALIZE switch is on, denominators of rational
expressions that contain complex numbers or root expressions are
simplified by multiplication by their conjugates.

examples:

     ____________________________________________________________
     
     qq := (1+sqrt(3))/(sqrt(3)-7);
     
             SQRT(3) + 1
       QQ := -----------
             SQRT(3) - 7
     
     
     on rationalize;
     
     qq;
     
       - 4*SQRT(3) - 5
       ---------------
             23
     
     
     2/(4 + 6**(1/3));
     
        2/3      1/3
       6    - 4*6    + 16
       ------------------
               35
     
     
     (i-1)/(i+3);
     
       2*I - 1
       -------
          5
     
     
     off rationalize;
     
     (i-1)/(i+3);
     
       I - 1
       ------
       I + 3
     
     ____________________________________________________________


File: ..\util\r37,  Node: RATPRI,  Next: REVPRI,  Prev: RATIONALIZE,  Up: General Switches section

   RATPRI                    switch

   When the RATPRI switch is on, rational expressions and fractions are
printed as two lines separated by a fraction bar, rather than in a
linear style. Default is ON .

examples:

     ____________________________________________________________
     
     3/17;
     
       3
       --
       17
     
     
     2/b + 3/y;
     
       3*B + 2*Y
       ---------
          B*Y
     
     
     off ratpri;
     
     3/17;
     
       3/17
     
     
     2/b + 3/y;
     
       (3*B + 2*Y)/(B*Y)
     
     ____________________________________________________________


File: ..\util\r37,  Node: REVPRI,  Next: RLISP88,  Prev: RATPRI,  Up: General Switches section

   REVPRI                    switch

   When the REVPRI switch is on, terms are printed in reverse order from
the normal printing order.

examples:

     ____________________________________________________________
     
     x**5 + x**2 + 18 + sqrt(y);
     
                  5    2
       SQRT(Y) + X  + X  + 18
     
     
     a + b + c + w;
     
       A + B + C + W
     
     
     on revpri;
     
     x**5 + x**2 + 18 + sqrt(y);
     
             2    5
       17 + X  + X  + SQRT(Y)
     
     
     a + b + c + w;
     
       W + C + B + A
     
     ____________________________________________________________
   Turn REVPRI on when you want to display a polynomial in ascending
rather than descending order.


File: ..\util\r37,  Node: RLISP88,  Next: ROUNDALL,  Prev: REVPRI,  Up: General Switches section

   RLISP88                    switch

   Rlisp '88 is a superset of the Rlisp that has been traditionally
used for the support of REDUCE. It is fully documented in the book
Marti, J.B., "RLISP '88: An Evolutionary Approach to Program Design and
Reuse", World Scientific, Singapore (1993). It supports different
looping constructs from the traditional Rlisp, and treats "-" as a
letter unless separated by spaces. Turning on the switch RLISP88
converts to Rlisp '88 parsing conventions in symbolic mode, and enables
the use of Rlisp '88 extensions. Turning off the switch reverts to the
traditional Rlisp and the previous mode ( ([*note SYMBOLIC::.]  or
[*note ALGEBRAIC::.] ) in force before RLISP88 was turned on.


File: ..\util\r37,  Node: ROUNDALL,  Next: ROUNDBF,  Prev: RLISP88,  Up: General Switches section

   ROUNDALL                    switch

   In [*note ROUNDED::.] mode, rational numbers are normally converted
to a floating point representation. If ROUNDALL is off, this conversion
does not occur. ROUNDALL is normally ON .

examples:

     ____________________________________________________________
     
     on rounded;
     
     1/2;
     
       0.5
     
     
     off roundall;
     ____________________________________________________________


File: ..\util\r37,  Node: ROUNDBF,  Next: ROUNDED,  Prev: ROUNDALL,  Up: General Switches section

   ROUNDBF                    switch

   When [*note ROUNDED::.] is on, the normal defaults cause underflows
to be converted to zero. If you really want the small number that
results in such cases, ROUNDBF can be turned on.

examples:

     ____________________________________________________________
     
     on rounded;
     
     exp(-100000.1^2);
     
       0
     
     
     on roundbf;
     
     exp(-100000.1^2);
     
       1.18441281937E-4342953505
     
     ____________________________________________________________
   If a polynomial is input in [*note ROUNDED::.] mode at the default
precision into any [*note ROOTS::.] function, and it is not possible to
represent any of the coefficients of the polynomial precisely in the
system floating point representation, the switch ROUNDBF will be
automatically turned on. All rounded computation will use the internal
bigfloat representation until the user subsequently turns ROUNDBF off.
(A message is output to indicate that this condition is in effect.)


File: ..\util\r37,  Node: ROUNDED,  Next: SAVESTRUCTR,  Prev: ROUNDBF,  Up: General Switches section

   ROUNDED                    switch

   When ROUNDED is on, floating-point arithmetic is enabled, with
precision initially at a system default value, which is usually 12
digits.  The precise number can be found by the command [*note
PRECISION::.] (0).

examples:

     ____________________________________________________________
     
     pi;
     
       PI
     
     
     35/217;
     
       5
       --
       31
     
     
     on rounded;
     
     pi;
     
       3.14159265359
     
     
     35/217;
     
       0.161
     
     
     sqrt(3);
     
       1.73205080756
     
     ____________________________________________________________

   If more than the default number of decimal places are required, use
the [*note PRECISION::.]  command to set the required number.


File: ..\util\r37,  Node: SAVESTRUCTR,  Next: SOLVESINGULAR,  Prev: ROUNDED,  Up: General Switches section

   SAVESTRUCTR                    switch

   When SAVESTRUCTR is on, results of the [*note STRUCTR::.] command are
returned as a list whose first element is the representation for the
expression and the remaining elements are equations showing the
relationships of the generated variables.

examples:

     ____________________________________________________________
     
     off exp;
     
     structr((x+y)^3 + sin(x)^2);
     
       ANS3
          where
                         3       2
             ANS3 := ANS1  + ANS2
             ANS2 := SIN(X)
             ANS1 := X + Y
     
     
     ans3;
     
       ANS3
     
     
     on savestructr;
     
     structr((x+y)^{3} + sin(x)^{2});
     
                     3       2
       ANS3,ANS3=ANS1  + ANS2 ,ANS2=SIN(X),ANS1=X + Y
     
     
     ans3 where rest ws;
     
              3         2
       (X + Y)  + SIN(X)
     
     ____________________________________________________________
   In normal operation, [*note STRUCTR::.] is only a display command.
With SAVESTRUCTR  on, you can access the various parts of the expression
produced by STRUCTR .

   The generic system names use the stem ANS . You can change this to
your own stem by the command [*note VARNAME::.] . REDUCE adds integers
to this stem to make unique identifiers.


File: ..\util\r37,  Node: SOLVESINGULAR,  Next: TIME,  Prev: SAVESTRUCTR,  Up: General Switches section

   SOLVESINGULAR                    switch

   When SOLVESINGULAR is on, singular or underdetermined systems of
linear equations are solved, using arbitrary real, complex or integer
variables in the answer. Default is ON .

examples:

     ____________________________________________________________
     
     solve({2x + y,4x + 2y},{x,y});
     
              ARBCOMPLEX(1)
       {{X= - -------------,Y=ARBCOMPLEX(1)}}
                    2
     
     
     solve({7x + 15y - z,x - y - z},{x,y,z});
     
     
           8*ARBCOMPLEX(3)
       {{X=----------------
                 11
              3*ARBCOMPLEX(3)
         Y= - ----------------
                    11
         Z=ARBCOMPLEX(3)}}
     
     
     off solvesingular;
     
     solve({2x + y,4x + 2y},{x,y});
     
       ***** SOLVE given singular equations
     
     
     solve({7x + 15y - z,x - y - z},{x,y,z});
     
     
       ***** SOLVE given singular equations
     
     ____________________________________________________________
   The integer following the identifier [*note ARBCOMPLEX::.] above is
assigned by the system, and serves to identify the variable uniquely.
It has no other significance.


File: ..\util\r37,  Node: TIME,  Next: TRALLFAC,  Prev: SOLVESINGULAR,  Up: General Switches section

   TIME                    switch

   When TIME is on, the system time used in executing each REDUCE
statement is printed after the answer is printed.

examples:

     ____________________________________________________________
     
     on time;
     
       Time: 4940 ms
     
     
     df(sin(x**2 + y),y);
     
                 2
       COS(X  + Y )
       Time: 180 ms
     
     
     solve(x**2 - 6*y,x);
     
       {X= - SQRT(Y)*SQRT(6),
        X=SQRT(Y)*SQRT(6)}
       Time: 320 ms
     
     ____________________________________________________________
   When TIME is first turned on, the time since the beginning of the
REDUCE session is printed. After that, the time used in computation,
(usually in milliseconds, though this is system dependent) is printed
after the results of each command. Idle time or time spent typing in
commands is not counted. If TIME is turned off, the first reading after
it is turned on again gives the time elapsed since it was turned off.
The time printed is CPU or wall clock time, depending on the system.


File: ..\util\r37,  Node: TRALLFAC,  Next: TRFAC,  Prev: TIME,  Up: General Switches section

   TRALLFAC                    switch

   When TRALLFAC is on, a more detailed trace of factorizer calls is
generated.

   The TRALLFAC switch takes precedence over [*note TRFAC::.] if they
are both on. TRFAC gives a factorization trace with less detail in it.
When the [*note FACTOR::.] switch is on also, all input polynomials are
sent to the factorizer automatically and trace information is
generated. The [*note OUT::.]  command saves the results of the
factoring, but not the trace.


File: ..\util\r37,  Node: TRFAC,  Next: TRIGFORM,  Prev: TRALLFAC,  Up: General Switches section

   TRFAC                    switch

   When TRFAC is on, a narrative trace of any calls to the factorizer is
generated. Default is OFF .

   When the switch [*note FACTOR::.] is on, and TRFAC is on, every input
polynomial is sent to the factorizer, and a trace generated. With
FACTOR  off, only polynomials that are explicitly factored with the
command [*note FACTORIZE::.] generate trace information.

   The [*note OUT::.] command saves the results of the factoring, but
not the trace. The [*note TRALLFAC::.] switch gives trace information
to a greater level of detail.


File: ..\util\r37,  Node: TRIGFORM,  Next: TRINT,  Prev: TRFAC,  Up: General Switches section

   TRIGFORM                    switch

   When [*note FULLROOTS::.] is on, [*note SOLVE::.] will compute the
roots of a cubic or quartic polynomial is closed form. When TRIGFORM
is on, the roots will be expressed by trigonometric forms. Otherwise
nested surds are used. Default is ON .


File: ..\util\r37,  Node: TRINT,  Next: TRNONLNR,  Prev: TRIGFORM,  Up: General Switches section

   TRINT                    switch

   When TRINT is on, a narrative tracing various steps in the
integration process is produced.

   The [*note OUT::.] command saves the results of the integration, but
not the trace.


File: ..\util\r37,  Node: TRNONLNR,  Next: VAROPT,  Prev: TRINT,  Up: General Switches section

   TRNONLNR                    switch

   When TRNONLNR is on, a narrative tracing various steps in the
process for solving non-linear equations is produced.

   TRNONLNR can only be used after the solve package has been loaded
(e.g., by an explicit call of [*note LOAD_PACKAGE::.] ). The [*note
OUT::.] command saves the results of the equation solving, but not the
trace.


File: ..\util\r37,  Node: VAROPT,  Prev: TRNONLNR,  Up: General Switches section

   VAROPT                    switch

   When VAROPT is on, the sequence of variables is optimized by [*note
SOLVE::.]  with respect to execution speed. Otherwise, the sequence
given in the call to [*note SOLVE::.] is preserved. Default is ON .

   In combination with the switch [*note ARBVARS::.] , VAROPT can be
used to control variable elimination.

examples:

     ____________________________________________________________
     
     off arbvars;
     
     solve({x+2z,x-3y},{x,y,z});
     
                x      x
                        {{y=-,z= - -}}
                3      2
     
     
     solve({x*y=1,z=x},{x,y,z});
     
                    1
                        {{z=x,y=-}}
                    x
     
     
     off varopt;
     
     solve({x+2z,x-3y},{x,y,z});
     
                            2*z
                        {{x= - 2*z,y= - ---}}
                             3
     
     
     solve({x*y=1,z=x},{x,y,z});
     
                1
                        {{y=-,x=z}}
                z
     
     ____________________________________________________________


File: ..\util\r37,  Node: General Switches section,  Next: Matrix Operations section,  Prev: Elementary Functions section,  Up: Top

   General Switches section

* Menu:

* SWITCHES::                introduction
* ALGINT::                  switch
* ALLBRANCH::               switch
* ALLFAC::                  switch
* ARBVARS::                 switch
* BALANCED_MOD::           switch
* BFSPACE::                 switch
* COMBINEEXPT::             switch
* COMBINELOGS::             switch
* COMP::                    switch
* COMPLEX::                 switch
* CREF::                    switch
* CRAMER::                  switch
* DEFN::                    switch
* DEMO::                    switch
* DFPRINT::                 switch
* DIV::                     switch
* ECHO::                    switch
* ERRCONT::                 switch
* EVALLHSEQP::              switch
* EXP switch::              switch
* EXPANDLOGS::              switch
* EZGCD::                   switch
* FACTOR::                  switch
* FAILHARD::                switch
* FORT::                    switch
* FORTUPPER::               switch
* FULLPREC::                switch
* FULLROOTS::               switch
* GC::                      switch
* GCD switch::              switch
* HORNER::                  switch
* IFACTOR::                 switch
* INT switch::              switch
* INTSTR::                  switch
* LCM::                     switch
* LESSSPACE::               switch
* LIMITEDFACTORS::          switch
* LIST switch::             switch
* LISTARGS::                switch
* MCD::                     switch
* MODULAR::                 switch
* MSG::                     switch
* MULTIPLICITIES::          switch
* NAT::                     switch
* NERO::                    switch
* NOARG::                   switch
* NOLNR::                   switch
* NOSPLIT::                 switch
* NUMVAL::                  switch
* OUTPUT::                  switch
* OVERVIEW::                switch
* PERIOD::                  switch
* PRECISE::                 switch
* PRET::                    switch
* PRI::                     switch
* RAISE::                   switch
* RAT::                     switch
* RATARG::                  switch
* RATIONAL::                switch
* RATIONALIZE::             switch
* RATPRI::                  switch
* REVPRI::                  switch
* RLISP88::                 switch
* ROUNDALL::                switch
* ROUNDBF::                 switch
* ROUNDED::                 switch
* SAVESTRUCTR::             switch
* SOLVESINGULAR::           switch
* TIME::                    switch
* TRALLFAC::                switch
* TRFAC::                   switch
* TRIGFORM::                switch
* TRINT::                   switch
* TRNONLNR::                switch
* VAROPT::                  switch


File: ..\util\r37,  Node: COFACTOR,  Next: DET,  Up: Matrix Operations section

   COFACTOR                    operator

   The operator COFACTOR returns the cofactor of the element in row
<row> and column <column> of a [*note MATRIX::.] . Errors occur if
<row> or <column> do not evaluate to integer expressions or if the
matrix is not square.

syntax:

   COFACTOR (<matrix_expression>,<row>,<column>)

examples:

     ____________________________________________________________
     
     cofactor(mat((a,b,c),(d,e,f),(p,q,r)),2,2);
     
     
       A*R - C*P
     
     
     cofactor(mat((a,b,c),(d,e,f)),1,1);
     
     
       ***** non-square matrix
     
     ____________________________________________________________


File: ..\util\r37,  Node: DET,  Next: MAT,  Prev: COFACTOR,  Up: Matrix Operations section

   DET                    operator

   The DET operator returns the determinant of its (square [*note
MATRIX::.] ) argument.

syntax:

   DET (<expression>) or DET <expression>

   <expression> must evaluate to a square matrix.

examples:

     ____________________________________________________________
     
     
     matrix m,n;
     
     
     m := mat((a,b),(c,d));
     
       M(1,1) := A
       M(1,2) := B
       M(2,1) := C
       M(2,2) := D
     
     
     
     det m;
     
       A*D - B*C
     
     
     n := mat((1,2),(1,2));
     
       N(1,1) := 1
       N(1,2) := 2
       N(2,1) := 1
       N(2,2) := 2
     
     
     
     
     det(n);
     
       0
     
     
     
     det(5);
     
       5
     
     ____________________________________________________________
   Given a numerical argument, DET returns the number. However, given a
variable name that has not been declared of type matrix, or a non-square
matrix, DET returns an error message.


File: ..\util\r37,  Node: MAT,  Next: MATEIGEN,  Prev: DET,  Up: Matrix Operations section

   MAT                    operator

   The MAT operator is used to represent a two-dimensional [*note
MATRIX::.] .

syntax:

   MAT ((<expr>,<expr>*) (<expr>, <expr>*)*)

   <expr> may be any valid REDUCE scalar expression.

examples:

     ____________________________________________________________
     
     mat((1,2),(3,4));
     
       MAT(1,1) := 1
       MAT(2,3) := 2
       MAT(2,1) := 3
       MAT(2,2) := 4
     
     
     mat(2,1);
     
       ***** Matrix mismatch
       Cont? (Y or N)
     
     
     matrix qt;
     
     qt := ws;
     
       QT(1,1) := 1
       QT(1,2) := 2
       QT(2,1) := 3
       QT(2,2) := 4
     
     
     matrix a,b;
     
     a := mat((x),(y),(z));
     
       A(1,1) := X
       A(2,1) := Y
       A(3,1) := Z
     
     
     b := mat((sin x,cos x,1));
     
       B(1,1) := SIN(X)
       B(1,2) := COS(X)
       B(1,3) := 1
     
     ____________________________________________________________
   Matrices need not have a size declared (unlike arrays). MAT
redimensions a matrix variable as needed. It is necessary, of course,
that all rows be the same length. An anonymous matrix, as shown in the
first example, must be named before it can be referenced (note error
message). When using MAT to fill a 1 x n matrix, the row of values must
be inside a second set of parentheses, to eliminate ambiguity.


File: ..\util\r37,  Node: MATEIGEN,  Next: MATRIX,  Prev: MAT,  Up: Matrix Operations section

   MATEIGEN                    operator

   The MATEIGEN operator calculates the eigenvalue equation and the
corresponding eigenvectors of a [*note MATRIX::.] .

syntax:

   MATEIGEN (<matrix-id>,<tag-id>)

   <matrix-id> must be a declared matrix of values, and <tag-id> must be
a legal REDUCE identifier.

examples:

     ____________________________________________________________
     
     aa := mat((2,5),(1,0))$
     
     mateigen(aa,alpha);
     
              2
       {{ALPHA  - 2*ALPHA - 5,
         1,
                     5*ARBCOMPLEX(1)
         MAT(1,1) := ---------------,
                        ALPHA - 2
         MAT(2,1) := ARBCOMPLEX(1)
         }}
     
     
     charpoly := first first ws;
     
                        2
       CHARPOLY := ALPHA  - 2*ALPHA - 5
     
     
     bb := mat((1,0,1),(1,1,0),(0,0,1))$
     
     mateigen(bb,lamb);
     
       {{LAMB - 1,3,
         [      0      ]
         [ARBCOMPLEX(2)]
         [      0      ]
         }}
     
     ____________________________________________________________
   The MATEIGEN operator returns a list of lists of three elements. The
first element is a square free factor of the characteristic polynomial;
the second element is its multiplicity; and the third element is the
corresponding eigenvector. If the characteristic polynomial can be
completely factored, the product of the first elements of all the
sublists will produce the minimal polynomial. You can access the
various parts of the answer with the usual list access operators.

   If the matrix is degenerate, more than one eigenvector can be
produced for the same eigenvalue, as shown by more than one arbitrary
variable in the eigenvector. The identification numbers of the
arbitrary complex variables shown in the examples above may not be the
same as yours. Note that since LAMBDA  is a reserved word in REDUCE,
you cannot use it as a tag-id for this operator.


File: ..\util\r37,  Node: MATRIX,  Next: NULLSPACE,  Prev: MATEIGEN,  Up: Matrix Operations section

   MATRIX                    declaration

   Identifiers are declared to be of type MATRIX .

syntax:

   MATRIX <identifier>  option (<index>,<index>)

   ,<identifier>  option  (<index>,<index>)*

   <identifier> must not be an already-defined operator or array or the
name of a scalar variable. Dimensions are optional, and if used appear
inside parentheses. <index> must be a positive integer.

examples:

     ____________________________________________________________
     
     matrix a,b(1,4),c(4,4);
     
     b(1,1);
     
       0
     
     
     a(1,1);
     
       ***** Matrix A not set
     
     
     a := mat((x0,y0),(x1,y1));
     
       A(1,1) := X0
       A(1,2) := Y0
       A(2,1) := X0
       A(2,2) := X1
     
     
     length a;
     
       {2,2}
     
     
     b := a**2;
     
                   2
       B(1,1) := X0  + X1*Y0
       B(1,2) := Y0*(X0 + Y1)
       B(2,1) := X1*(X0 + Y1)
                           2
       B(2,2) := X1*Y0 + Y1
     
     ____________________________________________________________
   When a matrix variable has not been dimensioned, matrix elements
cannot be referenced until the matrix is set by the [*note MAT::.]
operator. When a matrix is dimensioned in its declaration, matrix
elements are set to 0.  Matrix elements cannot stand for themselves.
When you use [*note LET::.] on a matrix element, there is no effect
unless the element contains a constant, in which case an error message
is returned. The same behavior occurs with [*note CLEAR::.] . Do <not>
use [*note CLEAR::.] to try to set a matrix element to 0. [*note
LET::.] statements can be applied to matrices as a whole, if the
right-hand side of the expression is a matrix expression, and the
left-hand side identifier has been declared to be a matrix.

   Arithmetical operators apply to matrices of the correct dimensions.
The operators + and - can be used with matrices of the same dimensions.
The operator * can be used to multiply m x n matrices by n x p
matrices. Matrix multiplication is non-commutative. Scalars can also be
multiplied with matrices, with the result that each element of the
matrix is multiplied by the scalar. The operator / applied to two
matrices computes the first matrix multiplied by the inverse of the
second, if the inverse exists, and produces an error message otherwise.
Matrices can be divided by scalars, which results in dividing each
element of the matrix. Scalars can also be divided by matrices when the
matrices are invertible, and the result is the multiplication of the
scalar by the inverse of the matrix. Matrix inverses can by found by
1/A or /A , where A is a matrix. Square matrices can be raised to
positive integer powers, and also to negative integer powers if they are
nonsingular.

   When a matrix variable is assigned to the results of a calculation,
the matrix is redimensioned if necessary.


File: ..\util\r37,  Node: NULLSPACE,  Next: RANK,  Prev: MATRIX,  Up: Matrix Operations section

   NULLSPACE                    operator

syntax:

   NULLSPACE (<matrix_expression>)

   <nullspace> calculates for its [*note MATRIX::.] argument, A , a
list of linear independent vectors (a basis) whose linear combinations
satisfy the equation a x = 0. The basis is provided in a form such that
as many upper components as possible are isolated.

examples:

     ____________________________________________________________
     
     nullspace mat((1,2,3,4),(5,6,7,8));
     
     
              {
                [ 1  ]
                [    ]
                [ 0  ]
                [    ]
                [ - 3]
                [    ]
                [ 2  ]
                ,
                [ 0  ]
                [    ]
                [ 1  ]
                [    ]
                [ - 2]
                [    ]
                [ 1  ]
               }
     
     ____________________________________________________________
   Note that with B := NULLSPACE A , the expression LENGTH B is the
nullity/ of A, and that SECOND LENGTH A - LENGTH B calculates the rank/
of A. The rank of a matrix expression can also be found more directly
by the [*note RANK::.] operator.

   In addition to the REDUCE matrix form, NULLSPACE accepts as input a
matrix given as a [*note LIST::.] of lists, that is interpreted as a
row matrix. If that form of input is chosen, the vectors in the result
will be represented by lists as well. This additional input syntax
facilitates the use of NULLSPACE in applications different from
classical linear algebra.


File: ..\util\r37,  Node: RANK,  Next: TP,  Prev: NULLSPACE,  Up: Matrix Operations section

   RANK                    operator

syntax:

   RANK (<matrix_expression>)

   RANK calculates the rank of its matrix argument.

examples:

     ____________________________________________________________
     
     rank mat((a,b,c),(d,e,f));
     
       2
     
     ____________________________________________________________
   The argument to RANK can also be a [*note LIST::.] of lists,
interpreted either as a row matrix or a set of equations. If that form
of input is chosen, the vectors in the result will be represented by
lists as well.  This additional input syntax facilitates the use of
RANK in applications different from classical linear algebra.


File: ..\util\r37,  Node: TP,  Next: TRACE,  Prev: RANK,  Up: Matrix Operations section

   TP                    operator

   The TP operator returns the transpose of its [*note MATRIX::.]
argument.

syntax:

   TP <identifier> or TP (<identifier>)

   <identifier> must be a matrix, which either has had its dimensions
set in its declaration, or has had values put into it by MAT .

examples:

     ____________________________________________________________
     
     matrix m,n;
     
     m := mat((1,2,3),(4,5,6))$
     
     n := tp m;
     
       N(1,1) := 1
       N(1,2) := 4
       N(2,1) := 2
       N(2,2) := 5
       N(3,1) := 3
       N(3,2) := 6
     
     ____________________________________________________________
   In an assignment statement involving TP , the matrix identifier on
the left-hand side is redimensioned to the correct size for the
transpose.


File: ..\util\r37,  Node: TRACE,  Prev: TP,  Up: Matrix Operations section

   TRACE                    operator

   The TRACE operator finds the trace of its [*note MATRIX::.] argument.

syntax:

   TRACE (<expression>) or TRACE <simple_expression>

   <expression> or <simple_expression> must evaluate to a square matrix.

examples:

     ____________________________________________________________
     
     matrix a;
     
     a := mat((x1,y1),(x2,y2))$
     
     trace a;
     
       X1 + Y2
     
     ____________________________________________________________
   The trace is the sum of the entries along the diagonal of a square
matrix.  Given a non-matrix expression, or a non-square matrix, TRACE
returns an error message.


File: ..\util\r37,  Node: Matrix Operations section,  Next: Groebner package section,  Prev: General Switches section,  Up: Top

   Matrix Operations section

* Menu:

* COFACTOR::                operator
* DET::                     operator
* MAT::                     operator
* MATEIGEN::                operator
* MATRIX::                  declaration
* NULLSPACE::               operator
* RANK::                    operator
* TP::                      operator
* TRACE::                   operator


File: ..\util\r37,  Node: Groebner bases,  Next: Ideal Parameters,  Up: Groebner package section

   GROEBNER BASES                    introduction

   The GROEBNER package calculates GROEBNER BASES  using the
BUCHBERGER ALGORITHM  and provides related algorithms for arithmetic
with ideal bases, such as ideal quotients, Hilbert polynomials (
HOLLMANN ALGORITHM ), basis conversion (  FAUGERE-GIANNI-LAZARD-MORA
ALGORITHM ), independent variable set ( KREDEL-WEISPFENNING ALGORITHM ).

   Some routines of the Groebner package are used by [*note SOLVE::.] -
in that context the package is loaded automatically. However, if you
want to use the package by explicit calls you must load it by
     ____________________________________________________________
     
         load_package groebner;
     ____________________________________________________________

   For the common parameter setting of most operators in this package
see [*note Ideal Parameters::.] .


File: ..\util\r37,  Node: Ideal Parameters,  Next: Term order section,  Prev: Groebner bases,  Up: Groebner package section

   IDEAL PARAMETERS

   Most operators of the GROEBNER package compute expressions in a
polynomial ring which given as <R>[<var>,<var>,...] where <R> is the
current REDUCE coefficient domain. All algebraically exact domains of
REDUCE are supported. The package can operate over rings and fields.
The operation mode is distinguished automatically. In general the ring
mode is a bit faster than the field mode. The factoring variant can be
applied only over domains which allow you factoring of multivariate
polynomials.

   The variable sequence <var> is either declared explicitly as argument
in form of a [*note LIST::.] in [*note torder::.] , or it is extracted
automatically from the expressions. In the second case the current
REDUCE system order is used (see [*note KORDER::.] ) for arranging the
variables.  If some kernels should play the role of formal parameters
(the ground domain <R> then is the polynomial ring over these), the
variable sequences must be given explicitly.

   All REDUCE [*note KERNEL::.] s can be used as variables. But please
note, that all variables are considered as independent. E.g. when using
SIN(A)  and COS(A) as variables, the basic relation
SIN(A)^2+COS(A)^2-1=0  must be explicitly added to an equation set
because the Groebner operators don't include such knowledge
automatically.

   The terms (monomials) in polynomials are arranged according to the
current [*note Term order::.] . Note that the algebraic properties of
the computed results only are valid as long as neither the ordering nor
the variable sequence changes.

   The input expressions <exp> can be polynomials <p>, rational
functions <n>/<d> or equations <lh>=<rh> built from polynomials or
rational functions. Apart from the TRACING algorithms [*note
groebnert::.] and [*note preducet::.] , where the equations have a
specific meaning, equations are converted to simple expressions by
taking the difference of the left-hand and right-hand sides
<lh>-<rh>=><p>. Rational functions are converted to polynomials by
converting the expression to a common denominator form first, and then
using the numerator only <n>=><p>. So eventual zeros of the
denominators are ignored.

   A basis on input or output of an algorithm is coded as [*note
LIST::.] of expressions <exp>,<exp>,... .


File: ..\util\r37,  Node: Term order,  Next: torder,  Up: Term order section

   TERM ORDER                    introduction

   For all GROEBNER operations the polynomials are represented in
distributive form: a sum of terms (monomials).  The terms are ordered
corresponding to the actual TERM ORDER which is set by the [*note
torder::.] operator, and to the actual variable sequence which is
either given as explicit parameter or by the system [*note KERNEL::.]
order.


File: ..\util\r37,  Node: torder,  Next: torder_compile,  Prev: Term order,  Up: Term order section

   TORDER                    operator

   The operator TORDER sets the actual variable sequence and term order.

   1. simple term order:

syntax:

   TORDER (<vl>, <m>)

   where <vl> is a [*note LIST::.] of variables ([*note KERNEL::.] s)
and <m> is the name of a simple [*note Term order::.] mode [*note lex
term order::.] , [*note gradlex term order::.] , [*note revgradlex term
order::.]  or another implemented parameterless mode.

   2. stepped term order:

syntax:

   TORDER (<vl>,<m>,<n>)

   where <m> is the name of a two step term order, one of [*note
gradlexgradlex term order::.] , [*note gradlexrevgradlex term order::.]
, [*note lexgradlex term order::.]  or [*note lexrevgradlex term
order::.] , and <n> is a positive integer.

   3. weighted term order

syntax:

   TORDER (<vl>, WEIGHTED , <n>,<n>,...);

   where the <n> are positive integers, see [*note weighted term
order::.] .

   4. matrix term order

syntax:

   TORDER (<vl>, MATRIX , <m>);

   where <m> is a matrix with integer elements, see [*note
torder_compile::.] .

   5. compiled term order

syntax:

   TORDER (<vl>, CO );

   where <co> is the name of a routine generated by [*note
torder_compile::.] .

   TORDER sets the variable sequence and the term order mode. If the an
empty list is used as variable sequence, the automatic variable
extraction is activated. The defaults are the empty variable list an the
[*note lex term order::.] .  The previous setting is returned as a list.

   Alternatively to the above syntax the arguments of TORDER may be
collected in a [*note LIST::.] and passed as one argument to TORDER .


File: ..\util\r37,  Node: torder_compile,  Next: lex term order,  Prev: torder,  Up: Term order section

   TORDER_COMPILE                    operator

   A matrix can be converted into a compilable LISP program for faster
execution by using

syntax:

   TORDER_COMPILE (<name>,<mat>)

   where <name> is an identifier for the new term order and <mat> is an
integer matrix to be used as [*note matrix term order::.] . Afterwards
the term order can be activated by using <name> in a [*note torder::.]
expression. The resulting program is compiled if the switch [*note
COMP::.] is on, or if the TORDER_COMPILE expression is part of a
compiled module.


File: ..\util\r37,  Node: lex term order,  Next: gradlex term order,  Prev: torder_compile,  Up: Term order section

   LEX TERM ORDER

   The terms are ordered lexicographically: two terms t1 t2 are
compared for their degrees along the fixed variable sequence: t1 is
higher than t2 if the first different degree is higher in t1.  This
order has the ELIMINATION PROPERTY for GROEBNER BASIS calculations.  If
the ideal has a univariate polynomial in the last variable the groebner
basis will contain such polynomial. LEX is best suited for solving of
polynomial equation systems.


File: ..\util\r37,  Node: gradlex term order,  Next: revgradlex term order,  Prev: lex term order,  Up: Term order section

   GRADLEX TERM ORDER

   The terms are ordered first with their total degree, and if the
total degree is identical the comparison is [*note lex term order::.] .
With GROEBNER basis calculations this term order produces polynomials
of lowest degree.


File: ..\util\r37,  Node: revgradlex term order,  Next: gradlexgradlex term order,  Prev: gradlex term order,  Up: Term order section

   REVGRADLEX TERM ORDER

   The terms are ordered first with their total degree (degree sum),
and if the total degree is identical the comparison is the inverse of
[*note lex term order::.] .  With [*note groebner::.] and [*note
groebnerf::.] calculations this term order is similar to [*note gradlex
term order::.] ; it is known as most efficient ordering with respect to
computing time.


File: ..\util\r37,  Node: gradlexgradlex term order,  Next: gradlexrevgradlex term order,  Prev: revgradlex term order,  Up: Term order section

   GRADLEXGRADLEX TERM ORDER

   The terms are separated into two groups where the second parameter
of the [*note torder::.] call determines the length of the first group.
For a comparison first the total degrees of both variable groups are
compared.  If both are equal [*note gradlex term order::.]  comparison
is applied to the first group, and if that does not decide [*note
gradlex term order::.] is applied for the second group. This order has
the elimination property for the variable groups. It can be used e.g.
for separating variables from parameters.


File: ..\util\r37,  Node: gradlexrevgradlex term order,  Next: lexgradlex term order,  Prev: gradlexgradlex term order,  Up: Term order section

   GRADLEXREVGRADLEX TERM ORDER

   Similar to [*note gradlexgradlex term order::.] , but using [*note
revgradlex term order::.]  for the second group.


File: ..\util\r37,  Node: lexgradlex term order,  Next: lexrevgradlex term order,  Prev: gradlexrevgradlex term order,  Up: Term order section

   LEXGRADLEX TERM ORDER

   Similar to [*note gradlexgradlex term order::.] , but using [*note
lex term order::.]  for the first group.


File: ..\util\r37,  Node: lexrevgradlex term order,  Next: weighted term order,  Prev: lexgradlex term order,  Up: Term order section

   LEXREVGRADLEX TERM ORDER

   Similar to [*note gradlexgradlex term order::.] , but using [*note
lex term order::.]  for the first group [*note revgradlex term
order::.]  for the second group.


File: ..\util\r37,  Node: weighted term order,  Next: graded term order,  Prev: lexrevgradlex term order,  Up: Term order section

   WEIGHTED TERM ORDER

   establishes a graduated ordering similar to [*note gradlex term
order::.] , where the exponents first are multiplied by the given
weights. If there are less weight values than variables, the weight
list is extended by ones. If the weighted degree comparison is not
decidable, the [*note lex term order::.]  is used.


File: ..\util\r37,  Node: graded term order,  Next: matrix term order,  Prev: weighted term order,  Up: Term order section

   GRADED TERM ORDER

   establishes a cascaded term ordering: first a graduated ordering
similar to [*note gradlex term order::.] is used, where the exponents
first are multiplied by the given weights. If there are less weight
values than variables, the weight list is extended by ones. If the
weighted degree comparison is not decidable, the term ordering
described in the following parameters of the [*note torder::.] command
is used.


File: ..\util\r37,  Node: matrix term order,  Prev: graded term order,  Up: Term order section

   MATRIX TERM ORDER

   Any arbitrary term order mode can be installed by a matrix with
integer elements where the row length corresponds to the variable
number. The matrix must have at least as many rows as columns.  It must
have full rank, and the top nonzero element of each column must be
positive.

   The matrix TERM ORDER MODE defines a term order where the exponent
vectors of the monomials are first multiplied by the matrix and the
resulting vectors are compared lexicographically.

   If the switch [*note COMP::.] is on, the matrix is converted into a
compiled LISP program for faster execution. A matrix can also be
compiled explicitly, see [*note torder_compile::.] .


File: ..\util\r37,  Node: Term order section,  Next: Basic Groebner operators section,  Prev: Ideal Parameters,  Up: Groebner package section

   Term order section

* Menu:

* Term order::              introduction
* torder::                  operator
* torder_compile::          operator
* lex term order::          concept
* gradlex term order::      concept
* revgradlex term order::   concept
* gradlexgradlex term order::concept
* gradlexrevgradlex term order::concept
* lexgradlex term order::   concept
* lexrevgradlex term order::concept
* weighted term order::     concept
* graded term order::       concept
* matrix term order::       concept


File: ..\util\r37,  Node: gvars,  Next: groebner,  Up: Basic Groebner operators section

   GVARS                    operator

syntax:

   GVARS (<exp>,<exp>,... )

   where <exp> are expressions or [*note EQUATION::.] s.

   GVARS extracts from the expressions the [*note KERNEL::.] S which can
play the role of variables for a [*note groebner::.] or [*note
groebnerf::.] calculation.


File: ..\util\r37,  Node: groebner,  Next: groebner_walk,  Prev: gvars,  Up: Basic Groebner operators section

   GROEBNER                    operator

syntax:

   GROEBNER (EXP , ...)

   where EXP , ... is a list of expressions or equations.

   The operator GROEBNER implements the Buchberger algorithm for
computing Groebner bases for a given set of expressions with respect to
the given set of variables in the order given. As a side effect, the
sequence of variables is stored as a REDUCE list in the shared variable
[*note gvarslast::.] - this is important in cases where the algorithm
rearranges the variable sequence because [*note groebopt::.] is ON .

examples:

     ____________________________________________________________
     
        groebner({x**2+y**2-1,x-y})
     
       {X - Y,2*Y**2 -1}
     
     ____________________________________________________________

related:

   [*note groebnerf::.] operator

   [*note gvarslast::.] variable

   [*note groebopt::.] switch

   [*note groebprereduce::.] switch

   [*note groebfullreduction::.] switch

   [*note gltbasis::.] switch

   [*note gltb::.] variable

   [*note glterms::.] variable

   [*note groebstat::.] switch

   [*note trgroeb::.] switch

   [*note trgroebs::.] switch

   [*note groebprot::.] switch

   [*note groebprotfile::.] variable

   [*note groebnert::.] operator


File: ..\util\r37,  Node: groebner_walk,  Next: groebopt,  Prev: groebner,  Up: Basic Groebner operators section

   GROEBNER_WALK                    operator

   The operator GROEBNER_WALK computes a lex basis from a given graded
(or weighted ) one.

syntax:

   GROEBNER_WALK (<g>)

   where <g> is a graded basis (or weighted basis with a weight vector
with one repeated element) of the polynomial ideal.  GROEBNER_WALK
computes a sequence of monomial bases, each time lifting the full
system to a complete basis. GROEBNER_WALK should be called only in
cases, where a normal kex computation would take too much computer time.

   The operator [*note torder::.] has to be called before in order to
define the variable sequence and the term order mode of <g>.

   The variable [*note gvarslast::.] is not set.

   Do not call GROEBNER_WALK with ON [*note groebopt::.] .

   GROEBNER_WALK includes some overhead (such as e. g.  computation
with division). On the other hand, sometimes GROEBNER_WALK  is faster
than a direct lex computation.


File: ..\util\r37,  Node: groebopt,  Next: gvarslast,  Prev: groebner_walk,  Up: Basic Groebner operators section

   GROEBOPT                    switch

   If GROEBOPT is set ON, the sequence of variables is optimized with
respect to execution speed of GROEBNER calculations; note that the
final list of variables is available in [*note gvarslast::.] .  By
default GROEBOPT is off, conserving the original variable sequence.

   An explicitly declared dependency using the [*note DEPEND::.]
declaration supersedes the variable optimization.

examples:

     ____________________________________________________________
     ____________________________________________________________

   guarantees that a will be placed in front of x and y.


File: ..\util\r37,  Node: gvarslast,  Next: groebprereduce,  Prev: groebopt,  Up: Basic Groebner operators section

   GVARSLAST                    variable

   After a [*note groebner::.] or [*note groebnerf::.] calculation the
actual variable sequence is stored in the variable GVARSLAST . If
[*note groebopt::.] is ON GVARSLAST  shows the variable sequence after
reordering.


File: ..\util\r37,  Node: groebprereduce,  Next: groebfullreduction,  Prev: gvarslast,  Up: Basic Groebner operators section

   GROEBPREREDUCE                    switch

   If GROEBPREREDUCE set ON, [*note groebner::.] and [*note
groebnerf::.] try to simplify the input expressions: if the head term
of an input expression is a multiple of the head term of another
expression, it can be reduced; these reductions are done cyclicly as
long as possible in order to shorten the main part of the algorithm.

   By default GROEBPREREDUCE is off.


File: ..\util\r37,  Node: groebfullreduction,  Next: gltbasis,  Prev: groebprereduce,  Up: Basic Groebner operators section

   GROEBFULLREDUCTION                    switch

   If GROEBFULLREDUCTION set off, the polynomial reduction steps during
[*note groebner::.]  and [*note groebnerf::.] are limited to the pure
head term reduction; subsequent terms are reduced otherwise.

   By default GROEBFULLREDUCTION is on.


File: ..\util\r37,  Node: gltbasis,  Next: gltb,  Prev: groebfullreduction,  Up: Basic Groebner operators section

   GLTBASIS                    switch

   If GLTBASIS set on, the leading terms of the result basis of a
[*note groebner::.] or [*note groebnerf::.] calculation are extracted.
They are collected as a basis of monomials, which is available as value
of the global variable [*note gltb::.] .


File: ..\util\r37,  Node: gltb,  Next: glterms,  Prev: gltbasis,  Up: Basic Groebner operators section

   GLTB                    variable

   See [*note gltbasis::.]


File: ..\util\r37,  Node: glterms,  Next: groebstat,  Prev: gltb,  Up: Basic Groebner operators section

   GLTERMS                    variable

   If the expressions in a [*note groebner::.] or [*note groebnerf::.]
call contain parameters (symbols which are not member of the variable
list), the share variable GLTERMS  is set to a list of expression which
during the calculation were assumed to be nonzero. The calculated bases
are valid only under the assumption that all these expressions do not
vanish.


File: ..\util\r37,  Node: groebstat,  Next: trgroeb,  Prev: glterms,  Up: Basic Groebner operators section

   GROEBSTAT                    switch

   if GROEBSTAT is on, a summary of the [*note groebner::.]  or [*note
groebnerf::.] computation is printed at the end including the computing
time, the number of intermediate H polynomials and the counters for the
criteria hits.


File: ..\util\r37,  Node: trgroeb,  Next: trgroebs,  Prev: groebstat,  Up: Basic Groebner operators section

   TRGROEB                    switch

   if TRGROEB is on, intermediate H polynomials are printed during a
[*note groebner::.] or [*note groebnerf::.] calculation.


File: ..\util\r37,  Node: trgroebs,  Next: gzerodim?,  Prev: trgroeb,  Up: Basic Groebner operators section

   TRGROEBS                    switch

   if TRGROEBS is on, intermediate H and S polynomials are printed
during a [*note groebner::.] or [*note groebnerf::.] calculation.


File: ..\util\r37,  Node: gzerodim?,  Next: gdimension,  Prev: trgroebs,  Up: Basic Groebner operators section

   GZERODIM?                    operator

syntax:

   GZERODIM!? (<basis>)

   where <bas> is a Groebner basis in the current [*note Term order::.]
with the actual setting (see [*note Ideal Parameters::.] ).

   GZERODIM!? tests whether the ideal spanned by the given basis has
dimension zero. If yes, the number of zeros is returned, [*note NIL::.]
otherwise.


File: ..\util\r37,  Node: gdimension,  Next: gindependent_sets,  Prev: gzerodim?,  Up: Basic Groebner operators section

   GDIMENSION                    operator

syntax:

   GDIMENSION (<bas>)

   where <bas> is a [*note groebner::.] basis in the current term order
(see [*note Ideal Parameters::.] ).  GDIMENSION  computes the dimension
of the ideal spanned by the given basis and returns the dimension as an
integer number. The Kredel-Weispfenning algorithm is used: the dimension
is the length of the longest independent variable set, see [*note
gindependent_sets::.]


File: ..\util\r37,  Node: gindependent_sets,  Next: dd_groebner,  Prev: gdimension,  Up: Basic Groebner operators section

   GINDEPENDENT_SETS                    operator

syntax:

   GINDEPENDENT_SETS (<bas>)

   where <bas> is a [*note groebner::.] basis in any TERM ORDER (which
must be the current TERM ORDER ) with the specified variables (see
[*note Ideal Parameters::.] ).

   GINDEPENDENT_SETS computes the maximal left independent variable
sets of the ideal, that are the variable sets which play the role of
free parameters in the current ideal basis. Each set is a list which is
a subset of the variable list. The result is a list of these sets. For
an ideal with dimension zero the list is empty.  The
Kredel-Weispfenning algorithm is used.


File: ..\util\r37,  Node: dd_groebner,  Next: glexconvert,  Prev: gindependent_sets,  Up: Basic Groebner operators section

   DD_GROEBNER                    operator

   For a homogeneous system of polynomials under [*note graded term
order::.] , [*note gradlex term order::.] , [*note revgradlex term
order::.] or [*note weighted term order::.] a Groebner Base can be
computed with limiting the grade of the intermediate S polynomials:

syntax:

   DD_GROEBNER (<d1>,<d2>,<plist>)

   where <d1> is a non negative integer and <d2> is an integer or
"infinity". A pair of polynomials is considered only if the grade of
the lcm of their head terms is between <d1> and <d2>.  For the term
orders GRADED or WEIGHTED the (first) weight vector is used for the
grade computation. Otherwise the total degree of a term is used.


File: ..\util\r37,  Node: glexconvert,  Next: greduce,  Prev: dd_groebner,  Up: Basic Groebner operators section

   GLEXCONVERT                    operator

syntax:

   GLEXCONVERT (<bas>[,<vars>][,MAXDEG=<mx>] [,NEWVARS=<nv>])

   where <bas> is a [*note groebner::.] basis in the current term
order, <mx> (optional) is a positive integer and <nvl> (optional) is a
list of variables (see [*note Ideal Parameters::.] ).

   The operator GLEXCONVERT converts the basis of a zero-dimensional
ideal (finite number of isolated solutions) from arbitrary ordering
into a basis under [*note lex term order::.] .

   The parameter <newvars> defines the new variable sequence.  If
omitted, the original variable sequence is used. If only a subset of
variables is specified here, the partial ideal basis is evaluated.

   If <newvars> is a list with one element, the minimal  UNIVARIATE
POLYNOMIAL  is computed.

   <maxdeg> is an upper limit for the degrees. The algorithm stops with
an error message, if this limit is reached.

   A warning occurs, if the ideal is not zero dimensional.

   During the call the TERM ORDER of the input basis must be active.


File: ..\util\r37,  Node: greduce,  Next: preduce,  Prev: glexconvert,  Up: Basic Groebner operators section

   GREDUCE                    operator

syntax:

   GREDUCE (exp, exp1, exp2, ... , expm)

   where exp is an expression, and exp1, exp2, ... , expm is a list of
expressions or equations.

   GREDUCE is functionally equivalent with a call to [*note
groebner::.]  and then a call to [*note preduce::.] .


File: ..\util\r37,  Node: preduce,  Next: idealquotient,  Prev: greduce,  Up: Basic Groebner operators section

   PREDUCE                    operator

syntax:

   PREDUCE (<p>, <exp>, ... )

   where <p> is an expression, and <exp>, ... is a list of expressions
or equations.

   PREDUCE computes the remainder of EXP modulo the given set of
polynomials resp. equations.  This result is unique (canonical) only if
the given set is a GROEBNER basis under the current [*note Term
order::.]

   see also: [*note preducet::.] operator.


File: ..\util\r37,  Node: idealquotient,  Next: hilbertpolynomial,  Prev: preduce,  Up: Basic Groebner operators section

   IDEALQUOTIENT                    operator

syntax:

   IDEALQUOTIENT (<exp>, ..., <d>)

   where <exp>,... is a list of expressions or equations, <d> is a
single expression or equation.

   IDEALQUOTIENT computes the ideal quotient: ideal spanned by the
expressions <exp>,...  divided by the single polynomial/expression <f>.
The result is the [*note groebner::.] basis of the quotient ideal.


File: ..\util\r37,  Node: hilbertpolynomial,  Prev: idealquotient,  Up: Basic Groebner operators section

   HILBERTPOLYNOMIAL                    operator

syntax:

   hilbertpolynomial(<bas>)

   where <bas> is a [*note groebner::.] basis in the current [*note
Term order::.] .

   The degree of the HILBERT POLYNOMIAL is the dimension of the ideal
spanned by the basis. For an ideal of dimension zero the Hilbert
polynomial is a constant which is the number of common zeros of the
ideal (including eventual multiplicities).  The HOLLMANN ALGORITHM is
used.


File: ..\util\r37,  Node: Basic Groebner operators section,  Next: Factorizing Groebner bases section,  Prev: Term order section,  Up: Groebner package section

   Basic Groebner operators section

* Menu:

* gvars::                   operator
* groebner::                operator
* groebner_walk::          operator
* groebopt::                switch
* gvarslast::               variable
* groebprereduce::          switch
* groebfullreduction::      switch
* gltbasis::                switch
* gltb::                    variable
* glterms::                 variable
* groebstat::               switch
* trgroeb::                 switch
* trgroebs::                switch
* gzerodim?::               operator
* gdimension::              operator
* gindependent_sets::      operator
* dd_groebner::             operator
* glexconvert::             operator
* greduce::                 operator
* preduce::                 operator
* idealquotient::           operator
* hilbertpolynomial::       operator


File: ..\util\r37,  Node: groebnerf,  Next: groebmonfac,  Up: Factorizing Groebner bases section

   GROEBNERF                    operator

syntax:

   GROEBNERF (<exp>, ...[,,<nz>, ... ]);

   where <exp>, ... is a list of expressions or equations, and <nz>,...
is an optional list of polynomials to be considered as non zero for
this calculation. An empty list must be passed as second argument if
the non-zero list is specified.

   GROEBNERF tries to separate polynomials into individual factors and
to branch the computation in a recursive manner (factorization tree).
The result is a list of partial Groebner bases.  Multiplicities (one
factor with a higher power, the same partial basis twice) are deleted
as early as possible in order to speed up the calculation.

   The third parameter of GROEBNERF declares some polynomials nonzero.
If any of these is found in a branch of the calculation the branch is
canceled.

example:

     ____________________________________________________________
     
     groebnerf({ 3*x**2*y+2*x*y+y+9*x**2+5*x = 3,
                 2*x**3*y-x*y-y+6*x**3-2*x**2-3*x = -3,
                 x**3*y+x**2*y+3*x**3+2*x**2 }, {y,x});
     
            {{Y - 3,X},
     
                           2
         {2*Y + 2*X - 1,2*X  - 5*X - 5}}
     ____________________________________________________________

related:

   [*note groebresmax::.] variable

   [*note groebmonfac::.] variable

   [*note groebrestriction::.] variable

   [*note groebner::.] operator

   [*note gvarslast::.] variable

   [*note groebopt::.] switch

   [*note groebprereduce::.] switch

   [*note groebfullreduction::.] switch

   [*note gltbasis::.] switch

   [*note gltb::.] variable

   [*note glterms::.] variable

   [*note groebstat::.] switch

   [*note trgroeb::.] switch

   [*note trgroebs::.] switch

   [*note groebnert::.] operator


File: ..\util\r37,  Node: groebmonfac,  Next: groebresmax,  Prev: groebnerf,  Up: Factorizing Groebner bases section

   GROEBMONFAC                    variable

   The variable GROEBMONFAC is connected to the handling of monomial
factors. A monomial factor is a product of variable powers as a factor,
e.g. x**2*y in x**3*y - 2*x**2*y**2. A monomial factor represents a
solution of the type  x = 0 or y = 0 with a certain multiplicity. With
[*note groebnerf::.]  the multiplicity of monomial factors is lowered
to the value of the shared variable GROEBMONFAC which by default is 1
(= monomial factors remain present, but their multiplicity is brought
down). With GROEBMONFAC := 0 the monomial factors are suppressed
completely.


File: ..\util\r37,  Node: groebresmax,  Next: groebrestriction,  Prev: groebmonfac,  Up: Factorizing Groebner bases section

   GROEBRESMAX                    variable

   The variable GROEBRESMAX controls during [*note groebnerf::.]
calculations the number of partial results. Its default value is 300. If
more partial results are calculated, the calculation is terminated.


File: ..\util\r37,  Node: groebrestriction,  Prev: groebresmax,  Up: Factorizing Groebner bases section

   GROEBRESTRICTION                    variable

   During [*note groebnerf::.] calculations irrelevant branches can be
excluded by setting the variable GROEBRESTRICTION . The following
restrictions are implemented:

syntax:

   GROEBRESTRICTION := NONNEGATIVE

   GROEBRESTRICTION := POSITIVE

   GROEBRESTRICTION := ZEROPOINT

   With NONNEGATIVE branches are excluded where one polynomial has no
nonnegative real zeros; with POSITIVE the restriction is sharpened to
positive zeros only.  The restriction ZEROPOINT excludes all branches
which do not have the origin (0,0,...0) in their solution set.


File: ..\util\r37,  Node: Factorizing Groebner bases section,  Next: Tracing Groebner bases section,  Prev: Basic Groebner operators section,  Up: Groebner package section

   Factorizing Groebner bases section

* Menu:

* groebnerf::               operator
* groebmonfac::             variable
* groebresmax::             variable
* groebrestriction::        variable


File: ..\util\r37,  Node: groebprot,  Next: groebprotfile,  Up: Tracing Groebner bases section

   GROEBPROT                    switch

   If GROEBPROT is ON the computation steps during [*note preduce::.] ,
[*note greduce::.] and [*note groebner::.] are collected in a list
which is assigned to the variable [*note groebprotfile::.] .


File: ..\util\r37,  Node: groebprotfile,  Next: groebnert,  Prev: groebprot,  Up: Tracing Groebner bases section

   GROEBPROTFILE                    variable

   See [*note groebprot::.] switch.


File: ..\util\r37,  Node: groebnert,  Next: preducet,  Prev: groebprotfile,  Up: Tracing Groebner bases section

   GROEBNERT                    operator

syntax:

   GROEBNERT (<v>=<exp>,...)

   where <v> are [*note KERNEL::.] S (simple or indexed variables),
<exp> are polynomials.

   GROEBNERT is functionally equivalent to a [*note groebner::.] call
for <exp>,..., but the result is a set of equations where the left-hand
sides are the basis elements while the right-hand sides are the same
values expressed as combinations of the input formulas, expressed in
terms of the names <v>

example:

     ____________________________________________________________
     
         groebnert({p1=2*x**2+4*y**2-100,p2=2*x-y+1});
     
        GB1 := {2*X - Y + 1=P2,
     
                2
             9*Y  - 2*Y - 199= - 2*X*P2 - Y*P2 + 2*P1 + P2}
     ____________________________________________________________


File: ..\util\r37,  Node: preducet,  Prev: groebnert,  Up: Tracing Groebner bases section

   PREDUCET                    operator

syntax:

   PREDUCE (<p>,<v>=<exp>...)

   where <p> is an expression, <v> are kernels (simple or indexed
variables), EXP  are polynomials.

   PREDUCET computes the remainder of <p> modulo <exp>,...  similar to
[*note preduce::.] , but the result is an equation which expresses the
remainder as combination of the polynomials.

example:

     ____________________________________________________________
     
     
        GB2 := {G1=2*X - Y + 1,G2=9*Y**2  - 2*Y - 199}
        preducet(q=x**2,gb2);
     
      - 16*Y + 208= - 18*X*G1 - 9*Y*G1 + 36*Q + 9*G1 - G2
     ____________________________________________________________


File: ..\util\r37,  Node: Tracing Groebner bases section,  Next: Groebner Bases for Modules section,  Prev: Factorizing Groebner bases section,  Up: Groebner package section

   Tracing Groebner bases section

* Menu:

* groebprot::               switch
* groebprotfile::           variable
* groebnert::               operator
* preducet::                operator


File: ..\util\r37,  Node: Module,  Next: gmodule,  Up: Groebner Bases for Modules section

   MODULE

   Given a polynomial ring, e.g. R=Z[x,y,...] and an integer n>1.  The
vectors with n elements of R form a free MODULE under elementwise
addition and multiplication with elements of R.

   For a submodule given by a finite basis a Groebner basis can be
computed, and the facilities of the GROEBNER package are available
except the operators [*note groebnerf::.] and GROESOLVE . The vectors
are encoded using auxiliary variables which represent the unit vectors
in the module.  These are declared in the share variable [*note
gmodule::.] .


File: ..\util\r37,  Node: gmodule,  Prev: Module,  Up: Groebner Bases for Modules section

   GMODULE                    variable

   The vectors of a free [*note Module::.] over a polynomial ring R are
encoded as linear combinations with unit vectors of M which are
represented by auxiliary variables. These must be collected in the
variable GMODULE before any call to an operator of the Groebner package.

     ____________________________________________________________
     
        torder({x,y,v1,v2,v3})$
        gmodule := {v1,v2,v3}$
        g:=groebner({x^2*v1 + y*v2,x*y*v1 - v3,2y*v1 + y*v3});
     ____________________________________________________________
   compute the Groebner basis of the submodule

     ____________________________________________________________
     
           ([x^2,y,0],[xy,0,-1],[0,2y,y])
     ____________________________________________________________
   The members of the list GMODULE are automatically appended to the
end of the variable list, if they are not yet members there. They take
part in the actual term ordering.


File: ..\util\r37,  Node: Groebner Bases for Modules section,  Next: Computing with distributive polynomials section,  Prev: Tracing Groebner bases section,  Up: Groebner package section

   Groebner Bases for Modules section

* Menu:

* Module::                  concept
* gmodule::                 variable


File: ..\util\r37,  Node: gsort,  Next: gsplit,  Up: Computing with distributive polynomials section

   GSORT                    operator

syntax:

   GSORT (<p>)

   where <p> is a polynomial or a list of polynomials.

   The polynomials are reordered and sorted corresponding to the
current [*note Term order::.] .

examples:

     ____________________________________________________________
     
     
       torder lex;
     
       gsort(x**2+2x*y+y**2,{y,x});
     
       y**2+2y*x+x**2
     
     ____________________________________________________________


File: ..\util\r37,  Node: gsplit,  Next: gspoly,  Prev: gsort,  Up: Computing with distributive polynomials section

   GSPLIT                    operator

syntax:

   GSPLIT (<p>[,<vars>]);

   where <p> is a polynomial or a list of polynomials.

   The polynomial is reordered corresponding to the the current [*note
Term order::.] and then separated into leading term and reductum.
Result is a list with the leading term as first and the reductum as
second element.

examples:

     ____________________________________________________________
     
     
       torder lex;
     
       gsplit(x**2+2x*y+y**2,{y,x});
     
       {y**2,2y*x+x**2}
     
     ____________________________________________________________


File: ..\util\r37,  Node: gspoly,  Prev: gsplit,  Up: Computing with distributive polynomials section

   GSPOLY                    operator

syntax:

   GSPOLY (<p1>,<p2>);

   where <p1> and <p2> are polynomials.

   The SUBTRACTION polynomial of p1 and p2 is computed corresponding to
the method of the Buchberger algorithm for computing GROEBNER BASES :
p1 and p2 are multiplied with terms such that when subtracting them the
leading terms cancel each other.


File: ..\util\r37,  Node: Computing with distributive polynomials section,  Prev: Groebner Bases for Modules section,  Up: Groebner package section

   Computing with distributive polynomials section

* Menu:

* gsort::                   operator
* gsplit::                  operator
* gspoly::                  operator


File: ..\util\r37,  Node: Groebner package section,  Next: High Energy Physics section,  Prev: Matrix Operations section,  Up: Top

   Groebner package section

* Menu:

* Groebner bases::          introduction
* Ideal Parameters::        concept
* Term order section::
* Basic Groebner operators section::
* Factorizing Groebner bases section::
* Tracing Groebner bases section::
* Groebner Bases for Modules section::
* Computing with distributive polynomials section::


File: ..\util\r37,  Node: HEPHYS,  Next: HE-dot,  Up: High Energy Physics section

   HEPHYS                    introduction

   The High-energy Physics package is historic for REDUCE, since REDUCE
originated as a program to aid in computations with Dirac expressions.
The commutation algebra of the gamma matrices is independent of their
representation, and is a natural subject for symbolic mathematics. Dirac
theory is applied to beta decay and the computation of cross-sections
and scattering. The high-energy physics operators are available in the
REDUCE main program, rather than as a module which must be loaded.


File: ..\util\r37,  Node: HE-dot,  Next: EPS,  Prev: HEPHYS,  Up: High Energy Physics section

   .     HE-DOT                    operator

   The . operator is used to denote the scalar product of two Lorentz
four-vectors.

syntax:

   <vector> . <vector>

   <vector> must be an identifier declared to be of type VECTOR to have
the scalar product definition. When applied to arguments that are not
vectors, the [*note CONS::.] operator is used, whose symbol is also
"dot."

examples:

     ____________________________________________________________
     
     vector aa,bb,cc;
     
     let aa.bb = 0;
     
     aa.bb;
     
       0
     
     
     aa.cc;
     
       AA.CC
     
     
     q := aa.cc;
     
       Q := AA.CC
     
     
     q;
     
       AA.CC
     
     ____________________________________________________________
   Since vectors are special high-energy physics entities that do not
contain values, the . product will not return a true scalar product.
You can assign a scalar identifier to the result of a . operation, or
assign a .  operation to have the value of the scalar you supply, as
shown above. Note that the result of a . operation is a scalar, not a
vector.

   The metric tensor g(u,v) can be represented by U.V . If contraction
over the indices is required, U and V should be declared to be of type
[*note INDEX::.] .

   The dot operator has the highest precedence of the infix operators,
so expressions involving . and other operators have the scalar product
evaluated first before other operations are done.


File: ..\util\r37,  Node: EPS,  Next: G,  Prev: HE-dot,  Up: High Energy Physics section

   EPS                    operator

   The EPS operator denotes the completely antisymmetric tensor of
order 4 and its contraction with Lorentz four-vectors, as used in
high-energy physics calculations.

syntax:

   EPS (<vector-expr>,<vector-expr>,<vector-expr>, <vector-expr>)

   <vector-expr> must be a valid vector expression, and may be an index.

examples:

     ____________________________________________________________
     
     vector g0,g1,g2,g3;
     
     eps(g1,g0,g2,g3);
     
       - EPS(G0,G1,G2,G3);
     
     
     eps(g1,g2,g0,g3);
     
       EPS(G0,G1,G2,G3);
     
     
     eps(g1,g2,g3,g1);
     
       0
     
     ____________________________________________________________
   Vector identifiers are ordered alphabetically by REDUCE. When an odd
number of transpositions is required to restore the canonical order to
the four arguments of EPS , the term is ordered and carries a minus
sign. When an even number of transpositions is required, the term is
returned ordered and positive. When one of the arguments is repeated,
the value 0 is returned.  A contraction of the form eps(_i j mu nu p_mu
q_nu) is represented by EPS(I,J,P,Q) when I and J have been declared to
be of type [*note INDEX::.] .


File: ..\util\r37,  Node: G,  Next: INDEX,  Prev: EPS,  Up: High Energy Physics section

   G                    operator

   G  is an n-ary operator used to denote a product of gamma matrices
contracted with Lorentz four-vectors, in high-energy physics.

syntax:

   G (<identifier>,<vector-expr> ,<vector-expr>*)

   <identifier> is a scalar identifier representing a fermion line
identifier, <vector-expr> can be any valid vector expression,
representing a vector or a gamma matrix.

examples:

     ____________________________________________________________
     
     vector aa,bb,cc;
     
     vector a;
     
     g(line1,aa,bb);
     
       AA.BB
     
     
     g(line2,aa,a);
     
       0
     
     
     g(id,aa,bb,cc);
     
       0
     
     
     g(li1,aa,bb) + k;
     
       AA.BB + K
     
     
     let aa.bb = m*k;
     
     g(ln1,aa)*g(ln1,bb);
     
       K*M
     
     
     g(ln1,aa)*g(ln2,bb);
     
       0
     
     ____________________________________________________________
   The vector A is reserved in arguments of G to denote the special
gamma matrix gamma_5. It must be declared to be a vector before you use
it.

   Gamma matrix expressions are associated with fermion lines in a
Feynman diagram. If more than one line occurs in an expression, the
gamma matrices involved are separate (operating in independent spin
space), as shown in the last two example lines above. A product of
gamma matrices associated with a single line can be entered either as a
single G command with several vector arguments, or as products of
separate G commands each with a single argument.

   While the product of vectors is not defined, the product, sum and
difference of several gamma expressions are defined, as is the product
of a gamma expression with a scalar. If an expression involving gamma
matrices includes a scalar, the scalar is treated as if it were the
product of itself with a unit 4 x 4 matrix.

   Dirac expressions are evaluated by computing the trace of the
expression using the commutation algebra of gamma matrices. The
algorithms used are described in articles by J. S. R. Chisholm in <Il
Nuovo Cimento X,> Vol.  30, p. 426, 1963, and J. Kahane, <Journal of
Mathematical Physics>, Vol. 9, p. 1732, 1968. The trace is then divided
by 4 to distinguish between the trace of a scalar and the trace of an
expression that is the product of a scalar with a unit 4 x 4 matrix.

   Trace calculations may be prevented over any line identifier by
declaring it to be [*note NOSPUR::.] . If it is later desired to
evaluate these traces, the declaration can be undone with the [*note
SPUR::.] declaration.

   The notation of Bjorken and Drell, <Relativistic Quantum Mechanics,>
1964, is assumed in all operations involving gamma matrices. For an
example of the use of G in a calculation, see the <REDUCE User's
Manual>.


File: ..\util\r37,  Node: INDEX,  Next: MASS,  Prev: G,  Up: High Energy Physics section

   INDEX                    declaration

   The declaration INDEX flags a four-vector as an index for subsequent
high-energy physics calculations.

syntax:

   INDEX <vector-id>,<vector-id>*

   <vector-id> must have been declared of type VECTOR .

examples:

     ____________________________________________________________
     
     vector aa,bb,cc;
     
     index uu;
     
     let aa.bb = 0;
     
     (aa.uu)*(bb.uu);
     
       0
     
     
     (aa.uu)*(cc.uu);
     
       AA.CC
     
     ____________________________________________________________
   Index variables are used to represent contraction over components of
vectors when scalar products are taken by the . operator, as well as
indicating contraction for the [*note EPS::.] operator or metric tensor.

   The special status of a vector as an index can be revoked with the
declaration [*note REMIND::.] . The object remains a vector, however.


File: ..\util\r37,  Node: MASS,  Next: MSHELL,  Prev: INDEX,  Up: High Energy Physics section

   MASS                    command

   The MASS command associates a scalar variable as a mass with the
corresponding vector variable, in high-energy physics calculations.

syntax:

   MASS <vector-var>= <scalar-var> ,<vector-var>= <scalar-var>*

   <vector-var> can be a declared vector variable; MASS will declare it
to be of type VECTOR if it is not. This may override an existing matrix
variable by that name. <scalar-var> must be a scalar variable.

examples:

     ____________________________________________________________
     
     vector bb,cc;
     
     mass cc=m;
     
     mshell cc;
     
     cc.cc;
     
        2
       M
     
     ____________________________________________________________
   Once a mass has been attached to a vector with a MASS declaration,
the [*note MSHELL::.] declaration puts the associated particle "on the
mass shell." Subsequent scalar (.) products of the vector with itself
will be replaced by the square of the mass expression.


File: ..\util\r37,  Node: MSHELL,  Next: NOSPUR,  Prev: MASS,  Up: High Energy Physics section

   MSHELL                    command

   The MSHELL command puts particles on the mass shell in high-energy
physics calculations.

syntax:

   MSHELL <vector-var>,<vector-var>*

   <vector-var> must have had a mass attached to it by a [*note MASS::.]
declaration.

examples:

     ____________________________________________________________
     
     vector v1,v2;
     
     mass v1=m,v2=q;
     
     mshell v1;
     
     v1.v1;
     
        2
       M
     
     
     v2.v2;
     
       V2.V2
     
     
     mshell v2;
     
     v1.v1*v2.v2;
     
        2  2
       M *Q
     
     ____________________________________________________________
   Even though a mass is attached to a vector variable representing a
particle, the replacement does not take place until the MSHELL
declaration is given for that vector variable.


File: ..\util\r37,  Node: NOSPUR,  Next: REMIND,  Prev: MSHELL,  Up: High Energy Physics section

   NOSPUR                    declaration

   The NOSPUR declaration prevents the trace calculation over the given
line identifiers in high-energy physics calculations.

syntax:

   NOSPUR <line-id>,<line-id>*

   <line-id> is a scalar identifier that will be used as a line
identifier.

examples:

     ____________________________________________________________
     
     vector a1,b1,c1;
     
     g(line1,a1,b1)*g(line2,b1,c1);
     
       A1.B1*B1.C1
     
     
     nospur line2;
     
     g(line1,a1,b1)*g(line2,b1,c1);
     
       A1.B1*G(LINE2,B1,C1)
     
     ____________________________________________________________
   Nospur declarations can be removed by making the declaration [*note
SPUR::.] .


File: ..\util\r37,  Node: REMIND,  Next: SPUR,  Prev: NOSPUR,  Up: High Energy Physics section

   REMIND                    declaration

   The REMIND declaration removes the special status of its arguments
as indices, which was set in the [*note INDEX::.] declaration, in
high-energy physics calculations.

syntax:

   REMIND <identifier>,<identifier>*

   <identifier> must have been declared to be of type [*note INDEX::.] .


File: ..\util\r37,  Node: SPUR,  Next: VECDIM,  Prev: REMIND,  Up: High Energy Physics section

   SPUR                    declaration

   The SPUR declaration removes the special exemption from trace
calculations that was declared by [*note NOSPUR::.] , in high-energy
physics calculations.

syntax:

   SPUR <line-id>,<line-id>*

   <line-id> must be a line-identifier that has previously been declared
NOSPUR .


File: ..\util\r37,  Node: VECDIM,  Next: VECTOR,  Prev: SPUR,  Up: High Energy Physics section

   VECDIM                    command

   The command VECDIM changes the vector dimension from 4 to an
arbitrary integer or symbol. Used in high-energy physics calculations.

syntax:

   VECDIM <dimension>

   <dimension> must be either an integer or a valid scalar identifier
that does not have a floating-point value.

   The [*note EPS::.] operator and the gamma_5 symbol (A ) are not
properly defined in anything except four dimensions and will print an
error message if you use them that way. The other high-energy physics
operators should work without problem.


File: ..\util\r37,  Node: VECTOR,  Prev: VECDIM,  Up: High Energy Physics section

   VECTOR                    declaration

   The VECTOR declaration declares that its arguments are of type
VECTOR .

syntax:

   VECTOR <identifier>,<identifier>*

   <identifier> must be a valid REDUCE identifier. It may have already
been used for a matrix, array, operator or scalar variable. After an
identifier has been declared to be a vector, it may not be used as a
scalar variable.

   Vectors are special entities for high-energy physics calculations.
You cannot put values into their coordinates; they do not have
coordinates.  They are legal arguments for the high-energy physics
operators [*note EPS::.] , [*note G::.] and . (dot). Vector variables
are used to represent gamma matrices and gamma matrices contracted with
Lorentz 4-vectors, since there are no Dirac variables per se in the
system.  Vectors do follow the usual vector rules for arithmetic
operations: +  and - operate upon two or more vectors, producing a
vector; * and / cannot be used between vectors; the scalar product is
represented by the . operator; and the product of a scalar and vector
expression is well defined, and is a vector.

   You can represent components of vectors by including representations
of unit vectors in your system. For instance, letting E0 represent the
unit vector (1,0,0,0), the command

   V1.E0 := 0; would set up the substitution of zero for the first
component of the vector V1 .

   Identifiers that are declared by the INDEX and MASS declarations are
automatically declared to be vectors.

   The following errors can occur in calculations using the high energy
physics package:

   A REPRESENTS ONLY GAMMA5 IN VECTOR EXPRESSIONS You have tried to use
A in some way other than gamma5 in a high-energy physics expression.

   GAMMA5 NOT ALLOWED UNLESS VECDIM IS 4 You have used gamma_5 in a
high-energy physics computation involving a vector dimension other than
4.

   <ID> HAS NO MASS

   One of the arguments to [*note MSHELL::.] has had no mass assigned
to it, in high-energy physics calculations.

   MISSING ARGUMENTS FOR G OPERATOR A line symbol is missing in a gamma
matrix expression in high-energy physics calculations.

   UNMATCHED INDEX <list>

   The parser has found unmatched indices during the evaluation of a
gamma matrix expression in high-energy physics calculations.


File: ..\util\r37,  Node: High Energy Physics section,  Next: Numeric Package section,  Prev: Groebner package section,  Up: Top

   High Energy Physics section

* Menu:

* HEPHYS::                  introduction
* HE-dot::                    .  operator
* EPS::                     operator
* G::                       operator
* INDEX::                   declaration
* MASS::                    command
* MSHELL::                  command
* NOSPUR::                  declaration
* REMIND::                  declaration
* SPUR::                    declaration
* VECDIM::                  command
* VECTOR::                  declaration


File: ..\util\r37,  Node: Numeric Package,  Next: Interval,  Up: Numeric Package section

   NUMERIC PACKAGE                    introduction

   The numeric package supplies algorithms based on approximation
techniques of numerical mathematics. The algorithms use the [*note
ROUNDED::.] mode arithmetic of REDUCE, including the variable precision
feature which is exploited in some algorithms in an adaptive manner in
order to reach the desired accuracy.


File: ..\util\r37,  Node: Interval,  Next: numeric accuracy,  Prev: Numeric Package,  Up: Numeric Package section

   INTERVAL                    type

   Intervals are generally coded as lower bound and upper bound
connected by the operator .. , usually associated to a variable in an
equation.

syntax:

   <var> = (<low> .. <high>)

   where <var> is a [*note KERNEL::.] and <low>, <high> are numbers or
expression which evaluate to numbers with <low><=<high>.

examples:

     ____________________________________________________________
     ____________________________________________________________
   means that the variable x is taken in the range from 2.5 up to 3.5.


File: ..\util\r37,  Node: numeric accuracy,  Next: TRNUMERIC,  Prev: Interval,  Up: Numeric Package section

   NUMERIC ACCURACY

   The keyword parameters ACCURACY=A and ITERATIONS=I , where A and I
must be positive integer numbers, control the iterative algorithms: the
iteration is continued until the local error is below 10**-a; if that
is impossible within I steps, the iteration is terminated with an error
message. The values reached so far are then returned as the result.


File: ..\util\r37,  Node: TRNUMERIC,  Next: num_min,  Prev: numeric accuracy,  Up: Numeric Package section

   TRNUMERIC                    switch

   Normally the algorithms produce only a minimum of printed output
during their operation. In cases of an unsuccessful or unexpected long
operation a TRACE OF THE ITERATION can be printed by setting TRNUMERIC
ON .


File: ..\util\r37,  Node: num_min,  Next: num_solve,  Prev: TRNUMERIC,  Up: Numeric Package section

   NUM_MIN                    operator

   The Fletcher Reeves version of the STEEPEST DESCENT algorithms is
used to find the MINIMUM of a function of one or more variables. The
function must have continuous partial derivatives with respect to all
variables. The starting point of the search can be specified; if not,
random values are taken instead.  The steepest descent algorithms in
general find only local minima.

syntax:

   NUM_MIN (<exp>,  <var>[=<val>] [,<var>[=<val>] ...   [,accuracy=<a>]
[,iterations=<i>])

   or

   NUM_MIN (exp,  <var>[=<val>] [,<var>[=<val>] ...]  [,accuracy=<a>]
[,iterations=<i>])

   where <exp> is a function expression, <var> are the variables in
<exp> and <val> are the (optional) start values.  For <a> and <i> see
[*note numeric accuracy::.] .

   NUM_MIN tries to find the next local minimum along the descending
path starting at the given point. The result is a [*note LIST::.] with
the minimum function value as first element followed by a list of
[*note EQUATION::.] S , where the variables are equated to the
coordinates of the result point.

examples:

     ____________________________________________________________
     
     num_min(sin(x)+x/5, x)
     
       {4.9489585606,{X=29.643767785}}
     
     
     num_min(sin(x)+x/5, x=0)
     
       { - 1.3342267466,{X= - 1.7721582671}}
     
     ____________________________________________________________


File: ..\util\r37,  Node: num_solve,  Next: num_int,  Prev: num_min,  Up: Numeric Package section

   NUM_SOLVE                    operator

   An adaptively damped Newton iteration is used to find an
approximative root of a function (function vector) or the solution of
an [*note EQUATION::.] (equation system). The expressions must have
continuous derivatives for all variables.  A starting point for the
iteration can be given. If not given random values are taken instead.
When the number of forms is not equal to the number of variables, the
Newton method cannot be applied. Then the minimum of the sum of
absolute squares is located instead.

   With [*note COMPLEX::.] on, solutions with imaginary parts can be
found, if either the expression(s) or the starting point contain a
nonzero imaginary part.

syntax:

   NUM_SOLVE (<exp>, <var>[=<val>][,accuracy=<a>][,iterations=<i>])

   or

   NUM_SOLVE (<exp>,...,<exp>, <var>[=<val>],...,<var>[=<val>]
[,accuracy=<a>][,iterations=<i>])

   or

   NUM_SOLVE (<exp>,...,<exp>, <var>[=<val>],...,<var>[=<val>]
[,accuracy=<a>][,iterations=<i>])

   where <exp> are function expressions,  <var> are the variables,
<val> are optional start values.  For <a> and <i> see [*note numeric
accuracy::.] .

   NUM_SOLVE tries to find a zero/solution of the expression(s).
Result is a list of equations, where the variables are equated to the
coordinates of the result point.

   The JACOBIAN MATRIX  is stored as side effect the shared variable
JACOBIAN .

examples:

     ____________________________________________________________
     
     num_solve({sin x=cos y, x + y = 1},{x=1,y=2});
     
     
       {X= - 1.8561957251,Y=2.856195584}
     
     
     jacobian;
     
           [COS(X)  SIN(Y)]
           [              ]
           [  1       1   ]
     
     ____________________________________________________________


File: ..\util\r37,  Node: num_int,  Next: num_odesolve,  Prev: num_solve,  Up: Numeric Package section

   NUM_INT                    operator

   For the numerical evaluation of univariate integrals over a finite
interval the following strategy is used: If [*note INT::.] finds a
formal antiderivative  which is bounded in the integration interval,
this  is evaluated and the end points and the difference  is returned.
Otherwise a [*note Chebyshev fit::.] is computed,  starting with order
20, eventually up to order 80.   If that is recognized as sufficiently
convergent  it is used for computing the integral by directly
integrating the coefficient sequence.  If none of these methods is
successful, an  adaptive multilevel quadrature algorithm is used.

   For multivariate integrals only the adaptive quadrature is used.
This algorithm tolerates isolated singularities.  The value ITERATIONS
here limits the number of local interval intersection levels.  <a> is a
measure for the relative total discretization error (comparison of
order 1 and order 2 approximations).

syntax:

   NUM_INT (<exp>,<var>=(<l> .. <u>)  [,<var>=(<l> .. <u>),...]
[,accuracy=<a>][,iterations=<i>])

   where <exp> is the function to be integrated, <var> are the
integration variables, <l> are the lower bounds, <u> are the upper
bounds.

   Result is the value of the integral.

examples:

     ____________________________________________________________
     
     num_int(sin x,x=(0 .. 3.1415926));
     
       2.0000010334
     
     ____________________________________________________________


File: ..\util\r37,  Node: num_odesolve,  Next: bounds,  Prev: num_int,  Up: Numeric Package section

   NUM_ODESOLVE                    operator

   The RUNGE-KUTTA method of order 3 finds an approximate graph for the
solution of real ODE INITIAL VALUE PROBLEM .

syntax:

   NUM_ODESOLVE (<exp>,<depvar>=<start>,  <indep>=(<from> .. <to>)
[,accuracy=<a>][,iterations=<i>])

   or

   NUM_ODESOLVE (<exp>,<exp>,...,  <depvar>=<start>,<depvar>=<start>,...
<indep>=(<from> .. <to>)  [,accuracy=<a>][,iterations=<i>])

   where <depvar> and <start> specify the dependent variable(s) and the
starting point value (vector), <indep>, <from> and <to> specify the
independent variable and the integration interval (starting point and
end point), <exp> are equations or expressions which contain the first
derivative of the independent variable with respect to the dependent
variable.

   The ODEs are converted to an explicit form, which then is used for a
Runge Kutta iteration over the given range. The number of steps is
controlled by the value of <i> (default: 20). If the steps are too
coarse to reach the desired accuracy in the neighborhood of the
starting point, the number is increased automatically.

   Result is a list of pairs, each representing a point of the
approximate solution of the ODE problem.

examples:

     ____________________________________________________________
     
     depend(y,x);
     
     num_odesolve(df(y,x)=y,y=1,x=(0 .. 1), iterations=5);
     
     
       ,{0.2,1.2214},{0.4,1.49181796},{0.6,1.8221064563},
         {0.8,2.2255208258},{1.0,2.7182511366}}
     
     ____________________________________________________________
   In most cases you must declare the dependency relation between the
variables explicitly using [*note DEPEND::.] ; otherwise the formal
derivative might be converted to zero.

   The operator [*note SOLVE::.] is used to convert the form into an
explicit ODE. If that process fails or if it has no unique result, the
evaluation is stopped with an error message.


File: ..\util\r37,  Node: bounds,  Next: Chebyshev fit,  Prev: num_odesolve,  Up: Numeric Package section

   BOUNDS                    operator

   Upper and lower bounds of a real valued function over an [*note
Interval::.]  or a rectangular multivariate domain are computed by the
operator BOUNDS . The algorithmic basis is the computation with
inequalities: starting from the interval(s) of the variables, the
bounds are propagated in the expression using the rules for inequality
computation. Some knowledge about the behavior of special functions
like ABS, SIN, COS, EXP, LOG, fractional exponentials etc. is
integrated and can be evaluated if the operator BOUNDS is called with
rounded mode on (otherwise only algebraic evaluation rules are
available).

   If BOUNDS finds a singularity within an interval, the evaluation is
stopped with an error message indicating the problem part of the
expression.

syntax:

   BOUNDS (<exp>,<var>=(<l> .. <u>)  [,<var>=(<l> .. <u>) ...])

   or

   BOUNDS (<exp>,<var>=(<l> .. <u>)  [,<var>=(<l> .. <u>) ...])

   where <exp> is the function to be investigated, <var> are the
variables of <exp>, <l> and <u> specify the area as set of [*note
Interval::.] S .

   BOUNDS computes upper and lower bounds for the expression in the
given area. An [*note Interval::.] is returned.

examples:

     ____________________________________________________________
     
     bounds(sin x,x=(1 .. 2));
     
       -1 .. 1
     
     
     on rounded;
     
     bounds(sin x,x=(1 .. 2));
     
       0.84147098481 .. 1
     
     
     bounds(x**2+x,x=(-0.5 .. 0.5));
     
       - 0.25 .. 0.75
     
     ____________________________________________________________


File: ..\util\r37,  Node: Chebyshev fit,  Next: num_fit,  Prev: bounds,  Up: Numeric Package section

   CHEBYSHEV FIT

   The operator family CHEBYSHEV_... implements approximation and
evaluation of functions by the Chebyshev method.  Let T(N,A,B,X) be the
Chebyshev polynomial of order N transformed to the interval (A,B) .
Then a function F(X) can be approximated in (A,B) by a series

     ____________________________________________________________
     
       for i := 0:n sum c(i)*T(i,a,b,x)
     ____________________________________________________________
   The operator CHEBYSHEV_FIT computes this approximation and returns a
list, which has as first element the sum expressed as a polynomial and
as second element the sequence of Chebyshev coefficients.  CHEBYSHEV_DF
and CHEBYSHEV_INT transform a Chebyshev coefficient list into the
coefficients of the corresponding derivative or integral respectively.
For evaluating a Chebyshev approximation at a given point in the basic
interval the operator CHEBYSHEV_EVAL can be used.  CHEBYSHEV_EVAL  is
based on a recurrence relation which is in general more stable than a
direct evaluation of the complete polynomial.

syntax:

   CHEBYSHEV_FIT (<fcn>,<var>=(<lo> .. <hi>),<n>)

   CHEBYSHEV_EVAL (<coeffs>,<var>=(<lo> .. <hi>),  <var>=<pt>)

   CHEBYSHEV_DF (<coeffs>,<var>=(<lo> .. <hi>))

   CHEBYSHEV_INT (<coeffs>,<var>=(<lo> .. <hi>))

   where <fcn> is an algebraic expression (the target function), <var>
is the variable of <fcn>, <lo> and <hi> are numerical real values which
describe an [*note Interval::.] <lo> < <hi>, the integer <n> is the
approximation order (set to 20 if missing), <pt> is a number in the
interval and <coeffs> is a series of Chebyshev coefficients.

examples:

     ____________________________________________________________
     
     
     on rounded;
     
     
     w:=chebyshev_fit(sin x/x,x=(1 .. 3),5);
     
     
                      3            2
       w := {0.03824*x   - 0.2398*x   + 0.06514*x + 0.9778,
             {0.8991,-0.4066,-0.005198,0.009464,-0.00009511}}
     
     
     chebyshev_eval(second w, x=(1 .. 3), x=2.1);
     
     
       0.4111
     
     ____________________________________________________________


File: ..\util\r37,  Node: num_fit,  Prev: Chebyshev fit,  Up: Numeric Package section

   NUM_FIT                    operator

   The operator NUM_FIT finds for a set of points the linear
combination of a given set of functions (function basis) which
approximates the points best under the objective of the LEAST SQUARES
criterion (minimum of the sum of the squares of the deviation).  The
solution is found as zero of the gradient vector of the sum of squared
errors.

syntax:

   NUM_FIT (<vals>,<basis>,<var>=<pts>)

   where <vals> is a list of numeric values, <var> is a variable used
for the approximation, <pts> is a list of coordinate values which
correspond to <var>, <basis> is a set of functions varying in VAR which
is used  for the approximation.

   The result is a list containing as first element the function which
approximates the given values, and as second element a list of
coefficients which were used to build this function from the basis.

examples:

     ____________________________________________________________
     
     
     pts:=for i:=1 step 1 until 5 collect i$
     
     vals:=for i:=1 step 1 until 5 collect
     
                 for j:=1:i product j$
     
     num_fit(vals,{1,x,x**2},x=pts);
     
                          2
           {14.571428571*X   - 61.428571429*X + 54.6,{54.6,
                - 61.428571429,14.571428571}}
     
     ____________________________________________________________


File: ..\util\r37,  Node: Numeric Package section,  Next: Roots Package section,  Prev: High Energy Physics section,  Up: Top

   Numeric Package section

* Menu:

* Numeric Package::         introduction
* Interval::                type
* numeric accuracy::        concept
* TRNUMERIC::               switch
* num_min::                 operator
* num_solve::               operator
* num_int::                 operator
* num_odesolve::            operator
* bounds::                  operator
* Chebyshev fit::           concept
* num_fit::                 operator


File: ..\util\r37,  Node: Roots Package,  Next: MKPOLY,  Up: Roots Package section

   ROOTS PACKAGE                    introduction

   The root finding package is designed so that it can be used to find
some or all of the roots of univariate polynomials with real or complex
coefficients, to the accuracy specified by the user.

   Not all operators of ROOTS PACKAGE are described here. For using the
operators

   ISOLATER  (intervals isolating real roots)

   RLROOTNO  (number of real roots in an interval)

   ROOTSAT-PREC  (roots at system precision)

   ROOTVAL  (result in equation form)

   FIRSTROOT  (computing only one root)

   GETROOT  (selecting roots from a collection)

   please consult the full documentation of the package.


File: ..\util\r37,  Node: MKPOLY,  Next: NEARESTROOT,  Prev: Roots Package,  Up: Roots Package section

   MKPOLY                    operator

   Given a roots list as returned by [*note ROOTS::.] , the operator
MKPOLY constructs a polynomial which has these numbers as roots.

syntax:

   MKPOLY <rl>

   where <rl> is a [*note LIST::.] with equations, which all have the
same [*note KERNEL::.] on their left-hand sides and numbers as
right-hand sides.

examples:

     ____________________________________________________________
     
     mkpoly{x=1,x=-2,x=i,x=-i};
     
       x**4 + x**3 - x**2 + x - 2
     
     ____________________________________________________________
   Note that this polynomial is unique only up to a numeric factor.


File: ..\util\r37,  Node: NEARESTROOT,  Next: REALROOTS,  Prev: MKPOLY,  Up: Roots Package section

   NEARESTROOT                    operator

   The operator NEARESTROOT finds one root of a polynomial with an
iteration using a given starting point.

syntax:

   NEARESTROOT (<p>,<pt>)

   where <p> is a univariate polynomial and <pt> is a number.

examples:

     ____________________________________________________________
     
     nearestroot(x^2+2,2);
     
       {x=1.41421*i}
     
     ____________________________________________________________
   The minimal accuracy of the result values is controlled by [*note
ROOTACC::.] .


File: ..\util\r37,  Node: REALROOTS,  Next: ROOTACC,  Prev: NEARESTROOT,  Up: Roots Package section

   REALROOTS                    operator

   The operator REALROOTS finds that real roots of a polynomial to an
accuracy that is sufficient to separate them and which is a minimum of
6 decimal places.

syntax:

   REALROOTS (<p>) or

   REALROOTS (<p>,<from>,<to>)

   where <p> is a univariate polynomial.  The optional parameters
<from> and <to> classify an interval: if given, exactly the real roots
in this interval will be returned. <from> and <to> can also take the
values INFINITY or -INFINITY .  If omitted all real roots will be
returned.  Result is a [*note LIST::.] of equations which represent the
roots of the polynomial at the given accuracy.

examples:

     ____________________________________________________________
     
     realroots(x^5-2);
     
       {x=1.1487}
     
     
     realroots(x^3-104*x^2+403*x-300,2,infinity);
     
     
       {x=3.0,x=100.0}
     
     
     realroots(x^3-104*x^2+403*x-300,-infinity,2);
     
     
       {x=1}
     
     ____________________________________________________________
   The minimal accuracy of the result values is controlled by [*note
ROOTACC::.] .


File: ..\util\r37,  Node: ROOTACC,  Next: ROOTS,  Prev: REALROOTS,  Up: Roots Package section

   ROOTACC                    operator

   The operator ROOTACC allows you to set the accuracy up to which the
roots package computes its results.

syntax:

   ROOTACC (<n>)

   Here <n> is an integer value. The internal accuracy of the ROOTS
package is adjusted to a value of MAX(6,N) . The default value is 6 .


File: ..\util\r37,  Node: ROOTS,  Next: ROOT_VAL,  Prev: ROOTACC,  Up: Roots Package section

   ROOTS                    operator

   The operator ROOTS is the main top level function of the roots
package.  It will find all roots, real and complex, of the polynomial p
to an accuracy that is sufficient to separate them and which is a
minimum of 6 decimal places.

syntax:

   ROOTS (<p>)

   where <p> is a univariate polynomial. Result is a [*note LIST::.] of
equations which represent the roots of the polynomial at the given
accuracy. In addition, ROOTS stores separate lists of real roots and
complex roots in the global variables [*note ROOTSREAL::.] and [*note
ROOTSCOMPLEX::.] .

examples:

     ____________________________________________________________
     
     roots(x^5-2);
     
       {x=-0.929316 + 0.675188*i,
         x=-0.929316 - 0.675188*i,
         x=0.354967 + 1.09248*i,
         x=0.354967 - 1.09248*i,
         x=1.1487}
     
     ____________________________________________________________
   The minimal accuracy of the result values is controlled by [*note
ROOTACC::.] .


File: ..\util\r37,  Node: ROOT_VAL,  Next: ROOTSCOMPLEX,  Prev: ROOTS,  Up: Roots Package section

   ROOT_VAL                    operator

   The operator ROOT_VAL computes the roots of a univariate polynomial
at system precision (or greater if required for root separation) and
presents its result as a list of numbers.

syntax:

   ROOTS (<p>)

   where <p> is a univariate polynomial.

examples:

     ____________________________________________________________
     
     root_val(x^5-2);
     
       {-0.929316490603 + 0.6751879524*i,
        -0.929316490603 - 0.6751879524*i,
        0.354967313105 + 1.09247705578*i,
        0.354967313105 - 1.09247705578*i,
        1.148698355}
     
     ____________________________________________________________


File: ..\util\r37,  Node: ROOTSCOMPLEX,  Next: ROOTSREAL,  Prev: ROOT_VAL,  Up: Roots Package section

   ROOTSCOMPLEX                    variable

   When the operator [*note ROOTS::.] is called the complex roots are
collected in the global variable ROOTSCOMPLEX as [*note LIST::.] .


File: ..\util\r37,  Node: ROOTSREAL,  Prev: ROOTSCOMPLEX,  Up: Roots Package section

   ROOTSREAL                    variable

   When the operator [*note ROOTS::.] is called the real roots are
collected in the global variable ROOTREAL as [*note LIST::.] .


File: ..\util\r37,  Node: Roots Package section,  Next: Special Functions section,  Prev: Numeric Package section,  Up: Top

   Roots Package section

* Menu:

* Roots Package::           introduction
* MKPOLY::                  operator
* NEARESTROOT::             operator
* REALROOTS::               operator
* ROOTACC::                 operator
* ROOTS::                   operator
* ROOT_VAL::               operator
* ROOTSCOMPLEX::            variable
* ROOTSREAL::               variable


File: ..\util\r37,  Node: Special Function Package,  Next: Constants,  Up: Special Functions section

   SPECIAL FUNCTION PACKAGE                    introduction

   The REDUCE SPECIAL FUNCTION PACKAGE supplies extended algebraic and
numeric support for a wide class of objects.  This package was released
together with REDUCE 3.5 (October 1993) for the first time, a major
update is released with REDUCE 3.6.

   The functions included in this package are in most cases (unless
otherwise stated) defined and named like in the book by Abramowitz and
Stegun: Handbook of Mathematical Functions, Dover Publications.

   The aim is to collect as much information on the special functions
and simplification capabilities as possible, i.e. algebraic
simplifications and numeric (rounded mode) code, limits of the
functions together with the definitions of the functions, which are in
most cases a power series, a (definite) integral and/or a differential
equation.

   What can be found: Some famous constants, a variety of Bessel
functions, special polynomials, the Gamma function, the (Riemann) Zeta
function, Elliptic Functions, Elliptic Integrals, 3J symbols
(Clebsch-Gordan coefficients) and integral functions.

   What is missing: Mathieu functions, LerchPhi, etc..  The information
about the special functions which solve certain differential equation
is very limited.  In several cases numerical approximation is
restricted to real arguments or is missing completely.

   The implementation of this package uses REDUCE rule sets to a large
extent, which guarantees a high 'readability' of the functions
definitions in the source file directory. It makes extensions to the
special functions code easy in most cases too. To look at these rules
it may be convenient to use the showrules operator e.g.

   [*note SHOWRULES::.] Besseli;

   .

   Some evaluations are improved if the special function package is
loaded, e.g. some (infinite) sums and products leading to expressions
including special functions are known in this case.

   Note: The special function package has to be loaded explicitly by
calling
     ____________________________________________________________
     
        load_package specfn;
     ____________________________________________________________

   The functions [*note MeijerG::.] and [*note HYPERGEOMETRIC::.]
require additionally
     ____________________________________________________________
     
        load_package specfn2;
     ____________________________________________________________


File: ..\util\r37,  Node: Constants,  Next: Bernoulli Euler Zeta section,  Prev: Special Function Package,  Up: Special Functions section

   CONSTANTS

   There are a few constants known to the special function package,
namely

   EULER CONSTANT  (which can be computed as -[*note PSI::.] (1)) and

   KHINCHIN CONSTANT  (which is defined in Khinchin's book  "Continued
Fractions") and

   GOLDEN_RATIO  (which can be computed as (1 + sqrt 5)/2) and

   CATALAN CONSTANT  (which is known as an infinite sum of reciprocal
powers)

examples:

     ____________________________________________________________
     
     on rounded;
     Euler_Gamma;
     
       0.577215664902
     
     
     Khinchin;
     
       2.68545200107
     
     
     Catalan
     
       0.915965594177
     
     
     Golden_Ratio
     
       1.61803398875
     
     ____________________________________________________________


File: ..\util\r37,  Node: BERNOULLI,  Next: BERNOULLIP,  Up: Bernoulli Euler Zeta section

   BERNOULLI                    operator

   The BERNOULLI operator returns the nth Bernoulli number.

syntax:

   BERNOULLI (<integer>)

examples:

     ____________________________________________________________
     
     bernoulli 20;
     
       - 174611 / 330
     
     
     bernoulli 17;
     
       0
     
     ____________________________________________________________
   All Bernoulli numbers with odd indices except for 1 are zero.


File: ..\util\r37,  Node: BERNOULLIP,  Next: EULER,  Prev: BERNOULLI,  Up: Bernoulli Euler Zeta section

   BERNOULLIP                    operator

   The BERNOULLIP operator returns the nth Bernoulli Polynomial
evaluated at x.

syntax:

   BERNOULLIP (<integer>,<expression>)

examples:

     ____________________________________________________________
     
     BernoulliP(3,z);
     
             2
       z*(2*z   - 3*z + 1)/2
     
     
     
     BernoulliP(10,3);
     
       338585 / 66
     
     ____________________________________________________________
   The value of the nth Bernoulli Polynomial at 0 is the nth Bernoulli
number.


File: ..\util\r37,  Node: EULER,  Next: EULERP,  Prev: BERNOULLIP,  Up: Bernoulli Euler Zeta section

   EULER                    operator

   The EULER operator returns the nth Euler number.

syntax:

   EULER (<integer>)

examples:

     ____________________________________________________________
     
     Euler 20;
     
       370371188237525
     
     
     Euler 0;
     
       1
     
     ____________________________________________________________
   The EULER numbers are evaluated by a recursive algorithm which makes
it hard to compute Euler numbers above say 200.

   Euler numbers appear in the coefficients of the power series
representation of 1/cos(z).


File: ..\util\r37,  Node: EULERP,  Next: ZETA,  Prev: EULER,  Up: Bernoulli Euler Zeta section

   EULERP                    operator

   The EULERP operator returns the nth Euler Polynomial.

syntax:

   EULERP (<integer>,<expression>)

examples:

     ____________________________________________________________
     
     EulerP(2,xx);
     
       xx*(xx - 1)
     
     
     EulerP(10,3);
     
       2046
     
     ____________________________________________________________
   The Euler numbers are the values of the Euler Polynomials at 1/2
multiplied by 2**n.


File: ..\util\r37,  Node: ZETA,  Prev: EULERP,  Up: Bernoulli Euler Zeta section

   ZETA                    operator

   The ZETA operator returns Riemann's Zeta function,

   Zeta (z) := sum(1/(k**z),k,1,infinity)

syntax:

   ZETA (<expression>)

examples:

     ____________________________________________________________
     
     Zeta(2);
     
         2
       pi  / 6
     
     
     on rounded;
     
     Zeta 1.01;
     
       100.577943338
     
     ____________________________________________________________
   Numerical computation for the Zeta function for arguments close to 1
are tedious, because the series is converging very slowly. In this case
a formula (e.g. found in Bender/Orzag: Advanced Mathematical Methods for
Scientists and Engineers, McGraw-Hill) is used.

   No numerical approximation for complex arguments is done.


File: ..\util\r37,  Node: Bernoulli Euler Zeta section,  Next: Bessel Functions section,  Prev: Constants,  Up: Special Functions section

   Bernoulli Euler Zeta section

* Menu:

* BERNOULLI::               operator
* BERNOULLIP::              operator
* EULER::                   operator
* EULERP::                  operator
* ZETA::                    operator


File: ..\util\r37,  Node: BESSELJ,  Next: BESSELY,  Up: Bessel Functions section

   BESSELJ                    operator

   The BESSELJ operator returns the Bessel function of the first kind.

syntax:

   BESSELJ (<order>,<argument>)

examples:

     ____________________________________________________________
     
     BesselJ(1/2,pi);
     
       0
     
     
     on rounded;
     
     BesselJ(0,1);
     
       0.765197686558
     
     ____________________________________________________________


File: ..\util\r37,  Node: BESSELY,  Next: HANKEL1,  Prev: BESSELJ,  Up: Bessel Functions section

   BESSELY                    operator

   The BESSELY operator returns the Bessel function of the second kind.

syntax:

   BESSELY (<order>,<argument>)

examples:

     ____________________________________________________________
     
     BesselY (1/2,pi);
     
       - sqrt(2) / pi
     
     
     on rounded;
     
     BesselY (1,3);
     
       0.324674424792
     
     ____________________________________________________________
   The operator BESSELY is also called Weber's function.


File: ..\util\r37,  Node: HANKEL1,  Next: HANKEL2,  Prev: BESSELY,  Up: Bessel Functions section

   HANKEL1                    operator

   The HANKEL1 operator returns the Hankel function of the first kind.

syntax:

   HANKEL1 (<order>,<argument>)

examples:

     ____________________________________________________________
     
     on complex;
     
     Hankel1 (1/2,pi);
     
       - i * sqrt(2) / pi
     
     
     Hankel1 (1,pi);
     
       besselj(1,pi) + i*bessely(1,pi)
     
     ____________________________________________________________
   The operator HANKEL1 is also called Bessel function of the third
kind.  There is currently no numeric evaluation of Hankel functions.


File: ..\util\r37,  Node: HANKEL2,  Next: BESSELI,  Prev: HANKEL1,  Up: Bessel Functions section

   HANKEL2                    operator

   The HANKEL2 operator returns the Hankel function of the second kind.

syntax:

   HANKEL2 (<order>,<argument>)

examples:

     ____________________________________________________________
     
     on complex;
     
     Hankel2 (1/2,pi);
     
       - i * sqrt(2) / pi
     
     
     Hankel2 (1,pi);
     
       besselj(1,pi) - i*bessely(1,pi)
     
     ____________________________________________________________
   The operator HANKEL2 is also called Bessel function of the third
kind.  There is currently no numeric evaluation of Hankel functions.


File: ..\util\r37,  Node: BESSELI,  Next: BESSELK,  Prev: HANKEL2,  Up: Bessel Functions section

   BESSELI                    operator

   The BESSELI operator returns the modified Bessel function I.

syntax:

   BESSELI (<order>,<argument>)

examples:

     ____________________________________________________________
     
     on rounded;
     
     Besseli (1,1);
     
       0.565159103992
     
     ____________________________________________________________
   The knowledge about the operator BESSELI is currently fairly limited.


File: ..\util\r37,  Node: BESSELK,  Next: StruveH,  Prev: BESSELI,  Up: Bessel Functions section

   BESSELK                    operator

   The BESSELK operator returns the modified Bessel function K.

syntax:

   BESSELK (<order>,<argument>)

examples:

     ____________________________________________________________
     
     df(besselk(0,x),x);
     
       - besselk(1,x)
     
     ____________________________________________________________
   There is currently no numeric support for the operator BESSELK .


File: ..\util\r37,  Node: StruveH,  Next: StruveL,  Prev: BESSELK,  Up: Bessel Functions section

   STRUVEH                    operator

   The STRUVEH operator returns Struve's H function.

syntax:

   STRUVEH (<order>,<argument>)

examples:

     ____________________________________________________________
     
     struveh(-3/2,x);
     
       - besselj(3/2,x) / i
     
     ____________________________________________________________


File: ..\util\r37,  Node: StruveL,  Next: KummerM,  Prev: StruveH,  Up: Bessel Functions section

   STRUVEL                    operator

   The STRUVEL operator returns the modified Struve L function .

syntax:

   STRUVEL (<order>,<argument>)

examples:

     ____________________________________________________________
     
     struvel(-3/2,x);
     
       besseli(3/2,x)
     
     ____________________________________________________________


File: ..\util\r37,  Node: KummerM,  Next: KummerU,  Prev: StruveL,  Up: Bessel Functions section

   KUMMERM                    operator

   The KUMMERM operator returns Kummer's M function.

syntax:

   KUMMERM (<parameter>,<parameter>,<argument>)

examples:

     ____________________________________________________________
     
     kummerm(1,1,x);
     
        x
       e
     
     
     on rounded;
     
     kummerm(1,3,1.3);
     
       1.62046942914
     
     ____________________________________________________________
   Kummer's M function is one of the Confluent Hypergeometric functions.
For reference see the [*note HYPERGEOMETRIC::.] operator.


File: ..\util\r37,  Node: KummerU,  Next: WhittakerW,  Prev: KummerM,  Up: Bessel Functions section

   KUMMERU                    operator

   The KUMMERU operator returns Kummer's U function.

syntax:

   KUMMERU (<parameter>,<parameter>,<argument>)

examples:

     ____________________________________________________________
     
     df(kummeru(1,1,x),x)
     
       - kummeru(2,2,x)
     
     ____________________________________________________________
   Kummer's U function is one of the Confluent Hypergeometric functions.
For reference see the [*note HYPERGEOMETRIC::.] operator.


File: ..\util\r37,  Node: WhittakerW,  Prev: KummerU,  Up: Bessel Functions section

   WHITTAKERW                    operator

   The WHITTAKERW operator returns Whittaker's W function.

syntax:

   WHITTAKERW (<parameter>,<parameter>,<argument>)

examples:

     ____________________________________________________________
     
     WhittakerW(2,2,2);
     
                         1
       4*sqrt(2)*kummeru(-,5,2)
                         2
       -------------------------
                  e
     
     ____________________________________________________________
   Whittaker's W function is one of the Confluent Hypergeometric
functions.  For reference see the [*note HYPERGEOMETRIC::.] operator.


File: ..\util\r37,  Node: Bessel Functions section,  Next: Airy Functions section,  Prev: Bernoulli Euler Zeta section,  Up: Special Functions section

   Bessel Functions section

* Menu:

* BESSELJ::                 operator
* BESSELY::                 operator
* HANKEL1::                 operator
* HANKEL2::                 operator
* BESSELI::                 operator
* BESSELK::                 operator
* StruveH::                 operator
* StruveL::                 operator
* KummerM::                 operator
* KummerU::                 operator
* WhittakerW::              operator


File: ..\util\r37,  Node: Airy_Ai,  Next: Airy_Bi,  Up: Airy Functions section

   AIRY_AI                    operator

   The AIRY_AI operator returns the Airy Ai function for a given
argument.

syntax:

   AIRY_AI (<argument>)

examples:

     ____________________________________________________________
     
     on complex;
     on rounded;
     Airy_Ai(0);
     
     
       0.355028053888
     
     
     Airy_Ai(3.45 + 17.97i);
     
       - 5.5561528511e+9 - 8.80397899932e+9*i
     
     ____________________________________________________________


File: ..\util\r37,  Node: Airy_Bi,  Next: Airy_Aiprime,  Prev: Airy_Ai,  Up: Airy Functions section

   AIRY_BI                    operator

   The AIRY_BI operator returns the Airy Bi function for a given
argument.

syntax:

   AIRY_BI (<argument>)

examples:

     ____________________________________________________________
     
     Airy_Bi(0);
     
       0.614926627446
     
     
     Airy_Bi(3.45 + 17.97i);
     
       8.80397899932e+9 - 5.5561528511e+9*i
     
     ____________________________________________________________


File: ..\util\r37,  Node: Airy_Aiprime,  Next: Airy_Biprime,  Prev: Airy_Bi,  Up: Airy Functions section

   AIRY_AIPRIME                    operator

   The AIRY_AIPRIME operator returns the Airy Aiprime function for a
given argument.

syntax:

   AIRY_AIPRIME (<argument>)

examples:

     ____________________________________________________________
     
     Airy_Aiprime(0);
     
       - 0.258819403793
     
     
     Airy_Aiprime(3.45+17.97i);
     
       - 3.83386421824e+19 + 2.16608828136e+19*i
     
     ____________________________________________________________


File: ..\util\r37,  Node: Airy_Biprime,  Prev: Airy_Aiprime,  Up: Airy Functions section

   AIRY_BIPRIME                    operator

   The AIRY_BIPRIME operator returns the Airy Biprime function for a
given argument.

syntax:

   AIRY_BIPRIME (<argument>)

examples:

     ____________________________________________________________
     
     Airy_Biprime(0);
     
     
     Airy_Biprime(3.45 + 17.97i);
     
       3.84251916792e+19 - 2.18006297399e+19*i
     
     ____________________________________________________________


File: ..\util\r37,  Node: Airy Functions section,  Next: Jacobi Elliptic Functions and Elliptic Integrals section,  Prev: Bessel Functions section,  Up: Special Functions section

   Airy Functions section

* Menu:

* Airy_Ai::                 operator
* Airy_Bi::                 operator
* Airy_Aiprime::            operator
* Airy_Biprime::            operator


File: ..\util\r37,  Node: JacobiSN,  Next: JacobiCN,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBISN                    operator

   The JACOBISN operator returns the Jacobi Elliptic function sn.

syntax:

   JACOBISN (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     Jacobisn(0.672, 0.36)
     
       0.609519691792
     
     
     Jacobisn(1,0.9)
     
       0.770085724907881
     
     ____________________________________________________________


File: ..\util\r37,  Node: JacobiCN,  Next: JacobiDN,  Prev: JacobiSN,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBICN                    operator

   The JACOBICN operator returns the Jacobi Elliptic function cn.

syntax:

   JACOBICN (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     Jacobicn(7.2, 0.6)
     
       0.837288298482018
     
     
     Jacobicn(0.11, 19)
     
       0.994403862690043 - 1.6219006985556e-16*i
     
     ____________________________________________________________


File: ..\util\r37,  Node: JacobiDN,  Next: JacobiCD,  Prev: JacobiCN,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBIDN                    operator

   The JACOBIDN operator returns the Jacobi Elliptic function dn.

syntax:

   JACOBIDN (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     Jacobidn(15, 0.683)
     
       0.640574162024592
     
     
     Jacobidn(0,0)
     
       1
     
     ____________________________________________________________


File: ..\util\r37,  Node: JacobiCD,  Next: JacobiSD,  Prev: JacobiDN,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBICD                    operator

   The JACOBICD operator returns the Jacobi Elliptic function cd.

syntax:

   JACOBICD (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     Jacobicd(1, 0.34)
     
       0.657683337805273
     
     
     Jacobicd(0.8,0.8)
     
       0.925587311582301
     
     ____________________________________________________________


File: ..\util\r37,  Node: JacobiSD,  Next: JacobiND,  Prev: JacobiCD,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBISD                    operator

   The JACOBISD operator returns the Jacobi Elliptic function sd.

syntax:

   JACOBISD (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     Jacobisd(12, 0.4)
     
       0.357189729437272
     
     
     Jacobisd(0.35,1)
     
       - 1.17713873203043
     
     ____________________________________________________________


File: ..\util\r37,  Node: JacobiND,  Next: JacobiDC,  Prev: JacobiSD,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBIND                    operator

   The JACOBIND operator returns the Jacobi Elliptic function nd.

syntax:

   JACOBIND (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     Jacobind(0.2, 17)
     
       1.46553203037507 + 0.0000000000334032759313703*i
     
     
     Jacobind(30, 0.001)
     
       1.00048958438
     
     ____________________________________________________________


File: ..\util\r37,  Node: JacobiDC,  Next: JacobiNC,  Prev: JacobiND,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBIDC                    operator

   The JACOBIDC operator returns the Jacobi Elliptic function dc.

syntax:

   JACOBIDC (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     Jacobidc(0.003,1)
     
       1
     
     
     Jacobidc(2, 0.75)
     
       6.43472885111
     
     ____________________________________________________________


File: ..\util\r37,  Node: JacobiNC,  Next: JacobiSC,  Prev: JacobiDC,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBINC                    operator

   The JACOBINC operator returns the Jacobi Elliptic function nc.

syntax:

   JACOBINC (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     Jacobinc(1,0)
     
       1.85081571768093
     
     
     Jacobinc(56, 0.4387)
     
       39.304842663512
     
     ____________________________________________________________


File: ..\util\r37,  Node: JacobiSC,  Next: JacobiNS,  Prev: JacobiNC,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBISC                    operator

   The JACOBISC operator returns the Jacobi Elliptic function sc.

syntax:

   JACOBISC (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     Jacobisc(9, 0.88)
     
       - 1.16417697982095
     
     
     Jacobisc(0.34, 7)
     
       0.305851938390775 - 9.8768100944891e-12*i
     
     ____________________________________________________________


File: ..\util\r37,  Node: JacobiNS,  Next: JacobiDS,  Prev: JacobiSC,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBINS                    operator

   The JACOBINS operator returns the Jacobi Elliptic function ns.

syntax:

   JACOBINS (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     Jacobins(3, 0.9)
     
       1.00945801599785
     
     
     Jacobins(0.887, 15)
     
       0.683578280513975 - 0.85023411082469*i
     
     ____________________________________________________________


File: ..\util\r37,  Node: JacobiDS,  Next: JacobiCS,  Prev: JacobiNS,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBIDS                    operator

   The JACOBISN operator returns the Jacobi Elliptic function ds.

syntax:

   JACOBIDS (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     Jacobids(98,0.223)
     
       - 1.061253961477
     
     
     Jacobids(0.36,0.6)
     
       2.76693172243692
     
     ____________________________________________________________


File: ..\util\r37,  Node: JacobiCS,  Next: JacobiAMPLITUDE,  Prev: JacobiDS,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBICS                    operator

   The JACOBICS operator returns the Jacobi Elliptic function cs.

syntax:

   JACOBICS (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     Jacobics(0, 0.767)
     
       infinity
     
     
     Jacobics(1.43, 0)
     
       0.141734127352112
     
     ____________________________________________________________


File: ..\util\r37,  Node: JacobiAMPLITUDE,  Next: AGM_FUNCTION,  Prev: JacobiCS,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBIAMPLITUDE                    operator

   The JACOBIAMPLITUDE operator returns the amplitude of u.

syntax:

   JACOBIAMPLITUDE (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     JacobiAmplitude(7.239, 0.427)
     
       0.0520978301448978
     
     
     JacobiAmplitude(0,0.1)
     
       0
     
     ____________________________________________________________
   Amplitude u = asin(JACOBISN(U,M) )


File: ..\util\r37,  Node: AGM_FUNCTION,  Next: LANDENTRANS,  Prev: JacobiAMPLITUDE,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   AGM_FUNCTION                    operator

   The AGM_FUNCTION operator returns a list of (N, AGM,  list of
aNtoa0, list of bNtob0, list of cNtoc0) where a0, b0 and c0 are the
initial values; N is the index number of the last term used to generate
the AGM. AGM is the Arithmetic Geometric Mean.

syntax:

   AGM_FUNCTION (<integer>,<integer>,<integer>)

examples:

     ____________________________________________________________
     
     AGM_function(1,1,1)
     
       1,1,1,1,1,1,0,1
     
     
     AGM_function(1, 0.1, 1.3)
     
       {6,
        2.27985615996629,
        {2.27985615996629, 2.27985615996629,
         2.2798561599706, 2.2798624278857,
         2.28742283656583, 2.55, 1},
        {2.27985615996629, 2.27985615996629,
         2.27985615996198, 2.2798498920555,
         2.27230201920557, 2.02484567313166, 4.1},
        {0, 4.30803136219904e-12, 0.0000062679151007581,
         0.00756040868012758, 0.262577163434171, - 1.55, 5.9}}
     
     ____________________________________________________________
   The other Jacobi functions use this function with initial values
a0=1, b0=sqrt(1-m), c0=sqrt(m).


File: ..\util\r37,  Node: LANDENTRANS,  Next: EllipticF,  Prev: AGM_FUNCTION,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   LANDENTRANS                    operator

   The LANDENTRANS operator generates the descending landen
transformation of the given imput values, returning a list of these
values; initial to final in each case.

syntax:

   LANDENTRANS (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     landentrans(0,0.1)
     
       {{0,0,0,0,0},{0.1,0.0025041751943776,
     
     
     
     
       0.00000156772498954046,6.1444078 9914461e-13,0}}
     
     ____________________________________________________________
   The first list ascends in value, and the second descends in value.


File: ..\util\r37,  Node: EllipticF,  Next: EllipticK,  Prev: LANDENTRANS,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   ELLIPTICF                    operator

   The ELLIPTICF operator returns the Elliptic Integral of the First
Kind.

syntax:

   ELLITPICF (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     EllipticF(0.3, 8.222)
     
       0.3
     
     
     EllipticF(7.396, 0.1)
     
       7.58123216114307
     
     ____________________________________________________________
   The Complete Elliptic Integral of the First Kind can be found by
putting the first argument to pi/2 or by using ELLIPTICK and the second
argument.


File: ..\util\r37,  Node: EllipticK,  Next: EllipticKprime,  Prev: EllipticF,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   ELLIPTICK                    operator

   The ELLIPTICK operator returns the Elliptic value K.

syntax:

   ELLIPTICK (<integer>)

examples:

     ____________________________________________________________
     
     EllipticK(0.2)
     
       1.65962359861053
     
     
     EllipticK(4.3)
     
       0.808442364282734 - 1.05562492399206*i
     
     
     EllipticK(0.000481)
     
       1.57098526617635
     
     ____________________________________________________________
   The ELLIPTICK function is the Complete Elliptic Integral of the
First Kind.


File: ..\util\r37,  Node: EllipticKprime,  Next: EllipticE,  Prev: EllipticK,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   ELLIPTICKPRIME                    operator

   The ELLIPTICK' operator returns the Elliptic value K(m).

syntax:

   ELLIPTICKPRIME (<integer>)

examples:

     ____________________________________________________________
     
     EllipticKprime(0.2)
     
       2.25720532682085
     
     
     EllipticKprime(4.3)
     
       1.05562492399206
     
     
     EllipticKprime(0.000481)
     
       5.206621921966
     
     ____________________________________________________________
   The ELLIPTICKPRIME function is the Complete Elliptic Integral of the
First Kind of (1-m).


File: ..\util\r37,  Node: EllipticE,  Next: EllipticTHETA,  Prev: EllipticKprime,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   ELLIPTICE                    operator

   The ELLIPTICE operator used with two arguments returns the Elliptic
Integral of the Second Kind.

syntax:

   ELLIPTICE (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     EllipticE(1.2,0.22)
     
       1.15094019180949
     
     
     EllipticE(0,4.35)
     
       0
     
     
     EllipticE(9,0.00719)
     
       8.98312465929145
     
     ____________________________________________________________
   The Complete Elliptic Integral of the Second Kind can be obtained by
using just the second argument, or by using pi/2 as the first argument.

   The ELLIPTICE operator used with one argument returns the Elliptic
value E.

syntax:

   ELLIPTICE (<integer>)

examples:

     ____________________________________________________________
     
     EllipticE(0.22)
     
       1.48046637439519
     
     
     EllipticE(pi/2, 0.22)
     
       1.48046637439519
     
     ____________________________________________________________


File: ..\util\r37,  Node: EllipticTHETA,  Next: JacobiZETA,  Prev: EllipticE,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   ELLIPTICTHETA                    operator

   The ELLIPTICTHETA operator returns one of the four Theta functions.
It cannot except any number other than 1,2,3 or 4 as its first argument.

syntax:

   ELLIPTICTHETA (<integer>,<expression>,<integer>)

examples:

     ____________________________________________________________
     
     EllipticTheta(1, 1.4, 0.72)
     
       0.91634775373
     
     
     EllipticTheta(2, 3.9, 6.1 )
     
       -48.0202736969 + 20.9881034377 i
     
     
     EllipticTheta(3, 0.67, 0.2)
     
       1.0083077448
     
     
     EllipticTheta(4, 8, 0.75)
     
       0.894963369304
     
     
     EllipticTheta(5, 1, 0.1)
     
       ***** In EllipticTheta(a,u,m); a = 1,2,3 or 4.
     
     ____________________________________________________________
   Theta functions are important because every one of the Jacobian
Elliptic functions can be expressed as the ratio of two theta functions.


File: ..\util\r37,  Node: JacobiZETA,  Prev: EllipticTHETA,  Up: Jacobi Elliptic Functions and Elliptic Integrals section

   JACOBIZETA                    operator

   The JACOBIZETA operator returns the Jacobian function Zeta.

syntax:

   JACOBIZETA (<expression>,<integer>)

examples:

     ____________________________________________________________
     
     JacobiZeta(3.2, 0.8)
     
       - 0.254536403439
     
     
     JacobiZeta(0.2, 1.6)
     
       0.171766095970451 - 0.0717028569800147*i
     
     ____________________________________________________________
   The Jacobian function Zeta is related to the Jacobian function Theta.
But it is significantly different from Riemann's Zeta Function [*note
ZETA::.] .


File: ..\util\r37,  Node: Jacobi Elliptic Functions and Elliptic Integrals section,  Next: Gamma and Related Functions section,  Prev: Airy Functions section,  Up: Special Functions section

   Jacobi Elliptic Functions and Elliptic Integrals section

* Menu:

* JacobiSN::                operator
* JacobiCN::                operator
* JacobiDN::                operator
* JacobiCD::                operator
* JacobiSD::                operator
* JacobiND::                operator
* JacobiDC::                operator
* JacobiNC::                operator
* JacobiSC::                operator
* JacobiNS::                operator
* JacobiDS::                operator
* JacobiCS::                operator
* JacobiAMPLITUDE::         operator
* AGM_FUNCTION::            operator
* LANDENTRANS::             operator
* EllipticF::               operator
* EllipticK::               operator
* EllipticKprime::          operator
* EllipticE::               operator
* EllipticTHETA::           operator
* JacobiZETA::              operator


File: ..\util\r37,  Node: POCHHAMMER,  Next: GAMMA,  Up: Gamma and Related Functions section

   POCHHAMMER                    operator

   The POCHHAMMER operator implements the Pochhammer notation (shifted
factorial).

syntax:

   POCHHAMMER (<expression>,<expression>)

examples:

     ____________________________________________________________
     
     pochhammer(17,4);
     
       116280
     
     
     
     pochhammer(1/2,z);
     
         factorial(2*z)
       --------------------
         2*z
       (2   *factorial(z))
     
     ____________________________________________________________
   A number of complex rules for POCHHAMMER are inactive, because they
cause a huge system load in algebraic mode. If one wants to use more
rules for the simplification of Pochhammer's notation, one can do:

   let special!*pochhammer!*rules;


File: ..\util\r37,  Node: GAMMA,  Next: BETA,  Prev: POCHHAMMER,  Up: Gamma and Related Functions section

   GAMMA                    operator

   The GAMMA operator returns the Gamma function.

syntax:

   GAMMA (<expression>)

examples:

     ____________________________________________________________
     
     gamma(10);
     
       362880
     
     
     gamma(1/2);
     
       sqrt(pi)
     
     ____________________________________________________________


File: ..\util\r37,  Node: BETA,  Next: PSI,  Prev: GAMMA,  Up: Gamma and Related Functions section

   BETA                    operator

   The BETA operator returns the Beta function defined by

   Beta (z,w) := defint(t**(z-1)* (1 - t)**(w-1),t,0,1) .

syntax:

   BETA (<expression>,<expression>)

examples:

     ____________________________________________________________
     
     Beta(2,2);
     
       1 / 6
     
     
     Beta(x,y);
     
       gamma(x)*gamma(y) / gamma(x + y)
     
     ____________________________________________________________
   The operator BETA is simplified towards the [*note GAMMA::.]
operator.


File: ..\util\r37,  Node: PSI,  Next: POLYGAMMA,  Prev: BETA,  Up: Gamma and Related Functions section

   PSI                    operator

   The PSI operator returns the Psi (or DiGamma) function.

   Psi(x) := df(Gamma(z),z)/ Gamma (z)

syntax:

   GAMMA (<expression>)

examples:

     ____________________________________________________________
     
     Psi(3);
     
       (2*log(2) + psi(1/2) + psi(1) + 3)/2
     
     
     on rounded;
     
     - Psi(1);
     
       0.577215664902
     
     ____________________________________________________________
   Euler's constant can be found as - Psi(1).


File: ..\util\r37,  Node: POLYGAMMA,  Prev: PSI,  Up: Gamma and Related Functions section

   POLYGAMMA                    operator

   The POLYGAMMA operator returns the Polygamma function.

   Polygamma(n,x) := df(Psi(z),z,n);

syntax:

   POLYGAMMA (<integer>,<expression>)

examples:

     ____________________________________________________________
     
      Polygamma(1,2);
     
          2
       (pi   - 6) / 6
     
     
     on rounded;
     
     Polygamma(1,2.35);
     
       0.52849689109
     
     ____________________________________________________________
   The Polygamma function is used for simplification of the [*note
ZETA::.] function for some arguments.


File: ..\util\r37,  Node: Gamma and Related Functions section,  Next: Miscellaneous Functions section,  Prev: Jacobi Elliptic Functions and Elliptic Integrals section,  Up: Special Functions section

   Gamma and Related Functions section

* Menu:

* POCHHAMMER::              operator
* GAMMA::                   operator
* BETA::                    operator
* PSI::                     operator
* POLYGAMMA::               operator


File: ..\util\r37,  Node: DILOG extended,  Next: Lambert_W function,  Up: Miscellaneous Functions section

   DILOG EXTENDED                    operator

   The package SPECFN supplies an extended support for the [*note
DILOG::.]  operator which implements the DILOGARITHM FUNCTION .

   dilog(x) := - defint(log(t)/(t - 1),t,1,x);

syntax:

   DILOG (<order>,<expression>)

examples:

     ____________________________________________________________
     
     defint(log(t)/(t - 1),t,1,x);
     
       - dilog (x)
     
     
     dilog 2;
     
           2
       - pi  /12
     
     
     
     on rounded;
     
     Dilog 20;
     
       - 5.92783972438
     
     ____________________________________________________________
   The operator DILOG is sometimes called Spence's Integral for n = 2.


File: ..\util\r37,  Node: Lambert_W function,  Prev: DILOG extended,  Up: Miscellaneous Functions section

   LAMBERT_W FUNCTION                    operator

   Lambert's W function is the inverse of the function w * e**w.  It is
used in the [*note SOLVE::.] package for equations containing
exponentials and logarithms.

syntax:

   LAMBERT_W (<z>)

examples:

     ____________________________________________________________
     
     Lambert_W(-1/e);
     
       -1
     
     
     solve(w + log(w),w);
     
       w=lambert_w(1)
     
     
     on rounded;
     
     Lambert_W(-0.05);
     
       - 0.0527059835515
     
     ____________________________________________________________
   The current implementation will compute the principal branch in
rounded mode only.


File: ..\util\r37,  Node: Miscellaneous Functions section,  Next: Orthogonal Polynomials section,  Prev: Gamma and Related Functions section,  Up: Special Functions section

   Miscellaneous Functions section

* Menu:

* DILOG extended::          operator
* Lambert_W function::     operator


File: ..\util\r37,  Node: ChebyshevT,  Next: ChebyshevU,  Up: Orthogonal Polynomials section

   CHEBYSHEVT                    operator

   The CHEBYSHEVT operator computes the nth Chebyshev T Polynomial (of
the first kind).

syntax:

   CHEBYSHEVT (<integer>,<expression>)

examples:

     ____________________________________________________________
     
     ChebyshevT(3,xx);
     
               2
       xx*(4*xx   - 3)
     
     
     
     ChebyshevT(3,4);
     
       244
     
     ____________________________________________________________
   Chebyshev's T polynomials are computed using the recurrence relation:

   ChebyshevT(n,x) := 2x*ChebyshevT(n-1,x) - ChebyshevT(n-2,x) with

   ChebyshevT(0,x) := 0 and ChebyshevT(1,x) := x


File: ..\util\r37,  Node: ChebyshevU,  Next: HermiteP,  Prev: ChebyshevT,  Up: Orthogonal Polynomials section

   CHEBYSHEVU                    operator

   The CHEBYSHEVU operator returns the nth Chebyshev U Polynomial (of
the second kind).

syntax:

   CHEBYSHEVU (<integer>,<expression>)

examples:

     ____________________________________________________________
     
     ChebyshevU(3,xx);
     
               2
       4*x*(2*x   - 1)
     
     
     
     ChebyshevU(3,4);
     
       496
     
     ____________________________________________________________
   Chebyshev's U polynomials are computed using the recurrence relation:

   ChebyshevU(n,x) := 2x*ChebyshevU(n-1,x) - ChebyshevU(n-2,x) with

   ChebyshevU(0,x) := 0 and ChebyshevU(1,x) := 2x


File: ..\util\r37,  Node: HermiteP,  Next: LaguerreP,  Prev: ChebyshevU,  Up: Orthogonal Polynomials section

   HERMITEP                    operator

   The HERMITEP operator returns the nth Hermite Polynomial.

syntax:

   HERMITEP (<integer>,<expression>)

examples:

     ____________________________________________________________
     
     HermiteP(3,xx);
     
                 2
       4*xx*(2*xx   - 3)
     
     
     HermiteP(3,4);
     
       464
     
     ____________________________________________________________
   Hermite polynomials are computed using the recurrence relation:

   HermiteP(n,x) := 2x*HermiteP(n-1,x) - 2*(n-1)*HermiteP(n-2,x) with

   HermiteP(0,x) := 1 and HermiteP(1,x) := 2x


File: ..\util\r37,  Node: LaguerreP,  Next: LegendreP,  Prev: HermiteP,  Up: Orthogonal Polynomials section

   LAGUERREP                    operator

   The LAGUERREP operator computes the nth Laguerre Polynomial.  The
two argument call of LaguerreP is a (common) abbreviation of
LaguerreP(n,0,x).

syntax:

   LAGUERREP (<integer>,<expression>) or

   LAGUERREP (<integer>,<expression>,<expression>)

examples:

     ____________________________________________________________
     
     LaguerreP(3,xx);
     
            3        2
       (- xx   + 9*xx   - 18*xx + 6)/6
     
     
     
     LaguerreP(2,3,4);
     
       -2
     
     ____________________________________________________________
   Laguerre polynomials are computed using the recurrence relation:

   LaguerreP(n,a,x) := (2n+a-1-x)/n*LaguerreP(n-1,a,x) -  (n+a-1) *
LaguerreP(n-2,a,x) with

   LaguerreP(0,a,x) := 1 and LaguerreP(2,a,x) := -x+1+a


File: ..\util\r37,  Node: LegendreP,  Next: JacobiP,  Prev: LaguerreP,  Up: Orthogonal Polynomials section

   LEGENDREP                    operator

   The binary LEGENDREP operator computes the nth Legendre Polynomial
which is a special case of the nth Jacobi Polynomial with

   LegendreP(n,x) := JacobiP(n,0,0,x)

   The ternary form returns the associated Legendre Polynomial (see
below).

syntax:

   LEGENDREP (<integer>,<expression>) or

   LEGENDREP (<integer>,<expression>,<expression>)

examples:

     ____________________________________________________________
     
     LegendreP(3,xx);
     
               2
       xx*(5*xx   - 3)
       ----------------
              2
     
     
     
     LegendreP(3,2,xx);
     
                   2
       15*xx*( - xx   + 1)
     
     ____________________________________________________________
   The ternary form of the operator LEGENDREP is the associated
Legendre Polynomial defined as

   P(n,m,x) = (-1)**m * (1-x**2)**(m/2) * df(LegendreP(n,x),x,m)


File: ..\util\r37,  Node: JacobiP,  Next: GegenbauerP,  Prev: LegendreP,  Up: Orthogonal Polynomials section

   JACOBIP                    operator

   The JACOBIP operator computes the nth Jacobi Polynomial.

syntax:

   JACOBIP (<integer>,<expression>,<expression>,  <expression>)

examples:

     ____________________________________________________________
     
     JacobiP(3,4,5,xx);
     
               3         2
       7*(65*xx   - 13*xx   - 13*xx + 1)
       ----------------------------------
                       8
     
     
     
     JacobiP(3,4,5,6);
     
       94465/8
     
     ____________________________________________________________


File: ..\util\r37,  Node: GegenbauerP,  Next: SolidHarmonicY,  Prev: JacobiP,  Up: Orthogonal Polynomials section

   GEGENBAUERP                    operator

   The GEGENBAUERP operator computes Gegenbauer's (ultraspherical)
polynomials.

syntax:

   GEGENBAUERP (<integer>,<expression>,<expression>)

examples:

     ____________________________________________________________
     
     GegenbauerP(3,2,xx);
     
                 2
       4*xx*(8*xx   - 3)
     
     
     
     GegenbauerP(3,2,4);
     
       2000
     
     ____________________________________________________________


File: ..\util\r37,  Node: SolidHarmonicY,  Next: SphericalHarmonicY,  Prev: GegenbauerP,  Up: Orthogonal Polynomials section

   SOLIDHARMONICY                    operator

   The SOLIDHARMONICY operator computes Solid harmonic (Laplace)
polynomials.

syntax:

   SOLIDHARMONICY (<integer>,<integer>,
<expression>,<expression>,<expression>,<expression>)

examples:

     ____________________________________________________________
     
     
     SolidHarmonicY(3,-2,x,y,z,r2);
     
                                2    2
       sqrt(105)*z*(-2*i*x*y + x  - y )
       ---------------------------------
              4*sqrt(pi)*sqrt(2)
     
     ____________________________________________________________


File: ..\util\r37,  Node: SphericalHarmonicY,  Prev: SolidHarmonicY,  Up: Orthogonal Polynomials section

   SPHERICALHARMONICY                    operator

   The SPHERICALHARMONICY operator computes Spherical harmonic (Laplace)
polynomials. These are special cases of the solid harmonic polynomials,
[*note SolidHarmonicY::.] .

syntax:

   SPHERICALHARMONICY (<integer>,<integer>, <expression>,<expression>)

examples:

     ____________________________________________________________
     
     SphericalHarmonicY(3,2,theta,phi);
     
     
                                      2          2                               2
       sqrt(105)*cos(theta)*sin(theta) *(cos(phi) +2*cos(phi)*sin(phi)*i-sin(phi) )
       -----------------------------------------------------------------------------
                                    4*sqrt(pi)*sqrt(2)
     
     ____________________________________________________________


File: ..\util\r37,  Node: Orthogonal Polynomials section,  Next: Integral Functions section,  Prev: Miscellaneous Functions section,  Up: Special Functions section

   Orthogonal Polynomials section

* Menu:

* ChebyshevT::              operator
* ChebyshevU::              operator
* HermiteP::                operator
* LaguerreP::               operator
* LegendreP::               operator
* JacobiP::                 operator
* GegenbauerP::             operator
* SolidHarmonicY::          operator
* SphericalHarmonicY::      operator


File: ..\util\r37,  Node: Si,  Next: Shi,  Up: Integral Functions section

   SI                    operator

   The SI operator returns the Sine Integral function.

syntax:

   SI (<expression>)

examples:

     ____________________________________________________________
     
     limit(Si(x),x,infinity);
     
       pi / 2
     
     
     on rounded;
     
     Si(0.35);
     
       0.347626790989
     
     ____________________________________________________________
   The numeric values for the operator SI are computed via the power
series representation, which limits the argument range.


File: ..\util\r37,  Node: Shi,  Next: s_i,  Prev: Si,  Up: Integral Functions section

   SHI                    operator

   The SHI operator returns the hyperbolic Sine Integral function.

syntax:

   SHI (<expression>)

examples:

     ____________________________________________________________
     
     df(shi(x),x);
     
       sinh(x) / x
     
     
     on rounded;
     
     Shi(0.35);
     
       0.352390716351
     
     ____________________________________________________________
   The numeric values for the operator SHI are computed via the power
series representation, which limits the argument range.


File: ..\util\r37,  Node: s_i,  Next: Ci,  Prev: Shi,  Up: Integral Functions section

   S_I                    operator

   The S_I operator returns the Sine Integral function si.

syntax:

   S_I (<expression>)

examples:

     ____________________________________________________________
     
     s_i(xx);
     
       (2*Si(xx) - pi) / 2
     
     
     df(s_i(x),x);
     
       sin(x) / x
     
     ____________________________________________________________
   The operator name S_I is simplified towards [*note Si::.] .  Since
REDUCE is not case sensitive by default the name "si" can't be used.


File: ..\util\r37,  Node: Ci,  Next: Chi,  Prev: s_i,  Up: Integral Functions section

   CI                    operator

   The CI operator returns the Cosine Integral function.

syntax:

   CI (<expression>)

examples:

     ____________________________________________________________
     
     defint(cos(t)/t,t,x,infinity);
     
       - ci (x)
     
     
     on rounded;
     
     Ci(0.35);
     
       - 0.50307556932
     
     ____________________________________________________________
   The numeric values for the operator CI are computed via the power
series representation, which limits the argument range.


File: ..\util\r37,  Node: Chi,  Next: ERF extended,  Prev: Ci,  Up: Integral Functions section

   CHI                    operator

   The CHI operator returns the Hyperbolic Cosine Integral function.

syntax:

   CHI (<expression>)

examples:

     ____________________________________________________________
     
     defint((cosh(t)-1)/t,t,0,x);
     
       - log(x) + psi(1) + chi(x)
     
     
     on rounded;
     
     Chi(0.35);
     
       - 0.44182471827
     
     ____________________________________________________________
   The numeric values for the operator CHI are computed via the power
series representation, which limits the argument range.


File: ..\util\r37,  Node: ERF extended,  Next: erfc,  Prev: Chi,  Up: Integral Functions section

   ERF EXTENDED                    operator

   The special function package supplies an extended support for the
[*note ERF::.]  operator which implements the ERROR FUNCTION

   defint(e**(-x**2),x,0,infinity) * 2/sqrt(pi)

   .

syntax:

   ERF (<expression>)

examples:

     ____________________________________________________________
     
     erf(-x);
     
       - erf(x)
     
     
     on rounded;
     
     erf(0.35);
     
       0.379382053562
     
     ____________________________________________________________
   The numeric values for the operator ERF are computed via the power
series representation, which limits the argument range.


File: ..\util\r37,  Node: erfc,  Next: Ei,  Prev: ERF extended,  Up: Integral Functions section

   ERFC                    operator

   The ERFC operator returns the complementary Error function

   1 - defint(e**(-x**2),x,0,infinity) * 2/sqrt(pi)

   .

syntax:

   ERFC (<expression>)

examples:

     ____________________________________________________________
     
     erfc(xx);
     
       - erf(xx) + 1
     
     ____________________________________________________________
   The operator ERFC is simplified towards the [*note ERF::.] operator.


File: ..\util\r37,  Node: Ei,  Next: Fresnel_C,  Prev: erfc,  Up: Integral Functions section

   EI                    operator

   The EI operator returns the Exponential Integral function.

syntax:

   EI (<expression>)

examples:

     ____________________________________________________________
     
     df(ei(x),x);
     
        x
       e
       ---
       x
     
     
     on rounded;
     
     Ei(0.35);
     
       - 0.0894340019184
     
     ____________________________________________________________
   The numeric values for the operator EI are computed via the power
series representation, which limits the argument range.


File: ..\util\r37,  Node: Fresnel_C,  Next: Fresnel_S,  Prev: Ei,  Up: Integral Functions section

   FRESNEL_C                    operator

   The FRESNEL_C operator represents Fresnel's Cosine function.

syntax:

   FRESNEL_C (<expression>)

examples:

     ____________________________________________________________
     
     int(cos(t^2*pi/2),t,0,x);
     
       fresnel_c(x)
     
     
     on rounded;
     
     fresnel_c(2.1);
     
       0.581564135061
     
     ____________________________________________________________
   The operator FRESNEL_C has a limited numeric evaluation of large
values of its argument.


File: ..\util\r37,  Node: Fresnel_S,  Prev: Fresnel_C,  Up: Integral Functions section

   FRESNEL_S                    operator

   The FRESNEL_S operator represents Fresnel's Sine Integral function.

syntax:

   FRESNEL_S (<expression>)

examples:

     ____________________________________________________________
     
     int(sin(t^2*pi/2),t,0,x);
     
       fresnel_s(x)
     
     
     on rounded;
     
     fresnel_s(2.1);
     
       0.374273359378
     
     ____________________________________________________________
   The operator FRESNEL_S has a limited numeric evaluation of large
values of its argument.


File: ..\util\r37,  Node: Integral Functions section,  Next: Combinatorial Operators section,  Prev: Orthogonal Polynomials section,  Up: Special Functions section

   Integral Functions section

* Menu:

* Si::                      operator
* Shi::                     operator
* s_i::                     operator
* Ci::                      operator
* Chi::                     operator
* ERF extended::            operator
* erfc::                    operator
* Ei::                      operator
* Fresnel_C::               operator
* Fresnel_S::               operator


File: ..\util\r37,  Node: BINOMIAL,  Next: STIRLING1,  Up: Combinatorial Operators section

   BINOMIAL                    operator

   The BINOMIAL operator returns the Binomial coefficient if both
parameter are integer and expressions involving the Gamma function
otherwise.

syntax:

   BINOMIAL (<integer>,<integer>)

examples:

     ____________________________________________________________
     
     Binomial(49,6);
     
       13983816
     
     
     
     Binomial(n,3);
     
        gamma(n + 1)
       ---------------
       6*gamma(n - 2)
     
     ____________________________________________________________
   The operator BINOMIAL evaluates the Binomial coefficients from the
explicit form and therefore it is not the best algorithm if you want to
compute many binomial coefficients with big indices in which case a
recursive algorithm is preferable.


File: ..\util\r37,  Node: STIRLING1,  Next: STIRLING2,  Prev: BINOMIAL,  Up: Combinatorial Operators section

   STIRLING1                    operator

   The STIRLING1 operator returns the Stirling Numbers S(n,m) of the
first kind, i.e. the number of permutations of n symbols which have
exactly m cycles (divided by (-1)**(n-m)).

syntax:

   STIRLING1 (<integer>,<integer>)

examples:

     ____________________________________________________________
     
     Stirling1 (17,4);
     
       -87077748875904
     
     
     Stirling1 (n,n-1);
     
       -gamma(n+1)
       -------------
       2*gamma(n-1)
     
     ____________________________________________________________
   The operator STIRLING1 evaluates the Stirling numbers of the first
kind by rulesets for special cases or by a computing the closed form,
which is a series involving the operators [*note BINOMIAL::.] and
[*note STIRLING2::.] .


File: ..\util\r37,  Node: STIRLING2,  Prev: STIRLING1,  Up: Combinatorial Operators section

   STIRLING2                    operator

   The STIRLING1 operator returns the Stirling Numbers S(n,m) of the
second kind, i.e. the number of ways of partitioning a set of n elements
into m non-empty subsets.

syntax:

   STIRLING2 (<integer>,<integer>)

examples:

     ____________________________________________________________
     
     Stirling2 (17,4);
     
       694337290
     
     
     Stirling2 (n,n-1);
     
        gamma(n+1)
       -------------
       2*gamma(n-1)
     
     ____________________________________________________________
   The operator STIRLING2 evaluates the Stirling numbers of the second
kind by rulesets for special cases or by a computing the closed form.


File: ..\util\r37,  Node: Combinatorial Operators section,  Next: 3j and 6j symbols section,  Prev: Integral Functions section,  Up: Special Functions section

   Combinatorial Operators section

* Menu:

* BINOMIAL::                operator
* STIRLING1::               operator
* STIRLING2::               operator


File: ..\util\r37,  Node: ThreejSymbol,  Next: Clebsch_Gordan,  Up: 3j and 6j symbols section

   THREEJSYMBOL                    operator

   The THREEJSYMBOL operator implements the 3j symbol.

syntax:

   THREEJSYMBOL (<list of j1,m1>,<list of j2,m2>, <list of j3,m3>)

examples:

     ____________________________________________________________
     
     
     ThreejSymbol({j+1,m},{j+1,-m},{1,0});
     
     
             j
       ( - 1)  *(abs(j - m + 1) - abs(j + m + 1))
       -------------------------------------------
                  3       2                    m
        2*sqrt(2*j   + 9*j   + 13*j + 6)*( - 1)
     
     ____________________________________________________________


File: ..\util\r37,  Node: Clebsch_Gordan,  Next: SixjSymbol,  Prev: ThreejSymbol,  Up: 3j and 6j symbols section

   CLEBSCH_GORDAN                    operator

   The CLEBSCH_GORDAN operator implements the Clebsch_Gordan
coefficients. This is closely related to the [*note ThreejSymbol::.] .

syntax:

   CLEBSCH_GORDAN (<list of j1,m1>,<list of j2,m2>, <list of j3,m3>)

examples:

     ____________________________________________________________
     
      Clebsch_Gordan({2,0},{2,0},{2,0});
     
     
          -2
       ---------
       sqrt(14)
     
     ____________________________________________________________


File: ..\util\r37,  Node: SixjSymbol,  Prev: Clebsch_Gordan,  Up: 3j and 6j symbols section

   SIXJSYMBOL                    operator

   The SIXJSYMBOL operator implements the 6j symbol.

syntax:

   SIXJSYMBOL (<list of j1,j2,j3>,<list of l1,l2,l3>)

examples:

     ____________________________________________________________
     
     
     SixjSymbol({7,6,3},{2,4,6});
     
            1
       -------------
       14*sqrt(858)
     
     ____________________________________________________________
   The operator SIXJSYMBOL uses the [*note INEQ::.] package in order to
find minima and maxima for the summation index.


File: ..\util\r37,  Node: 3j and 6j symbols section,  Next: Miscellaneous section,  Prev: Combinatorial Operators section,  Up: Special Functions section

   3j and  6j symbols section

* Menu:

* ThreejSymbol::            operator
* Clebsch_Gordan::          operator
* SixjSymbol::              operator


File: ..\util\r37,  Node: HYPERGEOMETRIC,  Next: MeijerG,  Up: Miscellaneous section

   HYPERGEOMETRIC                    operator

   The HYPERGEOMETRIC operator provides simplifications for the
generalized hypergeometric functions.  The HYPERGEOMETRIC operator is
included in the package specfn2.

syntax:

   HYPERGEOMETRIC (<list of parameters>,<list of parameters>,
<argument>)

examples:

     ____________________________________________________________
     
     load specfn2;
     
     hypergeometric ({1/2,1},{3/2},-x^2);
     
     
       atan(x)
       --------
          x
     
     
     hypergeometric ({},{},z);
     
        z
       e
     
     ____________________________________________________________
   The special case where the length of the first list is equal to 2 and
the length of the second list is equal to 1 is often called "the
hypergeometric function" (notated as 2F1(a1,a2,b;x)).


File: ..\util\r37,  Node: MeijerG,  Next: Heaviside,  Prev: HYPERGEOMETRIC,  Up: Miscellaneous section

   MEIJERG                    operator

   The MEIJERG operator provides simplifications for Meijer's G
function. The simplifications are performed towards polynomials,
elementary or special functions or (generalized) [*note
HYPERGEOMETRIC::.] functions.

   The MEIJERG operator is included in the package specfn2.

syntax:

   MEIJERG (<list of parameters>,<list of parameters>,  <argument>)

   The first element of the lists has to be the list containing the
first group (mostly called "m" and "n") of parameters. This passes the
four parameters of a Meijer's G function implicitly via the length of
the lists.

examples:

     ____________________________________________________________
     
     load specfn2;
     
     MeijerG({{},1},{{0}},x);
     
       heaviside(-x+1)
     
     
     MeijerG({{}},{{1+1/4},1-1/4},(x^2)/4) * sqrt pi;
     
     
     
                       2
       sqrt(2)*sin(x)*x
       ------------------
           4*sqrt(x)
     
     ____________________________________________________________
   Many well-known functions can be written as G functions, e.g.
exponentials, logarithms, trigonometric functions, Bessel functions and
hypergeometric functions.  The formulae can be found e.g. in

   A.P.Prudnikov, Yu.A.Brychkov, O.I.Marichev: Integrals and Series,
Volume 3: More special functions, Gordon and Breach Science Publishers
(1990).


File: ..\util\r37,  Node: Heaviside,  Next: erfi,  Prev: MeijerG,  Up: Miscellaneous section

   HEAVISIDE                    operator

   The HEAVISIDE operator returns the Heaviside function.

   Heaviside(~w) => if (w < 0) then 0 else 1

   when numberp w;

syntax:

   HEAVISIDE (<argument>)

   This operator is often included in the result of the simplification
of a generalized [*note HYPERGEOMETRIC::.] function or a [*note
MeijerG::.]  function.

   No simplification is done for this function.


File: ..\util\r37,  Node: erfi,  Prev: Heaviside,  Up: Miscellaneous section

   ERFI                    operator

   The ERFI operator returns the error function of an imaginary
argument.

   erfi(~x) => 2/sqrt(pi) * defint(e**(t**2),t,0,x);

syntax:

   ERFI (<argument>)

   This operator is sometimes included in the result of the
simplification of a generalized [*note HYPERGEOMETRIC::.] function or a
[*note MeijerG::.]  function.

   No simplification is done for this function.


File: ..\util\r37,  Node: Miscellaneous section,  Prev: 3j and 6j symbols section,  Up: Special Functions section

   Miscellaneous section

* Menu:

* HYPERGEOMETRIC::          operator
* MeijerG::                 operator
* Heaviside::               operator
* erfi::                    operator


File: ..\util\r37,  Node: Special Functions section,  Next: Taylor series section,  Prev: Roots Package section,  Up: Top

   Special Functions section

* Menu:

* Special Function Package::introduction
* Constants::               concept
* Bernoulli Euler Zeta section::
* Bessel Functions section::
* Airy Functions section::
* Jacobi Elliptic Functions and Elliptic Integrals section::
* Gamma and Related Functions section::
* Miscellaneous Functions section::
* Orthogonal Polynomials section::
* Integral Functions section::
* Combinatorial Operators section::
* 3j and 6j symbols section::
* Miscellaneous section::


File: ..\util\r37,  Node: TAYLOR introduction,  Next: taylor,  Up: Taylor series section

   TAYLOR                    introduction

   This short note describes a package of REDUCE procedures that allow
Taylor expansion in one or more variables and efficient manipulation of
the resulting Taylor series. Capabilities include basic operations
(addition, subtraction, multiplication and division) and also
application of certain algebraic and transcendental functions. To a
certain extent, Laurent expansion can be performed as well.


File: ..\util\r37,  Node: taylor,  Next: taylorautocombine,  Prev: TAYLOR introduction,  Up: Taylor series section

   TAYLOR                    operator

   The TAYLOR operator is used for expanding an expression into a
Taylor series.

syntax:

   TAYLOR (<expression>  , <var>,  <expression>, <number>

   , <var>,  <expression>, <number>*)

   <expression> can be any valid REDUCE algebraic expression.   <var>
must be a [*note KERNEL::.] , and is the expansion  variable. The
<expression> following it denotes the point  about which the expansion
is to take place. <number> must be a  non-negative integer and denotes
the maximum expansion order. If  more than one triple is specified
TAYLOR will expand its  first argument independently with respect to
all the variables.   Note that once the expansion has been done it is
not possible to  calculate higher orders.

   Instead of a [*note KERNEL::.] , <var> may also be a list of
kernels. In this case expansion will take place in a way so that  the
sum/ of the degrees of the kernels does not exceed the  maximum
expansion order. If the expansion point evaluates to the  special
identifier INFINITY , TAYLOR tries to expand in  a series in 1/<var>.

   The expansion is performed variable per variable, i.e. in the
example above by first expanding  exp(x^2+y^2)  with respect to  X and
then expanding every coefficient with respect to Y .

examples:

     ____________________________________________________________
     
         taylor(e^(x^2+y^2),x,0,2,y,0,2);
     
     
            2    2    2  2      2  2
       1 + Y  + X  + Y *X  + O(X ,Y )
     
     
         taylor(e^(x^2+y^2),{x,y},0,2);
     
     
            2    2       2  2
       1 + Y  + X  + O({X ,Y })
     
     ____________________________________________________________
   The following example shows the case of a non-analytical function.
     ____________________________________________________________
     
     
         taylor(x*y/(x+y),x,0,2,y,0,2);
     
     
       ***** Not a unit in argument to QUOTTAYLOR
     
     ____________________________________________________________

   Note that it is not generally possible to apply the standard  reduce
operators to a Taylor kernel. For example, [*note PART::.] ,  [*note
COEFF::.] , or [*note COEFFN::.] cannot be used. Instead, the
expression at hand has to be converted to standard form first  using
the [*note taylortostandard::.] operator.

   Differentiation of a Taylor expression is possible. If you
differentiate with respect to one of the Taylor variables the  order
will decrease by one.

   Substitution is a bit restricted: Taylor variables can only be
replaced by other kernels. There is one exception to this rule:  you
can always substitute a Taylor variable by an expression that
evaluates to a constant. Note that REDUCE will not always be able  to
determine that an expression is constant: an example is  sin(acos(4)).

   Only simple taylor kernels can be integrated. More complicated
expressions that contain Taylor kernels as parts of themselves are
automatically converted into a standard representation by means of  the
[*note taylortostandard::.] operator. In this case a suitable  warning
is printed.


File: ..\util\r37,  Node: taylorautocombine,  Next: taylorautoexpand,  Prev: taylor,  Up: Taylor series section

   TAYLORAUTOCOMBINE                    switch

   If you set TAYLORAUTOCOMBINE to ON , REDUCE  automatically combines
Taylor expressions during the simplification  process. This is
equivalent to applying [*note taylorcombine::.] to  every expression
that contains Taylor kernels. Default is  ON .


File: ..\util\r37,  Node: taylorautoexpand,  Next: taylorcombine,  Prev: taylorautocombine,  Up: Taylor series section

   TAYLORAUTOEXPAND                    switch

   TAYLORAUTOEXPAND makes Taylor expressions "contagious" in  the sense
that [*note taylorcombine::.] tries to Taylor expand all  non-Taylor
subexpressions and to combine the result with the rest.   Default is
OFF .


File: ..\util\r37,  Node: taylorcombine,  Next: taylorkeeporiginal,  Prev: taylorautoexpand,  Up: Taylor series section

   TAYLORCOMBINE                    operator

   This operator tries to combine all Taylor kernels found in its
argument into one. Operations currently possible are:

   Addition, subtraction, multiplication, and division.

   Roots, exponentials, and logarithms.

   Trigonometric and hyperbolic functions and their inverses.

examples:

     ____________________________________________________________
     
         hugo := taylor(exp(x),x,0,2);
     
                       1  2      3
       HUGO := 1 + X + -*X  + O(X )
                       2
     
     
         taylorcombine log hugo;
     
              3
       X + O(X )
     
     
         taylorcombine(hugo + x);
     
                1  2      3
       (1 + X + -*X  + O(X )) + X
                2
     
     
         on taylorautoexpand;
     
         taylorcombine(hugo + x);
     
                 1  2      3
       1 + 2*X + -*X  + O(X )
                 2
     
     ____________________________________________________________
   Application of unary operators like LOG and ATAN  will nearly always
succeed. For binary operations their arguments  have to be Taylor
kernels with the same template. This means that  the expansion variable
and the expansion point must match.   Expansion order is not so
important, different order usually means  that one of them is truncated
before doing the operation.

   If [*note taylorkeeporiginal::.] is set to ON and if all  Taylor
kernels in its argument have their original expressions  kept
TAYLORCOMBINE will also combine these and store the  result as the
original expression of the resulting Taylor kernel.   There is also the
switch [*note taylorautoexpand::.] .

   There are a few restrictions to avoid mathematically undefined
expressions: it is not possible to take the logarithm of a Taylor
kernel which has no terms (i.e. is zero), or to divide by such a
beast. There are some provisions made to detect singularities  during
expansion: poles that arise because the denominator has  zeros at the
expansion point are detected and properly treated,  i.e. the Taylor
kernel will start with a negative power. (This  is accomplished by
expanding numerator and denominator separately  and combining the
results.) Essential singularities of the known  functions (see above)
are handled correctly.


File: ..\util\r37,  Node: taylorkeeporiginal,  Next: taylororiginal,  Prev: taylorcombine,  Up: Taylor series section

   TAYLORKEEPORIGINAL                    switch

   TAYLORKEEPORIGINAL , if set to ON , forces the  [*note taylor::.]
and all Taylor kernel manipulation operators to  keep the original
expression, i.e. the expression that was Taylor  expanded. All
operations performed on the Taylor kernels are also  applied to this
expression which can be recovered using the operator  [*note
taylororiginal::.] . Default is OFF .


File: ..\util\r37,  Node: taylororiginal,  Next: taylorprintorder,  Prev: taylorkeeporiginal,  Up: Taylor series section

   TAYLORORIGINAL                    operator

   Recovers the original expression (the one that was expanded) from
the Taylor kernel that is given as its argument.

syntax:

   TAYLORORIGINAL (<expression>) or  TAYLORORIGINAL <simple_expression>

examples:

     ____________________________________________________________
     
         hugo := taylor(exp(x),x,0,2);
     
                       1  2      3
       HUGO := 1 + X + -*X  + O(X )
                       2
     
     
         taylororiginal hugo;
     
       ***** Taylor kernel doesn't have an original part in TAYLORORIGINAL
     
     
         on taylorkeeporiginal;
     
         hugo := taylor(exp(x),x,0,2);
     
                       1  2      3
       HUGO := 1 + X + -*X  + O(X )
                       2
     
     
         taylororiginal hugo;
     
        X
       E
     
     ____________________________________________________________
   An error is signalled if the argument is not a Taylor kernel or if
the original expression was not kept, i.e. if  [*note
taylorkeeporiginal::.] was set OFF during expansion.


File: ..\util\r37,  Node: taylorprintorder,  Next: taylorprintterms,  Prev: taylororiginal,  Up: Taylor series section

   TAYLORPRINTORDER                    switch

   TAYLORPRINTORDER , if set to ON , causes the remainder  to be
printed in big-O notation. Otherwise, three dots are printed.   Default
is ON .


File: ..\util\r37,  Node: taylorprintterms,  Next: taylorrevert,  Prev: taylorprintorder,  Up: Taylor series section

   TAYLORPRINTTERMS                    variable

   Only a certain number of (non-zero) coefficients are printed. If
there are more, an expression of the form N TERMS is printed  to
indicate how many non-zero terms have been suppressed. The  number of
terms printed is given by the value of the shared  algebraic variable
TAYLORPRINTTERMS . Allowed values are  integers and the special
identifier ALL . The latter setting  specifies that all terms are to be
printed. The default setting is  5.

examples:

     ____________________________________________________________
     
         taylor(e^(x^2+y^2),x,0,4,y,0,4);
     
     
            2   1  4    2    2  2                              5  5
       1 + Y  + -*Y  + X  + Y *X  +             (4 terms) + O(X ,Y )
                2
     
     
         taylorprintterms := all;
     
       TAYLORPRINTTERMS := ALL
     
     
         taylor(e^(x^2+y^2),x,0,4,y,0,4);
     
     
            2   1  4    2    2  2   1  4  2   1  4   1  2  4
       1 + Y  + -*Y  + X  + Y *X  + -*Y *X  + -*X  + -*Y *X
                2                   2         2      2
          1  4  4      5  5
        + -*Y *X  + O(X ,Y )
          4
     
     
     ____________________________________________________________


File: ..\util\r37,  Node: taylorrevert,  Next: taylorseriesp,  Prev: taylorprintterms,  Up: Taylor series section

   TAYLORREVERT                    operator

   TAYLORREVERT allows reversion of a Taylor series of a  function f,
i.e., to compute the first terms of the expansion of the  inverse of f
from the expansion of f.

syntax:

   TAYLORREVERT (<expression>,  <var>, <var>)

   The first argument must evaluate to a Taylor kernel with the second
argument being one of its expansion variables.

examples:

     ____________________________________________________________
     
         taylor(u - u**2,u,0,5);
     
            2      6
       U - U  + O(U )
     
     
         taylorrevert (ws,u,x);
     
            2      3      4       5      6
       X + X  + 2*X  + 5*X  + 14*X  + O(X )
     
     ____________________________________________________________


File: ..\util\r37,  Node: taylorseriesp,  Next: taylortemplate,  Prev: taylorrevert,  Up: Taylor series section

   TAYLORSERIESP                    operator

   This operator may be used to determine if its argument is a Taylor
kernel.

syntax:

   TAYLORSERIESP (<expression>) or TAYLORSERIESP  <simple_expression>

examples:

     ____________________________________________________________
     
         hugo := taylor(exp(x),x,0,2);
     
                       1  2      3
       HUGO := 1 + X + -*X  + O(X )
                       2
     
     
         if taylorseriesp hugo then OK;
     
       OK
     
     
         if taylorseriesp(hugo + y) then OK else NO;
     
     
       NO
     
     ____________________________________________________________
   Note that this operator is subject to the same restrictions as,
e.g., ORDP or NUMBERP , i.e. it may only be used in  boolean
expressions in IF or LET statements.


File: ..\util\r37,  Node: taylortemplate,  Next: taylortostandard,  Prev: taylorseriesp,  Up: Taylor series section

   TAYLORTEMPLATE                    operator

   The template of a Taylor kernel, i.e. the list of all variables
with respect to which expansion took place together with expansion
point and order can be extracted using

syntax:

   TAYLORTEMPLATE (<expression>) or  TAYLORTEMPLATE <simple_expression>

   This returns a list of lists with the three elements
(VAR,VAR0,ORDER). An error is signalled if the argument is not a
Taylor kernel.

examples:

     ____________________________________________________________
     
         hugo := taylor(exp(x),x,0,2);
     
                       1  2      3
       HUGO := 1 + X + -*X  + O(X )
                       2
     
     
         taylortemplate hugo;
     
       {{X,0,2}}
     
     ____________________________________________________________


File: ..\util\r37,  Node: taylortostandard,  Prev: taylortemplate,  Up: Taylor series section

   TAYLORTOSTANDARD                    operator

   This operator converts all Taylor kernels in its argument into
standard form and resimplifies the result.

syntax:

   TAYLORTOSTANDARD (<expression>) or  TAYLORTOSTANDARD
<simple_expression>

examples:

     ____________________________________________________________
     
         hugo := taylor(exp(x),x,0,2);
     
                       1  2      3
       HUGO := 1 + X + -*X  + O(X )
                       2
     
     
         taylortostandard hugo;
     
        2
       X  + 2*X + 2
       ------------
            2
     
     ____________________________________________________________


File: ..\util\r37,  Node: Taylor series section,  Next: Gnuplot package section,  Prev: Special Functions section,  Up: Top

   Taylor series section

* Menu:

* TAYLOR introduction::     introduction
* taylor::                  operator
* taylorautocombine::       switch
* taylorautoexpand::        switch
* taylorcombine::           operator
* taylorkeeporiginal::      switch
* taylororiginal::          operator
* taylorprintorder::        switch
* taylorprintterms::        variable
* taylorrevert::            operator
* taylorseriesp::           operator
* taylortemplate::          operator
* taylortostandard::        operator


File: ..\util\r37,  Node: GNUPLOT and REDUCE,  Next: Axes names,  Up: Gnuplot package section

   GNUPLOT AND REDUCE                    introduction

   The GNUPLOT system provides easy to use graphics output for curves
or surfaces which are defined by formulas and/or data sets. GNUPLOT
supports a great variety of output devices such as X-windows, VGA
screen, postscript, picTeX.  The REDUCE GNUPLOT package lets one use
the GNUPLOT graphical output directly from inside REDUCE, either for
the interactive display of curves/surfaces or for the production of
pictures on paper.

   Note that this package may not be supported on all system platforms.

   For a detailed description you should read the GNUPLOT system
documentation, available together with the GNUPLOT installation
material from several servers by anonymous FTP.

   The REDUCE developers thank the GNUPLOT people for their permission
to distribute GNUPLOT together with REDUCE.


File: ..\util\r37,  Node: Axes names,  Next: Pointset,  Prev: GNUPLOT and REDUCE,  Up: Gnuplot package section

   AXES NAMES

   Inside REDUCE the choice of variable names for a graph is completely
free. For referring to the GNUPLOT axes the names X and Y for 2
dimensions, X,Y and Z for 3 dimensions are used in the usual schoolbook
sense independent from the variables of the REDUCE expression.

examples:

     ____________________________________________________________
     ____________________________________________________________


File: ..\util\r37,  Node: Pointset,  Next: PLOT,  Prev: Axes names,  Up: Gnuplot package section

   POINTSET                    type

   A curve can be give as a set of precomputed points (a polygon) in 2
or 3 dimensions. Such a point set is a [*note LIST::.] of points, where
each point is a [*note LIST::.] 2 (or 3) numbers. These numbers are
interpreted as (X,Y) (or X,Y,Z ) coordinates. All points of one set
must have the same dimension.

examples:

     ____________________________________________________________
     ____________________________________________________________
   Also a surface in 3d can be given by precomputed points, but only on
a logically orthogonal mesh: the surface is defined by a list of curves
(in 3d) which must have a uniform length.  GNUPLOT then will draw an
orthogonal mesh by first drawing the given lines, and second connecting
the 1st point of the 1st curve with the 1st point of the 2nd curve,
that one with the 1st point of the 3rd curve and so on for all curves
and for all indexes.


File: ..\util\r37,  Node: PLOT,  Next: PLOTRESET,  Prev: Pointset,  Up: Gnuplot package section

   PLOT                    command

   The command PLOT is the main entry for drawing a picture from inside
REDUCE.

syntax:

   PLOT (<spec>,<spec>,...)

   where <spec> is a <function>, a <range> or an <option>.

   <function>:

   - an expression depending on one unknown (e.g. SIN(X) or two
unknowns (e.g.  SIN(X+Y) ,

   - an equation with a function on its right-hand side and a single
name on its left-hand side (e.g.  Z=SIN(X+Y)  where the name on the
left-hand side specifies the dependent variable.

   - a list of functions: if in 2 dimensions the picture should have
more than one curve the expressions can be given as list (e.g.
[SIN(X),COS(X)] ).

   - an equation with zero left or right hand side describing  an
implicit curve in two dimensions (e.g. X**3+X*Y**3-9X=0 ).

   - a point set: the graph can be given as point set in 2 dimensions
or a [*note Pointset::.] or pointset list in 3 dimensions.

   <range>:

   Each dependent and independent variable can be limited to an
interval by an equation where the left-hand side specifies the variable
and the right-hand side defines the [*note Interval::.] , e.g. X=( -3
.. 5) .

   If omitted the independent variables range from -10 to 10 and the
dependent variable is limited only by the precision of the IEEE
floating point arithmetic.

   <option>:

   An option can be an equation equating a variable and a value (in
general a string), or a keyword(GNUPLOT switch).  These have to be
included in the gnuplot command arguments directly.  Strings have to be
enclosed in string quotes (see [*note STRING::.] ). Available options
are:

   [*note title::.] : assign a heading (default: empty)

   [*note xlabel::.] : set label for the x axis

   [*note ylabel::.] : set label for the y axis

   [*note zlabel::.] : set label for the z axis

   [*note terminal::.] : select an output device

   [*note size::.] : rescale the picture

   [*note view::.] : set a viewpoint

   (NO) [*note contour::.] : 3d: add contour lines

   (NO) [*note surface::.] : 3d: draw surface (default: yes)

   (NO) [*note hidden3d::.] : 3d: remove hidden lines (default: no)

examples:

     ____________________________________________________________
     
     plot(cos x);
     
     plot(s=sin phi,phi=(-3 .. 3));
     
     plot(sin phi,cos phi,phi=(-3 .. 3));
     
     plot (cos sqrt(x**2 + y**2),x=(-3 .. 3),y=(-3 .. 3),hidden3d);
     
     plot {{0,0},{0,1},{1,1},{0,0},{1,0},{0,1},{0.5,1.5},{1,1},{1,0}};
     
     
     
     on rounded;
     
     w:=for j:=1:200 collect {1/j*sin j,1/j*cos j,j/200}$
     
     plot w;
     ____________________________________________________________
   Additional control of the PLOT operation: [*note PLOTREFINE::.] ,
[*note plot_xmesh::.] , [*note plot_ymesh::.] , [*note TRPLOT::.] ,
[*note PLOTKEEP::.] , [*note SHOW_GRID::.] .


File: ..\util\r37,  Node: PLOTRESET,  Next: title,  Prev: PLOT,  Up: Gnuplot package section

   PLOTRESET                    command

   The command PLOTRESET closes the current GNUPLOT windows.  The next
call to [*note PLOT::.] will create a new one. PLOTRESET can also be
used to reset the system status after technical problems.

syntax:

   PLOTRESET ;


File: ..\util\r37,  Node: title,  Next: xlabel,  Prev: PLOTRESET,  Up: Gnuplot package section

   TITLE                    variable

   [*note PLOT::.]  option: Assign a title to the GNUPLOT graph.

syntax:

   TITLE = <string>

examples:

     ____________________________________________________________
     
     title="annual revenue in 1993"
     ____________________________________________________________


File: ..\util\r37,  Node: xlabel,  Next: ylabel,  Prev: title,  Up: Gnuplot package section

   XLABEL                    variable

   [*note PLOT::.]  option: Assign a name to to the x axis (see [*note
Axes names::.] ).

syntax:

   XLABEL = <string>

examples:

     ____________________________________________________________
     
     xlabel="month"
     ____________________________________________________________


File: ..\util\r37,  Node: ylabel,  Next: zlabel,  Prev: xlabel,  Up: Gnuplot package section

   YLABEL                    variable

   [*note PLOT::.]  option: Assign a name to to the x axis (see [*note
Axes names::.] ).

syntax:

   YLABEL = <string>

examples:

     ____________________________________________________________
     
     ylabel="million forint"
     ____________________________________________________________


File: ..\util\r37,  Node: zlabel,  Next: terminal,  Prev: ylabel,  Up: Gnuplot package section

   ZLABEL                    variable

   [*note PLOT::.]  option: Assign a name to to the z axis (see [*note
Axes names::.] ).

syntax:

   ZLABEL = <string>

examples:

     ____________________________________________________________
     
     zlabel="local weight"
     ____________________________________________________________


File: ..\util\r37,  Node: terminal,  Next: size,  Prev: zlabel,  Up: Gnuplot package section

   TERMINAL                    variable

   [*note PLOT::.]  option: Select a different output device. The
possible values here depend highly on the facilities installed for your
GNUPLOT software.

syntax:

   TERMINAL = <string>

examples:

     ____________________________________________________________
     
     terminal="x11"
     ____________________________________________________________


File: ..\util\r37,  Node: size,  Next: view,  Prev: terminal,  Up: Gnuplot package section

   SIZE                    variable

   [*note PLOT::.]  option: Rescale the graph (not the window!) in x
and y direction.  Default is 1.0 (no rescaling).

syntax:

   SIZE = "<sx>,<sy>"

   where <sx>,<sy> are floating point number not too far from 1.0.

examples:

     ____________________________________________________________
     
     size="0.7,1"
     ____________________________________________________________


File: ..\util\r37,  Node: view,  Next: contour,  Prev: size,  Up: Gnuplot package section

   VIEW                    variable

   [*note PLOT::.]  option: Set a new viewpoint by turning the object
around the x and then around the z axis (see [*note Axes names::.] ).

syntax:

   VIEW = "<sx>,<sz>"

   where <sx>,<sz> are floating point number representing angles in
degrees.

examples:

     ____________________________________________________________
     
     view="30,130"
     ____________________________________________________________


File: ..\util\r37,  Node: contour,  Next: surface,  Prev: view,  Up: Gnuplot package section

   CONTOUR                    switch

   [*note PLOT::.]  option: If CONTOUR is member of the options for a
3d [*note PLOT::.] contour lines are projected to the z=0 plane (see
[*note Axes names::.] ). The absence of contour lines can be selected
explicitly by including NOCONTOUR . Default is NOCONTOUR .


File: ..\util\r37,  Node: surface,  Next: hidden3d,  Prev: contour,  Up: Gnuplot package section

   SURFACE                    switch

   [*note PLOT::.]  option: If SURFACE is member of the options for a
3d [*note PLOT::.] the surface is drawn. The absence of the surface
plotting can be selected by including NOSURFACE , e.g. if only the
[*note contour::.] should be visualized. Default is SURFACE .


File: ..\util\r37,  Node: hidden3d,  Next: PLOTKEEP,  Prev: surface,  Up: Gnuplot package section

   HIDDEN3D                    switch

   [*note PLOT::.]  option: If HIDDEN3D is member of the options for a
3d [*note PLOT::.] hidden lines are removed from the picture. Otherwise
a surface is drawn as transparent object. Default is NOHIDDEN3D .
Selecting HIDDEN3D increases the computing time substantially.


File: ..\util\r37,  Node: PLOTKEEP,  Next: PLOTREFINE,  Prev: hidden3d,  Up: Gnuplot package section

   PLOTKEEP                    switch

   Normally all intermediate data sets are deleted after terminating a
plot session. If the switch PLOTKEEP is set [*note ON::.] , the data
sets are kept for eventual post processing independent of REDUCE.


File: ..\util\r37,  Node: PLOTREFINE,  Next: plot_xmesh,  Prev: PLOTKEEP,  Up: Gnuplot package section

   PLOTREFINE                    switch

   In general [*note PLOT::.] tries to generate smooth pictures by
evaluating the functions at interior points until the distances are fine
enough. This can require a lot of computing time if the single function
evaluation is expensive. The refinement is controlled by the switch
PLOTREFINE which is [*note ON::.] by default. When you turn it [*note
OFF::.] the functions will be evaluated only at the basic points (see
[*note plot_xmesh::.] , [*note plot_ymesh::.] ).


File: ..\util\r37,  Node: plot_xmesh,  Next: plot_ymesh,  Prev: PLOTREFINE,  Up: Gnuplot package section

   PLOT_XMESH                    variable

   The integer value of the global variable PLOT_XMESH defines the
number of initial function evaluations in x direction (see [*note Axes
names::.] ) for [*note PLOT::.] . For 2d graphs additional points will
be used as long as [*note PLOTREFINE::.] is ON .  For 3d graphs this
number defines also the number of mesh lines orthogonal to the x axis.


File: ..\util\r37,  Node: plot_ymesh,  Next: SHOW_GRID,  Prev: plot_xmesh,  Up: Gnuplot package section

   PLOT_YMESH                    variable

   The integer value of the global variable PLOT_YMESH defines for 3d
[*note PLOT::.] calls the number of function evaluations in y direction
(see [*note Axes names::.] ) and the number of mesh lines orthogonal to
the y axis.


File: ..\util\r37,  Node: SHOW_GRID,  Next: TRPLOT,  Prev: plot_ymesh,  Up: Gnuplot package section

   SHOW_GRID                    switch

   The grid for localizing an implicitly defined curve in [*note
PLOT::.] consists of triangles. These are computed initially equally
distributed over the x-y plane controlled by [*note plot_xmesh::.] .
The grid is refined adaptively in several levels. The final grid can be
visualized by setting on the switch SHOW_GRID .


File: ..\util\r37,  Node: TRPLOT,  Prev: SHOW_GRID,  Up: Gnuplot package section

   TRPLOT                    switch

   In general the interaction between REDUCE and GNUPLOT is performed
as silently as possible. However, sometimes it might be useful to see
the GNUPLOT commands generated by REDUCE, e.g. for a postprocessing of
generated data sets independent of REDUCE.  When the switch TRPLOT is
set on all GNUPLOT commands will be printed to the standard output
additionally.


File: ..\util\r37,  Node: Gnuplot package section,  Next: Linear Algebra package section,  Prev: Taylor series section,  Up: Top

   Gnuplot package section

* Menu:

* GNUPLOT and REDUCE::      introduction
* Axes names::              concept
* Pointset::                type
* PLOT::                    command
* PLOTRESET::               command
* title::                   variable
* xlabel::                  variable
* ylabel::                  variable
* zlabel::                  variable
* terminal::                variable
* size::                    variable
* view::                    variable
* contour::                 switch
* surface::                 switch
* hidden3d::                switch
* PLOTKEEP::                switch
* PLOTREFINE::              switch
* plot_xmesh::              variable
* plot_ymesh::              variable
* SHOW_GRID::               switch
* TRPLOT::                  switch


File: ..\util\r37,  Node: Linear Algebra package,  Next: fast_la,  Up: Linear Algebra package section

   LINEAR ALGEBRA PACKAGE                    introduction

   This section briefly describes what's available in the Linear Algebra
package.

   Note on examples: In the examples throughout this document, the
matrix A will be
     ____________________________________________________________
     
          [1  2  3]
          [4  5  6]
          [7  8  9].
     ____________________________________________________________

   The functions can be divided into four categories:

   Basic matrix handling

   [*note add_columns::.] ,

   [*note add_rows::.] ,

   [*note add_to_columns::.] ,

   [*note add_to_rows::.] ,

   [*note augment_columns::.] ,

   [*note char_poly::.] ,

   [*note column_dim::.] ,

   [*note copy_into::.] ,

   [*note diagonal::.] ,

   [*note extend::.] ,

   [*note find_companion::.] ,

   [*note get_columns::.] ,

   [*note get_rows::.] ,

   [*note hermitian_tp::.] ,

   [*note matrix_augment::.] ,

   [*note matrix_stack::.] ,

   [*note minor::.] ,

   [*note mult_columns::.] ,

   [*note mult_rows::.] ,

   [*note pivot::.] ,

   [*note remove_columns::.] ,

   [*note remove_rows::.] ,

   [*note row_dim::.] ,

   [*note rows_pivot::.] ,

   [*note stack_rows::.] ,

   [*note sub_matrix::.] ,

   [*note swap_columns::.] ,

   [*note swap_entries::.] ,

   [*note swap_rows::.] .

   Constructors - functions that create matrices

   [*note band_matrix::.] ,

   [*note block_matrix::.] ,

   [*note char_matrix::.] ,

   [*note coeff_matrix::.] ,

   [*note companion::.] ,

   [*note hessian::.] ,

   [*note hilbert::.] ,

   [*note jacobian::.] ,

   [*note jordan_block::.] ,

   [*note make_identity::.] ,

   [*note random_matrix::.] ,

   [*note toeplitz::.] ,

   [*note vandermonde::.] .

   High level algorithms

   [*note char_poly::.] ,

   [*note cholesky::.] ,

   [*note gram_schmidt::.] ,

   [*note lu_decom::.] ,

   [*note pseudo_inverse::.] ,

   [*note simplex::.] ,

   [*note svd::.] .

   Normal Forms

   There is a separate package, NORMFORM, for computing the following
matrix normal forms in REDUCE:

   [*note Smithex::.] ,

   [*note Smithex_int::.] ,

   [*note Frobenius::.] ,

   [*note Ratjordan::.] ,

   [*note Jordansymbolic::.] ,

   [*note Jordan::.] .

   Predicates

   [*note matrixp::.] ,

   [*note squarep::.] ,

   [*note symmetricp::.] .


File: ..\util\r37,  Node: fast_la,  Next: add_columns,  Prev: Linear Algebra package,  Up: Linear Algebra package section

   FAST_LA                    switch

   By turning the FAST_LA switch on, the speed of the following
functions will be increased:

   [*note add_columns::.] ,

   [*note add_rows::.] ,

   [*note augment_columns::.] ,

   [*note column_dim::.] ,

   [*note copy_into::.] ,

   [*note make_identity::.] ,

   [*note matrix_augment::.] ,

   [*note matrix_stack::.] ,

   [*note minor::.] ,

   [*note mult_columns::.] ,

   [*note mult_rows::.] ,

   [*note pivot::.] ,

   [*note remove_columns::.] ,

   [*note remove_rows::.] ,

   [*note rows_pivot::.] ,

   [*note squarep::.] ,

   [*note stack_rows::.] ,

   [*note sub_matrix::.] ,

   [*note swap_columns::.] ,

   [*note swap_entries::.] ,

   [*note swap_rows::.] ,

   [*note symmetricp::.] .

   The increase in speed will be negligible unless you are making a
significant number (i.e. thousands) of calls. When using this switch,
error checking is minimized. This means that illegal input may give
strange error messages. Beware.


File: ..\util\r37,  Node: add_columns,  Next: add_rows,  Prev: fast_la,  Up: Linear Algebra package section

   ADD_COLUMNS                    operator

   Add columns, add rows:

syntax:

   ADD_COLUMNS (<matrix>,<c1>,<c2>,<expr>)

   <matrix> :- a [*note MATRIX::.] .

   <c1>,<c2> :- positive integers.

   <expr> :- a scalar expression.

   The Operator ADD_COLUMNS replaces column <metac2> of <matrix> by
<expr> * column(<matrix>,<c1>) + column(<matrix>,<c2>).

   ADD_ROWS performs the equivalent task on the rows of <matrix>.

examples:

     ____________________________________________________________
     
     
     add_columns(A,1,2,x);
     
       [1   x + 2   3]
       [             ]
       [4  4*x + 5  6]
       [             ]
       [7  7*x + 8  9]
     
     
     
     add_rows(A,2,3,5);
     
       [1   2   3 ]
       [          ]
       [4   5   6 ]
       [          ]
       [27  33  39]
     
     ____________________________________________________________
   Related functions: [*note add_to_columns::.] , [*note
add_to_rows::.] , [*note mult_columns::.] , [*note mult_rows::.] .


File: ..\util\r37,  Node: add_rows,  Next: add_to_columns,  Prev: add_columns,  Up: Linear Algebra package section

   ADD_ROWS                    operator

   see: [*note add_columns::.] .


File: ..\util\r37,  Node: add_to_columns,  Next: add_to_rows,  Prev: add_rows,  Up: Linear Algebra package section

   ADD_TO_COLUMNS                    operator

   Add to columns, add to rows:

syntax:

   ADD_TO_COLUMNS (<matrix>,<column_list>,<expr>)

   <matrix> :- a matrix.

   <column_list> :- a positive integer or a list of positive  integers.

   <expr> :- a scalar expression.

   ADD_TO_COLUMNS adds <expr> to each column specified in <column_list>
of <matrix>.

   ADD_TO_ROWS performs the equivalent task on the rows of <matrix>.

examples:

     ____________________________________________________________
     
     
     add_to_columns(A,{1,2},10);
     
       [11  12  3]
       [         ]
       [14  15  6]
       [         ]
       [17  18  9]
     
     
     
     add_to_rows(A,2,-x)
     
     
       [   1         2         3    ]
       [                            ]
       [ - x + 4   - x + 5   - x + 6]
       [                            ]
       [   7         8         9    ]
     
     ____________________________________________________________
   Related functions: [*note add_columns::.] , [*note add_rows::.] ,
[*note mult_rows::.] , [*note mult_columns::.] .


File: ..\util\r37,  Node: add_to_rows,  Next: augment_columns,  Prev: add_to_columns,  Up: Linear Algebra package section

   ADD_TO_ROWS                    operator

   see: [*note add_to_columns::.] .


File: ..\util\r37,  Node: augment_columns,  Next: band_matrix,  Prev: add_to_rows,  Up: Linear Algebra package section

   AUGMENT_COLUMNS                    operator

   Augment columns, stack rows:

syntax:

   AUGMENT_COLUMNS (<matrix>,<column_list>)

   <matrix> :- a matrix.

   <column_list> :- either a positive integer or a list of positive
integers.

   AUGMENT_COLUMNS gets hold of the columns of <matrix> specified in
COLUMN_LIST and sticks them together.

   STACK_ROWS performs the same task on rows of <matrix>.

examples:

     ____________________________________________________________
     
     
     augment_columns(A,{1,2})
     
     
       [1  2]
       [    ]
       [4  5]
       [    ]
       [7  8]
     
     
     
     stack_rows(A,{1,3})
     
       [1  2  3]
       [       ]
       [7  8  9]
     
     ____________________________________________________________
   Related functions: [*note get_columns::.] , [*note get_rows::.] ,
[*note sub_matrix::.] .


File: ..\util\r37,  Node: band_matrix,  Next: block_matrix,  Prev: augment_columns,  Up: Linear Algebra package section

   BAND_MATRIX                    operator

syntax:

   BAND_MATRIX (<expr_list>,<square_size>)

   <expr_list> :- either a single scalar expression or a list of  an
odd number of scalar expressions.

   <square_size> :- a positive integer.

   BAND_MATRIX creates a square matrix of dimension <square_size>. The
diagonal consists of the middle expression of the <expr_list>. The
expressions to the left of this fill the required number of
sub_diagonals and the expressions to the right the super_diagonals.

examples:

     ____________________________________________________________
     
     
     band_matrix({x,y,z},6)
     
       [y  z  0  0  0  0]
       [                ]
       [x  y  z  0  0  0]
       [                ]
       [0  x  y  z  0  0]
       [                ]
       [0  0  x  y  z  0]
       [                ]
       [0  0  0  x  y  z]
       [                ]
       [0  0  0  0  x  y]
     
     ____________________________________________________________
   Related functions: [*note diagonal::.] .


File: ..\util\r37,  Node: block_matrix,  Next: char_matrix,  Prev: band_matrix,  Up: Linear Algebra package section

   BLOCK_MATRIX                    operator

syntax:

   BLOCK_MATRIX (<r>,<c>,<matrix_list>)

   <r>,<c> :- positive integers.

   <matrix_list> :- a list of matrices.

   BLOCK_MATRIX creates a matrix that consists of <r> by <c> matrices
filled from the <matrix_list> row wise.

examples:

     ____________________________________________________________
     
     B := make_identity(2);
     
            [1  0]
       b := [    ]
            [0  1]
     
     
     
     C := mat((5),(5));
     
            [5]
       c := [ ]
            [5]
     
     
     
     D := mat((22,33),(44,55));
     
            [22  33]
       d := [      ]
            [44  55]
     
     
     
     block_matrix(2,3,{B,C,D,D,C,B});
     
     
       [1   0   5  22  33]
       [                 ]
       [0   1   5  44  55]
       [                 ]
       [22  33  5  1   0 ]
       [                 ]
       [44  55  5  0   1 ]
     
     ____________________________________________________________


File: ..\util\r37,  Node: char_matrix,  Next: char_poly,  Prev: block_matrix,  Up: Linear Algebra package section

   CHAR_MATRIX                    operator

syntax:

   CHAR_MATRIX (<matrix>,<lambda>)

   <matrix> :- a square matrix.  <lambda> :- a symbol or algebraic
expression.

   <char_matrix> creates the characteristic matrix C of <matrix>.

   This is C = <lambda> * Id - A.  Id is the identity matrix.

examples:

     ____________________________________________________________
     
     
     char_matrix(A,x);
     
       [x - 1   -2     -3  ]
       [                   ]
       [ -4    x - 5   -6  ]
       [                   ]
       [ -7     -8    x - 9]
     
     ____________________________________________________________
   Related functions: [*note char_poly::.] .


File: ..\util\r37,  Node: char_poly,  Next: cholesky,  Prev: char_matrix,  Up: Linear Algebra package section

   CHAR_POLY                    operator

syntax:

   CHAR_POLY (<matrix>,<lambda>)

   <matrix> :- a square matrix.

   <lambda> :- a symbol or algebraic expression.

   CHAR_POLY finds the characteristic polynomial of <matrix>.  This is
the determinant of <lambda> * Id - A.  Id is the identity matrix.

examples:

     ____________________________________________________________
     
     char_poly(A,x);
     
        3     2
       x -15*x -18*x
     
     ____________________________________________________________
   Related functions: [*note char_matrix::.] .


File: ..\util\r37,  Node: cholesky,  Next: coeff_matrix,  Prev: char_poly,  Up: Linear Algebra package section

   CHOLESKY                    operator

syntax:

   CHOLESKY (<matrix>)

   <matrix> :- a positive definite matrix containing numeric entries.

   CHOLESKY computes the cholesky decomposition of <matrix>.

   It returns L,U where L is a lower matrix, U is an upper matrix, A =
LU, and U = L^T.

examples:

     ____________________________________________________________
     
     F := mat((1,1,0),(1,3,1),(0,1,1));
     
     
            [1  1  0]
            [       ]
       f := [1  3  1]
            [       ]
            [0  1  1]
     
     
     
     on rounded;
     
     cholesky(F);
     
       {
        [1        0               0       ]
        [                                 ]
        [1  1.41421356237         0       ]
        [                                 ]
        [0  0.707106781187  0.707106781187]
        ,
        [1        1              0       ]
        [                                ]
        [0  1.41421356237  0.707106781187]
        [                                ]
        [0        0        0.707106781187]
       }
     
     ____________________________________________________________
   Related functions: [*note lu_decom::.] .


File: ..\util\r37,  Node: coeff_matrix,  Next: column_dim,  Prev: cholesky,  Up: Linear Algebra package section

   COEFF_MATRIX                    operator

syntax:

   COEFF_MATRIX (<lineq_list>)

   (If you are feeling lazy then the braces can be omitted.)

   <lineq_list> :- linear equations. Can be of the form equation =
number or just equation.

   COEFF_MATRIX creates the coefficient matrix C of the linear
equations.

   It returns C,X,B such that CX = B.

examples:

     ____________________________________________________________
     
     
     coeff_matrix({x+y+4*z=10,y+x-z=20,x+y+4});
     
     
       {
        [4   1  1]
        [        ]
        [-1  1  1]
        [        ]
        [0   1  1]
        ,
        [z]
        [ ]
        [y]
        [ ]
        [x]
        ,
        [10]
        [  ]
        [20]
        [  ]
        [-4]
       }
     
     ____________________________________________________________


File: ..\util\r37,  Node: column_dim,  Next: companion,  Prev: coeff_matrix,  Up: Linear Algebra package section

   COLUMN_DIM                    operator

   Column dimension, row dimension:

syntax:

   COLUMN_DIM (<matrix>)

   <matrix> :- a matrix.

   COLUMN_DIM finds the column dimension of <matrix>.

   ROW_DIM finds the row dimension of <matrix>.

examples:

     ____________________________________________________________
     
     
     column_dim(A);
     
       3
     
     
     row_dim(A);
     
       3
     
     ____________________________________________________________


File: ..\util\r37,  Node: companion,  Next: copy_into,  Prev: column_dim,  Up: Linear Algebra package section

   COMPANION                    operator

syntax:

   COMPANION (<poly>,<x>)

   <poly> :- a monic univariate polynomial in <x>.

   <x> :- the variable.

   COMPANION creates the companion matrix C of <poly>.

   This is the square matrix of dimension n, where n is the degree of
<poly> w.r.t. <x>.

   The entries of C are:

   C(i,n) = -coeffn(<poly>,<x>,i-1) for i = 1  ... n, C(i,i-1) = 1 for
i = 2 ... n and  the rest are 0.

examples:

     ____________________________________________________________
     
     
     companion(x^4+17*x^3-9*x^2+11,x);
     
     
       [0  0  0  -11]
       [            ]
       [1  0  0   0 ]
       [            ]
       [0  1  0   9 ]
       [            ]
       [0  0  1  -17]
     
     ____________________________________________________________
   Related functions: [*note find_companion::.] .


File: ..\util\r37,  Node: copy_into,  Next: diagonal,  Prev: companion,  Up: Linear Algebra package section

   COPY_INTO                    operator

syntax:

   COPY_INTO (<A>,<B>,<r>,<c>)

   <A>,<B> :- matrices.

   <r>,<c> :- positive integers.

   COPY_INTO copies matrix <matrix> into <B> with <matrix>(1,1) at
<B>(<r>,<c>).

examples:

     ____________________________________________________________
     
     
     G := mat((0,0,0,0,0),(0,0,0,0,0),(0,0,0,0,0),(0,0,0,0,0),(0,0,0,0,0));
     
     
            [0  0  0  0  0]
            [             ]
            [0  0  0  0  0]
            [             ]
       g := [0  0  0  0  0]
            [             ]
            [0  0  0  0  0]
            [             ]
            [0  0  0  0  0]
     
     
     
     copy_into(A,G,1,2);
     
       [0  1  2  3  0]
       [             ]
       [0  4  5  6  0]
       [             ]
       [0  7  8  9  0]
       [             ]
       [0  0  0  0  0]
       [             ]
       [0  0  0  0  0]
     
     ____________________________________________________________
   Related functions: [*note augment_columns::.] , [*note extend::.] ,
[*note matrix_augment::.] , [*note matrix_stack::.] , [*note
stack_rows::.] , [*note sub_matrix::.] .


File: ..\util\r37,  Node: diagonal,  Next: extend,  Prev: copy_into,  Up: Linear Algebra package section

   DIAGONAL                    operator

syntax:

   DIAGONAL (<mat_list>)

   (If you are feeling lazy then the braces can be omitted.)

   <mat_list> :- each can be either a scalar expression or a square
[*note MATRIX::.] .

   DIAGONAL creates a matrix that contains the input on the diagonal.

examples:

     ____________________________________________________________
     
     
     H := mat((66,77),(88,99));
     
            [66  77]
       h := [      ]
            [88  99]
     
     
     
     diagonal({A,x,H});
     
       [1  2  3  0  0   0 ]
       [                  ]
       [4  5  6  0  0   0 ]
       [                  ]
       [7  8  9  0  0   0 ]
       [                  ]
       [0  0  0  x  0   0 ]
       [                  ]
       [0  0  0  0  66  77]
       [                  ]
       [0  0  0  0  88  99]
     
     ____________________________________________________________
   Related functions: [*note jordan_block::.] .


File: ..\util\r37,  Node: extend,  Next: find_companion,  Prev: diagonal,  Up: Linear Algebra package section

   EXTEND                    operator

syntax:

   EXTEND (<matrix>,<r>,<c>,<expr>)

   <matrix> :- a [*note MATRIX::.] .

   <r>,<c> :- positive integers.

   <expr> :- algebraic expression or symbol.

   EXTEND returns a copy of <matrix> that has been extended by <r> rows
and <c> columns. The new entries are made equal to <expr>.

examples:

     ____________________________________________________________
     
     
     extend(A,1,2,x);
     
       [1  2  3  x  x]
       [             ]
       [4  5  6  x  x]
       [             ]
       [7  8  9  x  x]
       [             ]
       [x  x  x  x  x]
     
     ____________________________________________________________
   Related functions: [*note copy_into::.] , [*note matrix_augment::.]
, [*note matrix_stack::.] , [*note remove_columns::.] , [*note
remove_rows::.] .


File: ..\util\r37,  Node: find_companion,  Next: get_columns,  Prev: extend,  Up: Linear Algebra package section

   FIND_COMPANION                    operator

syntax:

   FIND_COMPANION (<matrix>,<x>)

   <matrix> :- a [*note MATRIX::.] .

   <x> :- the variable.

   Given a companion matrix, FIND_COMPANION finds the polynomial from
which it was made.

examples:

     ____________________________________________________________
     
     
     C := companion(x^4+17*x^3-9*x^2+11,x);
     
     
            [0  0  0  -11]
            [            ]
            [1  0  0   0 ]
       c := [            ]
            [0  1  0   9 ]
            [            ]
            [0  0  1  -17]
     
     
     
     find_companion(C,x);
     
        4     3    2
       x +17*x -9*x +11
     
     ____________________________________________________________
   Related functions: [*note companion::.] .


File: ..\util\r37,  Node: get_columns,  Next: get_rows,  Prev: find_companion,  Up: Linear Algebra package section

   GET_COLUMNS                    operator

   Get columns, get rows:

syntax:

   GET_COLUMNS (<matrix>,<column_list>)

   <matrix> :- a [*note MATRIX::.] .

   <c> :- either a positive integer or a list of positive  integers.

   GET_COLUMNS removes the columns of <matrix> specified in
<column_list> and returns them as a list of column matrices.

   GET_ROWS performs the same task on the rows of <matrix>.

examples:

     ____________________________________________________________
     
     
     get_columns(A,{1,3});
     
       {
        [1]
        [ ]
        [4]
        [ ]
        [7]
        ,
        [3]
        [ ]
        [6]
        [ ]
        [9]
       }
     
     
     
     get_rows(A,2);
     
       {
        [4  5  6]
       }
     
     ____________________________________________________________
   Related functions: [*note augment_columns::.] , [*note
stack_rows::.] , [*note sub_matrix::.] .


File: ..\util\r37,  Node: get_rows,  Next: gram_schmidt,  Prev: get_columns,  Up: Linear Algebra package section

   GET_ROWS                    operator

   see: [*note get_columns::.] .


File: ..\util\r37,  Node: gram_schmidt,  Next: hermitian_tp,  Prev: get_rows,  Up: Linear Algebra package section

   GRAM_SCHMIDT                    operator

syntax:

   GRAM_SCHMIDT (<vec_list>)

   (If you are feeling lazy then the braces can be omitted.)

   <vec_list> :- linearly independent vectors. Each vector must be
written as a list, eg:1,0,0.

   GRAM_SCHMIDT performs the gram_schmidt orthonormalization on the
input vectors.

   It returns a list of orthogonal normalized vectors.

examples:

     ____________________________________________________________
     
     
     gram_schmidt({{1,0,0},{1,1,0},{1,1,1}});
     
     
       {{1,0,0},{0,1,0},{0,0,1}}
     
     
     
     gram_schmidt({{1,2},{3,4}});
     
     
             1         2        2*sqrt(5)   -sqrt(5)
       {{ ------- , ------- },{ --------- , -------- }}
          sqrt(5)   sqrt(5)         5          5
     
     ____________________________________________________________


File: ..\util\r37,  Node: hermitian_tp,  Next: hessian,  Prev: gram_schmidt,  Up: Linear Algebra package section

   HERMITIAN_TP                    operator

syntax:

   HERMITIAN_TP (<matrix>)

   <matrix> :- a [*note MATRIX::.] .

   HERMITIAN_TP computes the hermitian transpose of <matrix>.

   This is a [*note MATRIX::.] in which the (i,j)'th entry is the
conjugate of the (j,i)'th entry of <matrix>.

examples:

     ____________________________________________________________
     
     
     J := mat((i+1,i+2,i+3),(4,5,2),(1,i,0));
     
     
            [i + 1  i + 2  i + 3]
            [                   ]
       j := [  4      5      2  ]
            [                   ]
            [  1      i      0  ]
     
     
     
     hermitian_tp(j);
     
       [ - i + 1  4   1  ]
       [                 ]
       [ - i + 2  5   - i]
       [                 ]
       [ - i + 3  2   0  ]
     
     ____________________________________________________________
   Related functions: [*note TP::.] .


File: ..\util\r37,  Node: hessian,  Next: hilbert,  Prev: hermitian_tp,  Up: Linear Algebra package section

   HESSIAN                    operator

syntax:

   HESSIAN (<expr>,<variable_list>)

   <expr> :- a scalar expression.

   <variable_list> :- either a single variable or a list of  variables.

   HESSIAN computes the hessian matrix of <expr> w.r.t. the variables
in <variable_list>.

   This is an n by n matrix where n is the number of variables and the
(i,j)'th entry is [*note DF::.] (<expr>,<variable_list>(i),
<variable_list>(j)).

examples:

     ____________________________________________________________
     
     
     hessian(x*y*z+x^2,{w,x,y,z});
     
       [0  0  0  0]
       [          ]
       [0  2  z  y]
       [          ]
       [0  z  0  x]
       [          ]
       [0  y  x  0]
     
     ____________________________________________________________
   Related functions: [*note DF::.] .


File: ..\util\r37,  Node: hilbert,  Next: jacobian,  Prev: hessian,  Up: Linear Algebra package section

   HILBERT                    operator

syntax:

   HILBERT (<square_size>,<expr>)

   <square_size> :- a positive integer.

   <expr> :- an algebraic expression.

   HILBERT computes the square hilbert matrix of dimension
<square_size>.

   This is the symmetric matrix in which the (i,j)'th entry is
1/(i+j-<expr>).

examples:

     ____________________________________________________________
     
     
     hilbert(3,y+x);
     
       [    - 1          - 1          - 1    ]
       [-----------  -----------  -----------]
       [ x + y - 2    x + y - 3    x + y - 4 ]
       [                                     ]
       [    - 1          - 1          - 1    ]
       [-----------  -----------  -----------]
       [ x + y - 3    x + y - 4    x + y - 5 ]
       [                                     ]
       [    - 1          - 1          - 1    ]
       [-----------  -----------  -----------]
       [ x + y - 4    x + y - 5    x + y - 6 ]
     
     ____________________________________________________________


File: ..\util\r37,  Node: jacobian,  Next: jordan_block,  Prev: hilbert,  Up: Linear Algebra package section

   JACOBIAN                    operator

syntax:

   JACOBIAN (<expr_list>,<variable_list>)

   <expr_list> :- either a single algebraic expression or a list  of
algebraic expressions.

   <variable_list> :- either a single variable or a list of  variables.

   JACOBIAN computes the jacobian matrix of <expr_list> w.r.t.
<variable_list>.

   This is a matrix whose (i,j)'th entry is [*note DF::.] (<expr_list>
(i),<variable_list>(j)).

   The matrix is n by m where n is the number of variables and m the
number of expressions.

examples:

     ____________________________________________________________
     
     
     jacobian({x^4,x*y^2,x*y*z^3},{w,x,y,z});
     
     
       [      3                 ]
       [0  4*x     0       0    ]
       [                        ]
       [     2                  ]
       [0   y    2*x*y     0    ]
       [                        ]
       [      3     3          2]
       [0  y*z   x*z    3*x*y*z ]
     
     ____________________________________________________________
   Related functions: [*note hessian::.] , [*note DF::.] .


File: ..\util\r37,  Node: jordan_block,  Next: lu_decom,  Prev: jacobian,  Up: Linear Algebra package section

   JORDAN_BLOCK                    operator

syntax:

   JORDAN_BLOCK (<expr>,<square_size>)

   <expr> :- an algebraic expression or symbol.

   <square_size> :- a positive integer.

   JORDAN_BLOCK computes the square jordan block matrix J of dimension
<square_size>.

   The entries of J are:

   J(i,i) = <expr> for i=1  ... n, J(i,i+1) = 1 for i=1  ... n-1, and
all other entries are 0.

examples:

     ____________________________________________________________
     
     
     jordan_block(x,5);
     
       [x  1  0  0  0]
       [             ]
       [0  x  1  0  0]
       [             ]
       [0  0  x  1  0]
       [             ]
       [0  0  0  x  1]
       [             ]
       [0  0  0  0  x]
     
     ____________________________________________________________
   Related functions: [*note diagonal::.] , [*note companion::.] .


File: ..\util\r37,  Node: lu_decom,  Next: make_identity,  Prev: jordan_block,  Up: Linear Algebra package section

   LU_DECOM                    operator

syntax:

   LU_DECOM (<matrix>)

   <matrix> :- a [*note MATRIX::.] containing either numeric entries
or imaginary entries with numeric coefficients.

   LU_DECOM performs LU decomposition on <matrix>, ie: it returns L,U
where L is a lower diagonal [*note MATRIX::.] , U an upper diagonal
[*note MATRIX::.] and A = LU.

   Caution:

   The algorithm used can swap the rows of <matrix> during the
calculation. This means that LU does not equal <matrix> but a row
equivalent of it. Due to this, LU_DECOM returns L,U,vec.  The call
CONVERT(META[MATRIX ,vec) will return the matrix that has been
decomposed, i.e: LU = convert(<matrix>,vec).

examples:

     ____________________________________________________________
     
     
     K := mat((1,3,5),(-4,3,7),(8,6,4));
     
     
            [1   3  5]
            [        ]
       k := [-4  3  7]
            [        ]
            [8   6  4]
     
     
     
     on rounded;
     
     lu :=  lu_decom(K);
     
       lu := {
              [8    0      0  ]
              [               ]
              [-4  6.0     0  ]
              [               ]
              [1   2.25  1.125]
              ,
              [1  0.75  0.5]
              [            ]
              [0   1    1.5]
              [            ]
              [0   0     1 ]
              ,
              [3 2 3]}
     
     
     
     first lu * second lu;
     
       [8   6.0  4.0]
       [            ]
       [-4  3.0  7.0]
       [            ]
       [1   3.0  5.0]
     
     
     
     convert(K,third lu);
     
       P := mat((i+1,i+2,i+3),(4,5,2),(1,i,0));
            [i + 1  i + 2  i + 3]
            [                   ]
       p := [  4      5      2  ]
            [                   ]
            [  1      i      0  ]
     
     
     lu :=  lu_decom(P);
     
       lu := {
              [  1        0                      0                ]
              [                                                   ]
              [  4     - 4*i + 5                 0                ]
              [                                                   ]
              [i + 1      3       0.414634146341*i + 2.26829268293]
              ,
              [1  i                 0                ]
              [                                      ]
              [0  1  0.19512195122*i + 0.243902439024]
              [                                      ]
              [0  0                 1                ]
              ,
              [3 2 3]}
     
     
     
     first lu * second lu;
     
       [  1      i       0   ]
       [                     ]
       [  4      5      2.0  ]
       [                     ]
       [i + 1  i + 2  i + 3.0]
     
     
     
     convert(P,third lu);
     
       [  1      i      0  ]
       [                   ]
       [  4      5      2  ]
       [                   ]
       [i + 1  i + 2  i + 3]
     
     ____________________________________________________________

   Related functions: [*note cholesky::.] .


File: ..\util\r37,  Node: make_identity,  Next: matrix_augment,  Prev: lu_decom,  Up: Linear Algebra package section

   MAKE_IDENTITY                    operator

syntax:

   MAKE_IDENTITY (<square_size>)

   <square_size> :- a positive integer.

   MAKE_IDENTITY creates the identity matrix of dimension <square_size>.

examples:

     ____________________________________________________________
     
     
     make_identity(4);
     
       [1  0  0  0]
       [          ]
       [0  1  0  0]
       [          ]
       [0  0  1  0]
       [          ]
       [0  0  0  1]
     
     ____________________________________________________________
   Related functions: [*note diagonal::.] .


File: ..\util\r37,  Node: matrix_augment,  Next: matrixp,  Prev: make_identity,  Up: Linear Algebra package section

   MATRIX_AUGMENT                    operator

   Matrix augment, matrix stack:

syntax:

   MATRIX_AUGMENT <matrix_list>

   (If you are feeling lazy then the braces can be omitted.)

   <matrix_list> :- matrices.

   MATRIX_AUGMENT sticks the matrices in <matrix_list> together
horizontally.

   MATRIX_STACK sticks the matrices in <matrix_list> together
vertically.

examples:

     ____________________________________________________________
     
     
     matrix_augment({A,A});
     
       [1  2  3  1  2  3]
       [                ]
       [4  5  6  4  5  6]
       [                ]
       [7  8  9  7  8  9]
     
     
     
     matrix_stack(A,A);
     
       [1  2  3]
       [       ]
       [4  5  6]
       [       ]
       [7  8  9]
       [       ]
       [1  2  3]
       [       ]
       [4  5  6]
       [       ]
       [7  8  9]
     
     ____________________________________________________________
   Related functions: [*note augment_columns::.] , [*note
stack_rows::.] , [*note sub_matrix::.] .


File: ..\util\r37,  Node: matrixp,  Next: matrix_stack,  Prev: matrix_augment,  Up: Linear Algebra package section

   MATRIXP                    operator

syntax:

   MATRIXP (<test_input>)

   <test_input> :- anything you like.

   MATRIXP is a boolean function that returns t if the input is a
matrix and nil otherwise.

examples:

     ____________________________________________________________
     
     
     matrixp A;
     
       t
     
     
     matrixp(doodlesackbanana);
     
       nil
     
     ____________________________________________________________
   Related functions: [*note squarep::.] , [*note symmetricp::.] .


File: ..\util\r37,  Node: matrix_stack,  Next: minor,  Prev: matrixp,  Up: Linear Algebra package section

   MATRIX_STACK                    operator

   see: [*note matrix_augment::.] .


File: ..\util\r37,  Node: minor,  Next: mult_columns,  Prev: matrix_stack,  Up: Linear Algebra package section

   MINOR                    operator

syntax:

   MINOR (<matrix>,<r>,<c>)

   <matrix> :- a [*note MATRIX::.] .  <r>,<c> :- positive integers.

   MINOR computes the (<r>,<c>)'th minor of <matrix>.  This is created
by removing the <r>'th row and the <c>'th column from <matrix>.

examples:

     ____________________________________________________________
     
     
     minor(A,1,3);
     
       [4  5]
       [    ]
       [7  8]
     
     ____________________________________________________________
   Related functions: [*note remove_columns::.] , [*note
remove_rows::.] .


File: ..\util\r37,  Node: mult_columns,  Next: mult_rows,  Prev: minor,  Up: Linear Algebra package section

   MULT_COLUMNS                    operator

   Mult columns, mult rows:

syntax:

   MULT_COLUMNS (<matrix>,<column_list>,<expr>)

   <matrix> :- a [*note MATRIX::.] .

   <column_list> :- a positive integer or a list of positive  integers.

   <expr> :- an algebraic expression.

   MULT_COLUMNS returns a copy of <matrix> in which the columns
specified in <column_list> have been multiplied by <expr>.

   MULT_ROWS performs the same task on the rows of <matrix>.

examples:

     ____________________________________________________________
     
     
     mult_columns(A,{1,3},x);
     
       [ x   2  3*x]
       [           ]
       [4*x  5  6*x]
       [           ]
       [7*x  8  9*x]
     
     
     
     mult_rows(A,2,10);
     
       [1   2   3 ]
       [          ]
       [40  50  60]
       [          ]
       [7   8   9 ]
     
     ____________________________________________________________
   Related functions: [*note add_to_columns::.] , [*note
add_to_rows::.] .


File: ..\util\r37,  Node: mult_rows,  Next: pivot,  Prev: mult_columns,  Up: Linear Algebra package section

   MULT_ROWS                    operator

   see: [*note mult_columns::.] .


File: ..\util\r37,  Node: pivot,  Next: pseudo_inverse,  Prev: mult_rows,  Up: Linear Algebra package section

   PIVOT                    operator

syntax:

   PIVOT (<matrix>,<r>,<c>)

   <matrix> :- a matrix.

   <r>,<c> :- positive integers such that <matrix>(<r>,  <c>) neq 0.

   PIVOT pivots <matrix> about it's (<r>,<c>)'th entry.

   To do this, multiples of the <r>'th row are added to every other row
in the matrix.

   This means that the <c>'th column will be 0 except for the
(<r>,<c>)'th entry.

examples:

     ____________________________________________________________
     
     
     pivot(A,2,3);
     
       [      - 1    ]
       [-1  ------  0]
       [      2      ]
       [             ]
       [4     5     6]
       [             ]
       [      1      ]
       [1    ---    0]
       [      2      ]
     
     ____________________________________________________________
   Related functions: [*note rows_pivot::.] .


File: ..\util\r37,  Node: pseudo_inverse,  Next: random_matrix,  Prev: pivot,  Up: Linear Algebra package section

   PSEUDO_INVERSE                    operator

syntax:

   PSEUDO_INVERSE (<matrix>)

   <matrix> :- a [*note MATRIX::.] .

   PSEUDO_INVERSE , also known as the Moore-Penrose inverse, computes
the pseudo inverse of <matrix>.

   Given the singular value decomposition of <matrix>, i.e: A =
U*P*V^T, then the pseudo inverse A^-1 is defined by A^-1 = V^T*P^-1*U.

   Thus <matrix> * pseudo_inverse(A) = Id.  (Id is the identity matrix).

examples:

     ____________________________________________________________
     
     
     R := mat((1,2,3,4),(9,8,7,6));
     
            [1  2  3  4]
       r := [          ]
            [9  8  7  6]
     
     
     
     on rounded;
     
     pseudo_inverse(R);
     
       [ - 0.199999999996      0.100000000013   ]
       [                                        ]
       [ - 0.0499999999988    0.0500000000037   ]
       [                                        ]
       [ 0.0999999999982     - 5.57825497203e-12]
       [                                        ]
       [  0.249999999995      - 0.0500000000148 ]
     
     ____________________________________________________________
   Related functions: [*note svd::.] .


File: ..\util\r37,  Node: random_matrix,  Next: remove_columns,  Prev: pseudo_inverse,  Up: Linear Algebra package section

   RANDOM_MATRIX                    operator

syntax:

   RANDOM_MATRIX (<r>,<c>,<limit>)

   <r>,<c>,<limit> :- positive integers.

   RANDOM_MATRIX creates an <r> by <c> matrix with random entries in
the range -limit < entry < limit.

   Switches:

   IMAGINARY :- if on then matrix entries are x+i*y where -limit < x,y
< <limit>.

   NOT_NEGATIVE :- if on then 0 < entry < <limit>. In the imaginary
case we have 0 < x,y < <limit>.

   ONLY_INTEGER :- if on then each entry is an integer. In the imaginary
                case x and y are integers.

   SYMMETRIC :- if on then the matrix is symmetric.

   UPPER_MATRIX :- if on then the matrix is upper triangular.

   LOWER_MATRIX :- if on then the matrix is lower triangular.

examples:

     ____________________________________________________________
     
     
     on rounded;
     
     random_matrix(3,3,10);
     
       [ - 8.11911717343    - 5.71677292768   0.620580830035 ]
       [                                                     ]
       [ - 0.032596262422    7.1655452861     5.86742633837  ]
       [                                                     ]
       [ - 9.37155438255    - 7.55636708637   - 8.88618627557]
     
     
     
     on only_integer, not_negative, upper_matrix, imaginary;
     
     random_matrix(4,4,10);
     
       [70*i + 15  28*i + 8   2*i + 79   27*i + 44]
       [                                          ]
       [    0      46*i + 95  9*i + 63   95*i + 50]
       [                                          ]
       [    0          0      31*i + 75  14*i + 65]
       [                                          ]
       [    0          0          0      5*i + 52 ]
     
     ____________________________________________________________


File: ..\util\r37,  Node: remove_columns,  Next: remove_rows,  Prev: random_matrix,  Up: Linear Algebra package section

   REMOVE_COLUMNS                    operator

   Remove columns, remove rows:

syntax:

   REMOVE_COLUMNS (<matrix>,<column_list>)

   <matrix> :- a [*note MATRIX::.] .  <column_list> :- either a
positive integer or a list of positive  integers.

   REMOVE_COLUMNS removes the columns specified in <column_list> from
<matrix>.

   REMOVE_ROWS performs the same task on the rows of <matrix>.

examples:

     ____________________________________________________________
     
     
     remove_columns(A,2);
     
       [1  3]
       [    ]
       [4  6]
       [    ]
       [7  9]
     
     
     
     remove_rows(A,{1,3});
     
       [4  5  6]
     
     ____________________________________________________________
   Related functions: [*note minor::.] .


File: ..\util\r37,  Node: remove_rows,  Next: row_dim,  Prev: remove_columns,  Up: Linear Algebra package section

   REMOVE_ROWS                    operator

   see: [*note remove_columns::.] .


File: ..\util\r37,  Node: row_dim,  Next: rows_pivot,  Prev: remove_rows,  Up: Linear Algebra package section

   ROW_DIM                    operator

   see: [*note column_dim::.] .


File: ..\util\r37,  Node: rows_pivot,  Next: simplex,  Prev: row_dim,  Up: Linear Algebra package section

   ROWS_PIVOT                    operator

syntax:

   ROWS_PIVOT (<matrix>,<r>,<c>,<row_list>)

   <matrix> :- a namerefmatrix.

   <r>,<c> :- positive integers such that <matrix>(<r>,  <c>) neq 0.

   <row_list> :- positive integer or a list of positive integers.

   ROWS_PIVOT performs the same task as PIVOT but applies the pivot
only to the rows specified in <row_list>.

examples:

     ____________________________________________________________
     
     
     N := mat((1,2,3),(4,5,6),(7,8,9),(1,2,3),(4,5,6));
     
     
            [1  2  3]
            [       ]
            [4  5  6]
            [       ]
       n := [7  8  9]
            [       ]
            [1  2  3]
            [       ]
            [4  5  6]
     
     
     
     rows_pivot(N,2,3,{4,5});
     
       [1     2     3]
       [             ]
       [4     5     6]
       [             ]
       [7     8     9]
       [             ]
       [      - 1    ]
       [-1  ------  0]
       [      2      ]
       [             ]
       [0     0     0]
     
     ____________________________________________________________
   Related functions: [*note pivot::.] .


File: ..\util\r37,  Node: simplex,  Next: squarep,  Prev: rows_pivot,  Up: Linear Algebra package section

   SIMPLEX                    operator

syntax:

   SIMPLEX (<max/min>,<objective function>, <linear inequalities>)

   <max/min> :- either max or min (signifying maximize and
           minimize).

   <objective function> :- the function you are maximizing or
              minimizing.

   <linear inequalities> :- the constraint inequalities. Each one must
be of the form sum of variables (  <=,=,>=) number.

   SIMPLEX applies the revised simplex algorithm to find the
optimal(either maximum or minimum) value of the <objective function>
under the linear inequality constraints.

   It returns optimal value, values of variables at this optimal.

   The algorithm implies that all the variables are non-negative.

examples:

     ____________________________________________________________
     
     
      simplex(max,x+y,{x>=10,y>=20,x+y<=25});
     
     
        ***** Error in simplex: Problem has no feasible solution
     
     
     
     simplex(max,10x+5y+5.5z,{5x+3z<=200,x+0.1y+0.5z<=12,
     0.1x+0.2y+0.3z<=9, 30x+10y+50z<=1500});
     
     
       {525.0,{x=40.0,y=25.0,z=0}}
     
     ____________________________________________________________


File: ..\util\r37,  Node: squarep,  Next: stack_rows,  Prev: simplex,  Up: Linear Algebra package section

   SQUAREP                    operator

syntax:

   SQUAREP (<matrix>)

   <matrix> :- a [*note MATRIX::.] .

   SQUAREP is a predicate that returns t if the <matrix> is square and
nil otherwise.

examples:

     ____________________________________________________________
     
     
     squarep(mat((1,3,5)));
     
       nil
     
     
     squarep(A);
     t
     ____________________________________________________________
   Related functions: [*note matrixp::.] , [*note symmetricp::.] .


File: ..\util\r37,  Node: stack_rows,  Next: sub_matrix,  Prev: squarep,  Up: Linear Algebra package section

   STACK_ROWS                    operator

   see: [*note augment_columns::.] .


File: ..\util\r37,  Node: sub_matrix,  Next: svd,  Prev: stack_rows,  Up: Linear Algebra package section

   SUB_MATRIX                    operator

syntax:

   SUB_MATRIX (<matrix>,<row_list>,<column_list>)

   <matrix> :- a matrix.  <row_list>, <column_list> :- either a
positive integer or a  list of positive integers.

   namesub_matrix produces the matrix consisting of the intersection of
the rows specified in <row_list> and the columns specified in
<column_list>.

examples:

     ____________________________________________________________
     
     
     sub_matrix(A,{1,3},{2,3});
     
       [2  3]
       [    ]
       [8  9]
     
     ____________________________________________________________
   Related functions: [*note augment_columns::.] , [*note
stack_rows::.] .


File: ..\util\r37,  Node: svd,  Next: swap_columns,  Prev: sub_matrix,  Up: Linear Algebra package section

   SVD                    operator

   Singular value decomposition:

syntax:

   SVD (<matrix>)

   <matrix> :- a [*note MATRIX::.] containing only numeric entries.

   SVD computes the singular value decomposition of <matrix>.

   It returns

   U,P,V

   where A = U*P*V^T

   and P = diag(sigma(1) ... sigma(n)).

   sigma(i) for i= 1 ... n are the singular values of <matrix>.

   n is the column dimension of <matrix>.

   The singular values of <matrix> are the non-negative square roots of
the eigenvalues of A^T*A.

   U and V are such that U*U^T = V*V^T = V^T*V = Id.  Id is the
identity matrix.

examples:

     ____________________________________________________________
     
     
     Q := mat((1,3),(-4,3));
     
            [1   3]
       q := [     ]
            [-4  3]
     
     
     
     on rounded;
     
     svd(Q);
     
       {
        [ 0.289784137735    0.957092029805]
        [                                 ]
        [ - 0.957092029805  0.289784137735]
        ,
        [5.1491628629       0      ]
        [                          ]
        [     0        2.9130948854]
        ,
        [ - 0.687215403194   0.726453707825  ]
        [                                    ]
        [ - 0.726453707825   - 0.687215403194]
       }
     
     ____________________________________________________________


File: ..\util\r37,  Node: swap_columns,  Next: swap_entries,  Prev: svd,  Up: Linear Algebra package section

   SWAP_COLUMNS                    operator

   Swap columns, swap rows:

syntax:

   SWAP_COLUMNS (<matrix>,<c1>,<c2>)

   <matrix> :- a [*note MATRIX::.] .

   <c1>,<c1> :- positive integers.

   SWAP_COLUMNS swaps column <c1> of <matrix> with column <c2>.

   SWAP_ROWS performs the same task on two rows of <matrix>.

examples:

     ____________________________________________________________
     
     
     swap_columns(A,2,3);
     
       [1  3  2]
       [       ]
       [4  6  5]
       [       ]
       [7  9  8]
     
     
     
     swap_rows(A,1,3);
     
       [7  8  9]
       [       ]
       [4  5  6]
       [       ]
       [1  2  3]
     
     ____________________________________________________________
   Related functions: [*note swap_entries::.] .


File: ..\util\r37,  Node: swap_entries,  Next: swap_rows,  Prev: swap_columns,  Up: Linear Algebra package section

   SWAP_ENTRIES                    operator

syntax:

   SWAP_ENTRIES (<matrix>,<r1>,<c1>,<r2>, <c2>)

   <matrix> :- a [*note MATRIX::.] .

   <r1>,<c1>,<r2>,<c2> :- positive integers.

   SWAP_ENTRIES swaps <matrix>(<r1>,<c1>) with <matrix>(<r2>,<c2>).

examples:

     ____________________________________________________________
     
     
     swap_entries(A,{1,1},{3,3});
     
       [9  2  3]
       [       ]
       [4  5  6]
       [       ]
       [7  8  1]
     
     ____________________________________________________________
   Related functions: [*note swap_columns::.] , [*note swap_rows::.] .


File: ..\util\r37,  Node: swap_rows,  Next: symmetricp,  Prev: swap_entries,  Up: Linear Algebra package section

   SWAP_ROWS                    operator

   see: [*note swap_columns::.] .


File: ..\util\r37,  Node: symmetricp,  Next: toeplitz,  Prev: swap_rows,  Up: Linear Algebra package section

   SYMMETRICP                    operator

syntax:

   SYMMETRICP (<matrix>)

   <matrix> :- a [*note MATRIX::.] .

   SYMMETRICP is a predicate that returns t if the matrix is symmetric
and nil otherwise.

examples:

     ____________________________________________________________
     
     
     symmetricp(make_identity(11));
     
       t
     
     
     symmetricp(A);
     
       nil
     
     ____________________________________________________________
   Related functions: [*note matrixp::.] , [*note squarep::.] .


File: ..\util\r37,  Node: toeplitz,  Next: vandermonde,  Prev: symmetricp,  Up: Linear Algebra package section

   TOEPLITZ                    operator

syntax:

   TOEPLITZ (<expr_list>)

   (If you are feeling lazy then the braces can be omitted.)

   <expr_list> :- list of algebraic expressions.

   TOEPLITZ creates the toeplitz matrix from the <expr_list>.

   This is a square symmetric matrix in which the first expression is
placed on the diagonal and the i'th expression is placed on the (i-1)'th
sub and super diagonals.

   It has dimension n where n is the number of expressions.

examples:

     ____________________________________________________________
     
     
     toeplitz({w,x,y,z});
     
       [w  x  y  z]
       [          ]
       [x  w  x  y]
       [          ]
       [y  x  w  x]
       [          ]
       [z  y  x  w]
     
     ____________________________________________________________


File: ..\util\r37,  Node: vandermonde,  Prev: toeplitz,  Up: Linear Algebra package section

   VANDERMONDE                    operator

syntax:

   VANDERMONDE (<expr_list>)

   (If you are feeling lazy then the braces can be omitted.)

   <expr_list> :- list of algebraic expressions.

   VANDERMONDE creates the vandermonde matrix from the <expr_list>.

   This is the square matrix in which the (i,j)'th entry is
<expr_list>(i)^(j-1).

   It has dimension n where n is the number of expressions.

examples:

     ____________________________________________________________
     
     vandermonde({x,2*y,3*z});
     
     
       [          2 ]
       [1   x    x  ]
       [            ]
       [           2]
       [1  2*y  4*y ]
       [            ]
       [           2]
       [1  3*z  9*z ]
     
     ____________________________________________________________


File: ..\util\r37,  Node: Linear Algebra package section,  Next: Matrix Normal Forms section,  Prev: Gnuplot package section,  Up: Top

   Linear Algebra package section

* Menu:

* Linear Algebra package::  introduction
* fast_la::                 switch
* add_columns::             operator
* add_rows::                operator
* add_to_columns::          operator
* add_to_rows::             operator
* augment_columns::         operator
* band_matrix::             operator
* block_matrix::            operator
* char_matrix::             operator
* char_poly::               operator
* cholesky::                operator
* coeff_matrix::            operator
* column_dim::              operator
* companion::               operator
* copy_into::               operator
* diagonal::                operator
* extend::                  operator
* find_companion::          operator
* get_columns::             operator
* get_rows::                operator
* gram_schmidt::            operator
* hermitian_tp::            operator
* hessian::                 operator
* hilbert::                 operator
* jacobian::                operator
* jordan_block::            operator
* lu_decom::                operator
* make_identity::           operator
* matrix_augment::          operator
* matrixp::                 operator
* matrix_stack::            operator
* minor::                   operator
* mult_columns::            operator
* mult_rows::               operator
* pivot::                   operator
* pseudo_inverse::          operator
* random_matrix::           operator
* remove_columns::          operator
* remove_rows::             operator
* row_dim::                 operator
* rows_pivot::              operator
* simplex::                 operator
* squarep::                 operator
* stack_rows::              operator
* sub_matrix::              operator
* svd::                     operator
* swap_columns::            operator
* swap_entries::            operator
* swap_rows::               operator
* symmetricp::              operator
* toeplitz::                operator
* vandermonde::             operator


File: ..\util\r37,  Node: Smithex,  Next: Smithex_int,  Up: Matrix Normal Forms section

   SMITHEX                    operator

   The operator SMITHEX computes the Smith normal form S of a [*note
MATRIX::.]  A (say). It returns S,P,P^-1 where P*S*P^-1 = A.

syntax:

   SMITHEX (<matrix>,<variable>)

   <matrix> :- a rectangular [*note MATRIX::.] of univariate
polynomials in  <variable>.  <variable> :- the variable.

examples:

     ____________________________________________________________
     
      a := mat((x,x+1),(0,3*x^2));
     
             [x  x + 1]
             [        ]
        a := [      2 ]
             [0  3*x  ]
     
     
     
      smithex(a,x);
     
          [1  0 ]    [1    0]    [x   x + 1]
       {  [     ],   [      ],   [         ]  }
          [    3]    [   2  ]    [         ]
          [0  x ]    [3*x  1]    [-3    -3 ]
     
     ____________________________________________________________


File: ..\util\r37,  Node: Smithex_int,  Next: Frobenius,  Prev: Smithex,  Up: Matrix Normal Forms section

   SMITHEX_INT                    operator

   The operator SMITHEX_INT performs the same task as SMITHEX but on
matrices containing only integer entries. Namely, SMITHEX_INT  returns
S,P,P^-1 where S is the smith normal form of the input [*note
MATRIX::.] (A say), and P*S*P^-1 = A.

syntax:

   SMITHEX_INT (<matrix>)

   <matrix> :- a rectangular [*note MATRIX::.] of integer entries.

examples:

     ____________________________________________________________
     
      a := mat((9,-36,30),(-36,192,-180),(30,-180,180));
     
     
            [ 9   -36    30 ]
            [               ]
       a := [-36  192   -180]
            [               ]
            [30   -180  180 ]
     
     
     
      smithex_int(a);
     
         [3  0   0 ]    [-17  -5   -4 ]    [1   -24  30 ]
         [         ]    [             ]    [            ]
       { [0  12  0 ],   [64   19   15 ],   [-1  25   -30] }
         [         ]    [             ]    [            ]
         [0  0   60]    [-50  -15  -12]    [0   -1    1 ]
     
     ____________________________________________________________


File: ..\util\r37,  Node: Frobenius,  Next: Ratjordan,  Prev: Smithex_int,  Up: Matrix Normal Forms section

   FROBENIUS                    operator

   The operator FROBENIUS computes the FROBENIUS normal form F of a
[*note MATRIX::.]  (A say). It returns F,P,P^-1 where P*F*P^-1 = A.

syntax:

   FROBENIUS (<matrix>)

   <matrix> :- a square [*note MATRIX::.] .

   Field Extensions:

   By default, calculations are performed in the rational numbers. To
extend this field the [*note ARNUM::.] package can be used. The package
must first be loaded by load_package arnum;. The field can now be
extended by using the defpoly command. For example, defpoly sqrt2**2-2;
will extend the field to include the square root of 2 (now defined by
sqrt2).

   Modular Arithmetic:

   FROBENIUS can also be calculated in a modular base. To do this first
type on modular;. Then setmod p; (where p is a prime) will set the
modular base of calculation to p. By further typing on balanced_mod the
answer will appear using a symmetric modular representation. See [*note
Ratjordan::.]  for an example.

examples:

     ____________________________________________________________
     
      a := mat((x,x^2),(3,5*x));
     
            [    2 ]
            [x  x  ]
       a := [      ]
            [3  5*x]
     
     
      frobenius(a);
     
          [         2]    [1  x]    [       - x ]
       {  [0   - 2*x ],   [    ],   [1     -----]  }
          [          ]    [0  3]    [        3  ]
          [1    6*x  ]              [           ]
                                    [        1  ]
                                    [0      --- ]
                                    [        3  ]
     
     
      load_package arnum;
     
      defpoly sqrt2**2-2;
     
      a := mat((sqrt2,5),(7*sqrt2,sqrt2));
     
     
            [ sqrt2     5  ]
       a := [              ]
            [7*sqrt2  sqrt2]
     
     
     
      frobenius(a);
     
         [0  35*sqrt2 - 2]    [1   sqrt2 ]    [           1  ]
       { [               ],   [          ],   [1       - --- ]  }
         [1    2*sqrt2   ]    [1  7*sqrt2]    [           7  ]
                                              [              ]
                                              [     1        ]
                                              [0   ----*sqrt2]
                                              [     14       ]
     
     ____________________________________________________________


File: ..\util\r37,  Node: Ratjordan,  Next: Jordansymbolic,  Prev: Frobenius,  Up: Matrix Normal Forms section

   RATJORDAN                    operator

   The operator RATJORDAN computes the rational Jordan normal form R of
a [*note MATRIX::.] (A say). It returns R,P,P^-1 where P*R*P^-1 = A.

syntax:

   RATJORDAN (<matrix>)

   <matrix> :- a square [*note MATRIX::.] .

   Field Extensions:

   By default, calculations are performed in the rational numbers. To
extend this field the ARNUM package can be used. The package must first
be loaded by load_package arnum;. The field can now be extended by
using the defpoly command. For example, defpoly sqrt2**2-2; will extend
the field to include the square root of 2 (now defined by sqrt2).  See
[*note Frobenius::.] for an example.

   Modular Arithmetic:

   RATJORDAN can also be calculated in a modular base. To do this first
type on modular;. Then setmod p; (where p is a prime) will set the
modular base of calculation to p. By further typing on balanced_mod the
answer will appear using a symmetric modular representation.

examples:

     ____________________________________________________________
     
      a := mat((5,4*x),(2,x^2));
     
            [5  4*x]
            [      ]
       a := [    2 ]
            [2  x  ]
     
     
     
      ratjordan(a);
     
         [0  x*( - 5*x + 8)]   [1  5]    [        -5 ]
       { [                 ],  [    ],   [1     -----] }
         [        2        ]   [0  2]    [        2  ]
         [1      x  + 5    ]             [           ]
                                         [        1  ]
                                         [0     -----]
                                         [        2  ]
     
     
      on modular;
     
      setmod 23;
     
      a := mat((12,34),(56,78));
     
            [12  11]
       a := [      ]
            [10  9 ]
     
     
     
      ratjordan(a);
     
         [15  0]   [16  8]   [1  21]
       { [     ],  [     ],  [     ]  }
         [0   6]   [19  4]   [1  4 ]
     
     
     
      on balanced_mod;
     
      ratjordan(a);
     
         [- 8  0]   [ - 7  8]   [1  - 2]
       { [      ],  [       ],  [      ]  }
         [ 0   6]   [ - 4  4]   [1   4 ]
     
     ____________________________________________________________


File: ..\util\r37,  Node: Jordansymbolic,  Next: Jordan,  Prev: Ratjordan,  Up: Matrix Normal Forms section

   JORDANSYMBOLIC                    operator

   The operator JORDANSYMBOLIC computes the Jordan normal form J of a
[*note MATRIX::.] (A say). It returns J,L,P,P^-1 where P*J*P^-1 = A. L
= ll,mm where mm is a name and ll is a list of irreducible factors of
p(mm).

syntax:

   JORDANSYMBOLIC (<matrix>)

   <matrix> :- a square [*note MATRIX::.] .

   Field Extensions:

   By default, calculations are performed in the rational numbers. To
extend this field the [*note ARNUM::.] package can be used. The package
must first be loaded by load_package arnum;. The field can now be
extended by using the defpoly command. For example, defpoly sqrt2**2-2;
will extend the field to include the square root of 2 (now defined by
sqrt2).  See [*note Frobenius::.] for an example.

   Modular Arithmetic:

   JORDANSYMBOLIC can also be calculated in a modular base. To do this
first type on modular;. Then setmod p; (where p is a prime) will set
the modular base of calculation to p. By further typing on balanced_mod
the answer will appear using a symmetric modular representation. See
[*note Ratjordan::.]  for an example.

examples:

     ____________________________________________________________
     
     
      a := mat((1,y),(2,5*y));
     
            [1   y ]
       a := [      ]
            [2  5*y]
     
     
     
      jordansymbolic(a);
     
       {
        [lambda11     0    ]
        [                  ]
        [   0      lambda12]
        ,
                2
        lambda  - 5*lambda*y - lambda + 3*y,lambda,
        [lambda11 - 5*y  lambda12 - 5*y]
        [                              ]
        [      2               2       ]
        ,
        [ 2*lambda11 - 5*y - 1    5*lambda11*y - lambda11 - y + 1 ]
        [----------------------  ---------------------------------]
        [       2                              2                  ]
        [   25*y  - 2*y + 1             2*(25*y  - 2*y + 1)       ]
        [                                                         ]
        [ 2*lambda12 - 5*y - 1    5*lambda12*y - lambda12 - y + 1 ]
        [----------------------  ---------------------------------]
        [       2                              2                  ]
        [   25*y  - 2*y + 1             2*(25*y  - 2*y + 1)       ]
        }
     
     ____________________________________________________________


File: ..\util\r37,  Node: Jordan,  Prev: Jordansymbolic,  Up: Matrix Normal Forms section

   JORDAN                    operator

   The operator JORDAN computes the Jordan normal form J of a [*note
MATRIX::.] (A say). It returns J,P,P^-1 where P*J*P^-1 = A.

syntax:

   JORDAN (<matrix>)

   <matrix> :- a square [*note MATRIX::.] .

   Field Extensions: By default, calculations are performed in the
rational numbers. To extend this field the ARNUM package can be used.
The package must first be loaded by load_package arnum;. The field can
now be extended by using the defpoly command. For example, defpoly
sqrt2**2-2; will extend the field to include the square root of 2 (now
defined by sqrt2).  See [*note Frobenius::.] for an example.

   Modular Arithmetic: JORDAN  can also be calculated in a modular
base. To do this first type on modular;. Then setmod p; (where p is a
prime) will set the modular base of calculation to p. By further typing
on balanced_mod the answer will appear using a symmetric modular
representation. See [*note Ratjordan::.]  for an example.

examples:

     ____________________________________________________________
     
     
      a := mat((1,x),(0,x));
     
            [1  x]
       a := [    ]
            [0  x]
     
     
     
      jordan(a);
     
       {
        [1  0]
        [    ]
        [0  x]
        ,
        [   1           x       ]
        [-------  --------------]
        [ x - 1     2           ]
        [          x  - 2*x + 1 ]
        [                       ]
        [               1       ]
        [   0        -------    ]
        [             x - 1     ]
        ,
        [x - 1   - x ]
        [            ]
        [  0    x - 1]
        }
     
     ____________________________________________________________


File: ..\util\r37,  Node: Matrix Normal Forms section,  Next: Miscellaneous Packages section,  Prev: Linear Algebra package section,  Up: Top

   Matrix Normal Forms section

* Menu:

* Smithex::                 operator
* Smithex_int::            operator
* Frobenius::               operator
* Ratjordan::               operator
* Jordansymbolic::          operator
* Jordan::                  operator


File: ..\util\r37,  Node: Miscellaneous Packages,  Next: ALGINT package,  Up: Miscellaneous Packages section

   MISCELLANEOUS PACKAGES                    introduction

   REDUCE includes a large number of packages that have been
contributed by users from various fields. Some of these, together with
their relevant commands, switches and so on (e.g., the NUMERIC
package), have been described elsewhere. This section describes those
packages for which no separate help material exists. Each has its own
switches, commands, and operators, and some redefine special characters
to aid in their notation. However, the brief descriptions given here do
not include all such information. Readers are referred to the general
package documentation in this case, which can be found, along with the
source code, under the subdirectories DOC and SRC in the REDUCE
directory. The [*note LOAD_PACKAGE::.] command is used to load the
files you wish into your system. There will be a short delay while the
package is loaded. A package cannot be unloaded. Once it is in your
system, it stays there until you end the session. Each package also has
a test file, which you will find under its name in the $REDUCE/XMPL
directory.

   Finally, it should be mentioned that such user-contributed packages
are unsupported; any questions or problems should be directed to their
authors.


File: ..\util\r37,  Node: ALGINT package,  Next: APPLYSYM,  Prev: Miscellaneous Packages,  Up: Miscellaneous Packages section

   ALGINT                    package

   Author: James H. Davenport

   The ALGINT package provides indefinite integration of square roots.
This package, which is an extension of the basic integration package
distributed with REDUCE, will analytically integrate a wide range of
expressions involving square roots. The [*note ALGINT::.] switch
provides for the use of the facilities given by the package, and is
automatically turned on when the package is loaded. If you want to
return to the standard integration algorithms, turn [*note ALGINT::.]
off. An error message is given if you try to turn the [*note ALGINT::.]
switch on when its package is not loaded.


File: ..\util\r37,  Node: APPLYSYM,  Next: ARNUM,  Prev: ALGINT package,  Up: Miscellaneous Packages section

   APPLYSYM                    package

   Author: Thomas Wolf

   This package provides programs APPLYSYM, QUASILINPDE and DETRAFO for
computing with infinitesimal symmetries of differential equations.


File: ..\util\r37,  Node: ARNUM,  Next: ASSIST,  Prev: APPLYSYM,  Up: Miscellaneous Packages section

   ARNUM                    package

   Author: Eberhard Schruefer

   This package provides facilities for handling algebraic numbers as
polynomial coefficients in REDUCE calculations. It includes facilities
for introducing indeterminates to represent algebraic numbers, for
calculating splitting fields, and for factoring and finding greatest
common divisors in such domains.


File: ..\util\r37,  Node: ASSIST,  Next: AVECTOR,  Prev: ARNUM,  Up: Miscellaneous Packages section

   ASSIST                    package

   Author: Hubert Caprasse

   ASSIST contains a large number of additional general purpose
functions that allow a user to better adapt REDUCE to various
calculational strategies and to make the programming task more
straightforward and more efficient.


File: ..\util\r37,  Node: AVECTOR,  Next: BOOLEAN,  Prev: ASSIST,  Up: Miscellaneous Packages section

   AVECTOR                    package

   Author: David Harper

   This package provides REDUCE with the ability to perform vector
algebra using the same notation as scalar algebra. The basic algebraic
operations are supported, as are differentiation and integration of
vectors with respect to scalar variables, cross product and dot
product, component manipulation and application of scalar functions
(e.g. cosine) to a vector to yield a vector result.


File: ..\util\r37,  Node: BOOLEAN,  Next: CALI,  Prev: AVECTOR,  Up: Miscellaneous Packages section

   BOOLEAN                    package

   Author: Herbert Melenk

   This package supports the computation with boolean expressions in the
propositional calculus. The data objects are composed from algebraic
expressions connected by the infix boolean operators and, or,  implies,
equiv, and the unary prefix operator not.   Boolean allows you to
simplify expressions built from these operators, and to test properties
like equivalence, subset property etc.


File: ..\util\r37,  Node: CALI,  Next: CAMAL,  Prev: BOOLEAN,  Up: Miscellaneous Packages section

   CALI                    package

   Author: Hans-Gert Gr"abe

   This package contains algorithms for computations in commutative
algebra closely related to the Groebner algorithm for ideals and
modules. Its heart is a new implementation of the Groebner algorithm
that also allows for the computation of syzygies. This implementation
is also applicable to submodules of free modules with generators
represented as rows of a matrix.


File: ..\util\r37,  Node: CAMAL,  Next: CHANGEVR,  Prev: CALI,  Up: Miscellaneous Packages section

   CAMAL                    package

   Author: John P. Fitch

   This packages implements in REDUCE the Fourier transform procedures
of the CAMAL package for celestial mechanics.


File: ..\util\r37,  Node: CHANGEVR,  Next: COMPACT,  Prev: CAMAL,  Up: Miscellaneous Packages section

   CHANGEVR                    package

   Author: G. Ucoluk

   This package provides facilities for changing the independent
variables in a differential equation. It is basically the application
of the chain rule.


File: ..\util\r37,  Node: COMPACT,  Next: CRACK,  Prev: CHANGEVR,  Up: Miscellaneous Packages section

   COMPACT                    package

   Author: Anthony C. Hearn

   COMPACT is a package of functions for the reduction of a polynomial
in the presence of side relations. COMPACT applies the side relations
to the polynomial so that an equivalent expression results with as few
terms as possible. For example, the evaluation of

     ____________________________________________________________
     
          compact(s*(1-sin x^2)+c*(1-cos x^2)+sin x^2+cos x^2,
                  {cos x^2+sin x^2=1});
     
     ____________________________________________________________
   yields the result
     ____________________________________________________________
     
     
                   2           2
             SIN(X) *C + COS(X) *S + 1
     ____________________________________________________________

   The first argument to the operator COMPACT is the expression and the
second is a list of side relations that can be equations or simple
expressions (implicitly equated to zero). The kernels in the side
relations may also be free variables with the same meaning as in rules,
e.g.
     ____________________________________________________________
     
          sin_cos_identity :=  {cos ~w^2+sin ~w^2=1}$
          compact(u,in_cos_identity);
     ____________________________________________________________

   Also the full rule syntax with the replacement operator is allowed
here.


File: ..\util\r37,  Node: CRACK,  Next: CVIT,  Prev: COMPACT,  Up: Miscellaneous Packages section

   CRACK                    package

   Authors: Andreas Brand, Thomas Wolf

   CRACK is a package for solving overdetermined systems of partial or
ordinary differential equations (PDEs, ODEs). Examples of programs which
make use of CRACK for investigating ODEs (finding symmetries, first
integrals, an equivalent Lagrangian or a "differential factorization")
are included.


File: ..\util\r37,  Node: CVIT,  Next: DEFINT,  Prev: CRACK,  Up: Miscellaneous Packages section

   CVIT                    package

   Authors: V.Ilyin, A.Kryukov, A.Rodionov, A.Taranov

   This package provides an alternative method for computing traces of
Dirac gamma matrices, based on an algorithm by Cvitanovich that treats
gamma matrices as 3-j symbols.


File: ..\util\r37,  Node: DEFINT,  Next: DESIR,  Prev: CVIT,  Up: Miscellaneous Packages section

   DEFINT                    package

   Authors: Kerry Gaskell, Stanley M. Kameny, Winfried Neun

   This package finds the definite integral of an expression in a stated
interval. It uses several techniques, including an innovative approach
based on the Meijer G-function, and contour integration.


File: ..\util\r37,  Node: DESIR,  Next: DFPART,  Prev: DEFINT,  Up: Miscellaneous Packages section

   DESIR                    package

   Authors: C. Dicrescenzo, F. Richard-Jung, E. Tournier

   This package enables the basis of formal solutions to be computed
for an ordinary homogeneous differential equation with polynomial
coefficients over Q of any order, in the neighborhood of zero (regular
or irregular singular point, or ordinary point).


File: ..\util\r37,  Node: DFPART,  Next: DUMMY,  Prev: DESIR,  Up: Miscellaneous Packages section

   DFPART                    package

   Author: Herbert Melenk

   This package supports computations with total and partial
derivatives of formal function objects. Such computations can be useful
in the context of differential equations or power series expansions.


File: ..\util\r37,  Node: DUMMY,  Next: EXCALC,  Prev: DFPART,  Up: Miscellaneous Packages section

   DUMMY                    package

   Author: Alain Dresse

   This package allows a user to find the canonical form of expressions
involving dummy variables. In that way, the simplification of
polynomial expressions can be fully done. The indeterminates are general
operator objects endowed with as few properties as possible. In that way
the package may be used in a large spectrum of applications.


File: ..\util\r37,  Node: EXCALC,  Next: FPS,  Prev: DUMMY,  Up: Miscellaneous Packages section

   EXCALC                    package

   Author: Eberhard Schruefer

   The EXCALC package is designed for easy use by all who are familiar
with the calculus of Modern Differential Geometry. The program is
currently able to handle scalar-valued exterior forms, vectors and
operations between them, as well as non-scalar valued forms (indexed
forms). It is thus an ideal tool for studying differential equations,
doing calculations in general relativity and field theories, or doing
simple things such as calculating the Laplacian of a tensor field for
an arbitrary given frame.


File: ..\util\r37,  Node: FPS,  Next: FIDE,  Prev: EXCALC,  Up: Miscellaneous Packages section

   FPS                    package

   Authors: Wolfram Koepf, Winfried Neun

   This package can expand a specific class of functions into their
corresponding Laurent-Puiseux series.


File: ..\util\r37,  Node: FIDE,  Next: GENTRAN,  Prev: FPS,  Up: Miscellaneous Packages section

   FIDE                    package

   Author: Richard Liska

   This package performs automation of the process of numerically
solving partial differential equations systems (PDES) by means of
computer algebra. For PDES solving, the finite difference method is
applied.  The computer algebra system REDUCE and the numerical
programming language FORTRAN are used in the presented methodology. The
main aim of this methodology is to speed up the process of preparing
numerical programs for solving PDES. This process is quite often,
especially for complicated systems, a tedious and time consuming task.


File: ..\util\r37,  Node: GENTRAN,  Next: IDEALS,  Prev: FIDE,  Up: Miscellaneous Packages section

   GENTRAN                    package

   Author: Barbara L. Gates

   This package is an automatic code GENerator and TRANslator. It
constructs complete numerical programs based on sets of algorithmic
specifications and symbolic expressions. Formatted FORTRAN, RATFOR or C
code can be generated through a series of interactive commands or under
the control of a template processing routine. Large expressions can be
automatically segmented into subexpressions of manageable size, and a
special file-handling mechanism maintains stacks of open I/O channels
to allow output to be sent to any number of files simultaneously and to
facilitate recursive invocation of the whole code generation process.


File: ..\util\r37,  Node: IDEALS,  Next: INEQ,  Prev: GENTRAN,  Up: Miscellaneous Packages section

   IDEALS                    package

   Author: Herbert Melenk

   This package implements the basic arithmetic for polynomial ideals by
exploiting the Groebner bases package of REDUCE. In order to save
computing time all intermediate Groebner bases are stored internally
such that time consuming repetitions are inhibited.


File: ..\util\r37,  Node: INEQ,  Next: INVBASE,  Prev: IDEALS,  Up: Miscellaneous Packages section

   INEQ                    package

   Author: Herbert Melenk

   This package supports the operator INEQ_SOLVE that tries to solves
single inequalities and sets of coupled inequalities.


File: ..\util\r37,  Node: INVBASE,  Next: LAPLACE,  Prev: INEQ,  Up: Miscellaneous Packages section

   INVBASE                    package

   Authors: A.Yu. Zharkov and Yu.A. Blinkov

   Involutive bases are a new tool for solving problems in connection
with multivariate polynomials, such as solving systems of polynomial
equations and analyzing polynomial ideals. An involutive basis of
polynomial ideal is nothing but a special form of a redundant Groebner
basis. The construction of involutive bases reduces the problem of
solving polynomial systems to simple linear algebra.


File: ..\util\r37,  Node: LAPLACE,  Next: LIE,  Prev: INVBASE,  Up: Miscellaneous Packages section

   LAPLACE                    package

   Authors: C. Kazasov, M. Spiridonova, V. Tomov

   This package can calculate ordinary and inverse Laplace transforms of
expressions. Documentation is in plain text.


File: ..\util\r37,  Node: LIE,  Next: MODSR,  Prev: LAPLACE,  Up: Miscellaneous Packages section

   LIE                    package

   Authors: Carsten and Franziska Sch"obel

   LIE is a package of functions for the classification of real
n-dimensional Lie algebras. It consists of two modules: LIENDMC1 and
LIE1234 . With the help of the functions in the LIENDMCL module, real
n-dimensional Lie algebras L with a derived algebra L^(1) of dimension
1 can be classified.


File: ..\util\r37,  Node: MODSR,  Next: NCPOLY,  Prev: LIE,  Up: Miscellaneous Packages section

   MODSR                    package

   Author: Herbert Melenk

   This package supports solve (M_SOLVE) and roots (M_ROOTS) operators
for modular polynomials and modular polynomial systems. The moduli need
not be primes. M_SOLVE requires a modulus to be set. M_ROOTS takes the
modulus as a second argument. For example:

     ____________________________________________________________
     
     on modular; setmod 8;
     m_solve(2x=4);            ->  {{X=2},{X=6}}
     m_solve({x^2-y^3=3});
         ->  {{X=0,Y=5}, {X=2,Y=1}, {X=4,Y=5}, {X=6,Y=1}}
     m_solve({x=2,x^2-y^3=3}); ->  {{X=2,Y=1}}
     off modular;
     m_roots(x^2-1,8);         ->  {1,3,5,7}
     m_roots(x^3-x,7);         ->  {0,1,6}
     ____________________________________________________________


File: ..\util\r37,  Node: NCPOLY,  Next: ORTHOVEC,  Prev: MODSR,  Up: Miscellaneous Packages section

   NCPOLY                    package

   Authors: Herbert Melenk, Joachim Apel

   This package allows the user to set up automatically a consistent
environment for computing in an algebra where the non-commutativity is
defined by Lie-bracket commutators. The package uses the REDUCE NONCOM
mechanism for elementary polynomial arithmetic; the commutator rules
are automatically computed from the Lie brackets.


File: ..\util\r37,  Node: ORTHOVEC,  Next: PHYSOP,  Prev: NCPOLY,  Up: Miscellaneous Packages section

   ORTHOVEC                    package

   Author: James W. Eastwood

   ORTHOVEC is a collection of REDUCE procedures and operations which
provide a simple-to-use environment for the manipulation of scalars and
vectors. Operations include addition, subtraction, dot and cross
products, division, modulus, div, grad, curl, laplacian,
differentiation, integration, and Taylor expansion.


File: ..\util\r37,  Node: PHYSOP,  Next: PM,  Prev: ORTHOVEC,  Up: Miscellaneous Packages section

   PHYSOP                    package

   Author: Mathias Warns

   This package has been designed to meet the requirements of
theoretical physicists looking for a computer algebra tool to perform
complicated calculations in quantum theory with expressions containing
operators.  These operations consist mainly of the calculation of
commutators between operator expressions and in the evaluations of
operator matrix elements in some abstract space.


File: ..\util\r37,  Node: PM,  Next: RANDPOLY,  Prev: PHYSOP,  Up: Miscellaneous Packages section

   PM                    package

   Author: Kevin McIsaac

   PM is a general pattern matcher similar in style to those found in
systems such as SMP and Mathematica, and is based on the pattern
matcher described in Kevin McIsaac, "Pattern Matching Algebraic
Identities", SIGSAM Bulletin, 19 (1985), 4-13.


File: ..\util\r37,  Node: RANDPOLY,  Next: REACTEQN,  Prev: PM,  Up: Miscellaneous Packages section

   RANDPOLY                    package

   Author: Francis J. Wright

   This package is based on a port of the Maple random polynomial
generator together with some support facilities for the generation of
random numbers and anonymous procedures.


File: ..\util\r37,  Node: REACTEQN,  Next: RESET,  Prev: RANDPOLY,  Up: Miscellaneous Packages section

   REACTEQN                    package

   Author: Herbert Melenk

   This package allows a user to transform chemical reaction systems
into ordinary differential equation systems (ODE) corresponding to the
laws of pure mass action.


File: ..\util\r37,  Node: RESET,  Next: RESIDUE,  Prev: REACTEQN,  Up: Miscellaneous Packages section

   RESET                    package

   Author: John Fitch

   This package defines a command command RESETREDUCE that works
through the history of previous commands, and clears any values which
have been assigned, plus any rules, arrays and the like. It also sets
the various switches to their initial values. It is not complete, but
does work for most things that cause a gradual loss of space. It would
be relatively easy to make it interactive, so allowing for selective
resetting.


File: ..\util\r37,  Node: RESIDUE,  Next: RLFI,  Prev: RESET,  Up: Miscellaneous Packages section

   RESIDUE                    package

   Author: Wolfram Koepf

   This package supports the calculation of residues of arbitrary
expressions.


File: ..\util\r37,  Node: RLFI,  Next: SCOPE,  Prev: RESIDUE,  Up: Miscellaneous Packages section

   RLFI                    package

   Author: Richard Liska

   This package adds LaTeX syntax to REDUCE. Text generated by REDUCE
in this mode can be directly used in LaTeX source documents. Various
mathematical constructions are supported by the interface including
subscripts, superscripts, font changing, Greek letters, divide-bars,
integral and sum signs, derivatives, and so on.


File: ..\util\r37,  Node: SCOPE,  Next: SETS,  Prev: RLFI,  Up: Miscellaneous Packages section

   SCOPE                    package

   Author: J.A. van Hulzen

   SCOPE is a package for the production of an optimized form of a set
of expressions. It applies an heuristic search for common
(sub)expressions to almost any set of proper REDUCE assignment
statements. The output is obtained as a sequence of assignment
statements. GENTRAN is used to facilitate expression output.


File: ..\util\r37,  Node: SETS,  Next: SPDE,  Prev: SCOPE,  Up: Miscellaneous Packages section

   SETS                    package

   Author: Francis J. Wright

   The SETS package provides algebraic-mode support for set operations
on lists regarded as sets (or representing explicit sets) and on
implicit sets represented by identifiers.


File: ..\util\r37,  Node: SPDE,  Next: SYMMETRY,  Prev: SETS,  Up: Miscellaneous Packages section

   SPDE                    package

   Author: Fritz Schwartz

   The package SPDE provides a set of functions which may be used to
determine the symmetry group of Lie- or point-symmetries of a given
system of partial differential equations. In many cases the determining
system is solved completely automatically. In other cases the user has
to provide additional input information for the solution algorithm to
terminate.


File: ..\util\r37,  Node: SYMMETRY,  Next: TPS,  Prev: SPDE,  Up: Miscellaneous Packages section

   SYMMETRY                    package

   Author: Karin Gatermann

   This package computes symmetry-adapted bases and block diagonal
forms of matrices which have the symmetry of a group. The package is the
implementation of the theory of linear representations for small finite
groups such as the dihedral groups.


File: ..\util\r37,  Node: TPS,  Next: TRI,  Prev: SYMMETRY,  Up: Miscellaneous Packages section

   TPS                    package

   Authors: Alan Barnes, Julian Padget

   This package implements formal Laurent series expansions in one
variable using the domain mechanism of REDUCE. This means that power
series objects can be added, multiplied, differentiated etc., like
other first class objects in the system. A lazy evaluation scheme is
used and thus terms of the series are not evaluated until they are
required for printing or for use in calculating terms in other power
series. The series are extendible giving the user the impression that
the full infinite series is being manipulated. The errors that can
sometimes occur using series that are truncated at some fixed depth
(for example when a term in the required series depends on terms of an
intermediate series beyond the truncation depth) are thus avoided.


File: ..\util\r37,  Node: TRI,  Next: TRIGSIMP,  Prev: TPS,  Up: Miscellaneous Packages section

   TRI                    package

   Author: Werner Antweiler

   This package provides facilities written in REDUCE-Lisp for
typesetting REDUCE formulas using TeX. The TeX-REDUCE-Interface
incorporates three levels of TeX output: without line breaking, with
line breaking, and with line breaking plus indentation.


File: ..\util\r37,  Node: TRIGSIMP,  Next: XCOLOR,  Prev: TRI,  Up: Miscellaneous Packages section

   TRIGSIMP                    package

   Author: Wolfram Koepf

   TRIGSIMP is a useful tool for all kinds of trigonometric and
hyperbolic simplification and factorization. There are three procedures
included in TRIGSIMP: TRIGSIMP , TRIGFACTORIZE and TRIGGCD . The first
is for finding simplifications of trigonometric or hyperbolic
expressions with many options, the second for factorizing them and the
third for finding the greatest common divisor of two trigonometric or
hyperbolic polynomials.


File: ..\util\r37,  Node: XCOLOR,  Next: XIDEAL,  Prev: TRIGSIMP,  Up: Miscellaneous Packages section

   XCOLOR                    package

   Author: A. Kryukov

   This package calculates the color factor in non-abelian gauge field
theories using an algorithm due to Cvitanovich.


File: ..\util\r37,  Node: XIDEAL,  Next: WU,  Prev: XCOLOR,  Up: Miscellaneous Packages section

   XIDEAL                    package

   Author: David Hartley

   XIDEAL constructs Groebner bases for solving the left ideal
membership problem: Groebner left ideal bases or GLIBs. For graded
ideals, where each form is homogeneous in degree, the distinction
between left and right ideals vanishes. Furthermore, if the generating
forms are all homogeneous, then the Groebner bases for the non-graded
and graded ideals are identical. In this case, XIDEAL is able to save
time by truncating the Groebner basis at some maximum degree if desired.


File: ..\util\r37,  Node: WU,  Next: ZEILBERG,  Prev: XIDEAL,  Up: Miscellaneous Packages section

   WU                    package

   Author: Russell Bradford

   This is a simple implementation of the Wu algorithm implemented in
REDUCE working directly from "A Zero Structure Theorem for
Polynomial-Equations-Solving," Wu Wen-tsun, Institute of Systems
Science, Academia Sinica, Beijing.


File: ..\util\r37,  Node: ZEILBERG,  Next: ZTRANS,  Prev: WU,  Up: Miscellaneous Packages section

   ZEILBERG                    package

   Authors: Gregor St"olting and Wolfram Koepf

   This package is a careful implementation of the Gosper and Zeilberger
algorithms for indefinite and definite summation of hypergeometric
terms, respectively. Extensions of these algorithms are also included
that are valid for ratios of products of powers, factorials, gamma
function terms, binomial coefficients, and shifted factorials that are
rational-linear in their arguments.


File: ..\util\r37,  Node: ZTRANS,  Prev: ZEILBERG,  Up: Miscellaneous Packages section

   ZTRANS                    package

   Authors: Wolfram Koepf, Lisa Temme

   This package is an implementation of the Z-transform of a sequence.
This is the discrete analogue of the Laplace Transform.


File: ..\util\r37,  Node: Miscellaneous Packages section,  Next: Outmoded Operations section,  Prev: Matrix Normal Forms section,  Up: Top

   Miscellaneous Packages section

* Menu:

* Miscellaneous Packages::  introduction
* ALGINT package::          package
* APPLYSYM::                package
* ARNUM::                   package
* ASSIST::                  package
* AVECTOR::                 package
* BOOLEAN::                 package
* CALI::                    package
* CAMAL::                   package
* CHANGEVR::                package
* COMPACT::                 package
* CRACK::                   package
* CVIT::                    package
* DEFINT::                  package
* DESIR::                   package
* DFPART::                  package
* DUMMY::                   package
* EXCALC::                  package
* FPS::                     package
* FIDE::                    package
* GENTRAN::                 package
* IDEALS::                  package
* INEQ::                    package
* INVBASE::                 package
* LAPLACE::                 package
* LIE::                     package
* MODSR::                   package
* NCPOLY::                  package
* ORTHOVEC::                package
* PHYSOP::                  package
* PM::                      package
* RANDPOLY::                package
* REACTEQN::                package
* RESET::                   package
* RESIDUE::                 package
* RLFI::                    package
* SCOPE::                   package
* SETS::                    package
* SPDE::                    package
* SYMMETRY::                package
* TPS::                     package
* TRI::                     package
* TRIGSIMP::                package
* XCOLOR::                  package
* XIDEAL::                  package
* WU::                      package
* ZEILBERG::                package
* ZTRANS::                  package


File: ..\util\r37,  Node: ED,  Next: EDITDEF,  Up: Outmoded Operations section

   ED                    command

   The ED command invokes a simple line editor for REDUCE input
statements.

syntax:

   ED <integer> or ED

   ED called with no argument edits the last input statement. If
<integer> is greater than or equal to the current line number, an error
message is printed. Reenter a proper ED command or return to the top
level with a semicolon.

   The editor formats REDUCE's version of the desired input statement,
dividing it into lines at semicolons and dollar signs. The statement is
printed at the beginning of the edit session. The editor works on one
line at a time, and has a pointer (shown by ^ ) to the current
character of that line. When the session begins, the pointer is at the
left hand side of the first line. The editing prompt is > .

   The following commands are available. They may be entered in either
upper or lower case. All commands are activated by the carriage return,
which also prints out the current line after changes. Several commands
can be placed on a single line, except that commands terminated by an
ESC must be the last command before the carriage return.

   b Move pointer to beginning of current line.

   d<digit> Delete current character and next (digit-1) characters. An
error message is printed if anything other than a single digit follows
d. If there are fewer than <digit> characters left on the line, all but
the final dollar sign or semicolon is removed. To delete a line
completely, use the k command.

   e End the current session, causing the edited expression to be
reparsed by REDUCE.

   f<char> Find the next occurrence of the character <char> to the
right of the pointer on the current line and move the pointer to it. If
the character is not found, an error message is printed and the pointer
remains in its original position. Other lines are not searched. The f
command is not case-sensitive.

   i<string>ESC Insert <string> in front of pointer. The ESC key is your
delimiter for the input string. No other command may follow this one on
the same line.

   k Kill rest of the current line, including the semicolon or dollar
sign terminator. If there are characters remaining on the current line,
and it is the last line of the input statement, a semicolon is added to
the line as a terminator for REDUCE. If the current line is now empty,
one of the following actions is performed: If there is a following
line, it becomes the current line and the pointer is placed at its
first character. If the current line was the final line of the
statement, and there is a previous line, the previous line becomes the
current line. If the current line was the only line of the statement,
and it is empty, a single semicolon is inserted for REDUCE to parse.

   l Finish editing this line and move to the last previous line. An
error message is printed if there is no previous line.

   n Finish editing this line and move to the next line. An error
message is printed if there is no next line.

   p Print out all the lines of the statement. Then a dotted line is
printed, and the current line is reprinted, with the pointer under it.

   q Quit the editing session without saving the changes. If a
semicolon is entered after q, a new line prompt is given, otherwise
REDUCE prompts you for another command. Whatever you type in to the
prompt appearing after the q is entered is stored as the input for the
line number in which you called the edit. Thus if you enter a
semicolon, neither [*note INPUT::.] ED  will find anything under the
current number.

   r<char> Replace the character at the pointer by <char>.

   s<string>ESC Search for the first occurrence of <string> to the
right of the pointer on the current line and move the pointer to its
first character.  The ESC key is your delimiter for the input string.
The s function does not search other lines of the statement. If the
string is not found, an error message is printed and the pointer
remains in its original position. The s command is not case-sensitive.
No other command may follow this one on the same line.

   x <or space> Move the pointer one character to the right. If the
pointer is already at the end of the line, an error message is printed.

   - <(minus)> Move the pointer one character to the left. If the
pointer is already at the beginning of the line, an error message is
printed.

   ?  Display the Help menu, showing the commands and their actions.

examples:

     ____________________________________________________________
     ____________________________________________________________
   (Line numbers are shown in the following examples)
     ____________________________________________________________
     
     
     2: >>x**2 + y;
     
     X^{2} + Y
     
     3: >>ed 2;
     
       X**2 + Y;
     
       ^
     
     For help, type '?'
     
     ?-                  (Enter three spaces and (Key){Return})
     
       X**2 + Y;
     
          ^
     
     ?- r5
     
       X**5 + Y;
     
          ^
     
     ?- fY
     
       X**5 + Y;
     
              ^
     
     ?- iabc (Terminate with (Key){ESC} and (Key){Return})
     
       X**5 + abcY;
     
                 ^
     
     ?- ----
     
       X**5 + abcY;
     
             ^
     
     ?- fbd2
     
       X**5 + aY;
     
               ^
     
     ?- b
     
       X**5 + aY;
     
       ^
     
     ?- e
     
     AY + X^{5}
     
     4: >>procedure dumb(a);
     
     >>write a;
     
     DUMB
     
     5: >>dumb(17);
     
     17
     
     6: >>ed 4;
     
       PROCEDURE DUMB (A);
     
       ^
     
     WRITE A;
     
     ?- fArBn
     
       WRITE A;
     
       ^
     
     ?- ibegin scalar a; a := b + 10; (Type a space, (Key){ESC}, and (Key){Return})
     
       begin scalar a; a := b + 10; WRITE A;
     
     ?- f;i end (Key){ESC}, (Key){Return}
     
       begin scalar b; b := a + 10; WRITE A end;
     
                                               ^
     
     ?- p
     
      PROCEDURE DUMB (B);
     
      begin scalar b; b := a + 10; WRITE A end;
     
      -  -  -  -  -  -  -  -  -  -
     
       begin scalar b; b := a + 10; WRITE A end;
     
                                               ^
     
     ?- e
     
     DUMB
     
     7: >>dumb(17);
     
     27
     
     8: >>
     
     ____________________________________________________________

   Note that REDUCE reparsed the procedure DUMB and updated the
definition.

   Since REDUCE divides the expression to be edited into lines at
semicolons or dollar sign terminators, some lines may occupy more than
one line of screen space. If the pointer is directly beneath the last
line of text, it refers to the top line of text. If there is a blank
line between the last line of text and the pointer, it refers to the
second line of text, and likewise for cases of greater than two lines
of text. In other words, the entire REDUCE statement up to the next
terminator is printed, even if it runs to several lines, then the
pointer line is printed.

   You can insert new statements which contain semicolons of their own
into the current line. They are run into the current line where you
placed them until you edit the statement again. REDUCE will understand
the set of statements if the syntax is correct.

   If you leave out needed closing brackets when you exit the editor, a
message is printed allowing you to redo the edit (you can edit the
previous line number and return to where you were). If you leave out a
closing double-quotation mark, an error message is printed, and the
editing must be redone from the original version; the edited version
has been destroyed.  Most syntax errors which you inadvertently leave
in an edited statement are caught as usual by the REDUCE parser, and
you will be able to re-edit the statement.

   When the editor processes a previous statement for your editing,
escape characters are removed. Most special characters that you may use
in identifiers are printed in legal fashion, prefixed by the exclamation
point. Be sure to treat the special character and its escape as a pair
in your editing. The characters ( ) # ; '  are different. Since they
have special meaning in Lisp, they are double-escaped in the editor.
It is unwise to use these characters inside identifiers anyway, due to
the probability of confusion.

   If you see a Lisp error message during editing, the edit has been
aborted.  Enter a semicolon and you will see a new line prompt.

   Since the editor has no dependence on any window system, it can be
used if you are running REDUCE without windows.


File: ..\util\r37,  Node: EDITDEF,  Prev: ED,  Up: Outmoded Operations section

   EDITDEF                    command

   The interactive editor [*note ED::.] may be used to edit a
user-defined procedure that has not been compiled.

syntax:

   EDITDEF (IDENTIFIER )

   where IDENTIFIER is the name of the procedure. When EDITDEF is
invoked, the procedure definition will be displayed in editing mode,
and may then be edited and redefined on exiting from the editor using
standard [*note ED::.] commands.


File: ..\util\r37,  Node: Outmoded Operations section,  Prev: Miscellaneous Packages section,  Up: Top

   Outmoded Operations section

* Menu:

* ED::                      command
* EDITDEF::                 command


File: ..\util\r37,  Node: Top,  Up: (dir)



   Top

* Menu:

* Concepts section::
* Variables section::
* Syntax section::
* Arithmetic Operations section::
* Boolean Operators section::
* General Commands section::
* Algebraic Operators section::
* Declarations section::
* Input and Output section::
* Elementary Functions section::
* General Switches section::
* Matrix Operations section::
* Groebner package section::
* High Energy Physics section::
* Numeric Package section::
* Roots Package section::
* Special Functions section::
* Taylor series section::
* Gnuplot package section::
* Linear Algebra package section::
* Matrix Normal Forms section::
* Miscellaneous Packages section::
* Outmoded Operations section::



Tag Table:
Node: IDENTIFIER89
Node: KERNEL2328
Node: STRING3400
Node: Concepts section3980
Node: assumptions4192
Node: CARD_NO4846
Node: E5891
Node: EVAL_MODE6510
Node: FORT_WIDTH7031
Node: HIGH_POW7851
Node: I8885
Node: INFINITY9808
Node: LOW_POW10146
Node: NIL11000
Node: PI11311
Node: requirements11826
Node: ROOT_MULTIPLICITIES12561
Node: T13020
Node: Variables section13340
Node: semicolon13813
Node: dollar15158
Node: percent16765
Node: dot17631
Node: assign18794
Node: equalsign21677
Node: replace22790
Node: plussign23268
Node: minussign24080
Node: asterisk25041
Node: slash26379
Node: power27935
Node: caret29360
Node: geqsign30722
Node: greater31744
Node: leqsign32892
Node: less33860
Node: tilde34849
Node: group35161
Node: AND36489
Node: BEGIN37597
Node: block39264
Node: COMMENT39580
Node: CONS40354
Node: END41657
Node: EQUATION42531
Node: FIRST44276
Node: FOR44975
Node: FOREACH49715
Node: GEQ50408
Node: GOTO51507
Node: GREATERP52499
Node: IF53605
Node: LIST56146
Node: OR57697
Node: PROCEDURE58849
Node: REPEAT64494
Node: REST65719
Node: RETURN66582
Node: REVERSE68782
Node: RULE69936
Node: Free Variable71628
Node: Optional Free Variable72207
Node: SECOND73143
Node: SET73867
Node: SETQ75061
Node: THIRD77159
Node: WHEN77921
Node: Syntax section78207
Node: ARITHMETIC_OPERATIONS80199
Node: ABS80532
Node: ADJPREC81451
Node: ARG82354
Node: CEILING83010
Node: CHOOSE83842
Node: DEG2DMS84550
Node: DEG2RAD85382
Node: DIFFERENCE86126
Node: DILOG87088
Node: DMS2DEG87872
Node: DMS2RAD88653
Node: FACTORIAL89439
Node: FIX90168
Node: FIXP91086
Node: FLOOR92058
Node: EXPT92873
Node: GCD93904
Node: LN94871
Node: LOG95881
Node: LOGB96756
Node: MAX97749
Node: MIN98431
Node: MINUS99111
Node: NEXTPRIME99789
Node: NOCONVERT100458
Node: NORM101060
Node: PERM101894
Node: PLUS102661
Node: QUOTIENT103669
Node: RAD2DEG105687
Node: RAD2DMS106428
Node: RECIP107213
Node: REMAINDER107756
Node: ROUND108808
Node: SETMOD109425
Node: SIGN110747
Node: SQRT111458
Node: TIMES112708
Node: Arithmetic Operations section113720
Node: boolean value115331
Node: EQUAL115706
Node: EVENP116900
Node: false117939
Node: FREEOF118377
Node: LEQ119561
Node: LESSP120640
Node: MEMBER121727
Node: NEQ122723
Node: NOT123789
Node: NUMBERP124724
Node: ORDP125600
Node: PRIMEP126588
Node: TRUE127301
Node: Boolean Operators section127956
Node: BYE128647
Node: CONT128975
Node: DISPLAY130326
Node: LOAD_PACKAGE131218
Node: PAUSE131644
Node: QUIT134026
Node: RECLAIM134386
Node: REDERR135160
Node: RETRY136591
Node: SAVEAS137408
Node: SHOWTIME138489
Node: WRITE139452
Node: General Commands section140870
Node: APPEND141475
Node: ARBINT142676
Node: ARBCOMPLEX143259
Node: ARGLENGTH143998
Node: COEFF145006
Node: COEFFN147109
Node: CONJ148866
Node: CONTINUED_FRACTION149576
Node: DECOMPOSE150762
Node: DEG151968
Node: DEN152865
Node: DF154160
Node: EXPAND_CASES155923
Node: EXPREAD156329
Node: FACTORIZE156797
Node: HYPOT159258
Node: IMPART160017
Node: INT160679
Node: INTERPOL163099
Node: LCOF164210
Node: LENGTH165156
Node: LHS166924
Node: LIMIT167879
Node: LPOWER169231
Node: LTERM170119
Node: MAINVAR171025
Node: MAP172412
Node: MKID174506
Node: NPRIMITIVE175914
Node: NUM176582
Node: ODESOLVE177503
Node: ONE_OF179429
Node: PART180289
Node: PF183016
Node: PROD184455
Node: REDUCT185276
Node: REPART186217
Node: RESULTANT186881
Node: RHS190006
Node: ROOT_OF191547
Node: SELECT193096
Node: SHOWRULES195041
Node: SOLVE196014
Node: SORT200783
Node: STRUCTR202377
Node: SUB204034
Node: SUM204922
Node: WS205816
Node: Algebraic Operators section208053
Node: ALGEBRAIC209992
Node: ANTISYMMETRIC210866
Node: ARRAY212303
Node: CLEAR214643
Node: CLEARRULES217331
Node: DEFINE218318
Node: DEPEND219467
Node: EVEN221250
Node: FACTOR declaration221950
Node: FORALL223818
Node: INFIX227026
Node: INTEGER228497
Node: KORDER229750
Node: LET230842
Node: LINEAR237763
Node: LINELENGTH239769
Node: LISP240357
Node: LISTARGP241097
Node: NODEPEND242132
Node: MATCH243065
Node: NONCOM245157
Node: NONZERO246343
Node: ODD246973
Node: OFF247845
Node: ON248195
Node: OPERATOR248545
Node: ORDER250974
Node: PRECEDENCE252649
Node: PRECISION254470
Node: PRINT_PRECISION255771
Node: REAL256507
Node: REMFAC257770
Node: SCALAR258207
Node: SCIENTIFIC_NOTATION259457
Node: SHARE261102
Node: SYMBOLIC262492
Node: SYMMETRIC263197
Node: TR264191
Node: UNTR266044
Node: VARNAME266569
Node: WEIGHT267696
Node: WHERE269643
Node: WHILE271776
Node: WTLEVEL272797
Node: Declarations section274671
Node: IN276534
Node: INPUT277827
Node: OUT278897
Node: SHUT281024
Node: Input and Output section281666
Node: ACOS281979
Node: ACOSH283100
Node: ACOT284659
Node: ACOTH285339
Node: ACSC286037
Node: ACSCH287150
Node: ASEC288235
Node: ASECH289342
Node: ASIN290902
Node: ASINH292105
Node: ATAN293476
Node: ATANH294590
Node: ATAN2295925
Node: COS297022
Node: COSH298010
Node: COT299115
Node: COTH300073
Node: CSC301063
Node: CSCH302030
Node: ERF303069
Node: EXP304128
Node: SEC305032
Node: SECH306015
Node: SIN307010
Node: SINH307934
Node: TAN309154
Node: TANH310422
Node: Elementary Functions section311617
Node: SWITCHES312793
Node: ALGINT313127
Node: ALLBRANCH313591
Node: ALLFAC314507
Node: ARBVARS315290
Node: BALANCED_MOD316564
Node: BFSPACE317257
Node: COMBINEEXPT318112
Node: COMBINELOGS318725
Node: COMP319853
Node: COMPLEX322106
Node: CREF323389
Node: CRAMER324376
Node: DEFN326224
Node: DEMO328497
Node: DFPRINT329175
Node: DIV330042
Node: ECHO331042
Node: ERRCONT331948
Node: EVALLHSEQP332798
Node: EXP switch333218
Node: EXPANDLOGS334284
Node: EZGCD335435
Node: FACTOR336099
Node: FAILHARD338161
Node: FORT338784
Node: FORTUPPER339877
Node: FULLPREC340433
Node: FULLROOTS341315
Node: GC341785
Node: GCD switch342242
Node: HORNER343745
Node: IFACTOR344614
Node: INT switch345756
Node: INTSTR346356
Node: LCM346892
Node: LESSSPACE348809
Node: LIMITEDFACTORS349041
Node: LIST switch350062
Node: LISTARGS350798
Node: MCD351752
Node: MODULAR353058
Node: MSG354224
Node: MULTIPLICITIES354599
Node: NAT355476
Node: NERO356411
Node: NOARG357538
Node: NOLNR358324
Node: NOSPLIT358949
Node: NUMVAL359416
Node: OUTPUT360061
Node: OVERVIEW360588
Node: PERIOD360861
Node: PRECISE361166
Node: PRET362237
Node: PRI363442
Node: RAISE364095
Node: RAT364500
Node: RATARG365685
Node: RATIONAL366726
Node: RATIONALIZE367793
Node: RATPRI368821
Node: REVPRI369537
Node: RLISP88370363
Node: ROUNDALL371179
Node: ROUNDBF371736
Node: ROUNDED372862
Node: SAVESTRUCTR373763
Node: SOLVESINGULAR375183
Node: TIME376477
Node: TRALLFAC377642
Node: TRFAC378228
Node: TRIGFORM378902
Node: TRINT379286
Node: TRNONLNR379606
Node: VAROPT380079
Node: General Switches section381261
Node: COFACTOR384100
Node: DET384837
Node: MAT385917
Node: MATEIGEN387375
Node: MATRIX389396
Node: NULLSPACE392386
Node: RANK394029
Node: TP394791
Node: TRACE395676
Node: Matrix Operations section396419
Node: Groebner bases396926
Node: Ideal Parameters397894
Node: Term order400308
Node: torder400781
Node: torder_compile402498
Node: lex term order403150
Node: gradlex term order403732
Node: revgradlex term order404109
Node: gradlexgradlex term order404637
Node: gradlexrevgradlex term order405346
Node: lexgradlex term order405646
Node: lexrevgradlex term order405930
Node: weighted term order406263
Node: graded term order406740
Node: matrix term order407305
Node: Term order section408087
Node: gvars408745
Node: groebner409134
Node: groebner_walk410498
Node: groebopt411542
Node: gvarslast412289
Node: groebprereduce412670
Node: groebfullreduction413215
Node: gltbasis413636
Node: gltb414043
Node: glterms414214
Node: groebstat414725
Node: trgroeb415106
Node: trgroebs415382
Node: gzerodim?415666
Node: gdimension416142
Node: gindependent_sets416718
Node: dd_groebner417475
Node: glexconvert418298
Node: greduce419451
Node: preduce419867
Node: idealquotient420403
Node: hilbertpolynomial420924
Node: Basic Groebner operators section421486
Node: groebnerf422494
Node: groebmonfac424356
Node: groebresmax425088
Node: groebrestriction425466
Node: Factorizing Groebner bases section426176
Node: groebprot426548
Node: groebprotfile426887
Node: groebnert427086
Node: preducet428004
Node: Tracing Groebner bases section428771
Node: Module429139
Node: gmodule429783
Node: Groebner Bases for Modules section430860
Node: gsort431172
Node: gsplit431744
Node: gspoly432470
Node: Computing with distributive polynomials section432936
Node: Groebner package section433260
Node: HEPHYS433735
Node: HE-dot434358
Node: EPS435919
Node: G437248
Node: INDEX440115
Node: MASS441132
Node: MSHELL442212
Node: NOSPUR443148
Node: REMIND443969
Node: SPUR444401
Node: VECDIM444818
Node: VECTOR445483
Node: High Energy Physics section447873
Node: Numeric Package448512
Node: Interval448970
Node: numeric accuracy449652
Node: TRNUMERIC450137
Node: num_min450503
Node: num_solve452018
Node: num_int453898
Node: num_odesolve455485
Node: bounds457515
Node: Chebyshev fit459222
Node: num_fit461460
Node: Numeric Package section462910
Node: Roots Package463480
Node: MKPOLY464228
Node: NEARESTROOT464981
Node: REALROOTS465627
Node: ROOTACC466859
Node: ROOTS467270
Node: ROOT_VAL468379
Node: ROOTSCOMPLEX469144
Node: ROOTSREAL469432
Node: Roots Package section469693
Node: Special Function Package470192
Node: Constants472729
Node: BERNOULLI473645
Node: BERNOULLIP474190
Node: EULER474843
Node: EULERP475523
Node: ZETA476100
Node: Bernoulli Euler Zeta section476959
Node: BESSELJ477328
Node: BESSELY477841
Node: HANKEL1478443
Node: HANKEL2479146
Node: BESSELI479850
Node: BESSELK480397
Node: StruveH480921
Node: StruveL481369
Node: KummerM481823
Node: KummerU482493
Node: WhittakerW483091
Node: Bessel Functions section483802
Node: Airy_Ai484402
Node: Airy_Bi484968
Node: Airy_Aiprime485513
Node: Airy_Biprime486098
Node: Airy Functions section486637
Node: JacobiSN487004
Node: JacobiCN487552
Node: JacobiDN488144
Node: JacobiCD488692
Node: JacobiSD489258
Node: JacobiND489824
Node: JacobiDC490419
Node: JacobiNC490965
Node: JacobiSC491527
Node: JacobiNS492118
Node: JacobiDS492705
Node: JacobiCS493271
Node: JacobiAMPLITUDE493836
Node: AGM_FUNCTION494461
Node: LANDENTRANS495747
Node: EllipticF496533
Node: EllipticK497258
Node: EllipticKprime497971
Node: EllipticE498703
Node: EllipticTHETA499905
Node: JacobiZETA500992
Node: Jacobi Elliptic Functions and Elliptic Integrals section501731
Node: POCHHAMMER502772
Node: GAMMA503629
Node: BETA504104
Node: PSI504746
Node: POLYGAMMA505365
Node: Gamma and Related Functions section506054
Node: DILOG extended506491
Node: Lambert_W function507302
Node: Miscellaneous Functions section508090
Node: ChebyshevT508385
Node: ChebyshevU509136
Node: HermiteP509905
Node: LaguerreP510628
Node: LegendreP511554
Node: JacobiP512575
Node: GegenbauerP513245
Node: SolidHarmonicY513843
Node: SphericalHarmonicY514557
Node: Orthogonal Polynomials section515486
Node: Si516031
Node: Shi516639
Node: s_i517269
Node: Ci517883
Node: Chi518514
Node: ERF extended519186
Node: erfc519946
Node: Ei520507
Node: Fresnel_C521157
Node: Fresnel_S521792
Node: Integral Functions section522423
Node: BINOMIAL523001
Node: STIRLING1523879
Node: STIRLING2524798
Node: Combinatorial Operators section525594
Node: ThreejSymbol525913
Node: Clebsch_Gordan526618
Node: SixjSymbol527248
Node: 3j and 6j symbols section527881
Node: HYPERGEOMETRIC528190
Node: MeijerG529115
Node: Heaviside530604
Node: erfi531111
Node: Miscellaneous section531600
Node: Special Functions section531901
Node: TAYLOR introduction532527
Node: taylor533063
Node: taylorautocombine536291
Node: taylorautoexpand536705
Node: taylorcombine537091
Node: taylorkeeporiginal539534
Node: taylororiginal540072
Node: taylorprintorder541299
Node: taylorprintterms541614
Node: taylorrevert542994
Node: taylorseriesp543873
Node: taylortemplate544810
Node: taylortostandard545731
Node: Taylor series section546484
Node: GNUPLOT and REDUCE547124
Node: Axes names548073
Node: Pointset548618
Node: PLOT549653
Node: PLOTRESET552582
Node: title552943
Node: xlabel553361
Node: ylabel553786
Node: zlabel554221
Node: terminal554656
Node: size555153
Node: view555671
Node: contour556221
Node: surface556624
Node: hidden3d557030
Node: PLOTKEEP557443
Node: PLOTREFINE557793
Node: plot_xmesh558410
Node: plot_ymesh558911
Node: SHOW_GRID559288
Node: TRPLOT559755
Node: Gnuplot package section560239
Node: Linear Algebra package561169
Node: fast_la563608
Node: add_columns564728
Node: add_rows565846
Node: add_to_columns566039
Node: add_to_rows567246
Node: augment_columns567452
Node: band_matrix568448
Node: block_matrix569606
Node: char_matrix570725
Node: char_poly571522
Node: cholesky572208
Node: coeff_matrix573508
Node: column_dim574458
Node: companion575060
Node: copy_into576022
Node: diagonal577288
Node: extend578361
Node: find_companion579312
Node: get_columns580218
Node: get_rows581270
Node: gram_schmidt581461
Node: hermitian_tp582436
Node: hessian583456
Node: hilbert584386
Node: jacobian585518
Node: jordan_block586711
Node: lu_decom587683
Node: make_identity590860
Node: matrix_augment591559
Node: matrixp592708
Node: matrix_stack593355
Node: minor593546
Node: mult_columns594245
Node: mult_rows595350
Node: pivot595538
Node: pseudo_inverse596491
Node: random_matrix597784
Node: remove_columns599658
Node: remove_rows600547
Node: row_dim600745
Node: rows_pivot600931
Node: simplex602194
Node: squarep603474
Node: stack_rows604084
Node: sub_matrix604277
Node: svd605070
Node: swap_columns606526
Node: swap_entries607419
Node: swap_rows608151
Node: symmetricp608344
Node: toeplitz608989
Node: vandermonde609919
Node: Linear Algebra package section610797
Node: Smithex612943
Node: Smithex_int613887
Node: Frobenius615098
Node: Ratjordan617563
Node: Jordansymbolic619877
Node: Jordan622347
Node: Matrix Normal Forms section624146
Node: Miscellaneous Packages624554
Node: ALGINT package625919
Node: APPLYSYM626711
Node: ARNUM627027
Node: ASSIST627510
Node: AVECTOR627905
Node: BOOLEAN628465
Node: CALI629026
Node: CAMAL629563
Node: CHANGEVR629846
Node: COMPACT630168
Node: CRACK631679
Node: CVIT632155
Node: DEFINT632520
Node: DESIR632921
Node: DFPART633374
Node: DUMMY633743
Node: EXCALC634249
Node: FPS634927
Node: FIDE635209
Node: GENTRAN635912
Node: IDEALS636714
Node: INEQ637142
Node: INVBASE637432
Node: LAPLACE638016
Node: LIE638326
Node: MODSR638801
Node: NCPOLY639675
Node: ORTHOVEC640190
Node: PHYSOP640682
Node: PM641233
Node: RANDPOLY641641
Node: REACTEQN641992
Node: RESET642332
Node: RESIDUE642924
Node: RLFI643170
Node: SCOPE643658
Node: SETS644138
Node: SPDE644481
Node: SYMMETRY645007
Node: TPS645424
Node: TRI646350
Node: TRIGSIMP646766
Node: XCOLOR647369
Node: XIDEAL647655
Node: WU648299
Node: ZEILBERG648693
Node: ZTRANS649267
Node: Miscellaneous Packages section649562
Node: ED651482
Node: EDITDEF660149
Node: Outmoded Operations section660658
Node: Top660878

End Tag Table
