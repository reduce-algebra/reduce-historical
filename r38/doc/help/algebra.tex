\section{Algebraic Operators}

\begin{Operator}{APPEND}
\index{list}
The \name{append} operator constructs a new \nameref{list} 
from the elements of its two arguments (which must be lists).

\begin{Syntax}
\name{append}\(\meta{list},\meta{list}\)
\end{Syntax}

\meta{list} must be a list, though it may be the empty list (\name{\{\}}).
Any arguments beyond the first two are ignored.

\begin{Examples}
alist := \{1,2,\{a,b\}\};      &      ALIST := \{1,2,\{A,B\}\} \\
blist := \{3,4,5,sin(y)\};   &      BLIST := \{3,4,5,SIN(Y)\} \\
append(alist,blist);       &      \{1,2,\{A,B\},3,4,5,SIN(Y)\} \\
append(alist,\{\});          &      \{1,2,\{A,B\}\} \\
append(list z,blist);      &      \{Z,3,4,5,SIN(Y)\}
\end{Examples}

\begin{Comments}
The new list consists of the elements of the second list appended to the
elements of the first list.  You can \name{append} new elements to the
beginning or end of an existing list by putting the new element in a
list (use curly braces or the operator \name{list}).  This is
particularly helpful in an iterative loop.
\end{Comments}
\end{Operator}

\begin{Operator}{ARBINT}
\index{arbitrary value}
The operator \name{arbint} is used to express arbitrary integer parts
of an expression, e.g. in the result of \nameref{solve} when
\nameref{allbranch} is on. 
\begin{Examples}

solve(log(sin(x+3)),x);    &
\begin{multilineoutput}{6cm}
\{X=2*ARBINT(1)*PI - ASIN(1) - 3,
 X=2*ARBINT(1)*PI + ASIN(1) + PI - 3\}
\end{multilineoutput}
\end{Examples}
\end{Operator} 

\begin{Operator}{ARBCOMPLEX}
\index{arbitrary value}
The operator \name{arbcomplex} is used to express arbitrary scalar parts
of an expression, e.g. in the result of \nameref{solve} when
the solution is parametric in one of the variable.
\begin{Examples}

solve({x+3=y-2z,y-3x=0},{x,y,z});    &
\begin{multilineoutput}{6cm}
\{X=\rfrac{2*ARBCOMPLEX(1) + 3}{2},
  Y=\rfrac{3*ARBCOMPLEX(1) + 3}{2},
  Z=ARBCOMPLEX(1)\}
\end{multilineoutput}
\end{Examples}
\end{Operator} 

\begin{Operator}{ARGLENGTH}
\index{argument}
The operator \name{arglength} returns the number of arguments of the top-level
operator in its argument.

\begin{Syntax}
\name{arglength}\(\meta{expression}\)
\end{Syntax}

\meta{expression} can be any valid REDUCE algebraic expression.

\begin{Examples}
arglength(a + b + c + d);                             &      4 \\
arglength(a/b/c);                                     &      2 \\
arglength(log(sin(df(r**3*x,x))));                    &      1
\end{Examples}

\begin{Comments}
In the first example, \name{+} is an n-ary operator, so the number of terms
is returned.  In the second example, since \name{/} is a binary operator, the
argument is actually (a/b)/c, so there are two terms at the top level.  In
the last example, no matter how deeply the operators are nested, there is
still only one argument at the top level.
\end{Comments}
\end{Operator}


\begin{Operator}{COEFF}
\index{coefficient}
The \name{coeff} operator returns the coefficients of the powers of the
specified variable in the given expression, in a \nameref{list}.

\begin{Syntax}
\name{coeff}\(\meta{expression}\name{,}\meta{variable}\)
\end{Syntax}

\meta{expression} is expected to be a polynomial expression, not a rational
expression.  Rational expressions are accepted when the switch
\nameref{ratarg} is on.  \meta{variable} must be a kernel.  The results are
returned in a list.

\begin{Examples}
coeff((x+y)**3,x);           &       \{Y^{3} ,3*Y^{2} ,3*Y,1\} \\
coeff((x+2)**4 + sin(x),x);  &       \{SIN(X) + 16,32,24,8,1\} \\
high_pow;                    &       4 \\
low_pow;                     &       0 \\
ab := x**9 + sin(x)*x**7 + sqrt(y); 
                             &       AB := SQRT(Y) + SIN(X)*X^{7}  + X^{9}\\
coeff(ab,x);                 &       \{SQRT(Y),0,0,0,0,0,0,SIN(X),0,1\}
\end{Examples}
\begin{Comments}
The variables \nameref{high\_pow} and \nameref{low\_pow} are set to the
highest and lowest powers of the variable, respectively, appearing in the
expression.

The coefficients are put into a list, with the coefficient of the lowest
(constant) term first.  You can use the usual list access methods
(\name{first}, \name{second}, \name{third}, \name{rest}, \name{length}, and
\name{part}) to extract them.  If a power does not appear in the
expression, the corresponding element of the list is zero. Terms involving
functions of the specified variable but not including powers of it (for
example in the expression \name{x**4 + 3*x**2 + tan(x)}) are placed in the
constant term.

Since the \name{coeff} command deals with the expanded form of the expression,
you may get unexpected results when \nameref{exp} is off, or when
\nameref{factor} or \nameref{ifactor} are on.

If you want only a specific coefficient rather than all of them, use the
\nameref{coeffn} operator.

\end{Comments}
\end{Operator}


\begin{Operator}{COEFFN}
\index{coefficient}
The \name{coeffn} operator takes three arguments: an expression, a kernel, and
a non-negative integer.  It returns the coefficient of the kernel to that
integer power, appearing in the expression.

\begin{Syntax}
\name{coeffn}\(\meta{expression},\meta{kernel},\meta{integer}\)
\end{Syntax}

\meta{expression} must be a polynomial, unless \nameref{ratarg} is on which
allows rational expressions.  \meta{kernel} must be a kernel, and
\meta{integer} must be a non-negative integer.

\begin{Examples}

ff := x**7 + sin(y)*x**5 + y**4 + x + 7;                &
               FF := SIN(Y)*X^{5}  + X^{7}  + X + Y^{4}  + 7 \\
coeffn(ff,x,5);              &        SIN(Y) \\
coeffn(ff,z,3);              &        0 \\
coeffn(ff,y,0);              &        SIN(Y)*X^{5}  + X^{7}  + X + 7 \\

rr := 1/y**2+y**3+sin(y);    &        
RR := \rfrac{SIN(Y)*Y^{2}  + Y^{5}  + 1}{Y^{2}} \\
on ratarg; \\

coeffn(rr,y,-2);             &        ***** -2 invalid as COEFFN index \\

coeffn(rr,y,5);              &        \rfrac{1}{Y^{2}}\\
                                        
\end{Examples}

\begin{Comments}
If the given power of the kernel does not appear in the expression,
\name{coeffn} returns 0.  Negative powers are never detected, even if
they appear in the expression and \nameref{ratarg} are on.  \name{coeffn}
with an integer argument of 0 returns any terms in the expression that
do {\em not} contain the given kernel.
\end{Comments}
\end{Operator}


\begin{Operator}{CONJ}
\index{conjugate}\index{complex}

\begin{Syntax}
\name{conj}\(\meta{expression}\) or \name{conj} \meta{simple\_expression}
\end{Syntax}
This operator returns the complex conjugate of an expression, if that
argument has an numerical value.  A non-numerical argument is returned as
an expression in the operators \nameref{repart} and \nameref{impart}.

\begin{Examples}
conj(1+i); & 1-I \\
conj(a+i*b); & REPART(A) - REPART(B)*I - IMPART(A)*I - IMPART(B)
\end{Examples}

\end{Operator}

\begin{Operator}{CONTINUED_FRACTION}
\index{approximation}\index{rational numbers}

\begin{Syntax}
\name{continued\_fraction}\(\meta{num}\) 
or \name{continued\_fraction}\( \meta{num},\meta{size}\)
\end{Syntax}
This operator approximates the real number \meta{num}
( \nameref{rational} number, \nameref{rounded} number)
into a continued fraction. The result is a list of two elements: the
first one is the rational value of the approximation, the second one
is the list of terms of the continued fraction which represents the
same value according to the definition \name{t0 +1/(t1 + 1/(t2 + ...))}.
Precision: the second optional parameter \meta{size} is an upper bound
for the absolute value of the result denominator. If omitted, the
approximation is performed up to the current system precision.


\begin{Examples}
continued_fraction pi;
 & \{\rfrac{1146408}{364913},\{3,7,15,1,292,1,1,1,2,1\}\} \\
continued_fraction(pi,100);
 & \{\rfrac{22}{7},\{3,7\}\} \\
\end{Examples}

\end{Operator}

\begin{Operator}{DECOMPOSE}
\index{decomposition}\index{polynomial}
The \name{decompose} operator takes a multivariate polynomial as argument,
and returns an expression and a \nameref{list} of 
\nameref{equation}s from which the
original polynomial can be found by composition.

\begin{Syntax}
\name{decompose}\(\meta{expression}\) or \name{decompose}
 \meta{simple\_expression}
\end{Syntax}

\begin{Examples}
\begin{multilineinput}
decompose(x^8-88*x^7+2924*x^6-43912*x^5+263431*x^4-
          218900*x^3+65690*x^2-7700*x+234)
\end{multilineinput}
              & {U^{2} + 35*U + 234, U=V^{2} + 10*V, V=X^{2} - 22*X} \\
     decompose(u^2+v^2+2u*v+1)  & {W^{2}  + 1, W=U + V}
\end{Examples}

\begin{Comments}
Unlike factorization, this decomposition is not unique.  Further
details can be found in V.S. Alagar, M.Tanh, \meta{Fast Polynomial
Decomposition}, Proc. EUROCAL 1985, pp 150-153 (Springer) and J. von zur
Gathen, \meta{Functional} 
\meta{Decomposition of Polynomials: the Tame Case}, J.
Symbolic Computation (1990) 9, 281-299.
\end{Comments}
\end{Operator}


\begin{Operator}{DEG}
\index{degree}\index{polynomial}
The operator \name{deg} returns the highest degree of its variable argument
found in its expression argument.

\begin{Syntax}
\name{deg}\(\meta{expression},\meta{kernel}\)
\end{Syntax}

\meta{expression} is expected to be a polynomial expression, not a rational
expression.  Rational expressions are accepted when the switch
\nameref{ratarg} is on.  \meta{variable} must be a \nameref{kernel}.  The
results are returned in a list.

\begin{Examples}

deg((x+y)**5,x);            &        5 \\

deg((a+b)*(c+2*d)**2,d);    &        2 \\

deg(x**2 + cos(y),sin(x));   \\

deg((x**2 + sin(x))**5,sin(x));                        &        5
\end{Examples}
\end{Operator}


\begin{Operator}{DEN}
\index{denominator}\index{rational expression}
The \name{den} operator returns the denominator of its argument.

\begin{Syntax}
\name{den}\(\meta{expression}\)
\end{Syntax}

\meta{expression} is ordinarily a rational expression, but may be any valid
scalar REDUCE expression.

\begin{Examples}

a := x**3 + 3*x**2 + 12*x;  &      A := X*(X^{2}  + 3*X + 12) \\

b := 4*x*y + x*sin(x);      &      B := X*(SIN(X) + 4*Y) \\

den(a/b);                   &      SIN(X) + 4*Y \\

den(aa/4 + bb/5);           &      20 \\

den(100/6);                 &      3 \\

den(sin(x));                &      1
\end{Examples}

\begin{Comments}
\name{den} returns the denominator of the expression after it has been
simplified by REDUCE.  As seen in the examples, this includes putting
sums of rational expressions over a common denominator, and reducing
common factors where possible.  If the expression does not have any
other denominator, 1 is returned.

Switch settings, such as \nameref{mcd} or \nameref{rational}, have an
effect on the denominator of an expression.
\end{Comments}
\end{Operator}


\begin{Operator}{DF}
\index{derivative}\index{partial derivative}
The \name{df} operator finds partial derivatives with respect to one or
more variables.

\begin{TEX}
\begin{Syntax}
  \name{df}\(\meta{expression}\name{,}\meta{var}
	     \&optional\(\name{,}\meta{number}\)
             \{\name{,}\meta{var}\&option\(\name{,}\meta{number}\)\}\optional\)
\end{Syntax}
\end{TEX}
\begin{INFO}{
\begin{Syntax}
  \name{df}\(\meta{expression}\name{,}\meta{var}
	     [\name{,}\meta{number}\]
             \{\name{,}\meta{var} [ \name{,}\meta{number}] \} \)
\end{Syntax}
}\end{INFO}

\meta{expression} can be any valid REDUCE algebraic expression.  \meta{var}
must be a \nameref{kernel}, and is the differentiation variable.
\meta{number} must be a non-negative integer.

\begin{Examples}

df(x**2,x);                 &         2*X \\

df(x**2*y + sin(y),y);      &         COS(Y) + X^{2} \\

df((x+y)**10,z);            &         0 \\


df(1/x**2,x,2);             &        \rfrac{6}{X^{4}}\\

df(x**4*y + sin(y),y,x,3);  &         24*X \\

for all x let df(tan(x),x) = sec(x)**2; \\

df(tan(3*x),x);             &         3*SEC(3*X)^{2}
\end{Examples}
\begin{Comments}
An error message results if a non-kernel is entered as a differentiation
operator.  If the optional number is omitted, it is assumed to be 1.
See the declaration \nameref{depend} to establish dependencies for implicit
differentiation.

You can define your own differentiation rules, expanding REDUCE's
capabilities, using the \nameref{let} command as shown in the last example
above.  Note that once you add your own rule for differentiating a
function, it supersedes REDUCE's normal handling of that function for the
duration of the REDUCE session.  If you clear the rule
(\nameref{clearrules}), you don't get back
to the previous rule.
\end{Comments}
\end{Operator}

\begin{Operator}{EXPAND\_CASES}
\index{solve}
When a \nameref{root\_of} form in a result of \nameref{solve} 
has been converted to a \nameref{one\_of} form, \name{expand\_cases}
can be used to convert this into form corresponding to the
normal explicit results of \nameref{solve}. See \nameref{root\_of}.
\end{Operator}

\begin{Operator}{EXPREAD}
\index{input}
\begin{Syntax}
\name{expread}\(\)
\end{Syntax}

\name{expread} reads one well-formed expression from the current input
buffer and returns its value.

\begin{Examples}
expread(); a+b;  & A + B
\end{Examples}

\end{Operator}


\begin{Operator}{FACTORIZE}
\index{factorize}\index{polynomial}
The \name{factorize} operator factors a given expression into a list of
\{factor,power\} pairs.
\begin{Syntax}
\name{factorize}\(\meta{expression}\)
\end{Syntax}

\meta{expression} should be a polynomial, otherwise an error will result.

\begin{Examples}

fff := factorize(x^3 - y^3);                          &
		  \{\{X^{2} + X*Y + Y^{2},1\},\{X - Y,1\}\} \\
fac1 := first fff;           &      FAC1 := \{\{X^{2} + X*Y + Y^{2},1\} \\
factorize(x^15 - 1);        &
\begin{multilineoutput}{5cm}
 \{\{ X^{8} - X^{7} + X^{6} - X^{5} + X^{4} - X + 1,1\},
 \{X^{4} + X^{3} + X^{2} + X + 1,1\},
 \{X^{2} + X + 1,1\},
 \{X - 1,1\}\}
\end{multilineoutput}\\
lastone := part(ws,length ws);                          &
	LASTONE := \{X - 1,1\} \\
setmod 2;                    &      1 \\
on modular; \\
factorize(x^15 - 1);        &
\begin{multilineoutput}{5cm}
\{\{X^{4} + X^{3} + X^{2} + X + 1,1\},
 \{X^{4} + X^{3} + 1,1\},
 \{X^{4} + X + 1,1\},
 \{ X^{2} + X + 1,1\},
 \{X + 1,1\}\}
\end{multilineoutput}
\end{Examples}

\begin{Comments}
The \name{factorize} command returns the factor,power pairs as a \nameref{list}.
You can therefore use the usual list access methods (\nameref{first},
\nameref{second}, \nameref{third}, \nameref{rest}, \nameref{length} and
\nameref{part}) to extract these pairs.

If the \meta{expression} given to \name{factorize} is an integer, it will be
factored into its prime components.  To factor any integer factor of a
non-numerical expression, the switch \nameref{ifactor} should be turned on.
Its default is off. \nameref{ifactor} has effect only when factoring is
explicitly done by \name{factorize}, not when factoring is automatically
done with the \nameref{factor} switch.  If full factorization is not
needed the switch \nameref{limitedfactors} allows you to reduce the
computing time of calls to \name{factorize}.

Factoring can be done in a modular domain by calling \name{factorize} when
\nameref{modular} is on.  You can set the modulus with the \nameref{setmod}
command.  The last example above shows factoring modulo 2.

For general comments on factoring, see comments under the switch
\nameref{factor}.
\end{Comments}
\end{Operator}


\begin{Operator}{HYPOT}

\begin{Syntax}
hypot(\meta{expression},\meta{expression})
\end{Syntax}

If \name{rounded} is on, and the two arguments evaluate to numbers, this
operator returns the square root of the sums of the squares of the
arguments in a manner that avoids intermediate overflow.  In other cases,
an expression in the original operator is returned.

\begin{Examples}
hypot(3,4); & HYPOT(3,4) \\
on rounded; \\
ws; & 5.0 \\
hypot(a,b); & HYPOT(A,B)
\end{Examples}

\end{Operator}


\begin{Operator}{IMPART}
\index{imaginary part}\index{complex}
\begin{Syntax}
\name{impart}\(\meta{expression}\) or \name{impart} \meta{simple\_expression}
\end{Syntax}
This operator returns the imaginary part of an expression, if that
argument has an numerical value.  A non-numerical argument is returned as
an expression in the operators \nameref{repart} and \name{impart}.
\begin{Examples}
impart(1+i);   &  1 \\
impart(a+i*b); &  REPART(B) + IMPART(A)
\end{Examples}

\end{Operator}


\begin{Operator}{INT}
\index{integration}
The \name{int} operator performs analytic integration on a variety of
functions.

\begin{Syntax}
\name{int}\(\meta{expression},\meta{kernel}\)
\end{Syntax}

\meta{expression} can be any scalar expression. involving polynomials, log
functions, exponential functions, or tangent or arctangent expressions.
\name{int} attempts expressions involving error functions, dilogarithms
and other trigonometric expressions.  Integrals involving algebraic
extensions (such as square roots) may not succeed. \meta{kernel} must be a
REDUCE \nameref{kernel}.

\begin{Examples}
int(x**3 + 3,x);             &      \rfrac{X*(X^{3} + 12)}{4} \\\\
int(sin(x)*exp(2*x),x);
  &      - \rfrac{E^{2*X}*(COS(X) - 2*SIN(X))}{5} \\
int(1/(x^2-2),x);
  & \rfrac{SQRT(2)*(LOG( - SQRT(2) + X) - LOG(SQRT(2) + X))}{4} \\
int(sin(x)/(4 + cos(x)**2),x);
  &       - \rfrac{ATAN(\rfrac{COS(X)}{2})}{2} \\\\
int(1/sqrt(x^2-x),x); & INT(\rfrac{SQRT(X)*SQRT(X - 1)}{X^{2}-X},X)
\end{Examples}

\begin{Comments}
Note that REDUCE couldn't handle the last integral with its default
integrator, since the integrand involves a square root.  However,
the integral can be found using the \nameref{algint} package.
Alternatively, you could add a rule using the \nameref{let} statement
to evaluate this integral.

The arbitrary constant of integration is not shown.  Definite integrals can
be found by evaluating the result at the limits of integration (use
\nameref{rounded}) and subtracting the lower from the higher.  Evaluation can
be easily done by the \nameref{sub} operator.

When \name{int} cannot find an integral it returns an expression
involving formal \name{int} expressions unless the switch 
\nameref{failhard} has been set. If not all of the expression
can be integrated, the switch \nameref{nolnr} controls whether a partially
integrated result should be returned or not.

\end{Comments}
\end{Operator}


\begin{Operator}{INTERPOL}
\index{interpolation}\index{polynomial}\index{approximation}
\name{interpol} generates an interpolation polynomial.
\begin{Syntax}
   interpol(\meta{values},\meta{variable},\meta{points})
\end{Syntax}

\meta{values} and \meta{points} are \nameref{list}s of equal length and
\meta{variable} is an algebraic expression (preferably a \nameref{kernel}).
The interpolation polynomial is generated in the given variable of degree
length(\meta{values})-1.  The unique polynomial \name{f} is defined by the
property that for corresponding elements \name{v} of \meta{values} and
\name{p} of \meta{points} the relation \name{f(p)=v} holds.

\begin{Examples}
f := for i:=1:4 collect(i**3-1);  & F := {0,7,26,63} \\
p := {1,2,3,4}; & P := {1,2,3,4} \\
interpol(f,x,p); & X^{3} - 1
\end{Examples}

\begin{Comments}
The Aitken-Neville interpolation algorithm is used which guarantees a
stable result even with rounded numbers and an ill-conditioned problem.
\end{Comments}
\end{Operator}


\begin{Operator}{LCOF}
\index{coefficient}\index{polynomial}
The \name{lcof} operator returns the leading coefficient of a given expression
with respect to a given variable.
\begin{Syntax}
\name{lcof}\(\meta{expression},\meta{kernel}\)
\end{Syntax}

\meta{expression} is ordinarily a polynomial. If \nameref{ratarg} is on,
a rational expression may also be used, otherwise an error results.
\meta{kernel} must be a \nameref{kernel}.

\begin{Examples}
lcof((x+2*y)**5,y);          &         32 \\
lcof((x + y*sin(x))**2 + cos(x)*sin(x)**2,sin(x));
			     &         COS(X)^{2} + Y \\
lcof(x**2 + 3*x + 17,y);     &         X^{2} + 3*X + 17
\end{Examples}

\begin{Comments}
If the kernel does not appear in the expression, \name{lcof} returns the
expression. 
\end{Comments}
\end{Operator}


\begin{Operator}{LENGTH}
\index{list}
The \name{length} operator returns the number of items in a \nameref{list}, the 
number of
terms in an expression, or the dimensions of an array or matrix.
\begin{Syntax}
\name{length}\(\meta{expr}\) or \name{length} \meta{expr}
\end{Syntax}

\meta{expr} can be a list structure, an array, a matrix, or a scalar expression.

\begin{Examples}
alist := \{a,b,\{ww,xx,yy,zz\}\};                           &
             ALIST := \{A,B,\{WW,XX,YY,ZZ\}\} \\
length alist;                &     3  \\
length third alist;          &     4  \\
dlist := \{d\};                &     DLIST := \{D\} \\
length rest dlist;           &     0  \\
matrix mmm(4,5);  \\
length mmm;                  &     \{4,5\} \\
array aaa(5,3,2); \\
length aaa;                  &     \{6,4,3\} \\
eex := (x+3)**2/(x-y);       &     EEX := \rfrac{X^{2} + 6*X + 9}{X - Y} \\
length eex;                  &     5
\end{Examples}

\begin{Comments}
An item in a list that is itself a list only counts as one item.  An error
message will be printed if \name{length} is called on a matrix which has
not had its dimensions set.  The \name{length} of an array includes the
zeroth element of each dimension, showing the full number of elements
allocated. (Declaring an array \IFTEX{$A$}{A} with \IFTEX{$n$}{n} elements
allocates \IFTEX{$ A(0),A(1),\ldots,A(n)$}{A(0),A(1),...,A(n)}.) The
\name{length} of an expression is the total number of additive terms
appearing in the numerator and denominator of the expression.  Note that
subtraction of a term is represented internally as addition of a negative
term.
\end{Comments}
\end{Operator}


\begin{Operator}{LHS}
\index{left-hand side}\index{equation}
The \name{lhs} operator returns the left-hand side of an \nameref{equation},
such as those
returned in a list by \nameref{solve}.
\begin{Syntax}
\name{lhs}\(\meta{equation}\) or \name{lhs} \meta{equation}

\end{Syntax}

\meta{equation} must be an equation of the form \\
\name{left-hand side} \name{=} \name{right-hand side}.

\begin{Examples}
polly := (x+3)*(x^4+2x+1); &
POLLY := X^{5} + 3*X^{4} + 2*X^{2} + 7*X + 3 \\
pollyroots := solve(polly,x); &
\begin{multilineoutput}{1cm}
POLLYROOTS := \{X=ROOT_OF(X_^{3} - X_^{2} + X_ + 1,X_),
               X=-1,
               X=-3\}
\end{multilineoutput} \\
variable := lhs first pollyroots; &
VARIABLE := X
\end{Examples}
\end{Operator}


\begin{Operator}{LIMIT}
\index{limit}\index{l'Hopital's rule}
LIMITS is  a fast limit  package for REDUCE  for functions which  are
continuous except  for computable poles  and singularities, based  on
some earlier  work by Ian  Cohen and John  P. Fitch.   The  Truncated
Power  Series package  is  used  for non-critical  points,  at  which
the  value of  the function  is the  constant term  in the  expansion
around  that point.    l'Hopital's rule  is used  in critical  cases,
with preprocessing  of 1-1  forms and reformatting  of product  forms
in order to apply l'Hopital's rule.   A limited amount of bounded
arithmetic is also employed where applicable.        

\begin{Syntax}
\name{limit}\(\meta{expr},\meta{var},\meta{limpoint}\) or \\
\name{limit!+}\(\meta{expr},\meta{var},\meta{limpoint}\) or \\
\name{limit!-}\(\meta{expr},\meta{var},\meta{limpoint}\) 
\end{Syntax}

where \meta{expr} is an expression depending of the variable \meta{var}
(a \nameref{kernel}) and \meta{limpoint} is the limit point. 
If the limit depends upon the direction of approach to  the \meta{limpoint},
the operators \name{limit!+} and \name{limit!-} may be used.

\begin{Examples}
limit(x*cot(x),x,0);&0\\
limit((2x+5)/(3x-2),x,infinity);&\rfrac{2}{3}\\
\end{Examples}

\end{Operator}


\begin{Operator}{LPOWER}
\index{leading power}\index{polynomial}
The \name{lpower} operator returns the leading power of an expression with
respect to a kernel.  1 is returned if the expression does not depend on
the kernel.
\begin{Syntax}
\name{lpower}\(\meta{expression},\meta{kernel}\)
\end{Syntax}

\meta{expression} is ordinarily a polynomial. If \nameref{ratarg} is on,
a rational expression may also be used, otherwise an error results.
\meta{kernel} must be a \nameref{kernel}.

\begin{Examples}
lpower((x+2*y)**6,y);        &     Y^{6} \\
lpower((x + cos(x))**8 + df(x**2,x),cos(x));
			     &     COS(X)^{8} \\
lpower(x**3 + 3*x,y);        &     1
\end{Examples}
\end{Operator}

\begin{Operator}{LTERM}
\index{leading term}\index{polynomial}
The \name{lterm} operator returns the leading term of an expression with
respect to a kernel.  The expression is returned if it does not depend on
the kernel.
\begin{Syntax}
\name{lterm}\(\meta{expression},\meta{kernel}\)
\end{Syntax}

\meta{expression} is ordinarily a polynomial. If \nameref{ratarg} is on,
a rational expression may also be used, otherwise an error results.
\meta{kernel} must be a \nameref{kernel}.

\begin{Examples}
lterm((x+2*y)**6,y);        &     64*Y^{6} \\
lterm((x + cos(x))**8 + df(x**2,x),cos(x));
			    &     COS(X)^{8} \\
lterm(x**3 + 3*x,y);        &     X^{3} + 3X
\end{Examples}
\end{Operator}


\begin{Operator}{MAINVAR}
\index{main variable}\index{polynomial}
The \name{mainvar} operator returns the main variable (in the system's
internal representation) of its argument.
\begin{Syntax}
\name{mainvar}\(\meta{expression}\)

\end{Syntax}

\meta{expression} is usually a polynomial, but may be any valid REDUCE
scalar expression.  In the case of a rational function, the main variable
of the numerator is returned.  The main variable returned is a
\nameref{kernel}.

\begin{Examples}
test := (a + b + c)**2;      &
     TEST := A^{2} + 2*A*B + 2*A*C + B^{2} + 2*B*C + C^{2} \\
mainvar(test);               &        A \\
korder c,b,a; \\
mainvar(test);               &        C \\
mainvar(2*cos(x)**2);        &        COS(X) \\
mainvar(17);                 &        0
\end{Examples}

\begin{Comments}
The main variable is the first variable in the canonical ordering of
kernels.  Generally, alphabetically ordered functions come first, then
alphabetically ordered identifiers (variables).  Numbers come last, and as
far as \name{mainvar} is concerned belong in the family \name{0}.  The
canonical ordering can be changed by the declaration \nameref{korder}, as
shown above.
\end{Comments}
\end{Operator}


\begin{Operator}{MAP}
\index{map}\index{composite structure}
The \name{map} operator applies a uniform evaluation pattern
to all members of a composite structure: a \nameref{matrix}, 
a \nameref{list} or the arguments of an \nameref{operator} expression. 
The evaluation pattern can be a
unary procedure, an operator, or an algebraic expression with
one free variable. 
\begin{Syntax}
  \name{map}\(\meta{function},\meta{object}\)
\end{Syntax}
\meta{object} is a list, a matrix or an operator expression.

\meta{function} is 
the name of an operator for a single argument: the operator
is evaluated once with each element of \meta{object} as its single argument,

or an algebraic expression with exactly one \nameref{free variable}, that is
a variable preceded by the tilde symbol: the expression
 is evaluated for each element of \meta{object} where the element is
 substituted for the free variable,

or a replacement \nameref{rule} of the form 
\begin{Syntax}
  \name{var} => \name{rep}
\end{Syntax}
  where \meta{var} is a variable (a \meta{kernel} without subscript)
 and \meta{rep} is an expression which contains \meta{var}.
  Here \name{rep} is evaluated for each element of \meta{object} where 
  the element is substituted for  \name{var}. \name{var} may be 
  optionally preceded by a tilde.

The rule form  for \meta{function} is needed when more than
one free variable occurs.

\begin{Examples}
map(abs,{1,-2,a,-a});         &   {1,2,abs(a),abs(a)} \\
map(int(~w,x), mat((x^2,x^5),(x^4,x^5))); &
\begin{multilineoutput}{1cm}
        [  3     6 ]
        [ x     x  ]
        [----  ----]
        [ 3     6  ]
        [          ]
        [  5     6 ]
        [ x     x  ]
        [----  ----]
	[ 5     6  ]
\end{multilineoutput}\\
map(~w*6, x^2/3 = y^3/2 -1); & 2*x^{2}=3*(y^{3}-2)\\
\end{Examples}

\begin{Comments}
You can use \name{map} in nested expressions. It is not allowed to
apply \name{map} for a non-composed object, e.g. an identifier or a number. 
\end{Comments}
\end{Operator}



\begin{Command}{MKID}
\index{identifier}
The \name{mkid} command constructs an identifier, given a stem and an identifier
or an integer.
\begin{Syntax}
\name{mkid}\(\meta{stem},\meta{leaf}\)
\end{Syntax}

\meta{stem} can be any valid REDUCE identifier that does not include escaped
special characters. \meta{leaf} may be an integer, including one given by a
local variable in a \nameref{for} loop, or any other legal group of
characters.

\begin{Examples}
mkid(x,3);                  &               X3 \\
factorize(x^15 - 1);        &  \begin{multilineoutput}{6cm}
\{X - 1,
 X^{2} + X + 1,
 X^{4} + X^{3} + X^{2} + X + 1,
 X^{8} - X^{7} + X^{5} - X^{4} + X^{3}  - X + 1\}
\end{multilineoutput}\\

for i := 1:length ws do write set(mkid(f,i),part(ws,i));
	  & \begin{multilineoutput}{6cm}
X^{8} - X^{7} + X^{5} - X^{4} + X^{3} - X + 1
X^{4} + X^{3} + X^{2} + X + 1
X^{2} + X + 1
X - 1
\end{multilineoutput} \\
\end{Examples}

\begin{Comments}
You can use \name{mkid} to construct identifiers from inside procedures.  This
allows you to handle an unknown number of factors, or deal with variable
amounts of data.  It is particularly helpful to attach identifiers to the
answers returned by \name{factorize} and \name{solve}.
\end{Comments}
\end{Command}


\begin{Operator}{NPRIMITIVE}
\index{primitive part}\index{polynomial}
\begin{Syntax}
\name{nprimitive}\(\meta{expression}\) or \name{nprimitive}
   \meta{simple\_expression}
\end{Syntax}
This operator returns the numerically-primitive part of any scalar
expression.  In other words, any overall integer factors in the expression
are removed.

\begin{Examples}
nprimitive((2x+2y)^2); & X^{2} + 2*X*Y + Y^{2} \\
nprimitive(3*a*b*c); & 3*A*B*C
\end{Examples}
\end{Operator}


\begin{Operator}{NUM}
\index{numerator}\index{rational expression}
The \name{num} operator returns the numerator of its argument.
\begin{Syntax}
\name{num}\(\meta{expression}\) or \name{num} \meta{simple\_expression}
\end{Syntax}

\meta{expression} can be any valid REDUCE scalar expression.

\begin{Examples}
num(100/6);                 &         50 \\
num(a/5 + b/6);             &         6*A + 5*B \\
num(sin(x));                &         SIN(X)
\end{Examples}

\begin{Comments}
\name{num} returns the numerator of the expression after it has been simplified
by REDUCE.  As seen in the examples, this includes putting sums of rational
expressions over a common denominator, and reducing common factors where
possible.  If the expression is not a rational expression, it is returned
unchanged.  
\end{Comments}
\end{Operator}


\begin{Operator}{ODESOLVE}
\index{differential equation}\index{solve}
The \name{odesolve} package is a solver for ordinary differential
equations.  At the present time it has still limited capabilities:

  1. it  can handle  only a single  scalar equation  presented as  an
     algebraic expression or equation, and

  2. it can solve only first-order equations of simple  types, linear
     equations with constant coefficients and Euler equations.

These  solvable  types  are exactly  those  for  which  Lie  symmetry
techniques give no useful information.

\begin{Syntax}

\name{odesolve}\(\meta{expr},\meta{var1},\meta{var2}\)

\end{Syntax}

\meta{expr} is  a single  scalar expression  such  that \meta{expr}=0  
is the ordinary differential equation (ODE for short) to be  solved, or
is an equivalent \nameref{equation}.

\meta{var1} is the name of the dependent variable,
\meta{var2} is the name of the independent variable.

A differential in \meta{expr} is expressed using the \nameref{df}
operator. Note that in most cases you must declare explicitly
\meta{var1} to depend of \meta{var2} using a \nameref{depend}
declaration -- otherwise the derivative might be evaluated to
zero on input to \name{odesolve}.

The returned value is a  list containing the equation giving the  general
solution  of the  ODE  (for simultaneous  equations  this will  be  a
list  of equations  eventually).    It  will contain  occurrences  of
the  operator \name{arbconst} for the  arbitrary constants  in the  general
solution.   The arguments of \name{arbconst} should  be new.
A counter  \name{!!arbconst}  is used  to  arrange  this.

\begin{Examples}
depend y,x;\\
\% A first-order linear equation, with an initial condition\\
ode:=df(y,x) + y * sin x/cos x - 1/cos x$\\
odesolve(ode,y,x); &  \{y=arbconst(1)*cos(x) + sin(x)\}
\end{Examples}      

\end{Operator}


\begin{Type}{ONE\_OF}
The operator \name{one\_of} is used to represent an indefinite choice
of one element from a finite set of objects. 
\begin{Examples}
x=one_of{1,2,5}\\
\explanation{this equation encodes that x can take one of the values
1,2 or 5}\\
\end{Examples}
REDUCE generates a \name{one\_of} form in cases when an implicit
\name{root\_of} expression could be converted to an explicit solution set.
A \name{one\_of} form can be converted to a \name{solve} solution using
\nameref{expand\_cases}.  See \nameref{root\_of}.
\end{Type}

\begin{Operator}{PART}
\index{decomposition}
The operator \name{part} permits the extraction of various parts or
operators of expressions and \nameref{list}\name{s}.
\begin{Syntax}
\name{part}\(\meta{expression,integer}\{,\meta{integer}\}\optional\)
\end{Syntax}

\meta{expression} can be any valid REDUCE expression or a list, {\it
integer} may be an expression that evaluates to a positive or negative
integer or 0.  A positive integer \meta{n} picks up the {\it n} th term,
counting from the first term toward the end.  A negative integer {\it n}
picks up the {\it n} th term, counting from the back toward the front.  The
integer 0 picks up the operator (which is \name{LIST} when the expression
is a \ref{list}).

\begin{Examples}
part((x + y)**5,4);          &        10*X^{2}*Y^{3} \\
part((x + y)**5,4,2);        &        X^{2} \\
part((x + y)**5,4,2,1);      &        X \\
part((x + y)**5,0);          &        PLUS \\
part((x + y)**5,-5);         &        5*X *Y^{4} \\
part((x + y)**5,4) := sin(x); &                          
  X^{5} + 5*X^{4}*Y + 10*X^{3}*Y^{2} + SIN(X) + 5*X*Y^{4} + Y^{5} \\
alist := \{x,y,\{aa,bb,cc\},x**2*sqrt(y)\};                 &
			 ALIST := \{X,Y,\{AA,BB,CC\},SQRT(Y)*X^{2}\} \\
part(alist,3,2);             &       BB \\
part(alist,4,0);             &       TIMES
\end{Examples}

\begin{Comments}
Additional integer arguments after the first one examine the
terms recursively, as shown above.  In the third line, the fourth term
is picked from the original polynomial, \IFTEX{$10x^2y^3$}{10x^2y^3},
then the second term from that, \IFTEX{$x^2$}{x^2}, and finally the first
component, \IFTEX{$x$}{x}.  If an integer's absolute value is too large for
the appropriate expression, a message is given.

\name{part} works on the form of the expression as printed, or as it would
have been printed at that point of the calculation, bearing in mind the
current switch settings.  It is important to realize that the switch settings
change the operation of \name{part}.  \nameref{pri} must be on when
\name{part} is used.

When \name{part} is used on a polynomial expression that has minus signs, the
\name{+} is always returned as the top-level operator.  The minus is found
as a unary operator attached to the negative term.

\name{part} can also be used to change the relevant part of the expression or
list as shown in the sixth example line.  The \name{part} operator returns the
changed expression, though original expression is not changed.  You can
also use \name{part} to change the operator.
\end{Comments}
\end{Operator}

\begin{Operator}{PF}
\index{partial fraction}\index{rational expression}
\begin{Syntax}
pf(\meta{expression},\meta{variable})
\end{Syntax}

\name{pf} transforms \meta{expression} into a \nameref{list} of partial fraction
s
with respect to the main variable, \meta{variable}. \name{pf} does a
complete partial fraction decomposition, and as the algorithms used are
fairly unsophisticated (factorization and the extended Euclidean
algorithm), the code may be unacceptably slow in complicated cases.
\begin{Examples}
pf(2/((x+1)^2*(x+2)),x); &
	\{\rfrac{2}{X + 2},\rfrac{-2}{X + 1},\rfrac{2}{X^{2} + 2*X + 1}\} \\
off exp; \\
pf(2/((x+1)^2*(x+2)),x);
 & \{\rfrac{2}{X + 2},\rfrac{- 2}{X + 1},\rfrac{2}{(X + 1)^{2}}\} \\
for each j in ws sum j; & \rfrac{2}{( + 2)*(X + 1)^{2}}
\end{Examples}

\begin{Comments}
If you want the denominators in factored form, turn \nameref{exp} off, as
shown in the second example above.  As shown in the final example, the
\nameref{for} \name{each} construct can be used to recombine the terms.
Alternatively, one can use the operations on lists to extract any desired
term.
\end{Comments}

\end{Operator}


\begin{Operator}{PROD}
\index{Gosper algorithm}\index{product}
The operator  \name{prod} returns
the indefinite or definite  product of a given expression.

\begin{Syntax}

\name{prod}\(\meta{expr},\meta{k}[,\meta{lolim} [,\meta{uplim} ]]\)

\end{Syntax}

where \meta{expr} is the expression to be multiplied, \meta{k} is the
control variable (a \nameref{kernel}), and \meta{lolim} and \meta{uplim}
uplim are the optional lower and upper limits. If \meta{uplim} is
not supplied the upper limit is taken as \meta{k}. The
Gosper algorithm is used.  If there is no closed form solution,
the operator returns the input unchanged.

\begin{Examples}
prod(k/(k-2),k);&k*( - k + 1)\\
\end{Examples}
\end{Operator}


\begin{Operator}{REDUCT}
\index{reductum}\index{polynomial}
The \name{reduct} operator returns the remainder of its expression after the
leading term with respect to the kernel in the second argument is removed.
\begin{Syntax}
\name{reduct}\(\meta{expression},\meta{kernel}\)
\end{Syntax}

\meta{expression} is ordinarily a polynomial. If \nameref{ratarg} is on,
a rational expression may also be used, otherwise an error results.
\meta{kernel} must be a \nameref{kernel}.

\begin{Examples}
reduct((x+y)**3,x);          &       Y*(3*X^{2} + 3*X*Y + Y^{2}) \\
reduct(x + sin(x)**3,sin(x));                           &       X \\
reduct(x + sin(x)**3,y);                         &      0
\end{Examples}

\begin{Comments}
If the expression does not contain the kernel, \name{reduct} returns 0.
\end{Comments}
\end{Operator}


\begin{Operator}{REPART}
\index{real part}\index{complex}
\begin{Syntax}
\name{repart}\(\meta{expression}\) or \name{repart} \meta{simple\_expression}
\end{Syntax}

This operator returns the real part of an expression, if that argument has an
numerical value.  A non-numerical argument is returned as an expression in
the operators \name{repart} and \nameref{impart}.
\begin{Examples}
repart(1+i);   & 1 \\
repart(a+i*b); & REPART(A) - IMPART(B)
\end{Examples}

\end{Operator}


\begin{Operator}{RESULTANT}
\index{polynomial}
The \name{resultant} operator computes the resultant of two polynomials with
respect to a given variable.  If the resultant is 0, the polynomials have
a root in common.
\begin{Syntax}
  \name{resultant}\(\meta{expression},\meta{expression},\meta{kernel}\)
\end{Syntax}

\meta{expression} must be a polynomial containing \meta{kernel} ;
\meta{kernel} must be a \nameref{kernel}.

\begin{Examples}
resultant(x**2 + 2*x + 1,x+1,x);                        &      0 \\
resultant(x**2 + 2*x + 1,x-3,x);                        &      16 \\
\begin{multilineinput}
resultant(z**3 + z**2 + 5*z + 5,
          z**4 - 6*z**3 + 16*z**2 - 30*z + 55,
          z);
\end{multilineinput}    &      0 \\
resultant(x**3*y + 4*x*y + 10,y**2 + 6*y + 4,y);       &
           Y^{6} + 18*Y^{5} + 120*Y^{4} + 360*Y^{3} + 480*Y^{2} + 288*Y + 64
\end{Examples}
\begin{Comments}
The resultant is the determinant of the Sylvester matrix, formed from the
coefficients of the two polynomials in the following way:

Given two polynomials: 

\begin{TEX}
\begin{displaymath}
a_0x^n+a_1x^{n-1}+\cdots+a_n
\end{displaymath}
\end{TEX}
\begin{INFO}
{\begin{verbatim}
    n       n-1 
 a x  + a1 x     + ... + an

\end{verbatim}}
\end{INFO}
and
\begin{TEX}
\begin{displaymath}
b_0x^n+b_1x^{n-1}+\cdots+b_n
\end{displaymath}
\end{TEX}
\begin{INFO}
{\begin{verbatim}
    m       m-1 
 b x  + b1 x     + ... + bm

\end{verbatim}}
\end{INFO}
form the  (m+n)x(m+n-1) Sylvester matrix by the following means:
\begin{TEX}
\begin{displaymath}
  \left(\begin{array}{cccccccc}
           0&\ldots&0&0&a_0&a_1&\ldots&a_n\\
	   0&\ldots&0&a_0&a_1&\ldots&a_n&0\\
	   \vdots&&&\vdots&&&\vdots\\
	   a_0&a_1&\ldots&a_n&0&0&\ldots&0\\
	   0&\ldots&0&0&b_0&b_1&\ldots&b_n\\
	   \vdots&&&\vdots&&&\vdots\\
	   b_0&b_1&\ldots&b_n&0&0&\ldots&0
         \end{array}\right)
\end{displaymath}
\end{TEX}
\begin{INFO}
{\begin{verbatim}
   0.......0 a  a1 .......... an
   0....0 a  a1 .......... an  0
       .    .   .   .  
   a0 a1 .......... an 0.......0
   0.......0 b  b1 .......... bm
   0....0 b  b1 .......... bm  0
       .    .   .   .  
   b  b1 .......... bm 0.......0  

\end{verbatim}}
\end{INFO}

If the determinant of this matrix is 0, the two polynomials have a common
root.  Finding the resultant of large expressions is time-consuming, due
to the time needed to find a large determinant.

The sign conventions \name{resultant} uses are those given in the article,
``Computing in Algebraic Extensions,'' by R.  Loos, appearing in
\meta{Computer Algebra--Symbolic and Algebraic Computation}, 2nd ed.,
edited by B.  Buchberger, G.E.  Collins and R.  Loos, and published by
Springer-Verlag, 1983.
These are:
\begin{TEX}
\begin{eqnarray*}
  \mbox{resultant}(p(x),q(x),x)
	&=& (-1)^{\deg p(x)*\deg q(x)}\cdot\mbox{resultant}(q(x),p(x),x),\\
  \mbox{resultant}(a,p(x),x) &=& a^{\deg p(x)},\\
  \mbox{resultant}(a,b,x) &=& 1
\end{eqnarray*}
where $p(x)$ and $q(x)$ are polynomials which have $x$ as a variable, and
$a$ and $b$ are free of $x$.
\end{TEX}
\begin{INFO}
{
\begin{verbatim}
  resultant(p(x),q(x),x) = (-1)^{deg p(x)*deg q(x)} * resultant(q(x),p(x),x),
  resultant(a,p(x),x)    = a^{deg p(x)},
  resultant(a,b,x)       = 1
\end{verbatim}
where p(x) and q(x) are polynomials which have x as a variable, and
a and b are free of x.
}
\end{INFO}

Error messages are given if \name{resultant} is given a non-polynomial
expression, or a non-kernel variable.
\end{Comments}
\end{Operator}


\begin{Operator}{RHS}
\index{right-hand side}\index{equation}
The \name{rhs} operator returns the right-hand side of an \nameref{equation}, 
such as those returned in a \nameref{list} by \nameref{solve}.
\begin{Syntax}
\name{rhs}\(\meta{equation}\) or \name{rhs} \meta{equation}
\end{Syntax}

\meta{equation} must be an equation of the form {\it left-hand side = right-hand
side}.

\begin{Examples}
roots := solve(x**2 + 6*x*y + 5x + 3y**2,x);            &
\begin{multilineoutput}{6cm}
    ROOTS := \{X= - \rfrac{SQRT(24*Y^{2} + 60*Y + 25) + 6*Y + 5}{2},
               X= \rfrac{SQRT(24*Y^{2} + 60*Y + 25) - 6*Y - 5}{2}\}
\end{multilineoutput} \\
root1 := rhs first roots;                               &
     ROOT1 := - \rfrac{SQRT(24*Y^{2} + 60*Y + 25) + 6*Y + 5}{2} \\
root2 := rhs second roots;                              &
     ROOT2 := \rfrac{SQRT(24*Y^{2} + 60*Y + 25) - 6*Y - 5}{2}
\end{Examples}

\begin{Comments}
An error message is given if \name{rhs} is applied to something other than an
equation.
\end{Comments}
\end{Operator}

\begin{Operator}{ROOT\_OF}
\index{roots}\index{solve}
When the operator \nameref{solve} is unable to find an explicit solution
or if that solution would be too complicated, the result is presented
as formal root expression using the internal operator \name{root\_of}
and a new local variable. An expression with a top level \name{root\_of}
is implicitly a list with an unknown number of elements since we
can't always know how many solutions an equation has. If a
substitution is made into such an expression, closed form solutions
can emerge. If this occurs, the \name{root\_of} construct is
replaced by an operator \nameref{one\_of}. At this point it is
of course possible to transform the result if the original \name{solve}
operator expression into a standard \name{solve} solution. To
effect this, the operator \nameref{expand\_cases} can be used.

\begin{Examples}
solve(a*x^7-x^2+1,x);&
\{x=root\_of(a*x\_^7 - x\_^2 + 1,x\_)\}\\
sub(a=0,ws);&
\{x=one\_of(1,-1)\}\\
expand_cases ws;&
{x=1,x=-1}\\
\end{Examples}
The components of \name{root\_of} and \name{one\_of} expressions can be
processed as usual with operators \nameref{arglength} and \nameref{part}.
A higher power of a \name{root\_of} expression with a polynomial
as first argument is simplified by using the polynomial as a side relation.
\end{Operator}

\begin{Operator}{SELECT}
\index{map}\index{list}

The \name{select} operator extracts from a list 
or from the arguments of an n--ary operator elements corresponding
to a boolean predicate. The predicate pattern can be a
unary procedure, an operator or an algebraic expression with
one \nameref{free variable}.
\begin{Syntax}
  \name{select}\(\meta{function},\meta{object}\)
\end{Syntax}
\meta{object} is a \nameref{list}.

\meta{function} is 
the name of an operator for a single argument: the operator
 is evaluated once with each element of \meta{object} as its single argument,

or an algebraic expression with exactly one \nameref{free variable}, that is
a variable preceded by the tilde symbol: the expression
 is evaluated for each element of \meta{object} where the element is
 substituted for the free variable,

or a replacement \nameref{rule} of the form 
\begin{Syntax}
  \name{var} => \name{rep}
\end{Syntax}
  where \meta{var} is a variable (a \meta{kernel} without subscript)
 and \meta{rep} is an expression which contains \meta{var}.
  Here \name{rep} is evaluated for each element of \meta{object} where 
  the element is substituted for  \name{var}. \name{var} may be 
  optionally preceded by a tilde.

The rule form  for \meta{function} is needed when more than
one free variable occurs. The evaluation result of \meta{function} is
interpreted as \nameref{boolean value} corresponding to the conventions of
REDUCE. The result value is built with the leading operator of the
input expression.
\begin{Examples}
  select( ~w>0 , {1,-1,2,-3,3}) &   \{1,2,3\} \\
  q:=(part((x+y)^5,0):=list)\\
  select(evenp deg(~w,y),q);& \{x^5 ,10*x^3 *y^2 ,5*x*y^4 \}\\
  select(evenp deg(~w,x),2x^2+3x^3+4x^4);& 2x^2+4x^4\\
\end{Examples}
\end{Operator}

\begin{Operator}{SHOWRULES}
\index{rule}\index{output}
\begin{Syntax}
\name{showrules}\(\meta{expression}\) or
 \name{showrules} \meta{simple\_expression}
\end{Syntax}

\name{showrules} returns in \nameref{rule}\name{-list} form any 
\nameref{operator} rules associated with its argument.

\begin{Examples}
showrules log; &
\begin{multilineoutput}{6cm}
\{LOG(E) => 1,
 LOG(1) => 0,
 LOG(E^{~X} ) => ~X,
 DF(LOG(~X),~X) => \rfrac{1}{~X}\}
\end{multilineoutput}
\end{Examples}

Such rules can then be manipulated further as with any \nameref{list}.  For
example
\name{rhs first ws;} has the value {\em 1}.

\begin{Comments}
An operator may have properties that cannot be displayed in such a form,
such as the fact it is an \ref{odd} function, or has a definition defined
as a procedure.
\end{Comments}
\end{Operator}


\begin{Operator}{SOLVE}
\index{equation}\index{equation solving}
\index{equation system}\index{root}\index{solve}
The \name{solve} operator solves a single algebraic \nameref{equation} or a
system of simultaneous equations.
\begin{TEX}
\begin{Syntax}
% \name{solve}\(\meta{expression} \&option(, \meta{kernel})\) or
% \name{solve}\(\name{\{}\meta{expression}\{,\meta{expression}\}
%    \optional\name{\}}
%           \&option(,\meta{kernel}\optional\)
\name{solve}\(\meta{expression}\&option(, \meta{kernel})\) or \\
 \name{solve}\(\name{\{}\meta{expression}\&option( ,\meta{expression})
 \optional\name{\}}
	  \&option(,\{\meta{kernel})\optional\name{\}\}}\)
\end{Syntax}
\end{TEX}
\begin{INFO}
{\begin{Syntax}
\name{solve}\(\meta{expression} [ , \meta{kernel}]\) or

\name{solve}\(\{\meta{expression},...\} [ ,\{ \meta{kernel} ,...\}] \)
\end{Syntax} 
}\end{INFO}

If the number of equations equals the number of distinct kernels, the
optional kernel argument(s) may be omitted.  \meta{expression} is either a
scalar expression or an \nameref{equation}.  
When more than one expression is given,
the \nameref{list} of expressions is surrounded by curly braces.
The optional list
of \nameref{kernel}s follows, also in curly braces.

\begin{Examples}
sss := solve(x^2 + 7);      &
\begin{multilineoutput}{6cm}
Unknown: X
SSS := \{X= - SQRT(7)*I,
        X=SQRT(7)*I\}
\end{multilineoutput}\\
rhs first sss;               &       - SQRT(7)*I \\
solve(sin(x^2*y),y);        &
\begin{multilineoutput}{6cm}
\{Y=\rfrac{2*ARBINT(1)*PI}{X^{2}}
 Y=\rfrac{PI*(2*ARBINT(1) + 1)}{X^{2}}\}
\end{multilineoutput}\\
off allbranch; \\
solve(sin(x**2*y),y);        &      \{Y=0\} \\
solve({3x + 5y = -4,2*x + y = -10},{x,y});
   & \{\{X= - \rfrac{22}{7},Y=\rfrac{46}{7}\}\} \\
solve({x + a*y + z,2x + 5},{x,y});
   &       \{\{X= - \rfrac{5}{2},Y= - \rfrac{2*Z - 5}{2*A}\}\} \\
% xval := rhs part(ws,1,1);    &       XVAL := - \rfrac{5}{2} \\
ab := (x+2)^2*(x^6 + 17x + 1);
 &      AB := X^{8} + 4*X^{7} + 4*X^{6} + 17*X^{3} + 69*X^{2} + 72*X + 4 \\
www := solve(ab,x);          &      \{X=ROOT_OF(X_^{6} + 17*X_ + 1),X=-2\} \\
root_multiplicities;         &      \{1,2\}
\end{Examples}
\begin{Comments}
Results of the \name{solve} operator are returned as \nameref{equation}\name{s} 
in a \nameref{list}.
You can use the usual list access methods (\nameref{first},
\nameref{second}, \nameref{third}, \nameref{rest} and \nameref{part}) to
extract the desired equation, and then use the operators \nameref{rhs} and
\nameref{lhs} to access the right-hand or left-hand expression of the
equation.  When \name{solve} is unable to solve an equation, it returns the
unsolved part as the argument of \name{root_of}, with the variable renamed
to avoid confusion, as shown in the last example above.

For one equation, \name{solve} uses square-free factorization, roots of
unity, and the known inverses of the \nameref{log}, \nameref{sin},
\nameref{cos}, \nameref{acos}, \nameref{asin}, and
exponentiation operators.  The quadratic, cubic and quartic formulas are
used if necessary, but these are applied only when the switch 
\nameref{fullroots} is set on; otherwise or when no closed form is available 
the result is returned as
\nameref{root\_of} expression. The switch \nameref{trigform}
determines which type of cubic and quartic formula is used.  
The multiplicity of each solution is given in a list as
the system variable \nameref{root\_multiplicities}.  For systems of
simultaneous linear equations, matrix inversion is used.  For nonlinear
systems, the Groebner basis method is used.

%If kernels are given for linear equations, and there are an unequal number
%of kernels and equations, an error message is given.  If no kernels are
%given, and there are more kernels in the equations than there are
%equations, an error message is given.  
Linear equation system solving is influenced by the switch \nameref{cramer}.
%For nonlinear equations, it is
%possible to have a consistent set in which the number of variables does not
%match the number of equations.

Singular systems can be solved when the switch \nameref{solvesingular} is
on, which is the default setting.  An empty list is returned the system of
equations is inconsistent. For a linear inconsistent system with parameters
the variable \nameref{requirements} constraints
conditions for the system to become consistent.

For a solvable linear and polynomial system with parameters 
the variable \nameref{assumptions}
contains a list side relations for the parameters: the solution is
valid only as long as none of these expressions is zero.

If the switch \nameref{varopt} is on (default), the system rearranges the 
variable sequence for minimal computation time. Without \name{varopt} 
the user supplied variable sequence is maintained.

If the solution has free variables (dimension of the solution is greater
than zero), these are represented by \nameref{arbcomplex} expressions 
as long as the switch \nameref{arbvars} is on (default). Without
\name{arbvars} no explicit equations are generated for free variables.
\end{Comments}

\begin{Related}
\item[\nameref{allbranch} switch]
\item[\nameref{arbvars} switch]
\item[\nameref{assumptions} variable]
\item[\nameref{fullroots} switch]
\item[\nameref{requirements} variable]
\item[\nameref{roots} operator]
\item[\nameref{root\_of} operator]
\item[\nameref{trigform} switch]
\item[\nameref{varopt} switch]
\end{Related}

\end{Operator}

\begin{Operator}{SORT}
\index{sorting}
The \name{sort} operator sorts the elements of a list according to
an arbitrary comparison operator.
\begin{Syntax}
\name{sort}\(\meta{lst},\meta{comp}\)
\end{Syntax}
\meta{lst} is a \nameref{list} of algebraic expressions.
\meta{comp} is a comparison operator which defines a partial
ordering among the members of \meta{lst}.  \meta{comp} may be
one of the builtin comparison operators like 
\name{<}(\nameref{lessp}), \name{<=}(\nameref{leq})
etc., or  \meta{comp}  may be the name of a comparison procedure.
Such a procedure has two arguments, and it returns 
\nameref{true} if the first argument
ranges before the second one, and 0 or \nameref{nil} otherwise.
The result of \name{sort} is a new list which contains the
elements of \meta{lst} in a sequence corresponding to \meta{comp}.
\begin{Examples}
 % Sort random integers\\
procedure ce(a,b);\\
   if evenp a and not evenp b then 1 else 0;\\
for i:=1:10 collect random(50)$\\
sort(ws,>=); & \{41,38,33,30,28,25,20,17,8,5\}\\
sort(ws,<); & \{5,8,17,20,25,28,30,33,38,41\}\\
sort(ws,ce); &\{8,20,28,30,38,5,17,25,33,41\}\\
 % Sort a set of polynomials, first for degree of x\\
 % and second for degree of y.\\
procedure cd(a,b);\\
  if deg(a,x)>deg(b,x) then 1 else\\
  if deg(a,x)<deg(b,x) then 0 else\\
  if deg(a,y)>deg(b,y) then 1 else 0;\\
sort({x^2,y^2,x*y},cd);&\{x^2,x*y,y^2\}
\end{Examples}
\end{Operator}

\begin{Operator}{STRUCTR}
\index{decomposition}
The \name{structr} operator breaks its argument expression into named
subexpressions.
\begin{TEX}
\begin{Syntax}
\name{structr}\(\meta{expression} \&option(,\meta{identifier}
                                  \&option(,\meta{identifier}))\)
\end{Syntax}
\end{TEX}
\begin{Syntax}
\name{structr}\(\meta{expression} [,\meta{identifier}[,\meta{identifier} ...]]\)
\end{Syntax}
\begin{INFO}
\end{INFO}
\meta{expression} may be any valid REDUCE scalar expression.
\meta{identifier} may be any valid REDUCE \name{identifier}.  The first
identifier
is the stem for subexpression names, the second is the name to be assigned
to the structured expression.

\begin{Examples}
structr(sqrt(x**2 + 2*x) + sin(x**2*z));     &
\begin{multilineoutput}{6cm}
ANS1 + ANS2
    where
        ANS2 := SIN(X^{2}*Z)
        ANS1 := ((X + 2)*X)^{1/2}
\end{multilineoutput}\\
ans3;                        &      ANS3 \\
on fort; \\
structr((x+1)**5 + tan(x*y*z),var,aa);                  &
\begin{multilineoutput}{6cm}
VAR1=TAN(X*Y*Z)
AA=VAR1+X**5+5.*X**4+10.*X**3+10.X**2+5.*X+1
\end{multilineoutput}
\end{Examples}
\begin{Comments}
The second argument to \name{structr} is optional.  If it is not given, the
default stem \name{ANS} is used by REDUCE to construct names for the
subexpression.  The names are only for display purposes: REDUCE does not
store the names and their values unless the switch \nameref{savestructr} is
on.

If a third argument is given, the structured expression as a whole is named by
this argument, when \nameref{fort} is on.  The expression is not stored
under this
name.  You can send these structured Fortran expressions to a file with the
\name{out} command.
\end{Comments}
\end{Operator}


\begin{Operator}{SUB}
\index{substitution}
The \name{sub} operator substitutes a new expression for a kernel in an
expression.
\begin{Syntax}
%\name{sub}\(\meta{kernel}\name{=}\meta{expression}%
%            \{,\meta{kernel}\name{=}\meta{expression}\}\optional,%
%            \meta{expression}\)
\name{sub}\(\meta{kernel}\name{=}\meta{expression}
	    \{,\meta{kernel}\name{=}\meta{expression}\}\optional,
	    \meta{expression}\) or \\
\name{sub}\(\{\meta{kernel}\name{=}\meta{expression}\optional,
	    \meta{kernel}\name{=}\name{expression}\},\meta{expression}\)
\end{Syntax}

\meta{kernel} must be a \nameref{kernel}, \meta{expression} can be any REDUCE
scalar expression.

\begin{Examples}
sub(x=3,y=4,(x+y)**3);       &             343 \\
x;                           &             X \\
sub({cos=sin,sin=cos},cos a+sin b) & COS(B) + SIN(A)
\end{Examples}
\begin{Comments}
Note in the second example that operators can be replaced using the
\name{sub} operator.
\end{Comments}
\end{Operator}


\begin{Operator}{SUM}
\index{Gosper algorithm}\index{summation}
The operator  \name{sum} returns
the indefinite or definite  summation of a given expression.

\begin{Syntax}

\name{sum}\(\meta{expr},\meta{k}[,\meta{lolim} [,\meta{uplim} ]]\)

\end{Syntax}

where \meta{expr} is the expression to be added, \meta{k} is the
control variable (a \nameref{kernel}), and \meta{lolim} and \meta{uplim}
are the optional lower and upper limits. If \meta{uplim} is
not supplied the upper limit is taken as \meta{k}. The Gosper
algorithm is used. If  there is  no closed  form solution,  the operator 
returns the input unchanged.

\begin{Examples}
sum(4n**3,n); &n^2 *(n^2  + 2*n + 1)\\
sum(2a+2k*r,k,0,n-1);& n*(2*a + n*r - r)\\
\end{Examples}
\end{Operator}


\begin{Operator}{WS}
\index{work space}\index{interactive}
The \name{ws} operator alone returns the last result; \name{ws} with a
number argument returns the results of the REDUCE statement executed after
that numbered prompt.
\begin{Syntax}
\name{ws} or \name{ws}\(\meta{number}\)
\end{Syntax}


\meta{number} must be an integer between 1 and the current REDUCE prompt number.

\begin{Examples}

\explanation{(In the following examples, unlike most others, the numbered
prompt is shown.)} \\
1: df(sin y,y);    & COS(Y) \\
2: ws^2;           & COS(Y)^{2} \\
3: df(ws 1,y);     & -SIN(Y)
\end{Examples}

\begin{Comments}
\name{ws} and \name{ws}\name{(}\meta{number}\name{)} can be used anywhere the
expression they stand for can be used.  Calling a number for which no
result was produced, such as a switch setting, will give an error message.

The current workspace always contains the results of the last REDUCE
command that produced an expression, even if several input statements
that do not produce expressions have intervened.  For example, if you do
a differentiation, producing a result expression, then change several
switches, the operator \name{ws;} returns the results of the differentiation.
The current workspace (\name{ws}) can also be used inside files, though the
numbered workspace contains only the \name{in} command that input the file.

There are three history lists kept in your REDUCE session.  The first
stores raw input, suitable for the statement editor.  The second stores
parsed input, ready to execute and accessible by \nameref{input}.  The
third stores results, when they are produced by statements, which are
accessible by the \name{ws}\meta{ n} operator.  If your session is very
long, storage space begins to fill up with these expressions, so it is a
good idea to end the session once in a while, saving needed expressions to
files with the \nameref{saveas} and \nameref{out} commands.
% Or you could use the \name{forget} command to clear all history lists and
% reset the prompt number to 1, which doesn't change any switch settings or
% variable assignments.

An error message is given if a reference number has not yet been used.
\end{Comments}
\end{Operator}

