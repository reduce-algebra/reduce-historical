{\rtf1\ansi \deff0{\fonttbl{\f0\froman Tms Rmn;}
{\f1\fdecor Symbol;}
{\f2\fswiss Helv;}
{\f3\fmodern pica;}
{\f4\fmodern Courier;}
{\f5\fmodern elite;}
{\f6\fmodern prestige;}
{\f7\fmodern lettergothic;}
{\f8\fmodern gothicPS;}
{\f9\fmodern cubicPS;}
{\f10\fmodern lineprinter;}
{\f11\fswiss Helvetica;}
{\f12\fmodern avantegarde;}
{\f13\fmodern spartan;}
{\f14\fmodern metro;}
{\f15\fmodern presentation;}
{\f16\fmodern APL;}
{\f17\fmodern OCRA;}
{\f18\fmodern OCRB;}
{\f19\froman boldPS;}
{\f20\froman emperorPS;}
{\f21\froman madaleine;}
{\f22\froman zapf humanist;}
{\f23\froman classic;}
{\f24\froman roman f;}
{\f25\froman roman g;}
{\f26\froman roman h;}
{\f27\froman timesroman;}
{\f28\froman century;}
{\f29\froman palantino;}
{\f30\froman souvenir;}
{\f31\froman garamond;}
{\f32\froman caledonia;}
{\f33\froman bodini;}
{\f34\froman university;}
{\f35\fscript Script;}
{\f36\fscript scriptPS;}
{\f37\fscript script c;}
{\f38\fscript script d;}
{\f39\fscript commercial script;}
{\f40\fscript park avenue;}
{\f41\fscript coronet;}
{\f42\fscript script h;}
{\f43\fscript greek;}
{\f44\froman kana;}
{\f45\froman hebrew;}
{\f46\froman roman s;}
{\f47\froman russian;}
{\f48\froman roman u;}
{\f49\froman roman v;}
{\f50\froman roman w;}
{\f51\fdecor narrator;}
{\f52\fdecor emphasis;}
{\f53\fdecor zapf chancery;}
{\f54\fdecor decor d;}
{\f55\fdecor old english;}
{\f56\fdecor decor f;}
{\f57\fdecor decor g;}
{\f58\fdecor cooper black;}
{\f59\fnil linedraw;}
{\f60\fnil math7;}
{\f61\fnil math8;}
{\f62\fnil bar3of9;}
{\f63\fnil EAN;}
{\f64\fnil pcline;}
{\f65\fnil tech h;}
{\f66\fswiss Helvetica-Narrow;}
{\f67\fmodern Modern;}
{\f68\froman Roman;}}

{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;
\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;}
{\stylesheet{\s244 \fs16\up6 \sbasedon0\snext0 footnote reference;}
{\s245 \fs20 \sbasedon0\snext245 footnote text;}
{\s246\li720 \i\fs20 
\sbasedon0\snext255 heading 9;}
{\s247\li720 \i\fs20 \sbasedon0\snext255 heading 8;}
{\s248\li720 \i\fs20 \sbasedon0\snext255 heading 7;}
{\s249\li720 \fs20\ul \sbasedon0\snext255 heading 6;}
{\s250\li720 \b\fs20 \sbasedon0\snext255 heading 5;}
{\s251\li360 
\ul \sbasedon0\snext255 heading 4;}
{\s252\li360 \b \sbasedon0\snext255 heading 3;}
{\s253\sb120 \b\f2 \sbasedon0\snext0 heading 2;}
{\s254\sb240 \b\f2\ul \sbasedon0\snext0 heading 1;}
{\s255\li720 \fs20 \sbasedon0\snext255 Normal Indent;}
{\fs20 
\snext0 Normal;}
{\s2\fi-240\li480\sb80\tx480 \f11 \sbasedon0\snext2 nscba;}
{\s3\fi-240\li240\sa20 \f11 \sbasedon0\snext3 j;}
{\s4\li480\sa20 \f11 \sbasedon0\snext4 ij;}
{\s5\sb80\sa20 \f11 \sbasedon0\snext5 btb;}
{\s6\fi-240\li2400\sb20\sa20 \f11\fs20 
\sbasedon0\snext6 ctcb;}
{\s7\fi-240\li480\sa40\tx480 \f11 \sbasedon0\snext7 ns;}
{\s8\sa120 \f11\fs28 \sbasedon0\snext8 TT;}
{\s9\fi-240\li2400\sa20 \f11 \sbasedon0\snext9 crtj;}
{\s10\fi-240\li480\tx480 \f11 \sbasedon0\snext10 nsca;}
{\s11\sa20 \f11 
\sbasedon0\snext11 bt;}
{\s12\li240\sb120\sa40 \f11 \sbasedon0\snext12 Hf;}
{\s13\li240\sb120\sa40 \f11 \sbasedon0\snext13 Hs;}
{\s14\li480\sb120\sa40 \f11 \sbasedon0\snext14 RT;}
{\s15\fi-2160\li2160\sb240\sa80\tx2160 \f11 \sbasedon0\snext15 c;}
{
\s16\li2160\sa20 \f11 \sbasedon0\snext16 ct;}
{\s17\li240\sa20 \f11 \sbasedon0\snext17 it;}
{\s18\li480 \f11\fs20 \sbasedon0\snext18 nsct;}
{\s19\fi-160\li400\sb80\sa40 \f11 \sbasedon0\snext19 nscb;}
{\s20\fi-2640\li2880\sb120\sa40\brdrb\brdrs \brdrbtw\brdrs 
\tx2880 \f11 \sbasedon0\snext20 HC2;}
{\s21\fi-2640\li2880\sb120\sa20\tx2880 \f11 \sbasedon0\snext21 C2;}
{\s22\fi-240\li2400\sa20 \f11\fs20 \sbasedon0\snext22 ctc;}
{\s23\li2160\sb160 \f11 \sbasedon0\snext23 crt;}
{\s24\li480\sb20\sa40 \f11 
\sbasedon0\snext24 or;}}

{\info{\author Dan Davids}{\operator Dan Davids}{\creatim\yr2137\mo8\dy7}
{\revtim\yr1990\mo5\dy9\hr16\min54}{\version3}{\edmins3134}{\nofpages0}
{\nofwords65536}{\nofchars69885}{\vern8310}}

\ftnbj \sectd \linex576\endnhere 
\pard\plain \sl240 \fs20 



{\f2 
#{\footnote \pard\plain \sl240 \fs20 # IDENTIFIER}

${\footnote \pard\plain \sl240 \fs20 $ IDENTIFIER}

+{\footnote \pard\plain \sl240 \fs20 + g2:0644}

 K{\footnote \pard\plain \sl240 \fs20 K IDENTIFIER type;type}

}{\b\f2 IDENTIFIER}{\f2 \tab \tab \tab \tab }{\b\f2 type}{\f2 \par 
\par 
 
Identifiers in REDUCE consist of one or more alphanumeric characters, of 
which the first must be alphabetical. The maximum number of characters 
allowed is system dependent, but is usually over 100. However, printing 
is simplified if they are kept under 25 characters. 
\par 
\par 
You can also use special characters in your identifiers, but each must be 
preceded by an exclamation point }{\f3 !} {\f2  as an escape character. Useful 
special characters are }{\f3  # $ % ^ & * - + = ? < > ~ | / !} {\f2  and 
the space. Note that the use of the exclamation point as a special 
character requires a second exclamation point as an escape character. 
The underscore }{\f3 _} {\f2  is special in this regard. It must be preceded 
by an escape character in the first position in an identifier, but is 
treated like a normal letter within an identifier. 
\par 
\par 
Other characters, such as }{\f3 ( ) # ; ` ' "} {\f2  can also be used if 
preceded by a }{\f3 !} {\f2 , but as they have special meanings to the Lisp 
reader it is best to avoid them to avoid confusion. 
\par 
\par 
Many system identifiers have * before or after their names, or - between 
words. If you accidentally pick one of these names for your own identifier, 
it could have disastrous effects. For this reason it is wise not to include 
* or - anywhere in your identifiers. 
\par 
\par 
You will notice that REDUCE does not use the escape characters when it prints 
identifiers containing special characters; however, you still must use them 
when you refer to these identifiers. Be careful when editing statements 
containing escaped special characters to treat the character and its escape 
as an inseparable pair. 
\par 
\par 
Identifiers are used for variable names, labels for }{\f3 go to} {\f2  statements, 
and names of arrays, matrices, operators, and procedures. Once an identifier is 
used as a matrix, array, scalar or operator identifier, it may not be used 
again as a matrix, array or operator. An operator or array identifier may 
later be used as a scalar without problems, but a matrix identifier cannot be 
used as a scalar. All procedures are entered into the system as operators, so 
the name of a procedure may not be used as a matrix, array, or operator 
identifier either. 
 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # KERNEL}

${\footnote \pard\plain \sl240 \fs20 $ KERNEL}

+{\footnote \pard\plain \sl240 \fs20 + g2:0645}

 K{\footnote \pard\plain \sl240 \fs20 K KERNEL type;type}

}{\b\f2 KERNEL}{\f2 \tab \tab \tab \tab }{\b\f2 type}{\f2 \par 
\par 
 
A }{\f3 kernel} {\f2  is a form that cannot be modified further by the REDUCE 
canonical simplifier. Scalar variables are always kernels. The 
other important class of kernels are operators with their arguments. 
Some examples should help clarify this concept: 
\par 
\par 
\pard \tx3420 }{\f4  \par
        Expression                     Kernel? \par
 \par
          x                              Yes \par
          varname                        Yes \par
          cos(a)                         Yes \par
          log(sin(x**2))                 Yes \par
          a*b                            No \par
          (x+y)**4                       No \par
          matrix-identifier              No \par
\pard \sl240 }{\f2 Many REDUCE operators expect kernels among their arguments. Error messages 
result from attempts to use non-kernel expressions for these arguments. 
 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # STRING}

${\footnote \pard\plain \sl240 \fs20 $ STRING}

+{\footnote \pard\plain \sl240 \fs20 + g2:0646}

 K{\footnote \pard\plain \sl240 \fs20 K STRING type;type}

}{\b\f2 STRING}{\f2 \tab \tab \tab \tab }{\b\f2 type}{\f2 \par 
\par 
 
A }{\f3 string} {\f2  is any collection of characters enclosed in double quotation 
marks (}{\f3 "} {\f2 ). It may be used as an argument for a variety of commands 
and operators, such as }{\f3 in} {\f2 , }{\f3 rederr} {\f2  and }{\f3 write} {\f2 . 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
write "this is a string";  \par
 \par
  this is a string  \par
 \par
 \par
write a, " ", b, " ",c,"!";  \par
 \par
  A B C! \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g2}

${\footnote \pard\plain \sl240 \fs20 $ Concepts}

+{\footnote \pard\plain \sl240 \fs20 + index:0002}
}{\b\f2 Concepts}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb IDENTIFIER type}
{\v\f2 IDENTIFIER}{\f2 \par 
}{\f2 \tab}{\f2\uldb KERNEL type}
{\v\f2 KERNEL}{\f2 \par 
}{\f2 \tab}{\f2\uldb STRING type}
{\v\f2 STRING}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # assumptions}

${\footnote \pard\plain \sl240 \fs20 $ assumptions}

+{\footnote \pard\plain \sl240 \fs20 + g3:0647}

 K{\footnote \pard\plain \sl240 \fs20 K solve;assumptions variable;variable}

}{\b\f2 ASSUMPTIONS}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
After solving a linear or polynomial equation system 
with parameters, the variable }{\f3 assumptions} {\f2  contains a list 
of side relations for the parameters. The solution is valid only 
as long as none of these expression is zero. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
solve(\{a*x-b*y+x,y-c\},\{x,y\}); \par
 \par
       b*c \par
  \{\{x=-----,y=c\}\}  \par
      a + 1 \par
 \par
 \par
assumptions;  \par
 \par
  \{a + 1\} \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CARD\_NO}

${\footnote \pard\plain \sl240 \fs20 $ CARD_NO}

+{\footnote \pard\plain \sl240 \fs20 + g3:0648}

 K{\footnote \pard\plain \sl240 \fs20 K output;FORTRAN;CARD_NO variable;variable}

}{\b\f2 CARD\_NO}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
}{\f3 card_no} {\f2 sets the total number of cards allowed in a Fortran 
output statement when }{\f3 fort} {\f2  is on. Default is 20. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on fort;  \par
 \par
card_no := 4;  \par
 \par
  CARD_NO=4.  \par
 \par
 \par
z := (x + y)**15;  \par
 \par
        ANS1=5005.*X**6*Y**9+3003.*X**5*Y**10+1365.*X**4*Y** \par
       . 11+455.*X**3*Y**12+105.*X**2*Y**13+15.*X*Y**14+Y**15 \par
        Z=X**15+15.*X**14*Y+105.*X**13*Y**2+455.*X**12*Y**3+  \par
       . 1365.*X**11*Y**4+3003.*X**10*Y**5+5005.*X**9*Y**6+ \par
       . 6435.*X**8*Y**7+6435.*X**7*Y**8+ANS1 \par
 \par
\pard \sl240 }{\f2 Twenty total cards means 19 continuation cards. You may set it for more 
if your Fortran system allows more. Expressions are broken apart in a 
Fortran-compatible way if they extend for more than }{\f3 card_no} {\f2  
continuation cards. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # E}

${\footnote \pard\plain \sl240 \fs20 $ E}

+{\footnote \pard\plain \sl240 \fs20 + g3:0649}

 K{\footnote \pard\plain \sl240 \fs20 K E constant;constant}

}{\b\f2 E}{\f2 \tab \tab \tab \tab }{\b\f2 constant}{\f2 \par 
\par 
 
The constant }{\f3 e} {\f2  is reserved for use as the base of the natural 
logarithm. Its value is approximately 2.71828284590, which REDUCE gives 
to the current decimal precision when the switch }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on. 
\par 
\par 
}{\f3 e} {\f2 may be used as an iterative variable in a }
{\f2\uldb for}{\v\f2 FOR} 
{\f2  statement, 
or as a local variable or a }
{\f2\uldb procedure}{\v\f2 PROCEDURE} 
{\f2 . If }{\f3 e} {\f2  is defined 
as a local 
variable inside the procedure, the normal definition as the base of the 
natural logarithm would be suspended inside the procedure. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EVAL\_MODE}

${\footnote \pard\plain \sl240 \fs20 $ EVAL_MODE}

+{\footnote \pard\plain \sl240 \fs20 + g3:0650}

 K{\footnote \pard\plain \sl240 \fs20 K symbolic;algebraic;EVAL_MODE variable;variable}

}{\b\f2 EVAL\_MODE}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
The system variable }{\f3 eval_mode} {\f2  contains the current mode, either 
}
{\f2\uldb algebraic}{\v\f2 ALGEBRAIC} 
{\f2  or }
{\f2\uldb symbolic}{\v\f2 SYMBOLIC} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
EVAL\_MODE;  \par
 \par
  ALGEBRAIC \par
 \par
\pard \sl240 }{\f2 Some commands do not behave the same way in algebraic and symbolic modes. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FORT\_WIDTH}

${\footnote \pard\plain \sl240 \fs20 $ FORT_WIDTH}

+{\footnote \pard\plain \sl240 \fs20 + g3:0651}

 K{\footnote \pard\plain \sl240 \fs20 K FORTRAN;output;FORT_WIDTH variable;variable}

}{\b\f2 FORT\_WIDTH}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 fort_width} {\f2  variable sets the number of characters in a line of 
Fortran-compatible output produced when the }
{\f2\uldb fort}{\v\f2 FORT} 
{\f2  switch is on. 
Default is 70. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
fort_width := 30;  \par
 \par
  FORT_WIDTH := 30   \par
 \par
 \par
on fort;  \par
 \par
df(sin(x**3*y),x);  \par
 \par
        ANS=3.*COS(X \par
       . **3*Y)*X**2* \par
       . Y \par
 \par
\pard \sl240 }{\f2 }{\f3 fort_width} {\f2 includes the usually blank characters at the beginning 
of the card. As you may notice above, it is conservative and makes the 
lines even shorter than it was told. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # HIGH\_POW}

${\footnote \pard\plain \sl240 \fs20 $ HIGH_POW}

+{\footnote \pard\plain \sl240 \fs20 + g3:0652}

 K{\footnote \pard\plain \sl240 \fs20 K degree;polynomial;HIGH_POW variable;variable}

}{\b\f2 HIGH\_POW}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
The variable }{\f3 high_pow} {\f2  is set by }
{\f2\uldb coeff}{\v\f2 COEFF} 
{\f2  to the highest power 
of the variable of interest in the given expression. You can access this 
variable for use in further computation or display. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
coeff((x+1)^5*(x*(y+3)^2)^2,x);  \par
 \par
  \{0, \par
   0, \par
    4       3       2 \par
   Y  + 12*Y  + 54*Y  + 108*Y + 81, \par
       4       3       2 \par
   5*(Y  + 12*Y  + 54*Y  + 108*Y + 81), \par
        4       3       2 \par
   10*(Y  + 12*Y  + 54*Y  + 108*Y + 81), \par
        4       3       2 \par
   10*(Y  + 12*Y  + 54*Y  + 108*Y + 81), \par
       4       3       2 \par
   5*(Y  + 12*Y  + 54*Y  + 108*Y + 81), \par
    4       3       2 \par
   Y  + 12*Y  + 54*Y  + 108*Y + 81\} \par
 \par
 \par
high_pow;  \par
 \par
  7 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # I}

${\footnote \pard\plain \sl240 \fs20 $ I}

+{\footnote \pard\plain \sl240 \fs20 + g3:0653}

 K{\footnote \pard\plain \sl240 \fs20 K complex;I constant;constant}

}{\b\f2 I}{\f2 \tab \tab \tab \tab }{\b\f2 constant}{\f2 \par 
\par 
 
 \par 
\par 
REDUCE knows }{\f3 i} {\f2  is the square root of -1, 
 and that i^2 = -1. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
(a + b*i)*(c + d*i);  \par
 \par
  A*C + A*D*I + B*C*I - B*D  \par
 \par
 \par
i**2;  \par
 \par
  -1 \par
 \par
\pard \sl240 }{\f2 }{\f3 i} {\f2 cannot be used as an identifier. It is all right to use }{\f3 i} {\f2  
as an index variable in a }{\f3 for} {\f2  loop, or as a local (}{\f3 scalar} {\f2 ) 
variable inside a }{\f3 begin...end} {\f2  block, but it loses its definition as 
the square root of -1 inside the block in that case. 
\par 
\par 
Only the simplest properties of i are known by REDUCE unless 
the switch }
{\f2\uldb complex}{\v\f2 COMPLEX} 
{\f2  is turned on, which implements full complex 
arithmetic in factoring, simplification, and functional values. 
}{\f3 complex} {\f2  is ordinarily off. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # INFINITY}

${\footnote \pard\plain \sl240 \fs20 $ INFINITY}

+{\footnote \pard\plain \sl240 \fs20 + g3:0654}

 K{\footnote \pard\plain \sl240 \fs20 K INFINITY constant;constant}

}{\b\f2 INFINITY}{\f2 \tab \tab \tab \tab }{\b\f2 constant}{\f2 \par 
\par 
 
The name }{\f3 infinity} {\f2  is used to represent the infinite positive number. 
However, at the present time, arithmetic in terms of this operator reflects 
finite arithmetic, rather than true operations on infinity. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LOW\_POW}

${\footnote \pard\plain \sl240 \fs20 $ LOW_POW}

+{\footnote \pard\plain \sl240 \fs20 + g3:0655}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;degree;LOW_POW variable;variable}

}{\b\f2 LOW\_POW}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
The variable }{\f3 low_pow} {\f2  is set by }
{\f2\uldb coeff}{\v\f2 COEFF} 
{\f2  to the lowest power 
of the variable of interest in the given expression. You can access this 
variable for use in further computation or display. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
coeff((x+2*y)**6,y);  \par
 \par
    6 \par
  \{X , \par
       5 \par
   12*X , \par
       4 \par
   60*X , \par
        3 \par
   160*X , \par
        2 \par
   240*X , \par
   192*X, \par
   64\} \par
 \par
 \par
low_pow;  \par
 \par
  0  \par
 \par
 \par
coeff(x**2*(x*sin(y) + 1),x);  \par
			  \par
 \par
 \par
  \{0,0,1,SIN(Y)\}  \par
 \par
 \par
low_pow;  \par
 \par
  2 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # NIL}

${\footnote \pard\plain \sl240 \fs20 $ NIL}

+{\footnote \pard\plain \sl240 \fs20 + g3:0656}

 K{\footnote \pard\plain \sl240 \fs20 K false;NIL constant;constant}

}{\b\f2 NIL}{\f2 \tab \tab \tab \tab }{\b\f2 constant}{\f2 \par 
\par 
 
 \par 
\par 
}{\f3 nil} {\f2 represents the truth value false in symbolic mode, and is 
a synonym for 0 in algebraic mode. It cannot be used for any other 
purpose, even inside procedures or }
{\f2\uldb for}{\v\f2 FOR} 
{\f2  loops. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PI}

${\footnote \pard\plain \sl240 \fs20 $ PI}

+{\footnote \pard\plain \sl240 \fs20 + g3:0657}

 K{\footnote \pard\plain \sl240 \fs20 K PI constant;constant}

}{\b\f2 PI}{\f2 \tab \tab \tab \tab }{\b\f2 constant}{\f2 \par 
\par 
 
The identifier }{\f3 pi} {\f2  is reserved for use as the circular constant. 
Its value is given by 3.14159265358..., which REDUCE gives to the current 
decimal precision when REDUCE is in a floating-point mode. 
\par 
\par 
}{\f3 pi} {\f2 may be used as a looping variable in a }
{\f2\uldb for}{\v\f2 FOR} 
{\f2  statement, 
or as a local variable in a }
{\f2\uldb procedure}{\v\f2 PROCEDURE} 
{\f2 . Its value in such cases 
will be taken from the local environment. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # requirements}

${\footnote \pard\plain \sl240 \fs20 $ requirements}

+{\footnote \pard\plain \sl240 \fs20 + g3:0658}

 K{\footnote \pard\plain \sl240 \fs20 K solve;requirements variable;variable}

}{\b\f2 REQUIREMENTS}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
After an attempt to solve an inconsistent equation system 
with parameters, the variable }{\f3 requirements} {\f2  contains a list 
of expressions. These expressions define a set of conditions implicitly 
equated with zero. Any solution to this system defines a setting for 
the parameters sufficient to make the original system consistent. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
solve(\{x-a,x-y,y-1\},\{x,y\});  \par
 \par
  \{\} \par
 \par
 \par
requirements; \par
 \par
  \{a - 1\} \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ROOT\_MULTIPLICITIES}

${\footnote \pard\plain \sl240 \fs20 $ ROOT_MULTIPLICITIES}

+{\footnote \pard\plain \sl240 \fs20 + g3:0659}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;solve;root;ROOT_MULTIPLICITIES variable;variable}

}{\b\f2 ROOT\_MULTIPLICITIES}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 root_multiplicities} {\f2  variable is set to the list of the 
multiplicities of the roots of an equation by the }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  operator. 
\par 
\par 
}
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2 returns its solutions in a list. The multiplicities of 
each solution are put in the corresponding locations of the list 
}{\f3 root_multiplicities} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # T}

${\footnote \pard\plain \sl240 \fs20 $ T}

+{\footnote \pard\plain \sl240 \fs20 + g3:0660}

 K{\footnote \pard\plain \sl240 \fs20 K T constant;constant}

}{\b\f2 T}{\f2 \tab \tab \tab \tab }{\b\f2 constant}{\f2 \par 
\par 
 
The constant }{\f3 t} {\f2  stands for the truth value true. It cannot be used 
as a scalar variable in a }
{\f2\uldb block}{\v\f2 block} 
{\f2 , as a looping variable in a 
}
{\f2\uldb for}{\v\f2 FOR} 
{\f2  statement or as an }
{\f2\uldb operator}{\v\f2 OPERATOR} 
{\f2  name. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g3}

${\footnote \pard\plain \sl240 \fs20 $ Variables}

+{\footnote \pard\plain \sl240 \fs20 + index:0003}
}{\b\f2 Variables}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb assumptions variable}
{\v\f2 assumptions}{\f2 \par 
}{\f2 \tab}{\f2\uldb CARD\_NO variable}
{\v\f2 CARD\_NO}{\f2 \par 
}{\f2 \tab}{\f2\uldb E constant}
{\v\f2 E}{\f2 \par 
}{\f2 \tab}{\f2\uldb EVAL\_MODE variable}
{\v\f2 EVAL\_MODE}{\f2 \par 
}{\f2 \tab}{\f2\uldb FORT\_WIDTH variable}
{\v\f2 FORT\_WIDTH}{\f2 \par 
}{\f2 \tab}{\f2\uldb HIGH\_POW variable}
{\v\f2 HIGH\_POW}{\f2 \par 
}{\f2 \tab}{\f2\uldb I constant}
{\v\f2 I}{\f2 \par 
}{\f2 \tab}{\f2\uldb INFINITY constant}
{\v\f2 INFINITY}{\f2 \par 
}{\f2 \tab}{\f2\uldb LOW\_POW variable}
{\v\f2 LOW\_POW}{\f2 \par 
}{\f2 \tab}{\f2\uldb NIL constant}
{\v\f2 NIL}{\f2 \par 
}{\f2 \tab}{\f2\uldb PI constant}
{\v\f2 PI}{\f2 \par 
}{\f2 \tab}{\f2\uldb requirements variable}
{\v\f2 requirements}{\f2 \par 
}{\f2 \tab}{\f2\uldb ROOT\_MULTIPLICITIES variable}
{\v\f2 ROOT\_MULTIPLICITIES}{\f2 \par 
}{\f2 \tab}{\f2\uldb T constant}
{\v\f2 T}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # semicolon}

${\footnote \pard\plain \sl240 \fs20 $ semicolon}

+{\footnote \pard\plain \sl240 \fs20 + g4:0661}

 K{\footnote \pard\plain \sl240 \fs20 K semicolon command;command}

}{\b\f2 ;}{\f2 \tab }{\b\f2 SEMICOLON}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The semicolon is a statement delimiter, indicating results are to be printed 
when used in interactive mode. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
(x+1)**2;  \par
 \par
   2 \par
  X  + 2*X + 1  \par
 \par
 \par
df(x**2 + 1,x);  \par
 \par
  2*X \par
 \par
\pard \sl240 }{\f2 Entering a }{\f3 Return} {\f2  without a semicolon or dollar sign results in a 
prompt on the following line. A semicolon or dollar sign can be 
added at this point to execute the statement. In interactive mode, a 
statement that is ended with a semicolon and }{\f3 Return} {\f2  has its results 
printed on the screen. 
\par 
\par 
Inside a group statement }{\f3 <<} {\f2 ...}{\f3 >>} {\f2  
or a }{\f3 begin} {\f2 ...}{\f3 end} {\f2  block, a 
semicolon or dollar sign separates individual REDUCE statements. Since 
results are not printed from a block without a specific }{\f3 return} {\f2  
statement, there is no difference between using the semicolon or dollar 
sign. In a group statement, the last value produced is the value 
returned by the group statement. Thus, if a semicolon or dollar sign is 
placed between the last statement and the ending brackets, the group 
statement returns the value 0 or nil, rather than the value of the 
last statement. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # dollar}

${\footnote \pard\plain \sl240 \fs20 $ dollar}

+{\footnote \pard\plain \sl240 \fs20 + g4:0662}

 K{\footnote \pard\plain \sl240 \fs20 K dollar command;command}

}{\b\f2 $}{\f2 \tab }{\b\f2 DOLLAR}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The dollar sign is a statement delimiter, indicating results are not to be 
printed when used in interactive mode. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
(x+1)**2$ \pard \sl240 }{\f2 The workspace is set to }{\f4 x^2 + 2x + 1}{\f2  
 but nothing shows on the screen}{\f4 \pard \tx3420  \par
 \par
 \par
ws;  \par
 \par
   2 \par
  X   + 2*X + 1 \par
 \par
\pard \sl240 }{\f2  
\par 
\par 
Entering a }{\f3 Return} {\f2  without a semicolon or dollar sign results in a 
prompt on the following line. A semicolon or dollar sign can 
be added at this point to execute the statement. In interactive mode, a 
statement that ends with a dollar sign }{\f3 $} {\f2  and a }{\f3 Return} {\f2  is 
executed, but the results not printed. 
\par 
\par 
Inside a }
{\f2\uldb group}{\v\f2 group} 
{\f2  statement }{\f3 <<} {\f2 ...}{\f3 >>} {\f2  
or a }{\f3 begin} {\f2 ...}{\f3 end} {\f2  }
{\f2\uldb block}{\v\f2 block} 
{\f2 , a 
semicolon or dollar sign separates individual REDUCE statements. Since 
results are not printed from a }
{\f2\uldb block}{\v\f2 block} 
{\f2  without a specific 
}
{\f2\uldb return}{\v\f2 RETURN} 
{\f2 \par 
\par 
statement, there is no difference between using the semicolon or dollar 
sign. 
\par 
\par 
In a group statement, the last value produced is the value returned by the 
group statement. Thus, if a semicolon or dollar sign is placed between the 
last statement and the ending brackets, the group statement returns the 
value 0 or nil, rather than the value of the last statement. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # percent}

${\footnote \pard\plain \sl240 \fs20 $ percent}

+{\footnote \pard\plain \sl240 \fs20 + g4:0663}

 K{\footnote \pard\plain \sl240 \fs20 K percent command;command}

}{\b\f2 %}{\f2 \tab }{\b\f2 PERCENT}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The percent sign is used to precede comments; everything from a percent 
to the end of the line is ignored. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
df(x**3 + y,x);\% This is a comment \key\{Return\}  \par
 \par
 \par
     2 \par
  3*X   \par
 \par
 \par
int(3*x**2,x) \%This is a comment; \key\{Return\}  \par
\pard \sl240 }{\f2 A prompt is given, waiting for the semicolon that was not 
detected in the comment}{\f4 \pard \tx3420 \pard \sl240 }{\f2  
\par 
\par 
Statement delimiters }{\f3 ;} {\f2  and }{\f3 $} {\f2  are not detected between a 
percent sign and the end of the line. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # dot}

${\footnote \pard\plain \sl240 \fs20 $ dot}

+{\footnote \pard\plain \sl240 \fs20 + g4:0664}

 K{\footnote \pard\plain \sl240 \fs20 K list;dot operator;operator}

}{\b\f2 .}{\f2 \tab }{\b\f2 DOT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The . (dot) infix binary operator adds a new item to the beginning of an 
existing }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 . In high energy physics expressions, 
it can also be used 
to represent the scalar product of two Lorentz four-vectors. 
\par 
\par 
 \par
syntax: \par
}{\f4 <item> }{\f3 .} {\f4  <list> 
\par 
\par 
}{\f2 \par 
<item> can be any REDUCE scalar expression, including a list; 
<list> must be a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  to avoid producing an error message. 
The dot operator is right associative. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
liss := a . \{\};  \par
 \par
  LISS := \{A\}  \par
 \par
 \par
liss := b . liss;  \par
 \par
  LISS := \{B,A\}  \par
 \par
 \par
newliss := liss . liss;  \par
 \par
  NEWLISS := \{\{B,A\},B,A\}  \par
 \par
 \par
firstlis := a . b . \{c\};  \par
 \par
  FIRSTLIS := \{A,B,C\}  \par
 \par
 \par
secondlis := x . y . \{z\};  \par
 \par
  SECONDLIS := \{X,Y,Z\}  \par
 \par
 \par
for i := 1:3 sum part(firstlis,i)*part(secondlis,i); \par
  \par
 \par
 \par
  A*X + B*Y + C*Z \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # assign}

${\footnote \pard\plain \sl240 \fs20 $ assign}

+{\footnote \pard\plain \sl240 \fs20 + g4:0665}

 K{\footnote \pard\plain \sl240 \fs20 K assign;assign operator;operator}

}{\b\f2 :=}{\f2 \tab }{\b\f2 ASSIGN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 :=} {\f2  is the assignment operator, assigning the value on the right-hand 
side to the identifier or other valid expression on the left-hand side. 
\par 
\par 
 \par
syntax: \par
}{\f4 <restricted\_expression> }{\f3 :=} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<restricted\_expression> is ordinarily a single identifier, though simple 
expressions may be used (see Comments below). <expression> is any 
valid REDUCE expression. If <expression> is a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  
identifier, then 
<restricted\_expression> can be a matrix identifier (redimensioned if 
necessary) which has each element set to the corresponding elements 
of the identifier on the right-hand side. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := x**2 + 1;  \par
 \par
        2 \par
  A := X   + 1  \par
 \par
 \par
a;  \par
 \par
   2 \par
  X  + 1  \par
 \par
 \par
first := second := third;  \par
 \par
  FIRST := SECOND := THIRD  \par
 \par
 \par
first;  \par
 \par
  THIRD  \par
 \par
 \par
second;  \par
 \par
  THIRD  \par
 \par
 \par
b := for i := 1:5 product i;  \par
 \par
  B := 120  \par
 \par
 \par
b;  \par
 \par
  120  \par
 \par
 \par
w + (c := x + 3) + z;  \par
 \par
  W + X + Z + 3  \par
 \par
 \par
c;  \par
 \par
  X + 3  \par
 \par
 \par
y + b := c;  \par
 \par
  Y + B := C  \par
 \par
 \par
y;  \par
 \par
  - (B - C) \par
 \par
\pard \sl240 }{\f2 The assignment operator is right associative, as shown in the second and 
third examples. A string of such assignments has all but the last 
item set to the value of the last item. Embedding an assignment statement 
in another expression has the side effect of making the assignment, as well 
as causing the given replacement in the expression. 
\par 
\par 
Assignments of values to expressions rather than simple identifiers (such as in 
the last example above) can also be done, subject to the following remarks: 
\par 
\par 
\tab (i) 
If the left-hand side is an identifier, an operator, or a power, the 
substitution rule is added to the rule table. 
\par 
\par 
\tab (ii) 
If the operators }{\f3 - + /} {\f2  appear on the left-hand side, all but the first 
term of the expression is moved to the right-hand side. 
\par 
\par 
\tab (iii) 
If the operator }{\f3 *} {\f2  appears on the left-hand side, any constant terms are 
moved to the right-hand side, but the symbolic factors remain. 
\par 
\par 
Assignment is valid for }
{\f2\uldb array}{\v\f2 ARRAY} 
{\f2  elements, but not for entire arrays. 
The assignment operator can also be used to attach functionality to operators. 
\par 
\par 
A recursive construction such as }{\f3 a := a + b} {\f2  is allowed, but when 
}{\f3 a} {\f2  is referenced again, the process of resubstitution continues 
until the expression stack overflows (you get an error message). 
Recursive assignments can be done safely inside controlled loop 
expressions, such as }
{\f2\uldb for}{\v\f2 FOR} 
{\f2 ... or }
{\f2\uldb repeat}{\v\f2 REPEAT} 
{\f2 ...}{\f3 until} {\f2 . 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # equalsign}

${\footnote \pard\plain \sl240 \fs20 $ equalsign}

+{\footnote \pard\plain \sl240 \fs20 + g4:0666}

 K{\footnote \pard\plain \sl240 \fs20 K equalsign operator;operator}

}{\b\f2 =}{\f2 \tab }{\b\f2 EQUALSIGN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 =} {\f2  operator is a prefix or infix equality comparison operator. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 =} {\f4 (<expression>}{\f3 ,} {\f4 <expression>) 
 or 
 <expression> }{\f3 =} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<expression> can be any REDUCE scalar expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := 4;  \par
 \par
  A := 4  \par
 \par
 \par
if =(a,10) then write "yes" else write "no"; \par
  \par
 \par
 \par
  no  \par
 \par
 \par
b := c;  \par
 \par
  B := C  \par
 \par
 \par
if b = c then write "yes" else write "no"; \par
  \par
 \par
 \par
  yes  \par
 \par
 \par
on rounded;  \par
 \par
if 4.0 = 4 then write "yes" else write "no"; \par
  \par
 \par
 \par
  yes \par
 \par
\pard \sl240 }{\f2 This logical equality operator can only be used inside a conditional 
statement, such as }
{\f2\uldb if}{\v\f2 IF} 
{\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  
or }
{\f2\uldb repeat}{\v\f2 REPEAT} 
{\f2 ...}{\f3 until} {\f2 . In other places the equal 
sign establishes an algebraic object of type }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2 . 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # replace}

${\footnote \pard\plain \sl240 \fs20 $ replace}

+{\footnote \pard\plain \sl240 \fs20 + g4:0667}

 K{\footnote \pard\plain \sl240 \fs20 K replace operator;operator}

}{\b\f2 =>}{\f2 \tab }{\b\f2 REPLACE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
The }{\f3 =>} {\f2  operator is a binary operator used in }
{\f2\uldb rule}{\v\f2 RULE} 
{\f2  lists to 
denote replacements. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
operator f;  \par
 \par
let f(x) => x^2;  \par
 \par
f(x);  \par
 \par
   2 \par
  x \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # plussign}

${\footnote \pard\plain \sl240 \fs20 $ plussign}

+{\footnote \pard\plain \sl240 \fs20 + g4:0668}

 K{\footnote \pard\plain \sl240 \fs20 K plussign operator;operator}

}{\b\f2 +}{\f2 \tab }{\b\f2 PLUSSIGN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 +} {\f2  operator is a prefix or infix n-ary addition operator. 
\par 
\par 
 \par
syntax: \par
}{\f4 <expression> \{}{\f3 +} {\f4 <expression>\}+ 
\par 
\par 
or }{\f3 +} {\f4 (<expression> \{,<expression>\}+) 
\par 
\par 
}{\f2 \par 
<expression> may be any valid REDUCE expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
x**4 + 4*x**2 + 17*x + 1;  \par
 \par
   4      2 \par
  X  + 4*X  + 17*X + 1  \par
 \par
 \par
14 + 15 + x;  \par
 \par
  X + 29  \par
 \par
 \par
+(1,2,3,4,5);  \par
 \par
  15 \par
 \par
\pard \sl240 }{\f2 }{\f3 +} {\f2 is also valid as an addition operator for }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  variables 
that are of the same dimensions and for }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2 s. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # minussign}

${\footnote \pard\plain \sl240 \fs20 $ minussign}

+{\footnote \pard\plain \sl240 \fs20 + g4:0669}

 K{\footnote \pard\plain \sl240 \fs20 K minussign operator;operator}

}{\b\f2 -}{\f2 \tab }{\b\f2 MINUSSIGN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 -} {\f2  operator is a prefix or infix binary subtraction operator, as well 
as the unary minus operator. 
\par 
\par 
 \par
syntax: \par
}{\f4 <expression> }{\f3 -} {\f4  <expression> 
or }{\f3 -} {\f4 (<expression>,<expression>) 
\par 
\par 
}{\f2 \par 
<expression> may be any valid REDUCE expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
15 - 4;  \par
 \par
  11  \par
 \par
 \par
x*(-5);  \par
 \par
  - 5*X  \par
 \par
 \par
a - b - 15;  \par
 \par
  A - B - 15  \par
 \par
 \par
-(a,4);  \par
 \par
  A - 4 \par
 \par
\pard \sl240 }{\f2 The subtraction operator is left associative, so that a - b - c is equivalent 
to (a - b) - c, as shown in the third example. The subtraction operator is 
also valid with }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  expressions of the correct dimensions 
and with }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2 s. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # asterisk}

${\footnote \pard\plain \sl240 \fs20 $ asterisk}

+{\footnote \pard\plain \sl240 \fs20 + g4:0670}

 K{\footnote \pard\plain \sl240 \fs20 K asterisk operator;operator}

}{\b\f2 *}{\f2 \tab }{\b\f2 ASTERISK}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 *} {\f2  operator is a prefix or infix n-ary multiplication operator. 
\par 
\par 
 \par
syntax: \par
}{\f4 <expression> \{}{\f3 *} {\f4  <expression>\}+ 
\par 
\par 
or }{\f3 *} {\f4 (<expression> \{,<expression>\}+) 
\par 
\par 
}{\f2 \par 
<expression> may be any valid REDUCE expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
15*3;  \par
 \par
  45  \par
 \par
 \par
24*x*yvalue*2;  \par
 \par
  48*X*YVALUE  \par
 \par
 \par
*(6,x);  \par
 \par
  6*X  \par
 \par
 \par
on rounded;  \par
 \par
3*1.5*x*x*x;  \par
 \par
       3 \par
  4.5*X   \par
 \par
 \par
off rounded;  \par
 \par
2x**2;  \par
 \par
     2 \par
  2*X \par
 \par
\pard \sl240 }{\f2 REDUCE assumes you are using an implicit multiplication operator when an 
identifier is preceded by a number, as shown in the last line above. Since 
no valid identifiers can begin with numbers, there is no ambiguity in 
making this assumption. 
\par 
\par 
The multiplication operator is also valid with }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  expressions 
of the 
proper dimensions: matrices A and B 
can be multiplied if 
A is n x m and B is 
m x p. Matrices and }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2 s can also be 
multiplied by scalars: the 
result is as if each element was multiplied by the scalar. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # slash}

${\footnote \pard\plain \sl240 \fs20 $ slash}

+{\footnote \pard\plain \sl240 \fs20 + g4:0671}

 K{\footnote \pard\plain \sl240 \fs20 K slash operator;operator}

}{\b\f2 /}{\f2 \tab }{\b\f2 SLASH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 /} {\f2  operator is a prefix or infix binary division operator or 
prefix unary }
{\f2\uldb recip}{\v\f2 RECIP} 
{\f2 rocal operator. 
\par 
\par 
 \par
syntax: \par
}{\f4 <expression>}{\f3 /} {\f4 <expression> or 
 }{\f3 /} {\f4 <expression> 
\par 
\par 
or }{\f3 /} {\f4 (<expression>,<expression>) 
\par 
\par 
}{\f2 \par 
<expression> may be any valid REDUCE expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
20/5;  \par
 \par
  4   \par
 \par
 \par
100/6;  \par
 \par
  50 \par
  --  \par
  3 \par
 \par
 \par
16/2/x;  \par
 \par
  8 \par
  -  \par
  X \par
 \par
 \par
/b;  \par
 \par
  1 \par
  -  \par
  B \par
 \par
 \par
/(y,5);  \par
 \par
  Y \par
  -  \par
  5 \par
 \par
 \par
on rounded;  \par
 \par
35/4;  \par
 \par
  8.75  \par
 \par
 \par
/20;  \par
 \par
  0.05 \par
 \par
\pard \sl240 }{\f2 The division operator is left associative, so that }{\f3 a/b/c} {\f2  is equivalent 
to }{\f3 (a/b)/c} {\f2 . The division operator is also valid with square 
}
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  expressions of the same dimensions: With A and 
B both n x n matrices and B 
invertible, A/B is 
given by A*B^-1. 
Division of a matrix by a scalar is defined, with the results being the 
division of each element of the matrix by the scalar. Division of a 
scalar by a matrix is defined if the matrix is invertible, and has the 
effect of multiplying the scalar by the inverse of the matrix. When 
}{\f3 /} {\f2  is used as a reciprocal operator for a matrix, the inverse of 
the matrix is returned if it exists. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # power}

${\footnote \pard\plain \sl240 \fs20 $ power}

+{\footnote \pard\plain \sl240 \fs20 + g4:0672}

 K{\footnote \pard\plain \sl240 \fs20 K power operator;operator}

}{\b\f2 **}{\f2 \tab }{\b\f2 POWER}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 **} {\f2  operator is a prefix or infix binary exponentiation operator. 
\par 
\par 
 \par
syntax: \par
}{\f4 <expression> }{\f3 **} {\f4 <expression> 
 or }{\f3 **} {\f4 (<expression>,<expression>) 
\par 
\par 
}{\f2 \par 
<expression> may be any valid REDUCE expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
x**15;  \par
 \par
   15 \par
  X    \par
 \par
 \par
x**y**z;  \par
 \par
   Y*Z \par
  X     \par
 \par
 \par
x**(y**z);  \par
 \par
    Z \par
   Y \par
  X    \par
 \par
 \par
 **(y,4);  \par
 \par
   4 \par
  Y   \par
 \par
 \par
on rounded;  \par
 \par
2**pi;  \par
 \par
  8.82497782708 \par
 \par
\pard \sl240 }{\f2 The exponentiation operator is left associative, so that }{\f3 a**b**c} {\f2  is 
equivalent to }{\f3 (a**b)**c} {\f2 , as shown in the second example. Note 
that this is not }{\f3 a**(b**c)} {\f2 , which would be right associative. 
\par 
\par 
When }
{\f2\uldb nat}{\v\f2 NAT} 
{\f2  is on (the default), REDUCE output produces raised 
exponents, as shown. The symbol }{\f3 ^} {\f2 , which is the upper-case 6 on 
most keyboards, may be used in the place of }{\f3 **} {\f2 . 
\par 
\par 
A square }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  may also be raised to positive and negative powers 
with the exponentiation operator (negative powers require the matrix to be 
invertible). Scalar expressions and }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2 s may be raised to 
fractional and floating-point powers. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # caret}

${\footnote \pard\plain \sl240 \fs20 $ caret}

+{\footnote \pard\plain \sl240 \fs20 + g4:0673}

 K{\footnote \pard\plain \sl240 \fs20 K caret operator;operator}

}{\b\f2 ^}{\f2 \tab }{\b\f2 CARET}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 ^} {\f2  operator is a prefix or infix binary exponentiation operator. 
It is equivalent to }
{\f2\uldb power}{\v\f2 power} 
{\f2  or **. 
\par 
\par 
 \par
syntax: \par
}{\f4 <expression> }{\f3 ^} {\f4 <expression> 
 or }{\f3 ^} {\f4 (<expression>,<expression>) 
\par 
\par 
}{\f2 \par 
<expression> may be any valid REDUCE expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
x^15;  \par
 \par
   15 \par
  X    \par
 \par
 \par
x^y^z;  \par
 \par
   Y*Z \par
  X     \par
 \par
 \par
x^(y^z);  \par
 \par
    Z \par
   Y \par
  X    \par
 \par
 \par
^(y,4);  \par
 \par
   4 \par
  Y   \par
 \par
 \par
on rounded;  \par
 \par
2^pi;  \par
 \par
  8.82497782708 \par
 \par
\pard \sl240 }{\f2 The exponentiation operator is left associative, so that }{\f3 a^b^c} {\f2  is 
equivalent to }{\f3 (a^b)^c} {\f2 , as shown in the second example. Note 
that this is <not> }{\f3 a^(b^c)} {\f2 , which would be right associative. 
\par 
\par 
When }
{\f2\uldb nat}{\v\f2 NAT} 
{\f2  is on (the default), REDUCE output produces raised 
exponents, as shown. 
\par 
\par 
A square }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  may also be raised to positive 
and negative powers with 
the exponentiation operator (negative powers require the matrix to be 
invertible). Scalar expressions and }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2 s 
may be raised to fractional and floating-point powers. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # geqsign}

${\footnote \pard\plain \sl240 \fs20 $ geqsign}

+{\footnote \pard\plain \sl240 \fs20 + g4:0674}

 K{\footnote \pard\plain \sl240 \fs20 K geqsign operator;operator}

}{\b\f2 >=}{\f2 \tab }{\b\f2 GEQSIGN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
}{\f3 >=} {\f2  is an infix binary comparison operator, which returns true if 
its first argument is greater than or equal to its second argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 <expression> }{\f3 >=} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<expression> must evaluate to an integer or floating-point number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
if (3 >= 2) then yes;  \par
 \par
  yes  \par
 \par
 \par
a := 15;  \par
 \par
  A := 15  \par
 \par
 \par
if a >= 20 then big else small; \par
  \par
 \par
  small  \par
 \par
\pard \sl240 }{\f2 The binary comparison operators can only be used for comparisons between 
numbers or variables that evaluate to numbers. The truth values returned 
by such a comparison can only be used inside programming constructs, such 
as }
{\f2\uldb if}{\v\f2 IF} 
{\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  
or }
{\f2\uldb repeat}{\v\f2 REPEAT} 
{\f2 ...}{\f3 until} {\f2  or }
{\f2\uldb while}{\v\f2 WHILE} 
{\f2 ...}{\f3 do} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # greater}

${\footnote \pard\plain \sl240 \fs20 $ greater}

+{\footnote \pard\plain \sl240 \fs20 + g4:0675}

 K{\footnote \pard\plain \sl240 \fs20 K greater operator;operator}

}{\b\f2 >}{\f2 \tab }{\b\f2 GREATER}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 >} {\f2  is an infix binary comparison operator that returns 
 true if its first argument is strictly greater than its second. 
\par 
\par 
 \par
syntax: \par
}{\f4 <expression> }{\f3 >} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<expression> must evaluate to a number, e.g., integer, rational or 
floating point number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
if 3.0 > 3 then write "different" else write "same";  \par
 \par
 \par
  same  \par
 \par
 \par
off rounded;  \par
 \par
a := 20;  \par
 \par
  A := 20  \par
 \par
 \par
if a > 20 then write "bigger" else write "not bigger";  \par
 \par
 \par
  not bigger  \par
 \par
\pard \sl240 }{\f2 The binary comparison operators can only be used for comparisons between 
numbers or variables that evaluate to numbers. The truth values returned 
by such a comparison can only be used inside programming constructs, such 
as }
{\f2\uldb if}{\v\f2 IF} 
{\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  or 
}
{\f2\uldb repeat}{\v\f2 REPEAT} 
{\f2 ...}{\f3 until} {\f2  or }
{\f2\uldb while}{\v\f2 WHILE} 
{\f2 ...}{\f3 do} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # leqsign}

${\footnote \pard\plain \sl240 \fs20 $ leqsign}

+{\footnote \pard\plain \sl240 \fs20 + g4:0676}

 K{\footnote \pard\plain \sl240 \fs20 K leqsign operator;operator}

}{\b\f2 <=}{\f2 \tab }{\b\f2 LEQSIGN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
}{\f3 <=} {\f2  is an infix binary comparison operator that returns 
 true if its first argument is less than or equal to its second argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 <expression> }{\f3 <=} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<expression> must evaluate to a number, e.g., integer, rational or 
floating point number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := 10;  \par
 \par
  A := 10  \par
 \par
 \par
if a <= 10 then true;  \par
 \par
  true \par
 \par
\pard \sl240 }{\f2 The binary comparison operators can only be used for comparisons between 
numbers or variables that evaluate to numbers. The truth values returned 
by such a comparison can only be used inside programming constructs, such 
as }
{\f2\uldb if}{\v\f2 IF} 
{\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  or 
}
{\f2\uldb repeat}{\v\f2 REPEAT} 
{\f2 ...}{\f3 until} {\f2  or }
{\f2\uldb while}{\v\f2 WHILE} 
{\f2 ...}{\f3 do} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # less}

${\footnote \pard\plain \sl240 \fs20 $ less}

+{\footnote \pard\plain \sl240 \fs20 + g4:0677}

 K{\footnote \pard\plain \sl240 \fs20 K less operator;operator}

}{\b\f2 <}{\f2 \tab }{\b\f2 LESS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
}{\f3 <} {\f2  is an infix binary logical comparison operator that 
returns true if its first argument is strictly less than its second 
argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 <expression> }{\f3 <} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<expression> must evaluate to a number, e.g., integer, rational or 
floating point number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
f := -3;  \par
 \par
  F := -3  \par
 \par
 \par
if f < -3 then write "yes" else write "no";  \par
 \par
 \par
  no \par
 \par
\pard \sl240 }{\f2 The binary comparison operators can only be used for comparisons between 
numbers or variables that evaluate to numbers. The truth values returned 
by such a comparison can only be used inside programming constructs, such 
as }
{\f2\uldb if}{\v\f2 IF} 
{\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  
or }
{\f2\uldb repeat}{\v\f2 REPEAT} 
{\f2 ...}{\f3 until} {\f2  or 
}
{\f2\uldb while}{\v\f2 WHILE} 
{\f2 ...}{\f3 do} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # tilde}

${\footnote \pard\plain \sl240 \fs20 $ tilde}

+{\footnote \pard\plain \sl240 \fs20 + g4:0678}

 K{\footnote \pard\plain \sl240 \fs20 K tilde operator;operator}

}{\b\f2 ~}{\f2 \tab }{\b\f2 TILDE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 ~} {\f2  is used as a unary prefix operator in the left-hand 
sides of }
{\f2\uldb rule}{\v\f2 RULE} 
{\f2 s to mark }
{\f2\uldb free variable}{\v\f2 Free_Variable} 
{\f2 s. A double tilde 
marks an optional }
{\f2\uldb free variable}{\v\f2 Free_Variable} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # group}

${\footnote \pard\plain \sl240 \fs20 $ group}

+{\footnote \pard\plain \sl240 \fs20 + g4:0679}

 K{\footnote \pard\plain \sl240 \fs20 K group command;command}

}{\b\f2 <<}{\f2 \tab }{\b\f2 GROUP}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 <<} {\f2 ...}{\f3 >>} {\f2  command is a group statement, 
used to group statements 
together where REDUCE expects a single statement. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 <<} {\f4 <statement>\{; <statement> }{\f3 or} {\f4  
 }{\f2 <statement>\}* }{\f3 >>} {\f2  
\par 
\par 
\par 
<statement> may be any valid REDUCE statement or expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := 2;  \par
 \par
  A := 2  \par
 \par
 \par
if a < 5 then <<b := a + 10; write b>>;  \par
 \par
 \par
  12  \par
 \par
 \par
<<d := c/15; f := d + 3; f**2>>; \par
  \par
 \par
   2 \par
  C  + 90*C + 202 \par
  ---------------- \par
        225 \par
 \par
\pard \sl240 }{\f2 The value returned from a group statement is the value of the last 
individual statement executed inside it. Note that when a semicolon is 
placed between the last statement and the closing brackets, 0 or 
 nil is returned. Group statements are often used in the 
consequence portions of }
{\f2\uldb if}{\v\f2 IF} 
{\f2 ...}{\f3 then} {\f2 , 
}
{\f2\uldb repeat}{\v\f2 REPEAT} 
{\f2 ...}{\f3 until} {\f2 , and 
}
{\f2\uldb while}{\v\f2 WHILE} 
{\f2 ...}{\f3 do} {\f2  
clauses. They may also be used in interactive 
operation to execute several statements at one time. Statements inside 
the group statement are separated by semicolons or dollar signs. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # AND}

${\footnote \pard\plain \sl240 \fs20 $ AND}

+{\footnote \pard\plain \sl240 \fs20 + g4:0680}

 K{\footnote \pard\plain \sl240 \fs20 K AND operator;operator}

}{\b\f2 AND}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 and} {\f2  binary logical operator returns true if both of its 
arguments are true. 
\par 
\par 
 \par
syntax: \par
}{\f4 <logical\_expression> }{\f3 and} {\f4  <logical\_expression> 
\par 
\par 
}{\f2 \par 
<logical\_expression> must evaluate to true or nil. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := 12;  \par
 \par
  A := 12  \par
 \par
 \par
if numberp a and a < 15 then write a**2 else write "no"; \par
  \par
 \par
 \par
  144  \par
 \par
 \par
clear a;  \par
 \par
if numberp a and a < 15 then write a**2 else write "no"; \par
  \par
 \par
 \par
  no \par
 \par
\pard \sl240 }{\f2 Logical operators can only be used inside conditional statements, such as 
}
{\f2\uldb while}{\v\f2 WHILE} 
{\f2 ...}{\f3 do} {\f2  or 
}
{\f2\uldb if}{\v\f2 IF} 
{\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2 . }{\f3 and} {\f2  examines each of 
its arguments in order, and quits, returning nil, on finding an 
argument that is not true. An error results if it is used in other 
contexts. 
\par 
\par 
}{\f3 and} {\f2 is left associative: }{\f3 x and y and z} {\f2  is equivalent to 
}{\f3 (x and y) and z} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # BEGIN}

${\footnote \pard\plain \sl240 \fs20 $ BEGIN}

+{\footnote \pard\plain \sl240 \fs20 + g4:0681}

 K{\footnote \pard\plain \sl240 \fs20 K BEGIN command;command}

}{\b\f2 BEGIN}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
}{\f3 begin} {\f2  is used to start a }
{\f2\uldb block}{\v\f2 block} 
{\f2  statement, which is closed with 
}{\f3 end} {\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 begin} {\f4 <statement>\{}{\f3 ;} {\f4  <statement>\}* }{\f3 end} {\f4  
\par 
\par 
}{\f2 \par 
<statement> is any valid REDUCE statement. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
begin for i := 1:3 do write i end;  \par
 \par
 \par
  1 \par
  2 \par
  3      \par
 \par
 \par
begin scalar n;n:=1;b:=for i:=1:4 product(x-i);return n end; \par
  \par
 \par
 \par
  1  \par
 \par
 \par
b;  \par
 \par
   4        3        2 \par
  X   - 10*X   + 35*X   - 50*X  + 24 \par
 \par
\pard \sl240 }{\f2 A }{\f3 begin} {\f2 ...}{\f3 end} {\f2  block can do actions (such as }{\f3 write} {\f2 ), but 
does not 
return a value unless instructed to by a }
{\f2\uldb return}{\v\f2 RETURN} 
{\f2  statement, which must 
be the last statement executed in the block. It is unnecessary to insert 
a semicolon before the }{\f3 end} {\f2 . 
\par 
\par 
Local variables, if any, are declared in the first statement immediately 
after }{\f3 begin} {\f2 , and may be defined as }{\f3 scalar, integer,} {\f2  or 
}{\f3 real} {\f2 . }
{\f2\uldb array}{\v\f2 ARRAY} 
{\f2  variables declared 
within a }{\f3 begin} {\f2 ...}{\f3 end} {\f2  block 
are global in every case, and }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statements have global 
effects. A }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statement involving a formal parameter affects 
the calling parameter that corresponds to it. }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statements 
involving local variables make global assignments, overwriting outside 
variables by the same name or creating them if they do not exist. You 
can use this feature to affect global variables from procedures, but be 
careful that you do not do it inadvertently. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # block}

${\footnote \pard\plain \sl240 \fs20 $ block}

+{\footnote \pard\plain \sl240 \fs20 + g4:0682}

 K{\footnote \pard\plain \sl240 \fs20 K block command;command}

}{\b\f2 BLOCK}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
A }{\f3 block} {\f2  is a sequence of statements enclosed by 
commands }
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2  and }
{\f2\uldb end}{\v\f2 END} 
{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 begin} {\f4 <statement>\{}{\f3 ;} {\f4  <statement>\}* }{\f3 end} {\f4  
\par 
\par 
}{\f2 \par 
For more details see }
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # COMMENT}

${\footnote \pard\plain \sl240 \fs20 $ COMMENT}

+{\footnote \pard\plain \sl240 \fs20 + g4:0683}

 K{\footnote \pard\plain \sl240 \fs20 K COMMENT command;command}

}{\b\f2 COMMENT}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
Beginning with the word }{\f3 comment} {\f2 , all text until the next statement 
terminator (}{\f3 ;} {\f2  or }{\f3 $} {\f2 ) is ignored. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
x := a**2 comment--a is the velocity of the particle;; \par
  \par
 \par
 \par
        2 \par
  X := A \par
 \par
\pard \sl240 }{\f2 Note that the first semicolon ends the comment and the second one 
terminates the original REDUCE statement. 
\par 
\par 
Multiple-line comments are often needed in interactive files. The 
}{\f3 comment} {\f2  command allows a normal-looking text to accompany the 
REDUCE statements in the file. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CONS}

${\footnote \pard\plain \sl240 \fs20 $ CONS}

+{\footnote \pard\plain \sl240 \fs20 + g4:0684}

 K{\footnote \pard\plain \sl240 \fs20 K CONS operator;operator}

}{\b\f2 CONS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 cons} {\f2  operator adds a new element to the beginning of a 
}
{\f2\uldb list}{\v\f2 LIST} 
{\f2 . Its 
operation is identical to the symbol }
{\f2\uldb dot}{\v\f2 dot} 
{\f2  (dot). It can be used 
infix or prefix. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 cons} {\f4 (<item>,<list>) or <item> }{\f3 cons} {\f4  <list> 
\par 
\par 
}{\f2 \par 
<item> can be any REDUCE scalar expression, including a list; <list> 
must be a list. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
liss := cons(a,\{b\});  \par
 \par
  \{A,B\}  \par
 \par
 \par
 \par
liss := c cons liss;  \par
 \par
  \{C,A,B\}  \par
 \par
 \par
 \par
newliss := for each y in liss collect cons(y,list x); \par
  \par
 \par
 \par
  NEWLISS := \{\{C,X\},\{A,X\},\{B,X\}\}  \par
 \par
 \par
 \par
for each y in newliss sum (first y)*(second y); \par
  \par
 \par
 \par
  X*(A + B + C) \par
 \par
\pard \sl240 }{\f2 If you want to use }{\f3 cons} {\f2  to put together two elements into a new list, 
you must make the second one into a list with curly brackets or the }{\f3 list} {\f2  
command. You can also start with an empty list created by }{\f3 \{\}} {\f2 . 
\par 
\par 
The }{\f3 cons} {\f2  operator is right associative: }{\f3 a cons b cons c} {\f2  is valid 
if }{\f3 c} {\f2  is a list; }{\f3 b} {\f2  need not be a list. The list produced is 
}{\f3 \{a,b,c\}} {\f2 . 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # END}

${\footnote \pard\plain \sl240 \fs20 $ END}

+{\footnote \pard\plain \sl240 \fs20 + g4:0685}

 K{\footnote \pard\plain \sl240 \fs20 K END command;command}

}{\b\f2 END}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The command }{\f3 end} {\f2  has two main uses: 
\par 
\par 
\tab (i) 
as the ending of a }
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2 ...}{\f3 end} {\f2  }
{\f2\uldb block}{\v\f2 block} 
{\f2 ; and 
\par 
\tab (ii) 
to end input from a file. 
\par 
\par 
In a }{\f3 begin} {\f2 ...}{\f3 end} {\f2  }
{\f2\uldb block}{\v\f2 block} 
{\f2 , there need not be a delimiter 
(}{\f3 ;} {\f2  or }{\f3 $} {\f2 ) before the }{\f3 end} {\f2 , though there must be one 
after it, or a right bracket matching an earlier left bracket. 
\par 
\par 
Files to be read into REDUCE should end with }{\f3 end;} {\f2 , which must be 
preceded by a semicolon (usually the last character of the previous line). 
The additional semicolon avoids problems with mistakes in the files. If 
you have suspended file operation by answering }{\f3 n} {\f2  to a }{\f3 pause} {\f2  
command, you are still, technically speaking, ``in" the file. Use 
}{\f3 end} {\f2  to exit the file. 
\par 
\par 
An }{\f3 end} {\f2  at the top level of a program is ignored. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EQUATION}

${\footnote \pard\plain \sl240 \fs20 $ EQUATION}

+{\footnote \pard\plain \sl240 \fs20 + g4:0686}

 K{\footnote \pard\plain \sl240 \fs20 K =;arithmetic;equal;equation;EQUATION type;type}

}{\b\f2 EQUATION}{\f2 \tab \tab \tab \tab }{\b\f2 type}{\f2 \par 
\par 
 
 \par 
\par 
An }{\f3 equation} {\f2  is an expression where two algebraic expressions 
are connected by the (infix) operator }
{\f2\uldb equal}{\v\f2 EQUAL} 
{\f2  or by }{\f3 =} {\f2 . 
For access to the components of an }{\f3 equation} {\f2  the operators 
}
{\f2\uldb lhs}{\v\f2 LHS} 
{\f2 , }
{\f2\uldb rhs}{\v\f2 RHS} 
{\f2  or }
{\f2\uldb part}{\v\f2 PART} 
{\f2  can be used. The 
evaluation of the left-hand side of an }{\f3 equation} {\f2  is controlled 
by the switch }
{\f2\uldb evallhseqp}{\v\f2 EVALLHSEQP} 
{\f2 , while the right-hand side is 
evaluated unconditionally. When an }{\f3 equation} {\f2  is part of a 
logical expression, e.g. in a }
{\f2\uldb if}{\v\f2 IF} 
{\f2  or }
{\f2\uldb while}{\v\f2 WHILE} 
{\f2  statement, 
the equation is evaluated by subtracting both sides can comparing 
the result with zero. 
\par 
\par 
Equations occur in many contexts, e.g. as arguments of the }
{\f2\uldb sub}{\v\f2 SUB} 
{\f2  
operator and in the arguments and the results 
of the operator }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2 . An equation can be member of a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  
and you may assign an equation to a variable. Elementary arithmetic is supported 
for equations: if }
{\f2\uldb evallhseqp}{\v\f2 EVALLHSEQP} 
{\f2  is on, you may add and subtract 
equations, and you can combine an equation with a scalar expression by 
addition, subtraction, multiplication, division and raise an equation 
to a power. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on evallhseqp; \par
 \par
u:=x+y=1$ \par
 \par
v:=2x-y=0$ \par
 \par
2*u-v;  \par
 \par
  - 3*y=-2 \par
 \par
 \par
ws/3;  \par
 \par
    2 \par
  y=-- \par
    3 \par
 \par
\pard \sl240 }{\f2 \par 
\par 
Important: the equation must occur in the leftmost term of such an expression. 
For other operations, e.g. taking function values of both sides, use the 
}
{\f2\uldb map}{\v\f2 MAP} 
{\f2  operator. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FIRST}

${\footnote \pard\plain \sl240 \fs20 $ FIRST}

+{\footnote \pard\plain \sl240 \fs20 + g4:0687}

 K{\footnote \pard\plain \sl240 \fs20 K decomposition;list;FIRST operator;operator}

}{\b\f2 FIRST}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 first} {\f2  operator returns the first element of a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 first} {\f4 (<list>) or }{\f3 first} {\f4  <list> 
\par 
\par 
}{\f2 \par 
<list> must be a non-empty list to avoid an error message. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
alist := \{a,b,c,d\};  \par
 \par
  ALIST := \{A,B,C,D\}  \par
 \par
 \par
first alist;  \par
 \par
  A  \par
 \par
 \par
blist := \{x,y,\{ww,aa,qq\},z\};  \par
 \par
  BLIST := \{X,Y,\{WW,AA,QQ\},Z\}  \par
 \par
 \par
first third blist;  \par
 \par
  WW \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # FOR}

${\footnote \pard\plain \sl240 \fs20 $ FOR}

+{\footnote \pard\plain \sl240 \fs20 + g4:0688}

 K{\footnote \pard\plain \sl240 \fs20 K loop;FOR command;command}

}{\b\f2 FOR}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 for} {\f2  command is used for iterative loops. There are many 
possible forms it can take. 
\par 
\par 
\pard \tx3420 }{\f4  \par
                   /                   \ \par
   /               |STEP <number> UNTIL|        \ \par
   |<var>:=<number>|                   |<number>| \par
FOR|               |         :         |        |<action> <exprn> \par
   |               \                   /        | \par
   |EACH <var> IN <list>                        | \par
   \                                            / \par
 \par
 where <action> ::= DO|PRODUCT|SUM|COLLECT|JOIN. \par
\pard \sl240 }{\f2 <var> can be any valid REDUCE identifier except }{\f3 t} {\f2  or 
}{\f3 nil} {\f2 , <inc>, <start> and <stop> can be any expression 
that evaluates to a positive or negative integer. <list> must be a 
valid }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  structure. 
The action taken must be one of the actions shown 
above, each of which is followed by a single REDUCE expression, statement 
or a }
{\f2\uldb group}{\v\f2 group} 
{\f2  (}{\f3 <<} {\f2 ...}{\f3 >>} {\f2 ) or }
{\f2\uldb block}{\v\f2 block} 
{\f2  
(}
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2 ...}
{\f2\uldb end}{\v\f2 END} 
{\f2 ) statement. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
for i := 1:10 sum i;                                     \par
  \par
 \par
 \par
  55  \par
 \par
 \par
for a := -2 step 3 until 6 product a; \par
							 \par
 \par
 \par
  -8  \par
 \par
 \par
a := 3;  \par
 \par
  A := 3  \par
 \par
 \par
for iter := 4:a do write iter;  \par
 \par
m := 0;  \par
 \par
  M := 0  \par
 \par
 \par
for s := 10 step -1 until 3 do <<d := 10*s;m := m + d>>;  \par
 \par
m;  \par
 \par
  520  \par
 \par
 \par
for each x in \{q,r,s\} sum x**2;  \par
 \par
   2    2    2 \par
  Q  + R  + S   \par
 \par
 \par
for i := 1:4 collect 1/i;                               \par
  \par
 \par
 \par
     1 1 1 \par
  \{1,-,-,-\}  \par
     2 3 4 \par
 \par
 \par
for i := 1:3 join list solve(x**2 + i*x + 1,x);          \par
  \par
 \par
 \par
        SQRT(3)*I + 1 \par
  \{\{X= --------------, \par
              2 \par
        SQRT(3)*I - 1 \par
    X= --------------\} \par
              2 \par
   \{X=-1\}, \par
         SQRT(5) + 3   SQRT(5) - 3 \par
   \{X= - -----------,X=-----------\}\} \par
              2             2 \par
 \par
\pard \sl240 }{\f2 The behavior of each of the five action words follows: 
\par 
\par 
\pard \tx3420 }{\f4  \par
                           Action Word Behavior \par
Keyword   Argument Type                    Action \par
   do    statement, command, group   Evaluates its argument once \par
         or block                    for each iteration of the loop, \par
                                     not saving results \par
collect expression, statement,       Evaluates its argument once for \par
        command, group, block, list  each iteration of the loop, \par
                                     storing the results in a list \par
                                     which is returned by the for \par
                                     statement when done \par
 join   list or an operator which    Evaluates its argument once for \par
        produces a list              each iteration of the loop, \par
                                     appending the elements in each \par
                                     individual result list onto the \par
                                     overall result list \par
product expression, statement,       Evaluates its argument once for \par
        command, group or block      each iteration of the loop, \par
                                     multiplying the results together \par
                                     and returning the overall product \par
  sum   expression, statement,       Evaluates its argument once for \par
        command, group or block      each iteration of the loop, \par
                                     adding the results together and \par
                                     returning the overall sum \par
\pard \sl240 }{\f2 For number-driven }{\f3 for} {\f2  statements, if the ending limit is smaller 
than the beginning limit (larger in the case of negative steps) the action 
statement is not executed at all. The iterative variable is local to the 
}{\f3 for} {\f2  statement, and does not affect the value of an identifier with 
the same name. For list-driven }{\f3 for} {\f2  statements, if the list is 
empty, the action statement is not executed, but no error occurs. 
\par 
\par 
You can use nested }{\f3 for} {\f2  statements, with the inner }{\f3 for} {\f2  
statement after the action keyword. You must make sure that your inner 
statement returns an expression that the outer statement can handle. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FOREACH}

${\footnote \pard\plain \sl240 \fs20 $ FOREACH}

+{\footnote \pard\plain \sl240 \fs20 + g4:0689}

 K{\footnote \pard\plain \sl240 \fs20 K loop;FOREACH command;command}

}{\b\f2 FOREACH}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
}{\f3 foreach} {\f2 is a synonym for the }{\f3 for each} {\f2  variant of the 
}
{\f2\uldb for}{\v\f2 FOR} 
{\f2  construct. It is designed to iterate down a list, and an 
error will occur if a list is not used. The use of }{\f3 for each} {\f2  is 
preferred to }{\f3 foreach} {\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 foreach} {\f4 <variable> in <list> <action> <expression> 
\par 
\par 
where <action> ::= }{\f3 do | product | sum | collect | join} {\f4  
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
foreach x in \{q,r,s\} sum x**2;  \par
 \par
   2    2    2 \par
  Q  + R  + S \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # GEQ}

${\footnote \pard\plain \sl240 \fs20 $ GEQ}

+{\footnote \pard\plain \sl240 \fs20 + g4:0690}

 K{\footnote \pard\plain \sl240 \fs20 K GEQ operator;operator}

}{\b\f2 GEQ}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 geq} {\f2  operator is a binary infix or prefix logical operator. It 
returns true if its first argument is greater than or equal to its second 
argument. As an infix operator it is identical with }{\f3 >=} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 geq} {\f4 (<expression>,<expression>) or <expression> 
}{\f3 geq} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE expression that evaluates to a 
number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := 20;  \par
 \par
  A := 20  \par
 \par
 \par
if geq(a,25) then write "big" else write "small"; \par
			  \par
 \par
 \par
  small  \par
 \par
 \par
if a geq 20 then write "big" else write "small"; \par
			  \par
 \par
 \par
  big   \par
 \par
 \par
if (a geq 18) then write "big" else write "small"; \par
			  \par
 \par
 \par
  big \par
 \par
\pard \sl240 }{\f2 Logical operators can only be used in conditional statements such as 
\par 
\par 
}
{\f2\uldb if}{\v\f2 IF} 
{\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  or 
}
{\f2\uldb repeat}{\v\f2 REPEAT} 
{\f2 ...}{\f3 until} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # GOTO}

${\footnote \pard\plain \sl240 \fs20 $ GOTO}

+{\footnote \pard\plain \sl240 \fs20 + g4:0691}

 K{\footnote \pard\plain \sl240 \fs20 K GOTO command;command}

}{\b\f2 GOTO}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
Inside a }{\f3 begin} {\f2 ...}{\f3 end} {\f2  }
{\f2\uldb block}{\v\f2 block} 
{\f2 , }{\f3 goto} {\f2 , or 
preferably, }{\f3 go to} {\f2 , transfers flow of control to a labeled statement. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 go to} {\f4 <labeled_statement> or }{\f3 goto} {\f4  <labeled_statement> 
\par 
\par 
}{\f2 \par 
<labeled_statement> is of the form <label> }{\f3 :} {\f2 <statement> 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
     procedure dumb(a); \par
        begin scalar q; \par
           go to lab; \par
           q := df(a**2 - sin(a),a); \par
           write q; \par
      lab: return a \par
        end; \par
\pard \sl240   \par
 \par
  DUMB  \par
 \par
 \par
 \par
dumb(17);  \par
 \par
  17 \par
 \par
\pard \sl240 }{\f2 }{\f3 go to} {\f2 can only be used inside a }{\f3 begin} {\f2 ...}{\f3 end} {\f2  
}
{\f2\uldb block}{\v\f2 block} 
{\f2 , and inside 
the block only statements at the top level can be labeled, not ones inside 
}{\f3 <<} {\f2 ...}{\f3 >>} {\f2 , }
{\f2\uldb while}{\v\f2 WHILE} 
{\f2 ...}{\f3 do} {\f2 , etc. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # GREATERP}

${\footnote \pard\plain \sl240 \fs20 $ GREATERP}

+{\footnote \pard\plain \sl240 \fs20 + g4:0692}

 K{\footnote \pard\plain \sl240 \fs20 K GREATERP operator;operator}

}{\b\f2 GREATERP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 greaterp} {\f2  logical operator returns true if its first argument is 
strictly greater than its second argument. As an infix operator it is 
identical with }{\f3 >} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 greaterp} {\f4 (<expression>,<expression>) or <expression> 
}{\f3 greaterp} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE expression that evaluates to a 
number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
a := 20;  \par
 \par
  A := 20  \par
 \par
 \par
if greaterp(a,25) then write "big" else write "small"; \par
			  \par
 \par
 \par
  small  \par
 \par
 \par
if a greaterp 20 then write "big" else write "small"; \par
			  \par
 \par
 \par
  small  \par
 \par
 \par
if (a greaterp 18) then write "big" else write "small"; \par
			  \par
 \par
 \par
  big \par
 \par
\pard \sl240 }{\f2 Logical operators can only be used in conditional statements such as 
\par 
\par 
}
{\f2\uldb if}{\v\f2 IF} 
{\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  
or }
{\f2\uldb repeat}{\v\f2 REPEAT} 
{\f2 ...}
{\f2\uldb while}{\v\f2 WHILE} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # IF}

${\footnote \pard\plain \sl240 \fs20 $ IF}

+{\footnote \pard\plain \sl240 \fs20 + g4:0693}

 K{\footnote \pard\plain \sl240 \fs20 K then;else;IF command;command}

}{\b\f2 IF}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 if} {\f2  command is a conditional statement that executes a statement 
if a condition is true, and optionally another statement if it is not. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 if} {\f4 <condition> }{\f3 then} {\f4  <statement> 
 \tab option(}{\f3 else} {\f4  <statement>) 
\par 
\par 
}{\f2 \par 
<condition> must be a logical or comparison operator that evaluates to 
a }
{\f2\uldb boolean value}{\v\f2 boolean_value} 
{\f2 . 
<statement> must be a single REDUCE statement or a 
}
{\f2\uldb group}{\v\f2 group} 
{\f2  (}{\f3 <<} {\f2 ...}{\f3 >>} {\f2 ) or 
}
{\f2\uldb block}{\v\f2 block} 
{\f2  (}{\f3 begin} {\f2 ...}{\f3 end} {\f2 ) statement. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
if x = 5 then a := b+c else a := d+f; \par
			  \par
 \par
 \par
  D + F  \par
 \par
 \par
x := 9;  \par
 \par
  X := 9  \par
 \par
 \par
if numberp x and x<20 then y := sqrt(x) else write "illegal"; \par
			  \par
 \par
 \par
  3   \par
 \par
 \par
clear x;  \par
 \par
if numberp x and x<20 then y := sqrt(x) else write "illegal"; \par
			  \par
 \par
 \par
  illegal  \par
 \par
 \par
x := 12;  \par
 \par
  X := 12  \par
 \par
 \par
a := if x < 5 then 100 else 150; \par
			  \par
 \par
 \par
  A := 150  \par
 \par
 \par
b := u**(if x < 10 then 2); \par
			  \par
 \par
  B := 1  \par
 \par
 \par
bb := u**(if x > 10 then 2); \par
			  \par
 \par
         2 \par
  BB := U \par
 \par
\pard \sl240 }{\f2 An }{\f3 if} {\f2  statement may be used inside an assignment statement and sets 
its value depending on the conditions, or used anywhere else an 
expression would be valid, as shown in the last example. If there is no 
 }{\f3 else} {\f2  clause, the value is 0 if a number is expected, and nothing 
otherwise. 
\par 
\par 
The }{\f3 else} {\f2  clause may be left out if no action is to be taken if the 
condition is false. 
\par 
\par 
The condition may be a compound conditional statement using }
{\f2\uldb and}{\v\f2 AND} 
{\f2  or 
}
{\f2\uldb or}{\v\f2 OR} 
{\f2 . If a non-conditional statement, such as a constant, is used by 
accident, it is assumed to have value true. 
 \par 
\par 
Be sure to use }
{\f2\uldb group}{\v\f2 group} 
{\f2  or }
{\f2\uldb block}{\v\f2 block} 
{\f2  statements after 
 }{\f3 then} {\f2  or }{\f3 else} {\f2 . 
\par 
\par 
The }{\f3 if} {\f2  operator is right associative. The following constructions are 
examples: 
\par 
\par 
\tab (1) 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 if} {\f4 <condition> }{\f3 then} {\f4  }{\f3 if} {\f4  <condition> }{\f3 then} {\f4  
 <action> }{\f3 else} {\f4  <action> 
\par 
\par 
}{\f2 \par 
which is equivalent to 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 if} {\f4 <condition> }{\f3 then} {\f4  (}{\f3 if} {\f4  <condition> 
 }{\f3 then} {\f4  <action> }{\f3 else} {\f4  <action>); 
\par 
\par 
}{\f2 \par 
\tab (2) 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 if} {\f4 <condition> }{\f3 then} {\f4  <action> }{\f3 else if} {\f4  
 <condition> }{\f3 then} {\f4  <action> }{\f3 else} {\f4  <action> 
\par 
\par 
}{\f2 \par 
which is equivalent to 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 if} {\f4 <condition> }{\f3 then} {\f4  <action> }{\f3 else} {\f4  
\par 
\par 
(}{\f3 if} {\f4  <condition> }{\f3 then} {\f4  <action> 
 }{\f3 else} {\f4  <action>). 
\par 
\par 
}{\f2 \par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LIST}

${\footnote \pard\plain \sl240 \fs20 $ LIST}

+{\footnote \pard\plain \sl240 \fs20 + g4:0694}

 K{\footnote \pard\plain \sl240 \fs20 K list;LIST operator;operator}

}{\b\f2 LIST}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 list} {\f2  operator constructs a list from its arguments. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 list} {\f4 (<item> \{,<item>\}*) or 
 }{\f3 list} {\f4 () to construct an empty list. 
\par 
\par 
}{\f2 \par 
<item> can be any REDUCE scalar expression, including another list. 
Left and right curly brackets can also be used instead of the operator 
}{\f3 list} {\f2  to construct a list. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
liss := list(c,b,c,\{xx,yy\},3x**2+7x+3,df(sin(2*x),x)); \par
	  \par
 \par
 \par
                            2 \par
  LISS := \{C,B,C,\{XX,YY\},3*X  + 7*X + 3,2*COS(2*X)\}  \par
 \par
 \par
length liss;  \par
 \par
  6  \par
 \par
 \par
liss := \{c,b,c,\{xx,yy\},3x**2+7x+3,df(sin(2*x),x)\}; \par
	  \par
 \par
 \par
                            2 \par
  LISS := \{C,B,C,\{XX,YY\},3*X  + 7*X + 3,2*COS(2*X)\}  \par
 \par
 \par
emptylis := list();  \par
 \par
  EMPTYLIS := \{\}  \par
 \par
 \par
a . emptylis;  \par
 \par
  \{A\} \par
 \par
\pard \sl240 }{\f2 Lists are ordered, hierarchical structures. The elements stay where you 
put them, and only change position in the list if you specifically change 
them. Lists can have nested sublists to any (reasonable) level. The 
}
{\f2\uldb part}{\v\f2 PART} 
{\f2  operator can be used to access elements anywhere within a list 
hierarchy. The }
{\f2\uldb length}{\v\f2 LENGTH} 
{\f2  operator counts the 
number of top-level elements 
of its list argument; elements that are themselves lists still only 
count as one element. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # OR}

${\footnote \pard\plain \sl240 \fs20 $ OR}

+{\footnote \pard\plain \sl240 \fs20 + g4:0695}

 K{\footnote \pard\plain \sl240 \fs20 K OR operator;operator}

}{\b\f2 OR}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 or} {\f2  binary logical operator returns true if either one or 
both of its arguments is true. 
 \par
syntax: \par
}{\f4 \par 
\par 
<logical expression> }{\f3 or} {\f4  <logical expression> 
\par 
\par 
}{\f2 \par 
<logical expression> must evaluate to true or nil. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := 10;  \par
 \par
  A := 10  \par
 \par
 \par
if a<0 or a>140 then write "not a valid human age" else \par
   write "age = ",a; \par
\pard \sl240   \par
 \par
 \par
 \par
  age = 10  \par
 \par
 \par
a := 200;  \par
 \par
  A := 200  \par
 \par
 \par
if a < 0 or a > 140 then write "not a valid human age"; \par
			  \par
 \par
 \par
  not a valid human age \par
 \par
\pard \sl240 }{\f2 The }{\f3 or} {\f2  operator is left associative: }{\f3 x or y or z} {\f2  is equivalent to 
}{\f3 (x or y)} {\f2  }{\f3 or z} {\f2 . 
\par 
\par 
Logical operators can only be used in conditional expressions, such as 
\par 
\par 
}
{\f2\uldb if}{\v\f2 IF} 
{\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  
and }
{\f2\uldb while}{\v\f2 WHILE} 
{\f2 ...}{\f3 do} {\f2 . 
}{\f3 or} {\f2  evaluates its arguments in order and quits, returning true, 
on finding the first true statement. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PROCEDURE}

${\footnote \pard\plain \sl240 \fs20 $ PROCEDURE}

+{\footnote \pard\plain \sl240 \fs20 + g4:0696}

 K{\footnote \pard\plain \sl240 \fs20 K PROCEDURE command;command}

}{\b\f2 PROCEDURE}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 procedure} {\f2  command allows you to define a mathematical operation as a 
function with arguments. 
 \par
syntax: \par
}{\f4 \par 
\par 
\tab <option> }{\f3 procedure} {\f4  <identifier> 
 (<arg>\{,<arg>\}+)}{\f3 ;} {\f4 <body> 
\par 
\par 
}{\f2 \par 
The <option> may be }
{\f2\uldb algebraic}{\v\f2 ALGEBRAIC} 
{\f2  or }
{\f2\uldb symbolic}{\v\f2 SYMBOLIC} 
{\f2 , 
indicating the 
mode under which the procedure is executed, or }
{\f2\uldb real}{\v\f2 REAL} 
{\f2  or 
}
{\f2\uldb integer}{\v\f2 INTEGER} 
{\f2 , indicating the type of answer expected. The default is 
algebraic. Real or integer procedures are subtypes of algebraic 
procedures; type-checking is done on the results of integer procedures, but 
not on real procedures (in the current REDUCE release). <identifier> 
may be any valid REDUCE identifier that is not already a procedure name, 
operator, }
{\f2\uldb array}{\v\f2 ARRAY} 
{\f2  or }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
<arg> is a formal parameter that may be any 
valid REDUCE identifier. <body> is a single statement (a }
{\f2\uldb group}{\v\f2 group} 
{\f2  
or }
{\f2\uldb block}{\v\f2 block} 
{\f2  statement may be used) with the desired activities in it. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
procedure fac(n); \par
   if not (fixp(n) and n>=0) \par
     then rederr "Choose nonneg. integer only" \par
    else for i := 0:n-1 product i+1; \par
\pard \sl240  \par
			  \par
 \par
  FAC  \par
 \par
 \par
fac(0);  \par
 \par
  1  \par
 \par
 \par
fac(5);  \par
 \par
  120  \par
 \par
 \par
fac(-5);  \par
 \par
  ***** choose nonneg. integer only \par
 \par
\pard \sl240 }{\f2 Procedures are automatically declared as operators upon definition. When 
REDUCE has parsed the procedure definition and successfully converted it to 
a form for its own use, it prints the name of the procedure. Procedure 
definitions cannot be nested. Procedures can call other procedures, or can 
recursively call themselves. Procedure identifiers can be cleared as you 
would clear an operator. Unlike }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statements, new definitions 
under the same procedure name replace the previous definitions completely. 
\par 
\par 
Be careful not to use the name of a system operator for your own procedure. 
REDUCE may or may not give you a warning message. If you redefine a system 
operator in your own procedure, the original function of the system operator 
is lost for the remainder of the REDUCE session. 
\par 
\par 
Procedures may have none, one, or more than one parameter. A REDUCE 
parameter is a formal parameter only; the use of x as a parameter in 
a }{\f3 procedure} {\f2  definition has no connection with a value of x in 
the REDUCE session, and the results of calling a procedure have no effect 
on the value of x. If a procedure is called with x as a 
parameter, the current value of x is used as specified in the 
computation, but is not changed outside the procedure. 
Making an assignment statement by }{\f3 :=} {\f2  with a 
formal parameter on the left-hand side only changes the value of the 
calling parameter within the procedure. 
\par 
\par 
Using a }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statement inside a procedure always changes the value 
globally: a }{\f3 let} {\f2  with a formal parameter makes the change to the calling 
parameter. }{\f3 let} {\f2  statements cannot be made on local variables inside 
}
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2 ...}{\f3 end} {\f2  }
{\f2\uldb block}{\v\f2 block} 
{\f3 s} {\f2 . 
When }
{\f2\uldb clear}{\v\f2 CLEAR} 
{\f2  statements are used on formal 
parameters, the calling variables associated with them are cleared globally too. 
The use of }{\f3 let} {\f2  or }{\f3 clear} {\f2  statements inside procedures 
should be done with extreme caution. 
\par 
\par 
Arrays and operators may be used as parameters to procedures. The body of the 
procedure can contain statements that appropriately manipulate these 
arguments. Changes are made to values of the calling arrays or operators. 
Simple expressions can also be used as arguments, in the place of scalar 
variables. Matrices may not be used as arguments to procedures. 
\par 
\par 
A procedure that has no parameters is called by the procedure name, 
immediately followed by empty parentheses. The empty parentheses may be left 
out when writing a procedure with no parameters, but must appear in a call of 
the procedure. If this is a nuisance to you, use a }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statement on 
the name of the procedure (i.e., }{\f3 let noargs = noargs()} {\f2 ) after which 
you can call the procedure by just its name. 
\par 
\par 
Procedures that have a single argument can leave out the parentheses around 
it both in the definition and procedure call. (You can use the parentheses if 
you wish.) Procedures with more than one argument must use parentheses, with 
the arguments separated by commas. 
\par 
\par 
Procedures often have a }{\f3 begin} {\f2 ...}{\f3 end} {\f2  block in them. Inside the 
block, local variables are declared using }{\f3 scalar} {\f2 , }{\f3 real} {\f2  or 
}{\f3 integer} {\f2  declarations. 
The declarations must be made immediately after the word 
}{\f3 begin} {\f2 , and if more than one type of declaration is made, they are 
separated by semicolons. REDUCE currently does no type checking on local 
variables; }{\f3 real} {\f2  and }{\f3 integer} {\f2  are treated just like }{\f3 scalar} {\f2 . 
Actions take place as specified in the statements inside the block statement. 
Any identifiers that are not formal parameters or local variables are treated 
as global variables, and activities involving these identifiers are global in 
effect. 
\par 
\par 
If a return value is desired from a procedure call, a specific 
}
{\f2\uldb return}{\v\f2 RETURN} 
{\f2  command must be the last statement executed before exiting 
from the procedure. If no }{\f3 return} {\f2  is used, a procedure returns a 
zero or no value. 
\par 
\par 
Procedures are often written in a file using an editor, then the file 
is input using the command }
{\f2\uldb in}{\v\f2 IN} 
{\f2 . This method allows easy changes in 
development, and also allows you to load the named procedures whenever 
you like, by loading the files that contain them. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # REPEAT}

${\footnote \pard\plain \sl240 \fs20 $ REPEAT}

+{\footnote \pard\plain \sl240 \fs20 + g4:0697}

 K{\footnote \pard\plain \sl240 \fs20 K until;loop;REPEAT command;command}

}{\b\f2 REPEAT}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }
{\f2\uldb repeat}{\v\f2 REPEAT} 
{\f2  command causes repeated execution of a statement 
 }{\f3 until} {\f2 \par 
\par 
the given condition is found to be true. The statement is always executed 
at least once. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 repeat} {\f4 <statement> }{\f3 until} {\f4  <condition> 
\par 
\par 
}{\f2 \par 
<statement> can be a single statement, }
{\f2\uldb group}{\v\f2 group} 
{\f2  statement, or 
a }{\f3 begin} {\f2 ...}{\f3 end} {\f2  }
{\f2\uldb block}{\v\f2 block} 
{\f2 . <condition> must be 
a logical operator that evaluates to true or nil. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
<<m := 4; repeat <<write 100*x*m;m := m-1>> until m = 0>>; \par
			  \par
 \par
 \par
  400*X \par
  300*X \par
  200*X \par
  100*X \par
 \par
 \par
 \par
<<m := -1; repeat <<write m; m := m-1>> until m <= 0>>; \par
			  \par
 \par
 \par
  -1 \par
 \par
\pard \sl240 }{\f2 }{\f3 repeat} {\f2 must always be followed by an }{\f3 until} {\f2  with a condition. 
Be careful not to generate an infinite loop with a condition that is never 
true. In the second example, if the condition had been }{\f3 m = 0} {\f2 , it 
would never have been true since }{\f3 m} {\f2  already had value -2 when the 
condition was first evaluated. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # REST}

${\footnote \pard\plain \sl240 \fs20 $ REST}

+{\footnote \pard\plain \sl240 \fs20 + g4:0698}

 K{\footnote \pard\plain \sl240 \fs20 K decomposition;list;REST operator;operator}

}{\b\f2 REST}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 rest} {\f2  operator returns a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  containing all but the first 
element of the list it is given. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 rest} {\f4 (<list>) or }{\f3 rest} {\f4  <list> 
\par 
\par 
\par 
\par 
}{\f2 <list> must be a non-empty list, but need not have more than one element. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
alist := \{a,b,c,d\};  \par
 \par
  ALIST := \{A,B,C,D\};  \par
 \par
 \par
rest alist;  \par
 \par
  \{B,C,D\}  \par
 \par
 \par
blist := \{x,y,\{aa,bb,cc\},z\};  \par
 \par
  BLIST := \{X,Y,\{AA,BB,CC\},Z\}  \par
 \par
 \par
second rest blist;  \par
 \par
  \{AA,BB,CC\}  \par
 \par
 \par
clist := \{c\};  \par
 \par
  CLIST := C  \par
 \par
 \par
rest clist;  \par
 \par
  \{\} \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # RETURN}

${\footnote \pard\plain \sl240 \fs20 $ RETURN}

+{\footnote \pard\plain \sl240 \fs20 + g4:0699}

 K{\footnote \pard\plain \sl240 \fs20 K RETURN command;command}

}{\b\f2 RETURN}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 return} {\f2  command causes a value to be returned from inside a 
}{\f3 begin} {\f2 ...}{\f3 end} {\f2  }
{\f2\uldb block}{\v\f2 block} 
{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 begin} {\f4 <statements> }{\f3 return} {\f4  <(expression)> 
 }{\f3 end} {\f4 \par 
\par 
\par 
\par 
}{\f2 <statements> can be any valid REDUCE statements. The value of 
<expression> is returned. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
begin write "yes"; return a end;  \par
 \par
  yes \par
  A \par
 \par
 \par
procedure dumb(a); \par
  begin if numberp(a) then return a else return 10 end; \par
\pard \sl240  \par
						  \par
 \par
  DUMB  \par
 \par
 \par
dumb(x);  \par
 \par
  10  \par
 \par
 \par
dumb(-5);  \par
 \par
  -5   \par
 \par
 \par
procedure dumb2(a); \par
  begin c := a**2 + 2*a + 1; d := 17; c*d; return end; \par
\pard \sl240 		  \par
 \par
  DUMB2  \par
 \par
 \par
dumb2(4);  \par
 \par
c;  \par
 \par
  25  \par
 \par
 \par
d;  \par
 \par
  17 \par
 \par
\pard \sl240 }{\f2 Note in }{\f3 dumb2} {\f2  above that the assignments were made as requested, but 
the product }{\f3 c*d} {\f2  cannot be accessed. Changing the procedure to read 
}{\f3 return c*d} {\f2  would remedy this problem. 
\par 
\par 
The }{\f3 return} {\f2  statement is always the last statement executed before 
leaving the block. If }{\f3 return} {\f2  has no argument, the block is exited but 
no value is returned. A block statement does not need a }{\f3 return} {\f2  ; 
the statements inside terminate in their normal fashion without one. 
In that case no value is returned, although the specified actions inside the 
block take place. 
\par 
\par 
The }{\f3 return} {\f2  command can be used inside }{\f3 <<} {\f2 ...}{\f3 >>} {\f2  
}
{\f2\uldb group}{\v\f2 group} 
{\f2  statements and 
}
{\f2\uldb if}{\v\f2 IF} 
{\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  commands that 
are inside }{\f3 begin} {\f2 ...}{\f3 end} {\f2  }
{\f2\uldb block}{\v\f2 block} 
{\f2 s. 
It is not valid in these constructions that are not inside 
a }{\f3 begin} {\f2 ...}{\f3 end} {\f2  
 block. It is not valid inside }
{\f2\uldb for}{\v\f2 FOR} 
{\f2 , 
}
{\f2\uldb repeat}{\v\f2 REPEAT} 
{\f2 ...}{\f3 until} {\f2  or }
{\f2\uldb while}{\v\f2 WHILE} 
{\f2 ...}{\f3 do} {\f2  
 loops in any construction. To force early termination from loops, the 
}{\f3 go to} {\f2 (}
{\f2\uldb goto}{\v\f2 GOTO} 
{\f2 ) command must be used. 
When you use nested block statements, a 
}{\f3 return} {\f2  from an inner block exits returning a value to the next-outermost 
block, rather than all the way to the outside. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # REVERSE}

${\footnote \pard\plain \sl240 \fs20 $ REVERSE}

+{\footnote \pard\plain \sl240 \fs20 + g4:0700}

 K{\footnote \pard\plain \sl240 \fs20 K list;REVERSE operator;operator}

}{\b\f2 REVERSE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 reverse} {\f2  operator returns a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  that is the reverse of the 
list it is given. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 reverse} {\f4 (<list>) or }{\f3 reverse} {\f4  <list> 
\par 
\par 
}{\f2 \par 
<list> must be a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
aa := \{c,b,a,\{x**2,z**3\},y\};  \par
 \par
                 2  3 \par
  AA := \{C,B,A,\{X ,Z \},Y\}  \par
 \par
 \par
reverse aa;  \par
 \par
       2  3 \par
  \{Y,\{X ,Z \},A,B,C\}  \par
 \par
 \par
reverse(q . reverse aa);  \par
 \par
           2  3 \par
  \{C,B,A,\{X ,Z \},Y,Q\} \par
 \par
\pard \sl240 }{\f2 }{\f3 reverse} {\f2 and }
{\f2\uldb cons}{\v\f2 CONS} 
{\f2  can be used together to add a new element to 
the end of a list (}{\f3 .} {\f2  adds its new element to the beginning). The 
}{\f3 reverse} {\f2  operator uses a noticeable amount of system resources, 
especially if the list is long. If you are doing much heavy-duty list 
manipulation, you should probably design your algorithms to avoid much 
reversing of lists. A moderate amount of list reversing is no problem. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RULE}

${\footnote \pard\plain \sl240 \fs20 $ RULE}

+{\footnote \pard\plain \sl240 \fs20 + g4:0701}

 K{\footnote \pard\plain \sl240 \fs20 K ~;rule list;rule;RULE type;type}

}{\b\f2 RULE}{\f2 \tab \tab \tab \tab }{\b\f2 type}{\f2 \par 
\par 
 
 \par 
\par 
A }{\f3 rule} {\f2  is an instruction to replace an algebraic expression 
or a part of an expression by another one. 
 \par
syntax: \par
}{\f4 \par 
\par 
<lhs> => <rhs> or 
<lhs> => <rhs> }{\f3 when} {\f4  <cond> 
\par 
\par 
}{\f2 \par 
<lhs> is an algebraic expression used as search pattern and 
<rhs> is an algebraic expression which replaces matches of 
<rhs>. }{\f3 =>} {\f2  is the operator }
{\f2\uldb replace}{\v\f2 replace} 
{\f2 . 
\par 
\par 
<lhs> can contain }
{\f2\uldb free variable}{\v\f2 Free_Variable} 
{\f2 s which are 
symbols preceded by a tilde }{\f3 ~} {\f2  in their leftmost position 
in <lhs>. 
A double tilde marks an }
{\f2\uldb optional free variable}{\v\f2 Optional_Free_Variable} 
{\f2 . 
If a rule has a }{\f3 when} {\f2  <cond> 
part it will fire only if the evaluation of <cond> has a 
result }
{\f2\uldb true}{\v\f2 TRUE} 
{\f2 . <cond> may contain references to 
free variables of <lhs>. 
\par 
\par 
Rules can be collected in a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  which then forms a 
 }{\f3 rule list} {\f2 . }{\f3 Rule lists} {\f2  can be used to collect 
algebraic knowledge for a specific evaluation context. 
\par 
\par 
}{\f3 Rules} {\f2 and }{\f3 rule lists} {\f2  are globally activated and 
deactivated by }
{\f2\uldb let}{\v\f2 LET} 
{\f2 , }
{\f2\uldb forall}{\v\f2 FORALL} 
{\f2 , }
{\f2\uldb clearrules}{\v\f2 CLEARRULES} 
{\f2 . 
For a single evaluation they can be locally activate by }
{\f2\uldb where}{\v\f2 WHERE} 
{\f2 . 
The active rules for an operator can be visualized by }
{\f2\uldb showrules}{\v\f2 SHOWRULES} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
operator f,g,h;  \par
 \par
let f(x) => x^2;  \par
 \par
f(x);  \par
 \par
   2 \par
  x \par
 \par
 \par
g_rules:=\{g(~n,~x)=>h(n/2,x) when evenp n, \par
 \par
g(~n,~x)=>h((1-n)/2,x) when not evenp n\}$ \par
 \par
let g_rules; \par
 \par
g(3,x);  \par
 \par
  h(-1,x) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # Free_Variable}

${\footnote \pard\plain \sl240 \fs20 $ Free_Variable}

+{\footnote \pard\plain \sl240 \fs20 + g4:0702}

 K{\footnote \pard\plain \sl240 \fs20 K variable;Free Variable type;type}

}{\b\f2 FREE VARIABLE}{\f2 \tab \tab \tab \tab }{\b\f2 type}{\f2 \par 
\par 
 
 \par 
\par 
A variable preceded by a tilde is considered as }{\f3 free variable} {\f2  
and stands for an arbitrary part in an algebraic form during 
pattern matching. Free variables occur in the left-hand sides 
of }
{\f2\uldb rule}{\v\f2 RULE} 
{\f2 s, in the side relations for }
{\f2\uldb compact}{\v\f2 COMPACT} 
{\f2  
and in the first arguments of }
{\f2\uldb map}{\v\f2 MAP} 
{\f2  and }
{\f2\uldb select}{\v\f2 SELECT} 
{\f2  
calls. See }
{\f2\uldb rule}{\v\f2 RULE} 
{\f2  for examples. 
\par 
\par 
In rules also }
{\f2\uldb optional free variable}{\v\f2 Optional_Free_Variable} 
{\f2 s may occur. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Optional_Free_Variable}

${\footnote \pard\plain \sl240 \fs20 $ Optional_Free_Variable}

+{\footnote \pard\plain \sl240 \fs20 + g4:0703}

 K{\footnote \pard\plain \sl240 \fs20 K variable;Optional Free Variable type;type}

}{\b\f2 OPTIONAL FREE VARIABLE}{\f2 \tab \tab \tab \tab }{\b\f2 type}{\f2 \par 
\par 
 
 \par 
\par 
A variable preceded by a double tilde is considered as 
}{\f3 optional free variable} {\f2 \par 
\par 
and stands for an arbitrary part part in an algebraic form during 
pattern matching. In contrast to ordinary }
{\f2\uldb free variable}{\v\f2 Free_Variable} 
{\f2 s 
an operator pattern with an }{\f3 optional free variable} {\f2  
matches also if the operand for the variable is missing. In such 
a case the variable is bound to a neutral value. 
Optional free variables can be used as 
\par 
\par 
term in a sum: set to 0 if missing, 
\par 
\par 
factor in a product: set to 1 if missing, 
\par 
\par 
exponent: set to 1 if missing 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4 \pard \sl240 }{\f2 Optional free variables are allowed only in the left-hand sides 
of }
{\f2\uldb rule}{\v\f2 RULE} 
{\f2 s. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SECOND}

${\footnote \pard\plain \sl240 \fs20 $ SECOND}

+{\footnote \pard\plain \sl240 \fs20 + g4:0704}

 K{\footnote \pard\plain \sl240 \fs20 K decomposition;list;SECOND operator;operator}

}{\b\f2 SECOND}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 second} {\f2  operator returns the second element of a list. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 second} {\f4 (<list>) or }{\f3 second} {\f4  <list> 
\par 
\par 
\par 
\par 
}{\f2 <list> must be a list with at least two elements, to avoid an error 
message. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
alist := \{a,b,c,d\};  \par
 \par
  ALIST := \{A,B,C,D\}  \par
 \par
 \par
second alist;  \par
 \par
  B  \par
 \par
 \par
blist := \{x,\{aa,bb,cc\},z\};  \par
 \par
  BLIST := \{X,\{AA,BB,CC\},Z\}  \par
 \par
 \par
second second blist;  \par
 \par
  BB \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # SET}

${\footnote \pard\plain \sl240 \fs20 $ SET}

+{\footnote \pard\plain \sl240 \fs20 + g4:0705}

 K{\footnote \pard\plain \sl240 \fs20 K assign;SET operator;operator}

}{\b\f2 SET}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 set} {\f2  operator is used for assignments when you want both sides of 
the assignment statement to be evaluated. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 set} {\f4 (<restricted\_expression>,<expression>) 
\par 
\par 
}{\f2 \par 
<expression> can be any REDUCE expression; <restricted\_expression> 
must be an identifier or an expression that evaluates to an identifier. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := y;  \par
 \par
  A := Y  \par
 \par
 \par
set(a,sin(x^2));  \par
 \par
       2 \par
  SIN(X )  \par
 \par
 \par
a;  \par
 \par
       2 \par
  SIN(X )  \par
 \par
 \par
y;  \par
 \par
       2 \par
  SIN(X )  \par
 \par
 \par
a := b + c;  \par
 \par
  A := B + C  \par
 \par
 \par
set(a-c,z);  \par
 \par
  Z  \par
 \par
 \par
b;  \par
 \par
  Z \par
 \par
\pard \sl240 }{\f2 Using an }
{\f2\uldb array}{\v\f2 ARRAY} 
{\f2  or }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  reference as the first 
argument to }{\f3 set} {\f2  has 
the result of setting the contents of the designated element to 
}{\f3 set} {\f2 's second argument. You should be careful to avoid unwanted 
side effects when you use this facility. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SETQ}

${\footnote \pard\plain \sl240 \fs20 $ SETQ}

+{\footnote \pard\plain \sl240 \fs20 + g4:0706}

 K{\footnote \pard\plain \sl240 \fs20 K assign;SETQ operator;operator}

}{\b\f2 SETQ}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 setq} {\f2  operator is an infix or prefix binary assignment operator. 
It is identical to }{\f3 :=} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 setq} {\f4 (<restricted\_expression>,<expression>) or 
\par 
\par 
<restricted\_expression> }{\f3 setq} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<restricted expression> is ordinarily a single identifier, though 
simple expressions may be used (see Comments below). <expression> can 
be any valid REDUCE expression. If <expression> is a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  
identifier, then <restricted\_expression> can be a matrix identifier 
(redimensioned if necessary), which has each element set to the 
corresponding elements of the identifier on the right-hand side. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
setq(b,6);  \par
 \par
  B := 6  \par
 \par
 \par
c setq sin(x);  \par
 \par
  C := SIN(X)  \par
 \par
 \par
w + setq(c,x+3) + z;  \par
 \par
  W + X + Z + 3  \par
 \par
 \par
c;  \par
 \par
  X + 3  \par
 \par
 \par
setq(a1 + a2,25);  \par
 \par
  A1 + A2 := 25  \par
 \par
 \par
a1;  \par
 \par
  - (A2 - 25) \par
 \par
\pard \sl240 }{\f2 Embedding a }{\f3 setq} {\f2  statement in an expression has the side effect of making 
the assignment, as shown in the third example above. 
\par 
\par 
Assignments are generally done for identifiers, but may be done for simple 
expressions as well, subject to the following remarks: 
\par 
\par 
\tab (i) 
If the left-hand side is an identifier, an operator, or a power, the rule 
is added to the rule table. 
\par 
\par 
\tab (ii) 
If the operators }{\f3 - + /} {\f2  appear on the left-hand side, all but the first 
term of the expression is moved to the right-hand side. 
\par 
\par 
\tab (iii) 
If the operator }{\f3 *} {\f2  appears on the left-hand side, any constant terms are 
moved to the right-hand side, but the symbolic factors remain. 
\par 
\par 
Be careful not to make a recursive }{\f3 setq} {\f2  assignment that is not 
controlled inside a loop statement. The process of resubstitution 
continues until you get a stack overflow message. }{\f3 setq} {\f2  can be used 
to attach functionality to operators, as the }{\f3 :=} {\f2  does. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # THIRD}

${\footnote \pard\plain \sl240 \fs20 $ THIRD}

+{\footnote \pard\plain \sl240 \fs20 + g4:0707}

 K{\footnote \pard\plain \sl240 \fs20 K decomposition;list;THIRD operator;operator}

}{\b\f2 THIRD}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 third} {\f2  operator returns the third item of a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 third} {\f4 (<list>) or }{\f3 third} {\f4  <list> 
\par 
\par 
\par 
\par 
}{\f2 <list> must be a list containing at least three items to avoid an error 
message. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
alist := \{a,b,c,d\};  \par
 \par
  ALIST := \{A,B,C,D\}  \par
 \par
 \par
third alist;  \par
 \par
  C  \par
 \par
 \par
blist := \{x,\{aa,bb,cc\},y,z\};  \par
 \par
  BLIST := \{X,\{AA,BB,CC\},Y,Z\};  \par
 \par
 \par
third second blist;  \par
 \par
  CC  \par
 \par
 \par
third blist;  \par
 \par
  Y \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # WHEN}

${\footnote \pard\plain \sl240 \fs20 $ WHEN}

+{\footnote \pard\plain \sl240 \fs20 + g4:0708}

 K{\footnote \pard\plain \sl240 \fs20 K rule;WHEN operator;operator}

}{\b\f2 WHEN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 when} {\f2  operator is used inside a }{\f3 rule} {\f2  to make the 
execution of the rule depend on a boolean condition which is 
evaluated at execution time. For the use see }
{\f2\uldb rule}{\v\f2 RULE} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g4}

${\footnote \pard\plain \sl240 \fs20 $ Syntax}

+{\footnote \pard\plain \sl240 \fs20 + index:0004}
}{\b\f2 Syntax}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb semicolon command}
{\v\f2 semicolon}  (;){\f2 \par 
}{\f2 \tab}{\f2\uldb dollar command}
{\v\f2 dollar}  ($){\f2 \par 
}{\f2 \tab}{\f2\uldb percent command}
{\v\f2 percent}  (%){\f2 \par 
}{\f2 \tab}{\f2\uldb dot operator}
{\v\f2 dot}  (.){\f2 \par 
}{\f2 \tab}{\f2\uldb assign operator}
{\v\f2 assign}  (: =){\f2 \par 
}{\f2 \tab}{\f2\uldb equalsign operator}
{\v\f2 equalsign}  (=){\f2 \par 
}{\f2 \tab}{\f2\uldb replace operator}
{\v\f2 replace}  (= >){\f2 \par 
}{\f2 \tab}{\f2\uldb plussign operator}
{\v\f2 plussign}  (+){\f2 \par 
}{\f2 \tab}{\f2\uldb minussign operator}
{\v\f2 minussign}  (-){\f2 \par 
}{\f2 \tab}{\f2\uldb asterisk operator}
{\v\f2 asterisk}  (*){\f2 \par 
}{\f2 \tab}{\f2\uldb slash operator}
{\v\f2 slash}  (/){\f2 \par 
}{\f2 \tab}{\f2\uldb power operator}
{\v\f2 power}  (* *){\f2 \par 
}{\f2 \tab}{\f2\uldb caret operator}
{\v\f2 caret}  (^){\f2 \par 
}{\f2 \tab}{\f2\uldb geqsign operator}
{\v\f2 geqsign}  (> =){\f2 \par 
}{\f2 \tab}{\f2\uldb greater operator}
{\v\f2 greater}  (>){\f2 \par 
}{\f2 \tab}{\f2\uldb leqsign operator}
{\v\f2 leqsign}  (< =){\f2 \par 
}{\f2 \tab}{\f2\uldb less operator}
{\v\f2 less}  (<){\f2 \par 
}{\f2 \tab}{\f2\uldb tilde operator}
{\v\f2 tilde}  (~){\f2 \par 
}{\f2 \tab}{\f2\uldb group command}
{\v\f2 group}  (< <){\f2 \par 
}{\f2 \tab}{\f2\uldb AND operator}
{\v\f2 AND}{\f2 \par 
}{\f2 \tab}{\f2\uldb BEGIN command}
{\v\f2 BEGIN}{\f2 \par 
}{\f2 \tab}{\f2\uldb block command}
{\v\f2 block}{\f2 \par 
}{\f2 \tab}{\f2\uldb COMMENT command}
{\v\f2 COMMENT}{\f2 \par 
}{\f2 \tab}{\f2\uldb CONS operator}
{\v\f2 CONS}{\f2 \par 
}{\f2 \tab}{\f2\uldb END command}
{\v\f2 END}{\f2 \par 
}{\f2 \tab}{\f2\uldb EQUATION type}
{\v\f2 EQUATION}{\f2 \par 
}{\f2 \tab}{\f2\uldb FIRST operator}
{\v\f2 FIRST}{\f2 \par 
}{\f2 \tab}{\f2\uldb FOR command}
{\v\f2 FOR}{\f2 \par 
}{\f2 \tab}{\f2\uldb FOREACH command}
{\v\f2 FOREACH}{\f2 \par 
}{\f2 \tab}{\f2\uldb GEQ operator}
{\v\f2 GEQ}{\f2 \par 
}{\f2 \tab}{\f2\uldb GOTO command}
{\v\f2 GOTO}{\f2 \par 
}{\f2 \tab}{\f2\uldb GREATERP operator}
{\v\f2 GREATERP}{\f2 \par 
}{\f2 \tab}{\f2\uldb IF command}
{\v\f2 IF}{\f2 \par 
}{\f2 \tab}{\f2\uldb LIST operator}
{\v\f2 LIST}{\f2 \par 
}{\f2 \tab}{\f2\uldb OR operator}
{\v\f2 OR}{\f2 \par 
}{\f2 \tab}{\f2\uldb PROCEDURE command}
{\v\f2 PROCEDURE}{\f2 \par 
}{\f2 \tab}{\f2\uldb REPEAT command}
{\v\f2 REPEAT}{\f2 \par 
}{\f2 \tab}{\f2\uldb REST operator}
{\v\f2 REST}{\f2 \par 
}{\f2 \tab}{\f2\uldb RETURN command}
{\v\f2 RETURN}{\f2 \par 
}{\f2 \tab}{\f2\uldb REVERSE operator}
{\v\f2 REVERSE}{\f2 \par 
}{\f2 \tab}{\f2\uldb RULE type}
{\v\f2 RULE}{\f2 \par 
}{\f2 \tab}{\f2\uldb Free Variable type}
{\v\f2 Free_Variable}{\f2 \par 
}{\f2 \tab}{\f2\uldb Optional Free Variable type}
{\v\f2 Optional_Free_Variable}{\f2 \par 
}{\f2 \tab}{\f2\uldb SECOND operator}
{\v\f2 SECOND}{\f2 \par 
}{\f2 \tab}{\f2\uldb SET operator}
{\v\f2 SET}{\f2 \par 
}{\f2 \tab}{\f2\uldb SETQ operator}
{\v\f2 SETQ}{\f2 \par 
}{\f2 \tab}{\f2\uldb THIRD operator}
{\v\f2 THIRD}{\f2 \par 
}{\f2 \tab}{\f2\uldb WHEN operator}
{\v\f2 WHEN}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ARITHMETIC\_OPERATIONS}

${\footnote \pard\plain \sl240 \fs20 $ ARITHMETIC_OPERATIONS}

+{\footnote \pard\plain \sl240 \fs20 + g5:0709}

 K{\footnote \pard\plain \sl240 \fs20 K ARITHMETIC_OPERATIONS introduction;introduction}

}{\b\f2 ARITHMETIC\_OPERATIONS}{\f2 \tab \tab \tab \tab }{\b\f2 introduction}{\f2 \par 
\par 
 
This section considers operations defined in REDUCE that concern numbers, 
or operators that can operate on numbers in addition, in most cases, to 
more general expressions. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ABS}

${\footnote \pard\plain \sl240 \fs20 $ ABS}

+{\footnote \pard\plain \sl240 \fs20 + g5:0710}

 K{\footnote \pard\plain \sl240 \fs20 K absolute value;ABS operator;operator}

}{\b\f2 ABS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 abs} {\f2  operator returns the absolute value of its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 abs} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
<expression> can be any REDUCE scalar expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
abs(-a);  \par
 \par
  ABS(A)  \par
 \par
 \par
abs(-5);  \par
 \par
  5  \par
 \par
 \par
a := -10;  \par
 \par
  A := -10  \par
 \par
 \par
abs(a);  \par
 \par
  10  \par
 \par
 \par
abs(-a);  \par
 \par
  10 \par
 \par
\pard \sl240 }{\f2 If the argument has had no numeric value assigned to it, such as an 
identifier or polynomial, }{\f3 abs} {\f2  returns an expression involving 
}{\f3 abs} {\f2  of its argument, doing as much simplification of the argument 
as it can, such as dropping any preceding minus sign. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ADJPREC}

${\footnote \pard\plain \sl240 \fs20 $ ADJPREC}

+{\footnote \pard\plain \sl240 \fs20 + g5:0711}

 K{\footnote \pard\plain \sl240 \fs20 K precision;input;ADJPREC switch;switch}

}{\b\f2 ADJPREC}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When a real number is input, it is normally truncated to the 
}
{\f2\uldb precision}{\v\f2 PRECISION} 
{\f2  in 
effect at the time the number is read. If it is desired to keep the full 
precision of all numbers input, the switch }{\f3 adjprec} {\f2  
(for <adjust precision>) can be turned on. While on, }{\f3 adjprec} {\f2  
will automatically increase the precision, when necessary, to match that 
of any integer or real input, and a message printed to inform the user of 
the precision increase. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
1.23456789012345;  \par
 \par
  1.23456789012  \par
 \par
 \par
on adjprec;  \par
 \par
1.23456789012345;  \par
 \par
*** precision increased to 15  \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # ARG}

${\footnote \pard\plain \sl240 \fs20 $ ARG}

+{\footnote \pard\plain \sl240 \fs20 + g5:0712}

 K{\footnote \pard\plain \sl240 \fs20 K polar angle;complex;ARG operator;operator}

}{\b\f2 ARG}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
If }
{\f2\uldb complex}{\v\f2 COMPLEX} 
{\f2  and }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  are on, and arg 
evaluates to a complex number, }{\f3 arg} {\f2  returns the polar angle of 
arg, measured in radians. Otherwise an expression in arg is 
returned. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
arg(3+4i)  \par
 \par
  ARG(3 + 4*I)  \par
 \par
 \par
on rounded, complex;  \par
 \par
ws;  \par
 \par
  0.927295218002  \par
 \par
 \par
arg a;  \par
 \par
  ARG(A) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # CEILING}

${\footnote \pard\plain \sl240 \fs20 $ CEILING}

+{\footnote \pard\plain \sl240 \fs20 + g5:0713}

 K{\footnote \pard\plain \sl240 \fs20 K integer;CEILING operator;operator}

}{\b\f2 CEILING}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 ceiling} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
This operator returns the ceiling (i.e., the least integer greater than or 
equal to its argument) if its argument has a numerical value. For 
negative numbers, this is equivalent to }
{\f2\uldb fix}{\v\f2 FIX} 
{\f2 . For non-numeric 
arguments, the value is an expression in the original operator. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
ceiling 3.4;  \par
 \par
  4  \par
 \par
 \par
fix 3.4;  \par
 \par
  3  \par
 \par
 \par
ceiling(-5.2);  \par
 \par
  -5  \par
 \par
 \par
fix(-5.2);  \par
 \par
  -5  \par
 \par
 \par
ceiling a;  \par
 \par
  CEILING(A) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # CHOOSE}

${\footnote \pard\plain \sl240 \fs20 $ CHOOSE}

+{\footnote \pard\plain \sl240 \fs20 + g5:0714}

 K{\footnote \pard\plain \sl240 \fs20 K CHOOSE operator;operator}

}{\b\f2 CHOOSE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
}{\f3 choose} {\f2 (<m>,<m>) returns the number of ways of choosing 
<m> objects from a collection of <n> distinct objects --- in other 
words the binomial coefficient. If <m> and <n> are not positive 
integers, or }{\f4 m > n}{\f2 , the expression is returned unchanged. 
than or equal to 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
choose(2,3);  \par
 \par
  3  \par
 \par
 \par
choose(3,2);  \par
 \par
  CHOOSE(3,2)  \par
 \par
 \par
choose(a,b);  \par
 \par
  CHOOSE(A,B) \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DEG2DMS}

${\footnote \pard\plain \sl240 \fs20 $ DEG2DMS}

+{\footnote \pard\plain \sl240 \fs20 + g5:0715}

 K{\footnote \pard\plain \sl240 \fs20 K radians;degrees;DEG2DMS operator;operator}

}{\b\f2 DEG2DMS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 deg2dms} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
In }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  mode, if <expression> is a real number, the 
operator }{\f3 deg2dms} {\f2  will interpret it as degrees, and convert it to a 
list containing the equivalent degrees, minutes and seconds. In all other 
cases, an expression in terms of the original operator is returned. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
deg2dms 60;  \par
 \par
  DEG2DMS(60)  \par
 \par
 \par
on rounded;  \par
 \par
ws;  \par
 \par
  \{60,0,0\}  \par
 \par
 \par
deg2dms 42.4;  \par
 \par
  \{42,23,60.0\}  \par
 \par
 \par
deg2dms a;  \par
 \par
  DEG2DMS(A) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # DEG2RAD}

${\footnote \pard\plain \sl240 \fs20 $ DEG2RAD}

+{\footnote \pard\plain \sl240 \fs20 + g5:0716}

 K{\footnote \pard\plain \sl240 \fs20 K radians;degrees;DEG2RAD operator;operator}

}{\b\f2 DEG2RAD}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 deg2rad} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
In }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  mode, if <expression> is a real number, the 
operator }{\f3 deg2rad} {\f2  will interpret it as degrees, and convert it to 
the equivalent radians. In all other cases, an expression in terms of the 
original operator is returned. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
deg2rad 60;  \par
 \par
  DEG2RAD(60)  \par
 \par
 \par
on rounded;  \par
 \par
ws;  \par
 \par
  1.0471975512  \par
 \par
 \par
deg2rad a;  \par
 \par
  DEG2RAD(A) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # DIFFERENCE}

${\footnote \pard\plain \sl240 \fs20 $ DIFFERENCE}

+{\footnote \pard\plain \sl240 \fs20 + g5:0717}

 K{\footnote \pard\plain \sl240 \fs20 K DIFFERENCE operator;operator}

}{\b\f2 DIFFERENCE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 difference} {\f2  operator may be used as either an infix or prefix binary 
subtraction operator. It is identical to }{\f3 -} {\f2  as a binary operator. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 difference} {\f4 (<expression>,<expression>) or 
\par 
\par 
<expression> }{\f3 difference} {\f4  <expression> 
 \{}{\f3 difference} {\f4  <expression>\}* 
\par 
\par 
}{\f2 \par 
<expression> can be a number or any other valid REDUCE expression. Matrix 
expressions are allowed if they are of the same dimensions. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
difference(10,4);  \par
 \par
  6  \par
 \par
 \par
 \par
15 difference 5 difference 2;  \par
 \par
  8  \par
 \par
 \par
 \par
a difference b;  \par
 \par
  A - B \par
 \par
\pard \sl240 }{\f2 The }{\f3 difference} {\f2  operator is left associative, as shown in the second 
example above. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DILOG}

${\footnote \pard\plain \sl240 \fs20 $ DILOG}

+{\footnote \pard\plain \sl240 \fs20 + g5:0718}

 K{\footnote \pard\plain \sl240 \fs20 K dilogarithm function;DILOG operator;operator}

}{\b\f2 DILOG}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 dilog} {\f2  operator is known to the differentiation and integration 
operators, but has numeric value attached only at }{\f3 dilog(0)} {\f2 . Dilog is 
defined by 
\par 
\par 
dilog(x) = -int(log(x),x)/(x-1) 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
df(dilog(x**2),x);  \par
 \par
           2 \par
    2*LOG(X )*X \par
  - ------------ \par
       2 \par
      X   - 1 \par
 \par
 \par
 \par
int(dilog(x),x);  \par
 \par
  DILOG(X)*X - DILOG(X) + LOG(X)*X - X  \par
 \par
 \par
 \par
dilog(0);  \par
 \par
    2 \par
  PI \par
  ---- \par
   6 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # DMS2DEG}

${\footnote \pard\plain \sl240 \fs20 $ DMS2DEG}

+{\footnote \pard\plain \sl240 \fs20 + g5:0719}

 K{\footnote \pard\plain \sl240 \fs20 K radians;degrees;DMS2DEG operator;operator}

}{\b\f2 DMS2DEG}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 dms2deg} {\f4 (<list>) 
\par 
\par 
}{\f2 \par 
In }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  mode, if <list> is a list of three real numbers, 
the operator }{\f3 dms2deg} {\f2  will interpret the list as degrees, minutes 
and seconds and convert it to the equivalent degrees. In all other cases, 
an expression in terms of the original operator is returned. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
dms2deg \{42,3,7\};  \par
 \par
  DMS2DEG(\{42,3,7\})  \par
 \par
 \par
on rounded;  \par
 \par
ws;  \par
 \par
  42.0519444444  \par
 \par
 \par
dms2deg a;  \par
 \par
  DMS2DEG(A) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # DMS2RAD}

${\footnote \pard\plain \sl240 \fs20 $ DMS2RAD}

+{\footnote \pard\plain \sl240 \fs20 + g5:0720}

 K{\footnote \pard\plain \sl240 \fs20 K radians;degrees;DMS2RAD operator;operator}

}{\b\f2 DMS2RAD}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 dms2rad} {\f4 (<list>) 
\par 
\par 
}{\f2 \par 
In }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  mode, if <list> is a list of three real numbers, 
the operator }{\f3 dms2rad} {\f2  will interpret the list as degrees, minutes 
and seconds and convert it to the equivalent radians. In all other cases, 
an expression in terms of the original operator is returned. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
dms2rad \{42,3,7\};  \par
 \par
  DMS2RAD(\{42,3,7\})  \par
 \par
 \par
on rounded;  \par
 \par
ws;  \par
 \par
  0.733944887421  \par
 \par
 \par
dms2rad a;  \par
 \par
  DMS2RAD(A) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # FACTORIAL}

${\footnote \pard\plain \sl240 \fs20 $ FACTORIAL}

+{\footnote \pard\plain \sl240 \fs20 + g5:0721}

 K{\footnote \pard\plain \sl240 \fs20 K gamma;FACTORIAL operator;operator}

}{\b\f2 FACTORIAL}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 factorial} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
If the argument of }{\f3 factorial} {\f2  is a positive integer or zero, its 
factorial is returned. Otherwise the result is expressed in terms of the 
original operator. For more general operations, the }
{\f2\uldb gamma}{\v\f2 GAMMA} 
{\f2  operator 
is available in the }
{\f2\uldb Special Function Package}{\v\f2 Special_Function_Package} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
factorial 4;  \par
 \par
  24  \par
 \par
 \par
factorial 30 ;  \par
 \par
  265252859812191058636308480000000  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # FIX}

${\footnote \pard\plain \sl240 \fs20 $ FIX}

+{\footnote \pard\plain \sl240 \fs20 + g5:0722}

 K{\footnote \pard\plain \sl240 \fs20 K integer;FIX operator;operator}

}{\b\f2 FIX}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 fix} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
The operator }{\f3 fix} {\f2  returns the integer part of its argument, if that 
argument has a numerical value. For positive numbers, this is equivalent 
to }
{\f2\uldb floor}{\v\f2 FLOOR} 
{\f2 , and, for negative numbers, }
{\f2\uldb ceiling}{\v\f2 CEILING} 
{\f2 . For 
non-numeric arguments, the value is an expression in the original operator. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
fix 3.4;  \par
 \par
  3  \par
 \par
 \par
floor 3.4;  \par
 \par
  3  \par
 \par
 \par
ceiling 3.4;  \par
 \par
  4  \par
 \par
 \par
fix(-5.2);  \par
 \par
  -5  \par
 \par
 \par
floor(-5.2);  \par
 \par
  -6  \par
 \par
 \par
ceiling(-5.2);  \par
 \par
  -5  \par
 \par
 \par
fix(a);  \par
 \par
  FIX(A) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # FIXP}

${\footnote \pard\plain \sl240 \fs20 $ FIXP}

+{\footnote \pard\plain \sl240 \fs20 + g5:0723}

 K{\footnote \pard\plain \sl240 \fs20 K integer;FIXP operator;operator}

}{\b\f2 FIXP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 fixp} {\f2  logical operator returns true if its argument is an integer. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 fixp} {\f4 (<expression>) or }{\f3 fixp} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE expression, <simple\_expression> 
must be a single identifier or begin with a prefix operator. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
if fixp 1.5 then write "ok" else write "not"; \par
			  \par
 \par
 \par
  not  \par
 \par
 \par
if fixp(a) then write "ok" else write "not"; \par
			  \par
 \par
 \par
  not  \par
 \par
 \par
a := 15;  \par
 \par
  A := 15  \par
 \par
 \par
if fixp(a) then write "ok" else write "not"; \par
			  \par
 \par
 \par
  ok \par
 \par
\pard \sl240 }{\f2 Logical operators can only be used inside conditional expressions such as 
}{\f3 if} {\f2 ...}{\f3 then} {\f2  or }{\f3 while} {\f2 ...}{\f3 do} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FLOOR}

${\footnote \pard\plain \sl240 \fs20 $ FLOOR}

+{\footnote \pard\plain \sl240 \fs20 + g5:0724}

 K{\footnote \pard\plain \sl240 \fs20 K integer;FLOOR operator;operator}

}{\b\f2 FLOOR}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 floor} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
This operator returns the floor (i.e., the greatest integer less than or 
equal to its argument) if its argument has a numerical value. For 
positive numbers, this is equivalent to }
{\f2\uldb fix}{\v\f2 FIX} 
{\f2 . For non-numeric 
arguments, the value is an expression in the original operator. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
floor 3.4;  \par
 \par
  3  \par
 \par
 \par
fix 3.4;  \par
 \par
  3  \par
 \par
 \par
floor(-5.2);  \par
 \par
  -6  \par
 \par
 \par
fix(-5.2);  \par
 \par
  -5  \par
 \par
 \par
floor a;  \par
 \par
  FLOOR(A) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # EXPT}

${\footnote \pard\plain \sl240 \fs20 $ EXPT}

+{\footnote \pard\plain \sl240 \fs20 + g5:0725}

 K{\footnote \pard\plain \sl240 \fs20 K EXPT operator;operator}

}{\b\f2 EXPT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 expt} {\f2  operator is both an infix and prefix binary exponentiation 
operator. It is identical to }{\f3 ^} {\f2  or }{\f3 **} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 expt} {\f4 (<expression>,<expression>) 
 or <expression> }{\f3 expt} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a expt b;  \par
 \par
   B \par
  A   \par
 \par
 \par
expt(a,b);  \par
 \par
   B \par
  A   \par
 \par
 \par
(x+y) expt 4;  \par
 \par
   4      3        2  2        3    4 \par
  X  + 4*X *Y + 6*X *Y  + 4*X*Y  + Y \par
 \par
\pard \sl240 }{\f2 Scalar expressions may be raised to fractional and floating-point powers. 
Square matrix expressions may be raised to positive powers, and also to 
negative powers if non-singular. 
\par 
\par 
}{\f3 expt} {\f2 is left associative. In other words, }{\f3 a expt b expt c} {\f2  is 
equivalent to }{\f3 a expt (b*c)} {\f2 , not }{\f3 a expt (b expt c)} {\f2 , which 
would be right associative. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # GCD}

${\footnote \pard\plain \sl240 \fs20 $ GCD}

+{\footnote \pard\plain \sl240 \fs20 + g5:0726}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;greatest common divisor;GCD operator;operator}

}{\b\f2 GCD}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 gcd} {\f2  operator returns the greatest common divisor of two 
polynomials. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 gcd} {\f4 (<expression>,<expression>) 
\par 
\par 
}{\f2 \par 
<expression> must be a polynomial (or integer), otherwise an error 
occurs. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
gcd(2*x**2 - 2*y**2,4*x + 4*y);  \par
 \par
  2*(X + Y)  \par
 \par
 \par
gcd(sin(x),x**2 + 1);  \par
 \par
  1   \par
 \par
 \par
gcd(765,68);  \par
 \par
  17 \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 gcd} {\f2  described here provides an explicit means to find the 
gcd of two expressions. The switch }{\f3 gcd} {\f2  described below simplifies 
expressions by finding and canceling gcd's at every opportunity. When 
the switch }
{\f2\uldb ezgcd}{\v\f2 EZGCD} 
{\f2  is also on, gcd's are figured using the EZ GCD 
algorithm, which is usually faster. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LN}

${\footnote \pard\plain \sl240 \fs20 $ LN}

+{\footnote \pard\plain \sl240 \fs20 + g5:0727}

 K{\footnote \pard\plain \sl240 \fs20 K logarithm;LN operator;operator}

}{\b\f2 LN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 ln} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
<expression> can be any valid scalar REDUCE expression. 
\par 
\par 
The }{\f3 ln} {\f2  operator returns the natural logarithm of its argument. 
However, unlike }
{\f2\uldb log}{\v\f2 LOG} 
{\f2 , there are no algebraic rules associated 
with it; it will only evaluate when }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on, and the 
argument is a real number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
ln(x);  \par
 \par
  LN(X)  \par
 \par
 \par
ln 4;  \par
 \par
  LN(4)  \par
 \par
 \par
ln(e);  \par
 \par
  LN(E)  \par
 \par
 \par
df(ln(x),x);  \par
 \par
  DF(LN(X),X)  \par
 \par
 \par
on rounded;  \par
 \par
ln 4;  \par
 \par
  1.38629436112  \par
 \par
 \par
ln e;  \par
 \par
  1 \par
 \par
\pard \sl240 }{\f2 Because of the restricted algebraic properties of }{\f3 ln} {\f2 , users are 
advised to use }
{\f2\uldb log}{\v\f2 LOG} 
{\f2  whenever possible. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LOG}

${\footnote \pard\plain \sl240 \fs20 $ LOG}

+{\footnote \pard\plain \sl240 \fs20 + g5:0728}

 K{\footnote \pard\plain \sl240 \fs20 K logarithm;LOG operator;operator}

}{\b\f2 LOG}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 log} {\f2  operator returns the natural logarithm of its argument. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 log} {\f4 (<expression>) or }{\f3 log} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<expression> can be any valid scalar REDUCE expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
log(x);  \par
 \par
  LOG(X)  \par
 \par
 \par
log 4;  \par
 \par
  LOG(4)  \par
 \par
 \par
log(e);  \par
 \par
  1  \par
 \par
 \par
on rounded;  \par
 \par
log 4;  \par
 \par
  1.38629436112 \par
 \par
\pard \sl240 }{\f2 }{\f3 log} {\f2 returns a numeric value only when }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on. In that 
case, use of a negative argument for }{\f3 log} {\f2  results in an error 
message. No error is given on a negative argument when REDUCE is not in 
that mode. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LOGB}

${\footnote \pard\plain \sl240 \fs20 $ LOGB}

+{\footnote \pard\plain \sl240 \fs20 + g5:0729}

 K{\footnote \pard\plain \sl240 \fs20 K logarithm;LOGB operator;operator}

}{\b\f2 LOGB}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 logb} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
<expression> can be any valid scalar REDUCE expression. 
\par 
\par 
The }{\f3 logb} {\f2  operator returns the logarithm of its first argument using 
the second argument as base. However, unlike }
{\f2\uldb log}{\v\f2 LOG} 
{\f2 , there are no 
algebraic rules associated with it; it will only evaluate when 
}
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on, and the first argument is a real number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
logb(x,2);  \par
 \par
  LOGB(X,2)  \par
 \par
 \par
logb(4,3);  \par
 \par
  LOGB(4,3)  \par
 \par
 \par
logb(2,2);  \par
 \par
  LOGB(2,2)  \par
 \par
 \par
df(logb(x,3),x);  \par
 \par
  DF(LOGB(X,3),X)  \par
 \par
 \par
on rounded;  \par
 \par
logb(4,3);  \par
 \par
  1.26185950714  \par
 \par
 \par
logb(2,2);  \par
 \par
  1 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # MAX}

${\footnote \pard\plain \sl240 \fs20 $ MAX}

+{\footnote \pard\plain \sl240 \fs20 + g5:0730}

 K{\footnote \pard\plain \sl240 \fs20 K maximum;MAX operator;operator}

}{\b\f2 MAX}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 max} {\f2  is an n-ary prefix operator, which returns the largest 
value in its arguments. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 max} {\f4 (<expression>\{,<expression>\}*) 
\par 
\par 
\par 
\par 
}{\f2 <expression> must evaluate to a number. }{\f3 max} {\f2  of an empty list 
returns 0. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
max(4,6,10,-1);  \par
 \par
  10  \par
 \par
 \par
<<a := 23;b := 2*a;c := 4**2;max(a,b,c)>>; \par
			  \par
 \par
 \par
  46  \par
 \par
 \par
max(-5,-10,-a);  \par
 \par
  -5 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # MIN}

${\footnote \pard\plain \sl240 \fs20 $ MIN}

+{\footnote \pard\plain \sl240 \fs20 + g5:0731}

 K{\footnote \pard\plain \sl240 \fs20 K minimum;MIN operator;operator}

}{\b\f2 MIN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 min} {\f2  is an n-ary prefix operator, which returns the 
smallest value in its arguments. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 min} {\f4 (<expression>\{,<expression>\}*) 
\par 
\par 
}{\f2 \par 
<expression> must evaluate to a number. }{\f3 min} {\f2  of an empty list 
returns 0. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
min(-3,0,17,2);  \par
 \par
  -3  \par
 \par
 \par
<<a := 23;b := 2*a;c := 4**2;min(a,b,c)>>; \par
			  \par
 \par
 \par
  16  \par
 \par
 \par
min(5,10,a);  \par
 \par
  5 \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MINUS}

${\footnote \pard\plain \sl240 \fs20 $ MINUS}

+{\footnote \pard\plain \sl240 \fs20 + g5:0732}

 K{\footnote \pard\plain \sl240 \fs20 K MINUS operator;operator}

}{\b\f2 MINUS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 minus} {\f2  operator is a unary minus, returning the negative of its 
argument. It is equivalent to the unary }{\f3 -} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 minus} {\f4 (<expression>) 
\par 
\par 
\par 
\par 
}{\f2 <expression> may be any scalar REDUCE expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
minus(a);  \par
 \par
  - A  \par
 \par
 \par
minus(-1);  \par
 \par
  1  \par
 \par
 \par
minus((x+1)**4);  \par
 \par
      4      3      2 \par
  - (X  + 4*X  + 6*X  + 4*X + 1) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # NEXTPRIME}

${\footnote \pard\plain \sl240 \fs20 $ NEXTPRIME}

+{\footnote \pard\plain \sl240 \fs20 + g5:0733}

 K{\footnote \pard\plain \sl240 \fs20 K prime number;NEXTPRIME operator;operator}

}{\b\f2 NEXTPRIME}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 nextprime} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
If the argument of }{\f3 nextprime} {\f2  is an integer, the least prime greater 
than that argument is returned. Otherwise, a type error results. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
nextprime 5001;  \par
 \par
  5003   \par
 \par
 \par
nextprime(10^30);  \par
 \par
  1000000000000000000000000000057  \par
 \par
 \par
nextprime a;  \par
 \par
  ***** A invalid as integer \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # NOCONVERT}

${\footnote \pard\plain \sl240 \fs20 $ NOCONVERT}

+{\footnote \pard\plain \sl240 \fs20 + g5:0734}

 K{\footnote \pard\plain \sl240 \fs20 K NOCONVERT switch;switch}

}{\b\f2 NOCONVERT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
Under normal circumstances when }{\f3 rounded} {\f2  is on, REDUCE converts the 
number 1.0 to the integer 1. If this is not desired, the switch 
}{\f3 noconvert} {\f2  can be turned on. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
1.0000000000001;  \par
 \par
  1  \par
 \par
 \par
on noconvert;  \par
 \par
1.0000000000001;  \par
 \par
  1.0  \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NORM}

${\footnote \pard\plain \sl240 \fs20 $ NORM}

+{\footnote \pard\plain \sl240 \fs20 + g5:0735}

 K{\footnote \pard\plain \sl240 \fs20 K complex;NORM operator;operator}

}{\b\f2 NORM}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 norm} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
If }{\f3 rounded} {\f2  is on, and the argument is a real number, <norm> 
returns its absolute value. If }{\f3 complex} {\f2  is also on, <norm> 
returns the square root of the sum of squares of the real and imaginary 
parts of the argument. In all other cases, a result is returned in 
terms of the original operator. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
norm (-2);  \par
 \par
  NORM(-2)  \par
 \par
 \par
on rounded; \par
 \par
ws;  \par
 \par
  2.0  \par
 \par
 \par
norm(3+4i);  \par
 \par
  NORM(4*I+3)  \par
 \par
 \par
on complex; \par
 \par
ws;  \par
 \par
  5.0 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # PERM}

${\footnote \pard\plain \sl240 \fs20 $ PERM}

+{\footnote \pard\plain \sl240 \fs20 + g5:0736}

 K{\footnote \pard\plain \sl240 \fs20 K permutation;PERM operator;operator}

}{\b\f2 PERM}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 perm(<expression1>,<expression2>) 
\par 
\par 
}{\f2 \par 
If <expression1> and <expression2> evaluate to positive integers, 
}{\f3 perm} {\f2  returns the number of permutations possible in selecting 
<expression1> objects from <expression2> objects. 
In other cases, an expression in the original operator is returned. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
perm(1,1);  \par
 \par
  1  \par
 \par
 \par
perm(3,5);  \par
 \par
  60  \par
 \par
 \par
perm(-3,5);  \par
 \par
  PERM(-3,5)  \par
 \par
 \par
perm(a,b);  \par
 \par
  PERM(A,B) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # PLUS}

${\footnote \pard\plain \sl240 \fs20 $ PLUS}

+{\footnote \pard\plain \sl240 \fs20 + g5:0737}

 K{\footnote \pard\plain \sl240 \fs20 K PLUS operator;operator}

}{\b\f2 PLUS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 plus} {\f2  operator is both an infix and prefix n-ary addition 
operator. It exists because of the way in which REDUCE handles such 
operators internally, and is not recommended for use in algebraic mode 
programming. }
{\f2\uldb plussign}{\v\f2 plussign} 
{\f2 , which has the identical effect, should be 
used instead. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 plus} {\f4 (<expression>,<expression>\{,<expression>\} 
*) or 
\par 
\par 
<expression> }{\f3 plus} {\f4  <expression> \{}{\f3 plus} {\f4  <expression>\}* 
\par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE expression, including matrix 
expressions of the same dimensions. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a plus b plus c plus d;  \par
 \par
  A + B + C + D  \par
 \par
 \par
4.5 plus 10;  \par
 \par
  29 \par
  --  \par
  2 \par
 \par
 \par
 \par
plus(x**2,y**2);  \par
 \par
   2    2 \par
  X  + Y \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # QUOTIENT}

${\footnote \pard\plain \sl240 \fs20 $ QUOTIENT}

+{\footnote \pard\plain \sl240 \fs20 + g5:0738}

 K{\footnote \pard\plain \sl240 \fs20 K QUOTIENT operator;operator}

}{\b\f2 QUOTIENT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 quotient} {\f2  operator is both an infix and prefix binary operator that 
returns the quotient of its first argument divided by its second. It is 
also a unary }
{\f2\uldb recip}{\v\f2 RECIP} 
{\f2 rocal operator. It is identical to }{\f3 /} {\f2  and 
}
{\f2\uldb slash}{\v\f2 slash} 
{\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 quotient} {\f4 (<expression>,<expression>) or 
<expression> }{\f3 quotient} {\f4  <expression> or 
}{\f3 quotient} {\f4 (<expression>) or 
}{\f3 quotient} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE scalar expression. Matrix 
expressions can also be used if the second expression is invertible and the 
matrices are of the correct dimensions. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
quotient(a,x+1);  \par
 \par
    A \par
  -----  \par
  X + 1 \par
 \par
 \par
7 quotient 17;  \par
 \par
  7 \par
  --  \par
  17 \par
 \par
 \par
on rounded;  \par
 \par
4.5 quotient 2;  \par
 \par
  2.25  \par
 \par
 \par
quotient(x**2 + 3*x + 2,x+1);  \par
 \par
  X + 2  \par
 \par
 \par
matrix m,inverse;  \par
 \par
m := mat((a,b),(c,d));  \par
 \par
  M(1,1) := A; \par
  M(1,2) := B; \par
  M(2,1) := C \par
  M(2,2) := D \par
 \par
 \par
 \par
inverse := quotient m;  \par
 \par
                      D \par
  INVERSE(1,1) := ---------- \par
                  A*D - B*C \par
                        B \par
  INVERSE(1,2) := - ---------- \par
                    A*D - B*C \par
                        C \par
  INVERSE(2,1) := - ---------- \par
                    A*D - B*C \par
                      A \par
  INVERSE(2,2) := ---------- \par
                  A*D - B*C \par
 \par
\pard \sl240 }{\f2 \par 
\par 
The }{\f3 quotient} {\f2  operator is left associative: }{\f3 a quotient b quotient c} {\f2  
is equivalent to }{\f3 (a quotient b) quotient c} {\f2 . 
\par 
\par 
If a matrix argument to the unary }{\f3 quotient} {\f2  is not invertible, or if the 
second matrix argument to the binary quotient is not invertible, an error 
message is given. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RAD2DEG}

${\footnote \pard\plain \sl240 \fs20 $ RAD2DEG}

+{\footnote \pard\plain \sl240 \fs20 + g5:0739}

 K{\footnote \pard\plain \sl240 \fs20 K radians;degrees;RAD2DEG operator;operator}

}{\b\f2 RAD2DEG}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 rad2deg} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
In }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  mode, if <expression> is a real number, the 
operator }{\f3 rad2deg} {\f2  will interpret it as radians, and convert it to 
the equivalent degrees. In all other cases, an expression in terms of the 
original operator is returned. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
rad2deg 1;  \par
 \par
  RAD2DEG(1)  \par
 \par
 \par
on rounded;  \par
 \par
ws;  \par
 \par
  57.2957795131  \par
 \par
 \par
rad2deg a;  \par
 \par
  RAD2DEG(A) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # RAD2DMS}

${\footnote \pard\plain \sl240 \fs20 $ RAD2DMS}

+{\footnote \pard\plain \sl240 \fs20 + g5:0740}

 K{\footnote \pard\plain \sl240 \fs20 K radians;degrees;RAD2DMS operator;operator}

}{\b\f2 RAD2DMS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 rad2dms} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
In }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  mode, if <expression> is a real number, the 
operator }{\f3 rad2dms} {\f2  will interpret it as radians, and convert it to a 
list containing the equivalent degrees, minutes and seconds. In all other 
cases, an expression in terms of the original operator is returned. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
rad2dms 1;  \par
 \par
  RAD2DMS(1)  \par
 \par
 \par
on rounded;  \par
 \par
ws;  \par
 \par
  \{57,17,44.8062470964\}  \par
 \par
 \par
rad2dms a;  \par
 \par
  RAD2DMS(A) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # RECIP}

${\footnote \pard\plain \sl240 \fs20 $ RECIP}

+{\footnote \pard\plain \sl240 \fs20 + g5:0741}

 K{\footnote \pard\plain \sl240 \fs20 K RECIP operator;operator}

}{\b\f2 RECIP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
}{\f3 recip} {\f2  is the alphabetical name for the division operator }{\f3 /} {\f2  
or }
{\f2\uldb slash}{\v\f2 slash} 
{\f2  used as a unary operator. The use of }{\f3 /} {\f2  is preferred. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
recip a;  \par
 \par
  1 \par
  -  \par
  A \par
 \par
 \par
recip 2;  \par
 \par
  1 \par
  -- \par
  2 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # REMAINDER}

${\footnote \pard\plain \sl240 \fs20 $ REMAINDER}

+{\footnote \pard\plain \sl240 \fs20 + g5:0742}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;REMAINDER operator;operator}

}{\b\f2 REMAINDER}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 remainder} {\f2  operator returns the remainder after its first 
argument is divided by its second argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 remainder} {\f4 (<expression>,<expression>) 
\par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE polynomial, and is not limited 
to numeric values. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
remainder(13,6);  \par
 \par
  1  \par
 \par
 \par
remainder(x**2 + 3*x + 2,x+1);  \par
 \par
  0   \par
 \par
 \par
remainder(x**3 + 12*x + 4,x**2 + 1);  \par
 \par
 \par
  11*X + 4  \par
 \par
 \par
remainder(sin(2*x),x*y);  \par
 \par
  SIN(2*X) \par
 \par
\pard \sl240 }{\f2 In the default case, remainders are calculated over the integers. If you 
need the remainder with respect to another domain, it must be declared 
explicitly. 
\par 
\par 
If the first argument to }{\f3 remainder} {\f2  contains a denominator not equal to 
1, an error occurs. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ROUND}

${\footnote \pard\plain \sl240 \fs20 $ ROUND}

+{\footnote \pard\plain \sl240 \fs20 + g5:0743}

 K{\footnote \pard\plain \sl240 \fs20 K integer;ROUND operator;operator}

}{\b\f2 ROUND}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 round} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
If its argument has a numerical value, }{\f3 round} {\f2  rounds it to the 
nearest integer. For non-numeric arguments, the value is an expression in 
the original operator. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
round 3.4;  \par
 \par
  3  \par
 \par
 \par
round 3.5;  \par
 \par
  4  \par
 \par
 \par
round a;  \par
 \par
  ROUND(A) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # SETMOD}

${\footnote \pard\plain \sl240 \fs20 $ SETMOD}

+{\footnote \pard\plain \sl240 \fs20 + g5:0744}

 K{\footnote \pard\plain \sl240 \fs20 K modular;SETMOD command;command}

}{\b\f2 SETMOD}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 setmod} {\f2  command sets the modulus value for subsequent }
{\f2\uldb modular}{\v\f2 MODULAR} 
{\f2  
arithmetic. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 setmod} {\f4 <integer> 
\par 
\par 
}{\f2 \par 
<integer> must be positive, and greater than 1. It need not be a prime 
number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
setmod 6;  \par
 \par
  1  \par
 \par
 \par
on modular;  \par
 \par
16;  \par
 \par
  4  \par
 \par
 \par
x^2 + 5x + 7;  \par
 \par
   2 \par
  X  + 5*X + 1  \par
 \par
 \par
x/3;  \par
 \par
  X \par
  -  \par
  3 \par
 \par
 \par
setmod 2;  \par
 \par
  6  \par
 \par
 \par
(x+1)^4;  \par
 \par
   4 \par
  X  + 1  \par
 \par
 \par
x/3;  \par
 \par
  X \par
 \par
\pard \sl240 }{\f2 }{\f3 setmod} {\f2 returns the previous modulus, or 1 if none has been set 
before. }{\f3 setmod} {\f2  only has effect when }
{\f2\uldb modular}{\v\f2 MODULAR} 
{\f2  is on. 
\par 
\par 
Modular operations are done only on numbers such as coefficients of 
polynomials, not on the exponents. The modulus need not be prime. 
Attempts to divide by a power of the modulus produces an error message, since the 
operation is equivalent to dividing by 0. However, dividing by a factor 
of a non-prime modulus does not produce an error message. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SIGN}

${\footnote \pard\plain \sl240 \fs20 $ SIGN}

+{\footnote \pard\plain \sl240 \fs20 + g5:0745}

 K{\footnote \pard\plain \sl240 \fs20 K SIGN operator;operator}

}{\b\f2 SIGN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 sign} {\f4 <expression> 
\par 
\par 
}{\f2 \par 
}{\f3 sign} {\f2 tries to evaluate the sign of its argument. If this 
is possible }{\f3 sign} {\f2  returns one of 1, 0 or -1. Otherwise, the result 
is the original form or a simplified variant. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
        sign(-5)  \par
 \par
  -1 \par
 \par
 \par
        sign(-a^2*b)  \par
 \par
  -SIGN(B) \par
 \par
\pard \sl240 }{\f2 Even powers of formal expressions are assumed to be positive only as long 
as the switch }
{\f2\uldb complex}{\v\f2 COMPLEX} 
{\f2  is off. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SQRT}

${\footnote \pard\plain \sl240 \fs20 $ SQRT}

+{\footnote \pard\plain \sl240 \fs20 + g5:0746}

 K{\footnote \pard\plain \sl240 \fs20 K square root;SQRT operator;operator}

}{\b\f2 SQRT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 sqrt} {\f2  operator returns the square root of its argument. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 sqrt} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
<expression> can be any REDUCE scalar expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
sqrt(16*a^3);  \par
 \par
  4*SQRT(A)*A  \par
 \par
 \par
sqrt(17);  \par
 \par
  SQRT(17)  \par
 \par
 \par
on rounded;  \par
 \par
sqrt(17);  \par
 \par
  4.12310562562  \par
 \par
 \par
off rounded;  \par
 \par
sqrt(a*b*c^5*d^3*27);  \par
 \par
                                             2 \par
  3*SQRT(D)*SQRT(C)*SQRT(B)*SQRT(A)*SQRT(3)*C *D \par
 \par
\pard \sl240 }{\f2 }{\f3 sqrt} {\f2 checks its argument for squared factors and removes them. 
\par 
\par 
Numeric values for square roots that are not exact integers are given only 
when }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on. 
\par 
\par 
Please note that }{\f3 sqrt(a**2)} {\f2  is given as }{\f3 a} {\f2 , which may be 
incorrect if }{\f3 a} {\f2  eventually has a negative value. If you are 
programming a calculation in which this is a concern, you can turn on the 
}
{\f2\uldb precise}{\v\f2 PRECISE} 
{\f2  switch, which causes the absolute value of the square root 
to be returned. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TIMES}

${\footnote \pard\plain \sl240 \fs20 $ TIMES}

+{\footnote \pard\plain \sl240 \fs20 + g5:0747}

 K{\footnote \pard\plain \sl240 \fs20 K TIMES operator;operator}

}{\b\f2 TIMES}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 times} {\f2  operator is an infix or prefix n-ary multiplication 
operator. It is identical to }{\f3 *} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
<expression> }{\f3 times} {\f4  <expression> \{}{\f3 times} {\f4  <expression>\}* 
\par 
\par 
or }{\f3 times} {\f4 (<expression>,<expression> \{,<expression>\}*) 
\par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE scalar or matrix expression. 
Matrix expressions must be of the correct dimensions. Compatible scalar 
and matrix expressions can be mixed. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
var1 times var2;  \par
 \par
  VAR1*VAR2  \par
 \par
 \par
times(6,5);  \par
 \par
  30  \par
 \par
 \par
matrix aa,bb;  \par
 \par
aa := mat((1),(2),(x))\$  \par
 \par
bb := mat((0,3,1))\$  \par
 \par
aa times bb times 5;  \par
 \par
  [0   15    5 ] \par
  [            ] \par
  [0   30   10 ] \par
  [            ] \par
  [0  15*X  5*X] \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # g5}

${\footnote \pard\plain \sl240 \fs20 $ Arithmetic Operations}

+{\footnote \pard\plain \sl240 \fs20 + index:0005}
}{\b\f2 Arithmetic Operations}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb ARITHMETIC\_OPERATIONS introduction}
{\v\f2 ARITHMETIC\_OPERATIONS}{\f2 \par 
}{\f2 \tab}{\f2\uldb ABS operator}
{\v\f2 ABS}{\f2 \par 
}{\f2 \tab}{\f2\uldb ADJPREC switch}
{\v\f2 ADJPREC}{\f2 \par 
}{\f2 \tab}{\f2\uldb ARG operator}
{\v\f2 ARG}{\f2 \par 
}{\f2 \tab}{\f2\uldb CEILING operator}
{\v\f2 CEILING}{\f2 \par 
}{\f2 \tab}{\f2\uldb CHOOSE operator}
{\v\f2 CHOOSE}{\f2 \par 
}{\f2 \tab}{\f2\uldb DEG2DMS operator}
{\v\f2 DEG2DMS}{\f2 \par 
}{\f2 \tab}{\f2\uldb DEG2RAD operator}
{\v\f2 DEG2RAD}{\f2 \par 
}{\f2 \tab}{\f2\uldb DIFFERENCE operator}
{\v\f2 DIFFERENCE}{\f2 \par 
}{\f2 \tab}{\f2\uldb DILOG operator}
{\v\f2 DILOG}{\f2 \par 
}{\f2 \tab}{\f2\uldb DMS2DEG operator}
{\v\f2 DMS2DEG}{\f2 \par 
}{\f2 \tab}{\f2\uldb DMS2RAD operator}
{\v\f2 DMS2RAD}{\f2 \par 
}{\f2 \tab}{\f2\uldb FACTORIAL operator}
{\v\f2 FACTORIAL}{\f2 \par 
}{\f2 \tab}{\f2\uldb FIX operator}
{\v\f2 FIX}{\f2 \par 
}{\f2 \tab}{\f2\uldb FIXP operator}
{\v\f2 FIXP}{\f2 \par 
}{\f2 \tab}{\f2\uldb FLOOR operator}
{\v\f2 FLOOR}{\f2 \par 
}{\f2 \tab}{\f2\uldb EXPT operator}
{\v\f2 EXPT}{\f2 \par 
}{\f2 \tab}{\f2\uldb GCD operator}
{\v\f2 GCD}{\f2 \par 
}{\f2 \tab}{\f2\uldb LN operator}
{\v\f2 LN}{\f2 \par 
}{\f2 \tab}{\f2\uldb LOG operator}
{\v\f2 LOG}{\f2 \par 
}{\f2 \tab}{\f2\uldb LOGB operator}
{\v\f2 LOGB}{\f2 \par 
}{\f2 \tab}{\f2\uldb MAX operator}
{\v\f2 MAX}{\f2 \par 
}{\f2 \tab}{\f2\uldb MIN operator}
{\v\f2 MIN}{\f2 \par 
}{\f2 \tab}{\f2\uldb MINUS operator}
{\v\f2 MINUS}{\f2 \par 
}{\f2 \tab}{\f2\uldb NEXTPRIME operator}
{\v\f2 NEXTPRIME}{\f2 \par 
}{\f2 \tab}{\f2\uldb NOCONVERT switch}
{\v\f2 NOCONVERT}{\f2 \par 
}{\f2 \tab}{\f2\uldb NORM operator}
{\v\f2 NORM}{\f2 \par 
}{\f2 \tab}{\f2\uldb PERM operator}
{\v\f2 PERM}{\f2 \par 
}{\f2 \tab}{\f2\uldb PLUS operator}
{\v\f2 PLUS}{\f2 \par 
}{\f2 \tab}{\f2\uldb QUOTIENT operator}
{\v\f2 QUOTIENT}{\f2 \par 
}{\f2 \tab}{\f2\uldb RAD2DEG operator}
{\v\f2 RAD2DEG}{\f2 \par 
}{\f2 \tab}{\f2\uldb RAD2DMS operator}
{\v\f2 RAD2DMS}{\f2 \par 
}{\f2 \tab}{\f2\uldb RECIP operator}
{\v\f2 RECIP}{\f2 \par 
}{\f2 \tab}{\f2\uldb REMAINDER operator}
{\v\f2 REMAINDER}{\f2 \par 
}{\f2 \tab}{\f2\uldb ROUND operator}
{\v\f2 ROUND}{\f2 \par 
}{\f2 \tab}{\f2\uldb SETMOD command}
{\v\f2 SETMOD}{\f2 \par 
}{\f2 \tab}{\f2\uldb SIGN operator}
{\v\f2 SIGN}{\f2 \par 
}{\f2 \tab}{\f2\uldb SQRT operator}
{\v\f2 SQRT}{\f2 \par 
}{\f2 \tab}{\f2\uldb TIMES operator}
{\v\f2 TIMES}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # boolean_value}

${\footnote \pard\plain \sl240 \fs20 $ boolean_value}

+{\footnote \pard\plain \sl240 \fs20 + g6:0748}

 K{\footnote \pard\plain \sl240 \fs20 K boolean value concept;concept}

}{\b\f2 BOOLEAN VALUE}{\f2 \par 
\par 
 
There are no extra symbols for the truth values true 
and false. Instead, }
{\f2\uldb nil}{\v\f2 NIL} 
{\f2  and the number zero 
are interpreted as truth value false in algebraic 
programs (see }
{\f2\uldb false}{\v\f2 false} 
{\f2 ), while any different 
value is considered as true (see }
{\f2\uldb true}{\v\f2 TRUE} 
{\f2 ). 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EQUAL}

${\footnote \pard\plain \sl240 \fs20 $ EQUAL}

+{\footnote \pard\plain \sl240 \fs20 + g6:0749}

 K{\footnote \pard\plain \sl240 \fs20 K equation;EQUAL operator;operator}

}{\b\f2 EQUAL}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 equal} {\f2  is an infix binary comparison 
operator. It is identical with }{\f3 =} {\f2 . It returns }
{\f2\uldb true}{\v\f2 TRUE} 
{\f2  if its two 
arguments are equal. 
\par 
\par 
 \par
syntax: \par
}{\f4 <expression> }{\f3 equal} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
Equality is given between floating point numbers and integers that have 
the same value. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
a := 4;  \par
 \par
  A := 4  \par
 \par
 \par
b := 4.0;  \par
 \par
  B := 4.0  \par
 \par
 \par
if a equal b then write "true" else write "false"; \par
			  \par
 \par
 \par
  true  \par
 \par
 \par
if a equal 5 then write "true" else write "false"; \par
			  \par
 \par
 \par
  false  \par
 \par
 \par
if a equal sqrt(16) then write "true" else write "false"; \par
			  \par
 \par
 \par
  true \par
 \par
\pard \sl240 }{\f2 Comparison operators can only be used as conditions in conditional commands 
such as }{\f3 if} {\f2 ...}{\f3 then} {\f2  and }{\f3 repeat} {\f2 ...}{\f3 until} {\f2 . 
<equal> can also be used as a prefix operator. However, this use 
is not encouraged. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EVENP}

${\footnote \pard\plain \sl240 \fs20 $ EVENP}

+{\footnote \pard\plain \sl240 \fs20 + g6:0750}

 K{\footnote \pard\plain \sl240 \fs20 K EVENP operator;operator}

}{\b\f2 EVENP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 evenp} {\f2  logical operator returns }
{\f2\uldb true}{\v\f2 TRUE} 
{\f2  if its argument is an 
even integer, and }
{\f2\uldb nil}{\v\f2 NIL} 
{\f2  if its argument is an odd integer. An error 
message is returned if its argument is not an integer. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 evenp} {\f4 (<integer>) or }{\f3 evenp} {\f4  <integer> 
\par 
\par 
}{\f2 \par 
<integer> must evaluate to an integer. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
aa := 1782;  \par
 \par
  AA := 1782  \par
 \par
 \par
if evenp aa then yes else no;  \par
 \par
  YES  \par
 \par
 \par
if evenp(-3) then yes else no;  \par
 \par
  NO  \par
 \par
\pard \sl240 }{\f2 Although you would not ordinarily enter an expression such as the last 
example above, note that the negative term must be enclosed in parentheses 
to be correctly parsed. The }{\f3 evenp} {\f2  operator can only be used in 
conditional statements such as }{\f3 if} {\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  
or }{\f3 while} {\f2 ...}{\f3 do} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # false}

${\footnote \pard\plain \sl240 \fs20 $ false}

+{\footnote \pard\plain \sl240 \fs20 + g6:0751}

 K{\footnote \pard\plain \sl240 \fs20 K false concept;concept}

}{\b\f2 FALSE}{\f2 \par 
\par 
 
The symbol }
{\f2\uldb nil}{\v\f2 NIL} 
{\f2  and the number zero are considered 
as }
{\f2\uldb boolean value}{\v\f2 boolean_value} 
{\f2  false if used in a place where 
a boolean value is required. Most builtin operators return 
}
{\f2\uldb nil}{\v\f2 NIL} 
{\f2  as false value. Algebraic programs use better zero. 
Note that }{\f3 nil} {\f2  is not printed when returned as result to 
a top level evaluation. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FREEOF}

${\footnote \pard\plain \sl240 \fs20 $ FREEOF}

+{\footnote \pard\plain \sl240 \fs20 + g6:0752}

 K{\footnote \pard\plain \sl240 \fs20 K FREEOF operator;operator}

}{\b\f2 FREEOF}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 freeof} {\f2  logical operator returns 
}
{\f2\uldb true}{\v\f2 TRUE} 
{\f2  if its first argument does 
not contain its second argument anywhere in its structure. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 freeof} {\f4 (<expression>,<kernel>) or 
<expression> }{\f3 freeof} {\f4  <kernel> 
\par 
\par 
}{\f2 \par 
<expression> can be any valid scalar REDUCE expression, <kernel> must 
be a kernel expression (see }{\f3 kernel} {\f2 ). 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := x + sin(y)**2 + log sin z; \par
			  \par
 \par
 \par
                           2 \par
  A := LOG(SIN(Z)) + SIN(Y)   + X  \par
 \par
 \par
if freeof(a,sin(y)) then write "free" else write "not free"; \par
			  \par
 \par
 \par
  not free  \par
 \par
 \par
if freeof(a,sin(x)) then write "free" else write "not free"; \par
			  \par
 \par
 \par
  free  \par
 \par
 \par
if a freeof sin z then write "free" else write "not free"; \par
			  \par
 \par
 \par
  not free \par
 \par
\pard \sl240 }{\f2 Logical operators can only be used in conditional expressions such as 
\par 
\par 
}{\f3 if} {\f2 ...}{\f3 then} {\f2  or }{\f3 while} {\f2 ...}{\f3 do} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LEQ}

${\footnote \pard\plain \sl240 \fs20 $ LEQ}

+{\footnote \pard\plain \sl240 \fs20 + g6:0753}

 K{\footnote \pard\plain \sl240 \fs20 K LEQ operator;operator}

}{\b\f2 LEQ}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 leq} {\f2  operator is a binary infix or prefix logical operator. It 
returns }
{\f2\uldb true}{\v\f2 TRUE} 
{\f2  if its first argument is less than or equal to its second 
argument. As an infix operator it is identical with }{\f3 <=} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 leq} {\f4 (<expression>,<expression>) or <expression> 
}{\f3 leq} {\f4  <expression> 
\par 
\par 
\par 
\par 
}{\f2 <expression> can be any valid REDUCE expression that evaluates to a 
number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := 15;  \par
 \par
  A := 15  \par
 \par
 \par
if leq(a,25) then write "yes" else write "no"; \par
			  \par
 \par
 \par
  yes  \par
 \par
 \par
if leq(a,15) then write "yes" else write "no"; \par
			  \par
 \par
 \par
  yes  \par
 \par
 \par
if leq(a,5) then write "yes" else write "no"; \par
			  \par
 \par
 \par
  no \par
 \par
\pard \sl240 }{\f2 Logical operators can only be used in conditional statements such as 
\par 
\par 
}{\f3 if} {\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  or }{\f3 while} {\f2 ...}{\f3 do} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LESSP}

${\footnote \pard\plain \sl240 \fs20 $ LESSP}

+{\footnote \pard\plain \sl240 \fs20 + g6:0754}

 K{\footnote \pard\plain \sl240 \fs20 K LESSP operator;operator}

}{\b\f2 LESSP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 lessp} {\f2  operator is a binary infix or prefix logical operator. It 
returns }
{\f2\uldb true}{\v\f2 TRUE} 
{\f2  if its first argument is strictly less than its second 
argument. As an infix operator it is identical with }{\f3 <} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 lessp} {\f4 (<expression>,<expression>) 
or <expression> }{\f3 lessp} {\f4  <expression> 
\par 
\par 
\par 
\par 
}{\f2 <expression> can be any valid REDUCE expression that evaluates to a 
number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := 15;  \par
 \par
  A := 15  \par
 \par
 \par
if lessp(a,25) then write "yes" else write "no"; \par
			  \par
 \par
 \par
  yes  \par
 \par
 \par
if lessp(a,15) then write "yes" else write "no"; \par
			  \par
 \par
 \par
  no  \par
 \par
 \par
if lessp(a,5) then write "yes" else write "no"; \par
			  \par
 \par
 \par
  no \par
 \par
\pard \sl240 }{\f2 Logical operators can only be used in conditional statements such as 
\par 
\par 
}{\f3 if} {\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  or }{\f3 while} {\f2 ...}{\f3 do} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MEMBER}

${\footnote \pard\plain \sl240 \fs20 $ MEMBER}

+{\footnote \pard\plain \sl240 \fs20 + g6:0755}

 K{\footnote \pard\plain \sl240 \fs20 K list;MEMBER operator;operator}

}{\b\f2 MEMBER}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 <expression> }{\f3 member} {\f4  <list> 
\par 
\par 
}{\f2 \par 
}{\f3 member} {\f2 is an infix binary comparison operator that evaluates to 
}
{\f2\uldb true}{\v\f2 TRUE} 
{\f2  if <expression> is }
{\f2\uldb equal}{\v\f2 EQUAL} 
{\f2  to a member of 
the }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  <list>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
if a member \{a,b\} then 1 else 0;  \par
 \par
  1  \par
 \par
 \par
if 1 member(1,2,3) then a else b;  \par
 \par
  a  \par
 \par
 \par
if 1 member(1.0,2) then a else b;  \par
 \par
  b \par
 \par
\pard \sl240 }{\f2 Logical operators can only be used in conditional statements such as 
\par 
\par 
}{\f3 if} {\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  or }{\f3 while} {\f2 ...}{\f3 do} {\f2 . 
<member> can also be used as a prefix operator. However, this use 
is not encouraged. Finally, }
{\f2\uldb equal}{\v\f2 EQUAL} 
{\f2  (}{\f3 =} {\f2 ) is used for the test 
within the list, so expressions must be of the same type to match. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NEQ}

${\footnote \pard\plain \sl240 \fs20 $ NEQ}

+{\footnote \pard\plain \sl240 \fs20 + g6:0756}

 K{\footnote \pard\plain \sl240 \fs20 K NEQ operator;operator}

}{\b\f2 NEQ}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The operator }{\f3 neq} {\f2  is an infix binary comparison 
operator. It returns }
{\f2\uldb true}{\v\f2 TRUE} 
{\f2  if its two 
arguments are not }
{\f2\uldb equal}{\v\f2 EQUAL} 
{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 <expression> }{\f3 neq} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
An inequality is satisfied between floating point numbers and integers 
that have the same value. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
a := 4;  \par
 \par
  A := 4  \par
 \par
 \par
b := 4.0;  \par
 \par
  B := 4.0  \par
 \par
 \par
if a neq b then write "true" else write "false"; \par
			  \par
 \par
 \par
  false  \par
 \par
 \par
if a neq 5 then write "true" else write "false"; \par
			  \par
 \par
 \par
  true \par
 \par
\pard \sl240 }{\f2 Comparison operators can only be used as conditions in conditional commands 
such as }{\f3 if} {\f2 ...}{\f3 then} {\f2  and }{\f3 repeat} {\f2 ...}{\f3 until} {\f2 . 
<neq> can also be used as a prefix operator. However, this use 
is not encouraged. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NOT}

${\footnote \pard\plain \sl240 \fs20 $ NOT}

+{\footnote \pard\plain \sl240 \fs20 + g6:0757}

 K{\footnote \pard\plain \sl240 \fs20 K NOT operator;operator}

}{\b\f2 NOT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 not} {\f2  operator returns }
{\f2\uldb true}{\v\f2 TRUE} 
{\f2  if its argument evaluates to 
}
{\f2\uldb nil}{\v\f2 NIL} 
{\f2 , and }{\f3 nil} {\f2  if its argument is }{\f3 true} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 not} {\f4 (<logical expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
if not numberp(a) then write "indeterminate" else write a; \par
			  \par
 \par
 \par
  indeterminate;  \par
 \par
 \par
a := 10;  \par
 \par
  A := 10  \par
 \par
 \par
if not numberp(a) then write "indeterminate" else write a; \par
			  \par
 \par
 \par
  10  \par
 \par
 \par
if not(numberp(a) and a < 0) then write "positive number"; \par
			  \par
 \par
 \par
  positive number \par
 \par
\pard \sl240 }{\f2 Logical operators can only be used in conditional statements such as 
\par 
\par 
}{\f3 if} {\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  or }{\f3 while} {\f2 ...}{\f3 do} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NUMBERP}

${\footnote \pard\plain \sl240 \fs20 $ NUMBERP}

+{\footnote \pard\plain \sl240 \fs20 + g6:0758}

 K{\footnote \pard\plain \sl240 \fs20 K NUMBERP operator;operator}

}{\b\f2 NUMBERP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 numberp} {\f2  operator returns }
{\f2\uldb true}{\v\f2 TRUE} 
{\f2  if its argument is a number, 
and }
{\f2\uldb nil}{\v\f2 NIL} 
{\f2  otherwise. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 numberp} {\f4 (<expression>) or }{\f3 numberp} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<expression> can be any REDUCE scalar expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
cc := 15.3;  \par
 \par
  CC := 15.3  \par
 \par
 \par
if numberp(cc) then write "number" else write "nonnumber";  \par
 \par
 \par
  number  \par
 \par
 \par
if numberp(cb) then write "number" else write "nonnumber";  \par
 \par
 \par
  nonnumber \par
 \par
\pard \sl240 }{\f2 Logical operators can only be used in conditional expressions, such as 
\par 
\par 
}{\f3 if} {\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  and }{\f3 while} {\f2 ...}{\f3 do} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ORDP}

${\footnote \pard\plain \sl240 \fs20 $ ORDP}

+{\footnote \pard\plain \sl240 \fs20 + g6:0759}

 K{\footnote \pard\plain \sl240 \fs20 K order;ORDP operator;operator}

}{\b\f2 ORDP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 ordp} {\f2  logical operator returns }
{\f2\uldb true}{\v\f2 TRUE} 
{\f2  if its first argument is 
ordered ahead of its second argument in canonical internal ordering, or is 
identical to it. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 ordp} {\f4 (<expression1>,<expression2>) 
\par 
\par 
\par 
\par 
}{\f2 <expression1> and <expression2> can be any valid REDUCE scalar 
expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
if ordp(x**2 + 1,x**3 + 3) then write "yes" else write "no"; \par
			  \par
 \par
 \par
  no  \par
 \par
 \par
if ordp(101,100) then write "yes" else write "no"; \par
			  \par
 \par
 \par
  yes  \par
 \par
 \par
if ordp(x,x) then write "yes" else write "no"; \par
			  \par
 \par
 \par
  yes \par
 \par
\pard \sl240 }{\f2 Logical operators can only be used in conditional expressions, such as 
\par 
\par 
}{\f3 if} {\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  and }{\f3 while} {\f2 ...}{\f3 do} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PRIMEP}

${\footnote \pard\plain \sl240 \fs20 $ PRIMEP}

+{\footnote \pard\plain \sl240 \fs20 + g6:0760}

 K{\footnote \pard\plain \sl240 \fs20 K prime number;PRIMEP operator;operator}

}{\b\f2 PRIMEP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 primep} {\f4 (<expression>) or }{\f3 primep} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
If <expression> evaluates to a integer, }{\f3 primep} {\f2  returns 
}
{\f2\uldb true}{\v\f2 TRUE} 
{\f2  \par 
\par 
if <expression> is a prime number (i.e., a number other than 0 and 
plus or minus 1 which is only exactly divisible by itself or a unit) 
and }
{\f2\uldb nil}{\v\f2 NIL} 
{\f2  otherwise. 
If <expression> does not have an integer value, a type error occurs. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
if primep 3 then write "yes" else write "no";  \par
 \par
 \par
  YES  \par
 \par
 \par
if primep a then 1;  \par
 \par
  ***** A invalid as integer \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # TRUE}

${\footnote \pard\plain \sl240 \fs20 $ TRUE}

+{\footnote \pard\plain \sl240 \fs20 + g6:0761}

 K{\footnote \pard\plain \sl240 \fs20 K false;TRUE concept;concept}

}{\b\f2 TRUE}{\f2 \par 
\par 
 
\par 
\par 
Any value of the boolean part of a logical expression which is neither 
}
{\f2\uldb nil}{\v\f2 NIL} 
{\f2  nor }{\f3 0} {\f2  is considered as }{\f3 true} {\f2 . Most 
builtin test and compare functions return }
{\f2\uldb t}{\v\f2 T} 
{\f2  for }{\f3 true} {\f2  
and }
{\f2\uldb nil}{\v\f2 NIL} 
{\f2  for }{\f3 false} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
if member(3,\{1,2,3\}) then 1 else -1; \par
 \par
 \par
  1 \par
 \par
 \par
if floor(1.7) then 1 else -1;  \par
 \par
  1  \par
 \par
 \par
if floor(0.7) then 1 else -1;  \par
 \par
  -1 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # g6}

${\footnote \pard\plain \sl240 \fs20 $ Boolean Operators}

+{\footnote \pard\plain \sl240 \fs20 + index:0006}
}{\b\f2 Boolean Operators}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb boolean value concept}
{\v\f2 boolean_value}{\f2 \par 
}{\f2 \tab}{\f2\uldb EQUAL operator}
{\v\f2 EQUAL}{\f2 \par 
}{\f2 \tab}{\f2\uldb EVENP operator}
{\v\f2 EVENP}{\f2 \par 
}{\f2 \tab}{\f2\uldb false concept}
{\v\f2 false}{\f2 \par 
}{\f2 \tab}{\f2\uldb FREEOF operator}
{\v\f2 FREEOF}{\f2 \par 
}{\f2 \tab}{\f2\uldb LEQ operator}
{\v\f2 LEQ}{\f2 \par 
}{\f2 \tab}{\f2\uldb LESSP operator}
{\v\f2 LESSP}{\f2 \par 
}{\f2 \tab}{\f2\uldb MEMBER operator}
{\v\f2 MEMBER}{\f2 \par 
}{\f2 \tab}{\f2\uldb NEQ operator}
{\v\f2 NEQ}{\f2 \par 
}{\f2 \tab}{\f2\uldb NOT operator}
{\v\f2 NOT}{\f2 \par 
}{\f2 \tab}{\f2\uldb NUMBERP operator}
{\v\f2 NUMBERP}{\f2 \par 
}{\f2 \tab}{\f2\uldb ORDP operator}
{\v\f2 ORDP}{\f2 \par 
}{\f2 \tab}{\f2\uldb PRIMEP operator}
{\v\f2 PRIMEP}{\f2 \par 
}{\f2 \tab}{\f2\uldb TRUE concept}
{\v\f2 TRUE}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # BYE}

${\footnote \pard\plain \sl240 \fs20 $ BYE}

+{\footnote \pard\plain \sl240 \fs20 + g7:0762}

 K{\footnote \pard\plain \sl240 \fs20 K BYE command;command}

}{\b\f2 BYE}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 bye} {\f2  command ends the REDUCE session, returning control to the 
program (e.g., the operating system) that called REDUCE. When you are at 
the top level, the }{\f3 bye} {\f2  command exits REDUCE. }{\f3 quit} {\f2  is a 
synonym for }{\f3 bye} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CONT}

${\footnote \pard\plain \sl240 \fs20 $ CONT}

+{\footnote \pard\plain \sl240 \fs20 + g7:0763}

 K{\footnote \pard\plain \sl240 \fs20 K CONT command;command}

}{\b\f2 CONT}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The command }{\f3 cont} {\f2  returns control to an interactive file after a 
}
{\f2\uldb pause}{\v\f2 PAUSE} 
{\f2  command that has been answered with }{\f3 n} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4 \pard \sl240 }{\f2 Suppose you are in the middle of an interactive file.}{\f4 \pard \tx3420   \par
 \par
  \par
 \par
  factorize(x**2 + 17*x + 60);  \par
 \par
 \par
  \par
 \par
  \{\{X + 12,1\},\{X + 5,1\}\}  \par
 \par
 \par
   pause;  \par
 \par
  Cont? (Y or N)  \par
 \par
 \par
n  \par
 \par
saveas results;  \par
 \par
factor1 := first results;  \par
 \par
  FACTOR1 := \{X + 12,1\}  \par
 \par
 \par
factor2 := second results;  \par
 \par
  FACTOR2 := \{X + 5,1\}  \par
 \par
 \par
cont; \pard \sl240 }{\f2  the file resumes}{\f4 \pard \tx3420  \par
 \par
\pard \sl240 }{\f2  
\par 
\par 
A }
{\f2\uldb pause}{\v\f2 PAUSE} 
{\f2  allows you to enter your own REDUCE commands, change 
switch values, inquire about results, or other such activities. When you 
wish to resume operation of the interactive file, use }{\f3 cont} {\f2 . 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DISPLAY}

${\footnote \pard\plain \sl240 \fs20 $ DISPLAY}

+{\footnote \pard\plain \sl240 \fs20 + g7:0764}

 K{\footnote \pard\plain \sl240 \fs20 K interactive;history;DISPLAY command;command}

}{\b\f2 DISPLAY}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
When given a numeric argument <n>, }{\f3 display} {\f2  prints the <n> 
most recent input statements, identified by prompt numbers. If an empty 
pair of parentheses is given, or if <n> is greater than the current 
number of statements, all the input statements since the beginning of 
the session are printed. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 display} {\f4 (<n>) or }{\f3 display} {\f4 () 
\par 
\par 
}{\f2 \par 
<n> should be a positive integer. However, if it is a real number, the 
truncated integer value is used, and if a non-numeric argument is used, all 
the input statements are printed. 
\par 
\par 
The statements are displayed in upper case, with lines split at semicolons or 
dollar signs, as they are in editing. If long files have been input during 
the session, the }{\f3 display} {\f2  command is slow to format these for 
printing. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LOAD\_PACKAGE}

${\footnote \pard\plain \sl240 \fs20 $ LOAD_PACKAGE}

+{\footnote \pard\plain \sl240 \fs20 + g7:0765}

 K{\footnote \pard\plain \sl240 \fs20 K package;LOAD_PACKAGE command;command}

}{\b\f2 LOAD\_PACKAGE}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 load_package} {\f2  command is used to load REDUCE packages, such as 
}{\f3 gentran} {\f2  that are not automatically loaded by the system. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 load_package "} {\f4 <package\_name>}{\f3 "} {\f4  
\par 
\par 
}{\f2 \par 
A package is only loaded once; subsequent calls of }{\f3 load_package} {\f2  
for the same package name are ignored. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PAUSE}

${\footnote \pard\plain \sl240 \fs20 $ PAUSE}

+{\footnote \pard\plain \sl240 \fs20 + g7:0766}

 K{\footnote \pard\plain \sl240 \fs20 K interactive;PAUSE command;command}

}{\b\f2 PAUSE}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 pause} {\f2  command, given in an interactive file, stops operation and 
asks if you want to continue or not. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4 \pard \sl240 }{\f2 An interactive file is running, and at some point you see the 
question}{\f4 \pard \tx3420   \par
 \par
				   Cont? (Y or N)  \par
\pard \sl240 }{\f2 If you type}{\f4 \pard \tx3420   \par
 \par
y\key\{Return\} \par
\pard \sl240 }{\f2 the file continues to run until the next pause or the end.}{\f4 \pard \tx3420   \par
\pard \sl240 }{\f2 If you type }{\f4 \pard \tx3420   \par
 \par
n\key\{Return\}  \par
\pard \sl240 }{\f2 you will get a numbered REDUCE prompt, and be allowed to 
enter and execute any REDUCE statements. If you later wish to continue with 
the file, type}{\f4 \pard \tx3420   \par
 \par
cont;  \par
\pard \sl240 }{\f2 and the file resumes.}{\f4 \pard \tx3420 \pard \sl240 }{\f2  
\par 
\par 
To use }{\f3 pause} {\f2  in your own interactive files, type 
\par 
\par 
}{\f3 pause;} {\f2 in the file wherever you want it. 
\par 
\par 
}{\f3 pause} {\f2 does not allow you to continue without typing either }{\f3 y} {\f2  
or }{\f3 n} {\f2 . Its use is to slow down scrolling of interactive files, or to 
let you change parameters or switch settings for the calculations. 
\par 
\par 
If you have stopped an interactive file at a }{\f3 pause,} {\f2  and do not wish to 
resume the file, type }{\f3 end;} {\f2 . This does not end the REDUCE session, but 
stops input from the file. A second }{\f3 end;} {\f2  ends the REDUCE session. 
However, if you have pauses from more than one file stacked up, an }{\f3 end;} {\f2  
brings you back to the top level, not the file directly above. 
\par 
\par 
A }{\f3 pause} {\f2  typed from the terminal has no effect. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # QUIT}

${\footnote \pard\plain \sl240 \fs20 $ QUIT}

+{\footnote \pard\plain \sl240 \fs20 + g7:0767}

 K{\footnote \pard\plain \sl240 \fs20 K QUIT command;command}

}{\b\f2 QUIT}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 quit} {\f2  command ends the REDUCE session, returning control to the 
program (e.g., the operating system) that called REDUCE. When you are at 
the top level, the }{\f3 quit} {\f2  command exits REDUCE. }
{\f2\uldb bye}{\v\f2 BYE} 
{\f2  is a 
synonym for }{\f3 quit} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RECLAIM}

${\footnote \pard\plain \sl240 \fs20 $ RECLAIM}

+{\footnote \pard\plain \sl240 \fs20 + g7:0768}

 K{\footnote \pard\plain \sl240 \fs20 K memory;RECLAIM operator;operator}

}{\b\f2 RECLAIM}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
REDUCE's memory is in a storage structure called a heap. As REDUCE 
statements execute, chunks of memory are used up. When these chunks are no 
longer needed, they remain idle. When the memory is almost full, 
the system executes a garbage collection, reclaiming space that is no 
longer needed, and putting all the free space at one end. Depending on 
the size of the image REDUCE is using, 
garbage collection needs to be done more or less often. A 
larger image means fewer but longer garbage collections. 
Regardless of memory size, 
if you ask REDUCE to do something ridiculous, like }{\f3 factorial(2000)} {\f2 , it may 
garbage collect many times. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # REDERR}

${\footnote \pard\plain \sl240 \fs20 $ REDERR}

+{\footnote \pard\plain \sl240 \fs20 + g7:0769}

 K{\footnote \pard\plain \sl240 \fs20 K error handling;REDERR command;command}

}{\b\f2 REDERR}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 rederr} {\f2  command allows you to print an error message from inside 
a }
{\f2\uldb procedure}{\v\f2 PROCEDURE} 
{\f2  or a }
{\f2\uldb block}{\v\f2 block} 
{\f2  statement. 
The calculation is gracefully terminated. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 rederr} {\f4 <message> 
\par 
\par 
}{\f2 \par 
<message> is an error message, usually inside double quotation marks 
(a }
{\f2\uldb string}{\v\f2 STRING} 
{\f2 ). 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
procedure fac(n); \par
   if not (fixp(n) and n>=0) \par
     then  rederr "Choose nonneg. integer only" \par
    else for i := 0:n-1 product i+1; \par
\pard \sl240   \par
 \par
  fac  \par
 \par
 \par
fac a;  \par
 \par
  	   ***** Choose nonneg. integer only  \par
 \par
 \par
fac 5;  \par
 \par
  120 \par
 \par
\pard \sl240 }{\f2 The above procedure finds the factorial of its argument. 
If n is not a positive integer or 0, an error message is returned. 
\par 
\par 
If your procedure is executed in a file, the usual error message is 
printed, followed by }{\f3 Cont? (Y or N)} {\f2 , just as any other error does from 
a file. Although the procedure is gracefully terminated, any switch settings or 
variable assignments you made before the error occurred are not undone. If you 
need to clean up such items before exiting, use a group statement, with the 
}{\f3 rederr} {\f2  command as its last statement. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RETRY}

${\footnote \pard\plain \sl240 \fs20 $ RETRY}

+{\footnote \pard\plain \sl240 \fs20 + g7:0770}

 K{\footnote \pard\plain \sl240 \fs20 K interactive;RETRY command;command}

}{\b\f2 RETRY}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 retry} {\f2  command allows you to retry the latest statement that resulted 
in an error message. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
matrix a;  \par
 \par
det a;  \par
 \par
  ***** Matrix A not set  \par
 \par
 \par
a := mat((1,2),(3,4));  \par
 \par
  A(1,1) := 1 \par
  A(1,2) := 2 \par
  A(2,1) := 3 \par
  A(2,2) := 4 \par
 \par
 \par
retry;  \par
 \par
  -2 \par
 \par
\pard \sl240 }{\f2 }{\f3 retry} {\f2 remembers only the most recent statement that resulted in an 
error message. It allows you to stop and fix something obvious, then 
continue on your way without retyping the original command. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SAVEAS}

${\footnote \pard\plain \sl240 \fs20 $ SAVEAS}

+{\footnote \pard\plain \sl240 \fs20 + g7:0771}

 K{\footnote \pard\plain \sl240 \fs20 K SAVEAS command;command}

}{\b\f2 SAVEAS}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 saveas} {\f2  command saves the current workspace under the name of its 
argument. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 saveas} {\f4 <identifier> 
\par 
\par 
}{\f2 \par 
<identifier> can be any valid REDUCE identifier. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4 \pard \sl240 }{\f2 (The numbered prompts are shown below, unlike in most examples)}{\f4 \pard \tx3420  \par
 \par
1: solve(x^2-3); \par
 \par
  \{x=sqrt(3),x= - sqrt(3)\} \par
 \par
 \par
2: saveas rts(0)\$ \par
 \par
3: rts(0); \par
 \par
  \{x=sqrt(3),x= - sqrt(3)\} \par
 \par
\pard \sl240 }{\f2  
\par 
\par 
}{\f3 saveas} {\f2 works only for the current workspace, the last algebraic 
expression produced by REDUCE. This allows you to save a result that you 
did not assign to an identifier when you originally typed the input. 
For access to previous output use }
{\f2\uldb ws}{\v\f2 WS} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SHOWTIME}

${\footnote \pard\plain \sl240 \fs20 $ SHOWTIME}

+{\footnote \pard\plain \sl240 \fs20 + g7:0772}

 K{\footnote \pard\plain \sl240 \fs20 K time;SHOWTIME command;command}

}{\b\f2 SHOWTIME}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 showtime} {\f2  command prints the elapsed system time since the last 
call of this command or since the beginning of the session, if it has not 
been called before. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
showtime;  \par
 \par
  Time: 1020 ms  \par
 \par
 \par
factorize(x^4 - 8x^4 + 8x^2 - 136x - 153); \par
			  \par
 \par
 \par
          2 \par
  \{X - 9,X  + 17,X + 1\}  \par
 \par
 \par
showtime;  \par
 \par
  Time: 920 ms \par
 \par
\pard \sl240 }{\f2 The time printed is either the elapsed cpu time or the elapsed wall clock 
time, depending on your system. }{\f3 showtime} {\f2  allows you to see the 
system time resources REDUCE uses in its calculations. Your time readings 
will of course vary from this example according to the system you use. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # WRITE}

${\footnote \pard\plain \sl240 \fs20 $ WRITE}

+{\footnote \pard\plain \sl240 \fs20 + g7:0773}

 K{\footnote \pard\plain \sl240 \fs20 K output;WRITE command;command}

}{\b\f2 WRITE}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 write} {\f2  command explicitly writes its arguments to the output device 
(terminal or file). 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 write} {\f4 <item>\{,<item>\}* 
\par 
\par 
}{\f2 \par 
<item> can be an expression, an assignment or a }
{\f2\uldb string}{\v\f2 STRING} 
{\f2  
enclosed in double quotation marks (}{\f3 "} {\f2 ). 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
write a, sin x, "this is a string";  \par
 \par
 \par
  ASIN(X)this is a string  \par
 \par
 \par
write a," ",sin x," this is a string";  \par
 \par
 \par
  A SIN(X) this is a string  \par
 \par
 \par
if not numberp(a) then write "the symbol ",a; \par
							 \par
 \par
 \par
  the symbol A  \par
 \par
 \par
array m(10);  \par
 \par
for i := 1:5 do write m(i) := 2*i;  \par
 \par
 \par
  M(1) := 2 \par
  M(2) := 4 \par
  M(3) := 6 \par
  M(4) := 8 \par
  M(5) := 10 \par
 \par
 \par
m(4);  \par
 \par
  8 \par
 \par
\pard \sl240 }{\f2 The items specified by a single }{\f3 write} {\f2  statement print on a single line 
unless they are too long. A printed line is always ended with a carriage 
return, so the next item printed starts a new line. 
\par 
\par 
When an assignment statement is printed, the assignment is also made. This 
allows you to get feedback on filling slots in an array with a }
{\f2\uldb for}{\v\f2 FOR} 
{\f2  
 statement, as shown in the last example above. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g7}

${\footnote \pard\plain \sl240 \fs20 $ General Commands}

+{\footnote \pard\plain \sl240 \fs20 + index:0007}
}{\b\f2 General Commands}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb BYE command}
{\v\f2 BYE}{\f2 \par 
}{\f2 \tab}{\f2\uldb CONT command}
{\v\f2 CONT}{\f2 \par 
}{\f2 \tab}{\f2\uldb DISPLAY command}
{\v\f2 DISPLAY}{\f2 \par 
}{\f2 \tab}{\f2\uldb LOAD\_PACKAGE command}
{\v\f2 LOAD\_PACKAGE}{\f2 \par 
}{\f2 \tab}{\f2\uldb PAUSE command}
{\v\f2 PAUSE}{\f2 \par 
}{\f2 \tab}{\f2\uldb QUIT command}
{\v\f2 QUIT}{\f2 \par 
}{\f2 \tab}{\f2\uldb RECLAIM operator}
{\v\f2 RECLAIM}{\f2 \par 
}{\f2 \tab}{\f2\uldb REDERR command}
{\v\f2 REDERR}{\f2 \par 
}{\f2 \tab}{\f2\uldb RETRY command}
{\v\f2 RETRY}{\f2 \par 
}{\f2 \tab}{\f2\uldb SAVEAS command}
{\v\f2 SAVEAS}{\f2 \par 
}{\f2 \tab}{\f2\uldb SHOWTIME command}
{\v\f2 SHOWTIME}{\f2 \par 
}{\f2 \tab}{\f2\uldb WRITE command}
{\v\f2 WRITE}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # APPEND}

${\footnote \pard\plain \sl240 \fs20 $ APPEND}

+{\footnote \pard\plain \sl240 \fs20 + g8:0774}

 K{\footnote \pard\plain \sl240 \fs20 K list;APPEND operator;operator}

}{\b\f2 APPEND}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 append} {\f2  operator constructs a new }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  
from the elements of its two arguments (which must be lists). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 append} {\f4 (<list>,<list>) 
\par 
\par 
}{\f2 \par 
<list> must be a list, though it may be the empty list (}{\f3 \{\}} {\f2 ). 
Any arguments beyond the first two are ignored. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
alist := \{1,2,\{a,b\}\};  \par
 \par
  ALIST := \{1,2,\{A,B\}\}  \par
 \par
 \par
blist := \{3,4,5,sin(y)\};  \par
 \par
  BLIST := \{3,4,5,SIN(Y)\}  \par
 \par
 \par
append(alist,blist);  \par
 \par
  \{1,2,\{A,B\},3,4,5,SIN(Y)\}  \par
 \par
 \par
append(alist,\{\});  \par
 \par
  \{1,2,\{A,B\}\}  \par
 \par
 \par
append(list z,blist);  \par
 \par
  \{Z,3,4,5,SIN(Y)\} \par
 \par
\pard \sl240 }{\f2 The new list consists of the elements of the second list appended to the 
elements of the first list. You can }{\f3 append} {\f2  new elements to the 
beginning or end of an existing list by putting the new element in a 
list (use curly braces or the operator }{\f3 list} {\f2 ). This is 
particularly helpful in an iterative loop. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ARBINT}

${\footnote \pard\plain \sl240 \fs20 $ ARBINT}

+{\footnote \pard\plain \sl240 \fs20 + g8:0775}

 K{\footnote \pard\plain \sl240 \fs20 K arbitrary value;ARBINT operator;operator}

}{\b\f2 ARBINT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 arbint} {\f2  is used to express arbitrary integer parts 
of an expression, e.g. in the result of }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  when 
}
{\f2\uldb allbranch}{\v\f2 ALLBRANCH} 
{\f2  is on. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
solve(log(sin(x+3)),x);  \par
 \par
  \{X=2*ARBINT(1)*PI - ASIN(1) - 3, \par
   X=2*ARBINT(1)*PI + ASIN(1) + PI - 3\} \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ARBCOMPLEX}

${\footnote \pard\plain \sl240 \fs20 $ ARBCOMPLEX}

+{\footnote \pard\plain \sl240 \fs20 + g8:0776}

 K{\footnote \pard\plain \sl240 \fs20 K arbitrary value;ARBCOMPLEX operator;operator}

}{\b\f2 ARBCOMPLEX}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 arbcomplex} {\f2  is used to express arbitrary scalar parts 
of an expression, e.g. in the result of }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  when 
the solution is parametric in one of the variable. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
solve(\{x+3=y-2z,y-3x=0\},\{x,y,z\});  \par
 \par
 \par
     2*ARBCOMPLEX(1) + 3 \par
  \{X=-------------------, \par
              2 \par
      3*ARBCOMPLEX(1) + 3 \par
    Y=-------------------, \par
               2 \par
    Z=ARBCOMPLEX(1)\} \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ARGLENGTH}

${\footnote \pard\plain \sl240 \fs20 $ ARGLENGTH}

+{\footnote \pard\plain \sl240 \fs20 + g8:0777}

 K{\footnote \pard\plain \sl240 \fs20 K argument;ARGLENGTH operator;operator}

}{\b\f2 ARGLENGTH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 arglength} {\f2  returns the number of arguments of the top-level 
operator in its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 arglength} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE algebraic expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
arglength(a + b + c + d);  \par
 \par
  4  \par
 \par
 \par
arglength(a/b/c);  \par
 \par
  2  \par
 \par
 \par
arglength(log(sin(df(r**3*x,x))));  \par
 \par
 \par
  1 \par
 \par
\pard \sl240 }{\f2 In the first example, }{\f3 +} {\f2  is an n-ary operator, so the number of terms 
is returned. In the second example, since }{\f3 /} {\f2  is a binary operator, the 
argument is actually (a/b)/c, so there are two terms at the top level. In 
the last example, no matter how deeply the operators are nested, there is 
still only one argument at the top level. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # COEFF}

${\footnote \pard\plain \sl240 \fs20 $ COEFF}

+{\footnote \pard\plain \sl240 \fs20 + g8:0778}

 K{\footnote \pard\plain \sl240 \fs20 K coefficient;COEFF operator;operator}

}{\b\f2 COEFF}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 coeff} {\f2  operator returns the coefficients of the powers of the 
specified variable in the given expression, in a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 coeff} {\f4 (<expression>}{\f3 ,} {\f4 <variable>) 
\par 
\par 
}{\f2 \par 
<expression> is expected to be a polynomial expression, not a rational 
expression. Rational expressions are accepted when the switch 
}
{\f2\uldb ratarg}{\v\f2 RATARG} 
{\f2  is on. <variable> must be a kernel. The results are 
returned in a list. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
coeff((x+y)**3,x);  \par
 \par
    3     2 \par
  \{Y  ,3*Y  ,3*Y,1\}  \par
 \par
 \par
coeff((x+2)**4 + sin(x),x);  \par
 \par
  \{SIN(X) + 16,32,24,8,1\}  \par
 \par
 \par
high_pow;  \par
 \par
  4  \par
 \par
 \par
low_pow;  \par
 \par
  0  \par
 \par
 \par
ab := x**9 + sin(x)*x**7 + sqrt(y);  \par
  \par
 \par
 \par
                          7     9 \par
  AB := SQRT(Y) + SIN(X)*X   + X \par
 \par
 \par
coeff(ab,x);  \par
 \par
  \{SQRT(Y),0,0,0,0,0,0,SIN(X),0,1\} \par
 \par
\pard \sl240 }{\f2 The variables }
{\f2\uldb high_pow}{\v\f2 HIGH\_POW} 
{\f2  and }
{\f2\uldb low_pow}{\v\f2 LOW\_POW} 
{\f2  are set to the 
highest and lowest powers of the variable, respectively, appearing in the 
expression. 
\par 
\par 
The coefficients are put into a list, with the coefficient of the lowest 
(constant) term first. You can use the usual list access methods 
(}{\f3 first} {\f2 , }{\f3 second} {\f2 , }{\f3 third} {\f2 , }{\f3 rest} {\f2 , }{\f3 length} {\f2 , and 
}{\f3 part} {\f2 ) to extract them. If a power does not appear in the 
expression, the corresponding element of the list is zero. Terms involving 
functions of the specified variable but not including powers of it (for 
example in the expression }{\f3 x**4 + 3*x**2 + tan(x)} {\f2 ) are placed in the 
constant term. 
\par 
\par 
Since the }{\f3 coeff} {\f2  command deals with the expanded form of the expression, 
you may get unexpected results when }
{\f2\uldb exp}{\v\f2 EXP} 
{\f2  is off, or when 
}
{\f2\uldb factor}{\v\f2 FACTOR} 
{\f2  or }
{\f2\uldb ifactor}{\v\f2 IFACTOR} 
{\f2  are on. 
\par 
\par 
If you want only a specific coefficient rather than all of them, use the 
}
{\f2\uldb coeffn}{\v\f2 COEFFN} 
{\f2  operator. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # COEFFN}

${\footnote \pard\plain \sl240 \fs20 $ COEFFN}

+{\footnote \pard\plain \sl240 \fs20 + g8:0779}

 K{\footnote \pard\plain \sl240 \fs20 K coefficient;COEFFN operator;operator}

}{\b\f2 COEFFN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 coeffn} {\f2  operator takes three arguments: an expression, a kernel, and 
a non-negative integer. It returns the coefficient of the kernel to that 
integer power, appearing in the expression. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 coeffn} {\f4 (<expression>,<kernel>,<integer>) 
\par 
\par 
}{\f2 \par 
<expression> must be a polynomial, unless }
{\f2\uldb ratarg}{\v\f2 RATARG} 
{\f2  is on which 
allows rational expressions. <kernel> must be a kernel, and 
<integer> must be a non-negative integer. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
ff := x**7 + sin(y)*x**5 + y**4 + x + 7;  \par
 \par
 \par
                5     7         4 \par
  FF := SIN(Y)*X   + X   + X + Y   + 7  \par
 \par
 \par
coeffn(ff,x,5);  \par
 \par
  SIN(Y)  \par
 \par
 \par
coeffn(ff,z,3);  \par
 \par
  0  \par
 \par
 \par
coeffn(ff,y,0);  \par
 \par
          5     7 \par
  SIN(Y)*X   + X   + X + 7  \par
 \par
 \par
 \par
rr := 1/y**2+y**3+sin(y);  \par
 \par
                2     5 \par
        SIN(Y)*Y   + Y   + 1 \par
  RR := --------------------  \par
                  2 \par
                 Y \par
 \par
 \par
on ratarg;  \par
 \par
 \par
coeffn(rr,y,-2);  \par
 \par
  ***** -2 invalid as COEFFN index  \par
 \par
 \par
 \par
coeffn(rr,y,5);  \par
 \par
  1 \par
  --- \par
   2 \par
  Y \par
 \par
\pard \sl240 }{\f2 If the given power of the kernel does not appear in the expression, 
}{\f3 coeffn} {\f2  returns 0. Negative powers are never detected, even if 
they appear in the expression and }
{\f2\uldb ratarg}{\v\f2 RATARG} 
{\f2  are on. }{\f3 coeffn} {\f2  
with an integer argument of 0 returns any terms in the expression that 
do not contain the given kernel. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CONJ}

${\footnote \pard\plain \sl240 \fs20 $ CONJ}

+{\footnote \pard\plain \sl240 \fs20 + g8:0780}

 K{\footnote \pard\plain \sl240 \fs20 K complex;conjugate;CONJ operator;operator}

}{\b\f2 CONJ}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 conj} {\f4 (<expression>) or }{\f3 conj} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
This operator returns the complex conjugate of an expression, if that 
argument has an numerical value. A non-numerical argument is returned as 
an expression in the operators }
{\f2\uldb repart}{\v\f2 REPART} 
{\f2  and }
{\f2\uldb impart}{\v\f2 IMPART} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
conj(1+i);  \par
 \par
  1-I  \par
 \par
 \par
conj(a+i*b);  \par
 \par
  REPART(A) - REPART(B)*I - IMPART(A)*I - IMPART(B) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # CONTINUED_FRACTION}

${\footnote \pard\plain \sl240 \fs20 $ CONTINUED_FRACTION}

+{\footnote \pard\plain \sl240 \fs20 + g8:0781}

 K{\footnote \pard\plain \sl240 \fs20 K rational numbers;approximation;CONTINUED_FRACTION operator;operator}

}{\b\f2 CONTINUED_FRACTION}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 continued_fraction} {\f4 (<num>) 
or }{\f3 continued_fraction} {\f4 ( <num>,<size>) 
\par 
\par 
}{\f2 \par 
This operator approximates the real number <num> 
( }
{\f2\uldb rational}{\v\f2 RATIONAL} 
{\f2  number, }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  number) 
into a continued fraction. The result is a list of two elements: the 
first one is the rational value of the approximation, the second one 
is the list of terms of the continued fraction which represents the 
same value according to the definition }{\f3 t0 +1/(t1 + 1/(t2 + ...))} {\f2 . 
Precision: the second optional parameter <size> is an upper bound 
for the absolute value of the result denominator. If omitted, the 
approximation is performed up to the current system precision. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
continued_fraction pi; \par
  \par
 \par
   1146408 \par
  \{-------,\{3,7,15,1,292,1,1,1,2,1\}\}  \par
   364913 \par
 \par
 \par
continued_fraction(pi,100); \par
  \par
 \par
   22 \par
  \{--,\{3,7\}\}  \par
   7 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # DECOMPOSE}

${\footnote \pard\plain \sl240 \fs20 $ DECOMPOSE}

+{\footnote \pard\plain \sl240 \fs20 + g8:0782}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;decomposition;DECOMPOSE operator;operator}

}{\b\f2 DECOMPOSE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 decompose} {\f2  operator takes a multivariate polynomial as argument, 
and returns an expression and a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  of 
}
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2 s from which the 
original polynomial can be found by composition. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 decompose} {\f4 (<expression>) or }{\f3 decompose} {\f4  
 <simple\_expression> 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
decompose(x^8-88*x^7+2924*x^6-43912*x^5+263431*x^4- \par
          218900*x^3+65690*x^2-7700*x+234) \par
\pard \sl240  \par
  \par
 \par
   2                  2            2 \par
  U  + 35*U + 234, U=V  + 10*V, V=X  - 22*X  \par
 \par
 \par
     decompose(u^2+v^2+2u*v+1)  \par
 \par
   2 \par
  W   + 1, W=U + V \par
 \par
\pard \sl240 }{\f2 Unlike factorization, this decomposition is not unique. Further 
details can be found in V.S. Alagar, M.Tanh, <Fast Polynomial 
Decomposition>, Proc. EUROCAL 1985, pp 150-153 (Springer) and J. von zur 
Gathen, <Functional> 
<Decomposition of Polynomials: the Tame Case>, J. 
Symbolic Computation (1990) 9, 281-299. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DEG}

${\footnote \pard\plain \sl240 \fs20 $ DEG}

+{\footnote \pard\plain \sl240 \fs20 + g8:0783}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;degree;DEG operator;operator}

}{\b\f2 DEG}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 deg} {\f2  returns the highest degree of its variable argument 
found in its expression argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 deg} {\f4 (<expression>,<kernel>) 
\par 
\par 
}{\f2 \par 
<expression> is expected to be a polynomial expression, not a rational 
expression. Rational expressions are accepted when the switch 
}
{\f2\uldb ratarg}{\v\f2 RATARG} 
{\f2  is on. <variable> must be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 . The 
results are returned in a list. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
deg((x+y)**5,x);  \par
 \par
  5  \par
 \par
 \par
 \par
deg((a+b)*(c+2*d)**2,d);  \par
 \par
  2  \par
 \par
 \par
 \par
deg(x**2 + cos(y),sin(x));  \par
 \par
 \par
deg((x**2 + sin(x))**5,sin(x));  \par
 \par
  5 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # DEN}

${\footnote \pard\plain \sl240 \fs20 $ DEN}

+{\footnote \pard\plain \sl240 \fs20 + g8:0784}

 K{\footnote \pard\plain \sl240 \fs20 K rational expression;denominator;DEN operator;operator}

}{\b\f2 DEN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 den} {\f2  operator returns the denominator of its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 den} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
<expression> is ordinarily a rational expression, but may be any valid 
scalar REDUCE expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
a := x**3 + 3*x**2 + 12*x;  \par
 \par
           2 \par
  A := X*(X   + 3*X + 12)  \par
 \par
 \par
 \par
b := 4*x*y + x*sin(x);  \par
 \par
  B := X*(SIN(X) + 4*Y)  \par
 \par
 \par
 \par
den(a/b);  \par
 \par
  SIN(X) + 4*Y  \par
 \par
 \par
 \par
den(aa/4 + bb/5);  \par
 \par
  20  \par
 \par
 \par
 \par
den(100/6);  \par
 \par
  3  \par
 \par
 \par
 \par
den(sin(x));  \par
 \par
  1 \par
 \par
\pard \sl240 }{\f2 }{\f3 den} {\f2 returns the denominator of the expression after it has been 
simplified by REDUCE. As seen in the examples, this includes putting 
sums of rational expressions over a common denominator, and reducing 
common factors where possible. If the expression does not have any 
other denominator, 1 is returned. 
\par 
\par 
Switch settings, such as }
{\f2\uldb mcd}{\v\f2 MCD} 
{\f2  or }
{\f2\uldb rational}{\v\f2 RATIONAL} 
{\f2 , have an 
effect on the denominator of an expression. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DF}

${\footnote \pard\plain \sl240 \fs20 $ DF}

+{\footnote \pard\plain \sl240 \fs20 + g8:0785}

 K{\footnote \pard\plain \sl240 \fs20 K partial derivative;derivative;DF operator;operator}

}{\b\f2 DF}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 df} {\f2  operator finds partial derivatives with respect to one or 
more variables. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 df} {\f4 (<expression>}{\f3 ,} {\f4 <var> 
	 [}{\f3 ,} {\f4 <number>] 
 \{}{\f3 ,} {\f4 <var> [ }{\f3 ,} {\f4 <number>] \}) 
\par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE algebraic expression. <var> 
must be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 , and is the differentiation variable. 
<number> must be a non-negative integer. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
df(x**2,x);  \par
 \par
  2*X  \par
 \par
 \par
 \par
df(x**2*y + sin(y),y);  \par
 \par
            2 \par
  COS(Y) + X   \par
 \par
 \par
 \par
df((x+y)**10,z);  \par
 \par
  0  \par
 \par
 \par
 \par
 \par
df(1/x**2,x,2);  \par
 \par
  6 \par
  --- \par
   4 \par
  X \par
 \par
 \par
 \par
df(x**4*y + sin(y),y,x,3);  \par
 \par
  24*X  \par
 \par
 \par
 \par
for all x let df(tan(x),x) = sec(x)**2;  \par
 \par
 \par
df(tan(3*x),x);  \par
 \par
            2 \par
  3*SEC(3*X) \par
 \par
\pard \sl240 }{\f2 An error message results if a non-kernel is entered as a differentiation 
operator. If the optional number is omitted, it is assumed to be 1. 
See the declaration }
{\f2\uldb depend}{\v\f2 DEPEND} 
{\f2  to establish dependencies for implicit 
differentiation. 
\par 
\par 
You can define your own differentiation rules, expanding REDUCE's 
capabilities, using the }
{\f2\uldb let}{\v\f2 LET} 
{\f2  command as shown in the last example 
above. Note that once you add your own rule for differentiating a 
function, it supersedes REDUCE's normal handling of that function for the 
duration of the REDUCE session. If you clear the rule 
(}
{\f2\uldb clearrules}{\v\f2 CLEARRULES} 
{\f2 ), you don't get back 
to the previous rule. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EXPAND\_CASES}

${\footnote \pard\plain \sl240 \fs20 $ EXPAND_CASES}

+{\footnote \pard\plain \sl240 \fs20 + g8:0786}

 K{\footnote \pard\plain \sl240 \fs20 K solve;EXPAND_CASES operator;operator}

}{\b\f2 EXPAND\_CASES}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
When a }
{\f2\uldb root_of}{\v\f2 ROOT\_OF} 
{\f2  form in a result of }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  
has been converted to a }
{\f2\uldb one_of}{\v\f2 ONE\_OF} 
{\f2  form, }{\f3 expand_cases} {\f2  
can be used to convert this into form corresponding to the 
normal explicit results of }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2 . See }
{\f2\uldb root_of}{\v\f2 ROOT\_OF} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EXPREAD}

${\footnote \pard\plain \sl240 \fs20 $ EXPREAD}

+{\footnote \pard\plain \sl240 \fs20 + g8:0787}

 K{\footnote \pard\plain \sl240 \fs20 K input;EXPREAD operator;operator}

}{\b\f2 EXPREAD}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 expread} {\f4 () 
\par 
\par 
}{\f2 \par 
}{\f3 expread} {\f2 reads one well-formed expression from the current input 
buffer and returns its value. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
expread(); a+b;  \par
 \par
  A + B \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # FACTORIZE}

${\footnote \pard\plain \sl240 \fs20 $ FACTORIZE}

+{\footnote \pard\plain \sl240 \fs20 + g8:0788}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;factorize;FACTORIZE operator;operator}

}{\b\f2 FACTORIZE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 factorize} {\f2  operator factors a given expression into a list of 
\{factor,power\} pairs. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 factorize} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
<expression> should be a polynomial, otherwise an error will result. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
fff := factorize(x^3 - y^3);  \par
 \par
         2          2 \par
  		  \{\{X  + X*Y + Y ,1\},\{X - Y,1\}\}  \par
 \par
 \par
fac1 := first fff;  \par
 \par
             2          2 \par
  FAC1 := \{\{X  + X*Y + Y ,1\}  \par
 \par
 \par
factorize(x^15 - 1);  \par
 \par
       8    7    6    5    4 \par
   \{\{ X  - X  + X  - X  + X  - X + 1,1\}, \par
     4    3    2 \par
   \{X  + X  + X  + X + 1,1\}, \par
     2 \par
   \{X  + X + 1,1\}, \par
   \{X - 1,1\}\} \par
 \par
 \par
lastone := part(ws,length ws);  \par
 \par
  	LASTONE := \{X - 1,1\}  \par
 \par
 \par
setmod 2;  \par
 \par
  1  \par
 \par
 \par
on modular;  \par
 \par
factorize(x^15 - 1);  \par
 \par
     4    3    2 \par
  \{\{X  + X  + X  + X + 1,1\}, \par
     4    3 \par
   \{X  + X  + 1,1\}, \par
     4 \par
   \{X  + X + 1,1\}, \par
      2 \par
   \{ X  + X + 1,1\}, \par
   \{X + 1,1\}\} \par
 \par
\pard \sl240 }{\f2 The }{\f3 factorize} {\f2  command returns the factor,power pairs as a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 . 
You can therefore use the usual list access methods (}
{\f2\uldb first}{\v\f2 FIRST} 
{\f2 , 
}
{\f2\uldb second}{\v\f2 SECOND} 
{\f2 , }
{\f2\uldb third}{\v\f2 THIRD} 
{\f2 , }
{\f2\uldb rest}{\v\f2 REST} 
{\f2 , }
{\f2\uldb length}{\v\f2 LENGTH} 
{\f2  and 
}
{\f2\uldb part}{\v\f2 PART} 
{\f2 ) to extract these pairs. 
\par 
\par 
If the <expression> given to }{\f3 factorize} {\f2  is an integer, it will be 
factored into its prime components. To factor any integer factor of a 
non-numerical expression, the switch }
{\f2\uldb ifactor}{\v\f2 IFACTOR} 
{\f2  should be turned on. 
Its default is off. }
{\f2\uldb ifactor}{\v\f2 IFACTOR} 
{\f2  has effect only when factoring is 
explicitly done by }{\f3 factorize} {\f2 , not when factoring is automatically 
done with the }
{\f2\uldb factor}{\v\f2 FACTOR} 
{\f2  switch. If full factorization is not 
needed the switch }
{\f2\uldb limitedfactors}{\v\f2 LIMITEDFACTORS} 
{\f2  allows you to reduce the 
computing time of calls to }{\f3 factorize} {\f2 . 
\par 
\par 
Factoring can be done in a modular domain by calling }{\f3 factorize} {\f2  when 
}
{\f2\uldb modular}{\v\f2 MODULAR} 
{\f2  is on. You can set the modulus with the }
{\f2\uldb setmod}{\v\f2 SETMOD} 
{\f2  
command. The last example above shows factoring modulo 2. 
\par 
\par 
For general comments on factoring, see comments under the switch 
}
{\f2\uldb factor}{\v\f2 FACTOR} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # HYPOT}

${\footnote \pard\plain \sl240 \fs20 $ HYPOT}

+{\footnote \pard\plain \sl240 \fs20 + g8:0789}

 K{\footnote \pard\plain \sl240 \fs20 K HYPOT operator;operator}

}{\b\f2 HYPOT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 hypot(<expression>,<expression>) 
\par 
\par 
}{\f2 \par 
If }{\f3 rounded} {\f2  is on, and the two arguments evaluate to numbers, this 
operator returns the square root of the sums of the squares of the 
arguments in a manner that avoids intermediate overflow. In other cases, 
an expression in the original operator is returned. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
hypot(3,4);  \par
 \par
  HYPOT(3,4)  \par
 \par
 \par
on rounded;  \par
 \par
ws;  \par
 \par
  5.0  \par
 \par
 \par
hypot(a,b);  \par
 \par
  HYPOT(A,B) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # IMPART}

${\footnote \pard\plain \sl240 \fs20 $ IMPART}

+{\footnote \pard\plain \sl240 \fs20 + g8:0790}

 K{\footnote \pard\plain \sl240 \fs20 K complex;imaginary part;IMPART operator;operator}

}{\b\f2 IMPART}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 impart} {\f4 (<expression>) or }{\f3 impart} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
This operator returns the imaginary part of an expression, if that 
argument has an numerical value. A non-numerical argument is returned as 
an expression in the operators }
{\f2\uldb repart}{\v\f2 REPART} 
{\f2  and }{\f3 impart} {\f2 . 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
impart(1+i);  \par
 \par
  1  \par
 \par
 \par
impart(a+i*b);  \par
 \par
  REPART(B) + IMPART(A) \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # INT}

${\footnote \pard\plain \sl240 \fs20 $ INT}

+{\footnote \pard\plain \sl240 \fs20 + g8:0791}

 K{\footnote \pard\plain \sl240 \fs20 K integration;INT operator;operator}

}{\b\f2 INT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 int} {\f2  operator performs analytic integration on a variety of 
functions. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 int} {\f4 (<expression>,<kernel>) 
\par 
\par 
}{\f2 \par 
<expression> can be any scalar expression. involving polynomials, log 
functions, exponential functions, or tangent or arctangent expressions. 
}{\f3 int} {\f2  attempts expressions involving error functions, dilogarithms 
and other trigonometric expressions. Integrals involving algebraic 
extensions (such as square roots) may not succeed. <kernel> must be a 
REDUCE }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
int(x**3 + 3,x);  \par
 \par
      3 \par
  X*(X  + 12) \par
  -----------  \par
       4 \par
 \par
 \par
 \par
int(sin(x)*exp(2*x),x); \par
  \par
 \par
     2*X \par
    E   *(COS(X) - 2*SIN(X)) \par
  - ------------------------  \par
               5 \par
 \par
 \par
int(1/(x^2-2),x); \par
  \par
 \par
  SQRT(2)*(LOG( - SQRT(2) + X) - LOG(SQRT(2) + X)) \par
  ------------------------------------------------  \par
                         4 \par
 \par
 \par
int(sin(x)/(4 + cos(x)**2),x); \par
  \par
 \par
         COS(X) \par
    ATAN(------) \par
           2 \par
  - ------------  \par
         2 \par
 \par
 \par
 \par
int(1/sqrt(x^2-x),x);  \par
 \par
      SQRT(X)*SQRT(X - 1) \par
  INT(-------------------,X) \par
              2 \par
             X -X \par
 \par
\pard \sl240 }{\f2 Note that REDUCE couldn't handle the last integral with its default 
integrator, since the integrand involves a square root. However, 
the integral can be found using the }
{\f2\uldb algint}{\v\f2 ALGINT} 
{\f2  package. 
Alternatively, you could add a rule using the }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statement 
to evaluate this integral. 
\par 
\par 
The arbitrary constant of integration is not shown. Definite integrals can 
be found by evaluating the result at the limits of integration (use 
}
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2 ) and subtracting the lower from the higher. Evaluation can 
be easily done by the }
{\f2\uldb sub}{\v\f2 SUB} 
{\f2  operator. 
\par 
\par 
When }{\f3 int} {\f2  cannot find an integral it returns an expression 
involving formal }{\f3 int} {\f2  expressions unless the switch 
}
{\f2\uldb failhard}{\v\f2 FAILHARD} 
{\f2  has been set. If not all of the expression 
can be integrated, the switch }
{\f2\uldb nolnr}{\v\f2 NOLNR} 
{\f2  controls whether a partially 
integrated result should be returned or not. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # INTERPOL}

${\footnote \pard\plain \sl240 \fs20 $ INTERPOL}

+{\footnote \pard\plain \sl240 \fs20 + g8:0792}

 K{\footnote \pard\plain \sl240 \fs20 K approximation;polynomial;interpolation;INTERPOL operator;operator}

}{\b\f2 INTERPOL}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
}{\f3 interpol} {\f2 generates an interpolation polynomial. 
 \par
syntax: \par
}{\f4 \par 
\par 
interpol(<values>,<variable>,<points>) 
\par 
\par 
}{\f2 \par 
<values> and <points> are }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 s of equal length and 
<variable> is an algebraic expression (preferably a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 ). 
The interpolation polynomial is generated in the given variable of degree 
length(<values>)-1. The unique polynomial }{\f3 f} {\f2  is defined by the 
property that for corresponding elements }{\f3 v} {\f2  of <values> and 
}{\f3 p} {\f2  of <points> the relation }{\f3 f(p)=v} {\f2  holds. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
f := for i:=1:4 collect(i**3-1);  \par
 \par
  F := 0,7,26,63  \par
 \par
 \par
p := \{1,2,3,4\};  \par
 \par
  P := 1,2,3,4  \par
 \par
 \par
interpol(f,x,p);  \par
 \par
   3 \par
  X  - 1 \par
 \par
\pard \sl240 }{\f2 The Aitken-Neville interpolation algorithm is used which guarantees a 
stable result even with rounded numbers and an ill-conditioned problem. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LCOF}

${\footnote \pard\plain \sl240 \fs20 $ LCOF}

+{\footnote \pard\plain \sl240 \fs20 + g8:0793}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;coefficient;LCOF operator;operator}

}{\b\f2 LCOF}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 lcof} {\f2  operator returns the leading coefficient of a given expression 
with respect to a given variable. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 lcof} {\f4 (<expression>,<kernel>) 
\par 
\par 
}{\f2 \par 
<expression> is ordinarily a polynomial. If }
{\f2\uldb ratarg}{\v\f2 RATARG} 
{\f2  is on, 
a rational expression may also be used, otherwise an error results. 
<kernel> must be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
lcof((x+2*y)**5,y);  \par
 \par
  32  \par
 \par
 \par
lcof((x + y*sin(x))**2 + cos(x)*sin(x)**2,sin(x)); \par
			  \par
 \par
 \par
        2 \par
  COS(X)  + Y  \par
 \par
 \par
lcof(x**2 + 3*x + 17,y);  \par
 \par
   2 \par
  X  + 3*X + 17 \par
 \par
\pard \sl240 }{\f2 If the kernel does not appear in the expression, }{\f3 lcof} {\f2  returns the 
expression. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LENGTH}

${\footnote \pard\plain \sl240 \fs20 $ LENGTH}

+{\footnote \pard\plain \sl240 \fs20 + g8:0794}

 K{\footnote \pard\plain \sl240 \fs20 K list;LENGTH operator;operator}

}{\b\f2 LENGTH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 length} {\f2  operator returns the number of items in a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 , the 
number of 
terms in an expression, or the dimensions of an array or matrix. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 length} {\f4 (<expr>) or }{\f3 length} {\f4  <expr> 
\par 
\par 
}{\f2 \par 
<expr> can be a list structure, an array, a matrix, or a scalar expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
alist := \{a,b,\{ww,xx,yy,zz\}\};  \par
 \par
  ALIST := \{A,B,\{WW,XX,YY,ZZ\}\}  \par
 \par
 \par
length alist;  \par
 \par
  3   \par
 \par
 \par
length third alist;  \par
 \par
  4   \par
 \par
 \par
dlist := \{d\};  \par
 \par
  DLIST := \{D\}  \par
 \par
 \par
length rest dlist;  \par
 \par
  0   \par
 \par
 \par
matrix mmm(4,5);  \par
 \par
length mmm;  \par
 \par
  \{4,5\}  \par
 \par
 \par
array aaa(5,3,2);  \par
 \par
length aaa;  \par
 \par
  \{6,4,3\}  \par
 \par
 \par
eex := (x+3)**2/(x-y);  \par
 \par
          2 \par
         X  + 6*X + 9 \par
  EEX := ------------  \par
            X - Y \par
 \par
 \par
length eex;  \par
 \par
  5 \par
 \par
\pard \sl240 }{\f2 An item in a list that is itself a list only counts as one item. An error 
message will be printed if }{\f3 length} {\f2  is called on a matrix which has 
not had its dimensions set. The }{\f3 length} {\f2  of an array includes the 
zeroth element of each dimension, showing the full number of elements 
allocated. (Declaring an array A with n elements 
allocates A(0),A(1),...,A(n).) The 
}{\f3 length} {\f2  of an expression is the total number of additive terms 
appearing in the numerator and denominator of the expression. Note that 
subtraction of a term is represented internally as addition of a negative 
term. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LHS}

${\footnote \pard\plain \sl240 \fs20 $ LHS}

+{\footnote \pard\plain \sl240 \fs20 + g8:0795}

 K{\footnote \pard\plain \sl240 \fs20 K equation;left-hand side;LHS operator;operator}

}{\b\f2 LHS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 lhs} {\f2  operator returns the left-hand side of an }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2 , 
such as those 
returned in a list by }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 lhs} {\f4 (<equation>) or }{\f3 lhs} {\f4  <equation> 
\par 
\par 
\par 
\par 
}{\f2 <equation> must be an equation of the form 
\par 
\par 
}{\f3 left-hand side} {\f3 =} {\f3 right-hand side} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
polly := (x+3)*(x^4+2x+1);  \par
 \par
            5      4      2 \par
  POLLY := X  + 3*X  + 2*X  + 7*X + 3  \par
 \par
 \par
pollyroots := solve(polly,x);  \par
 \par
  POLLYROOTS := \{X=ROOT F(X3 - X2 + X + 1,X , \par
                       O                   ) \par
                 X=-1, \par
                 X=-3\} \par
 \par
 \par
variable := lhs first pollyroots;  \par
 \par
  VARIABLE := X \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # LIMIT}

${\footnote \pard\plain \sl240 \fs20 $ LIMIT}

+{\footnote \pard\plain \sl240 \fs20 + g8:0796}

 K{\footnote \pard\plain \sl240 \fs20 K l'Hopital's rule;limit;LIMIT operator;operator}

}{\b\f2 LIMIT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
LIMITS is a fast limit package for REDUCE for functions which are 
continuous except for computable poles and singularities, based on 
some earlier work by Ian Cohen and John P. Fitch. The Truncated 
Power Series package is used for non-critical points, at which 
the value of the function is the constant term in the expansion 
around that point. l'Hopital's rule is used in critical cases, 
with preprocessing of 1-1 forms and reformatting of product forms 
in order to apply l'Hopital's rule. A limited amount of bounded 
arithmetic is also employed where applicable. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 limit} {\f4 (<expr>,<var>,<limpoint>) or 
\par 
\par 
}{\f3 limit!+} {\f4 (<expr>,<var>,<limpoint>) or 
\par 
\par 
}{\f3 limit!-} {\f4 (<expr>,<var>,<limpoint>) 
\par 
\par 
}{\f2 \par 
where <expr> is an expression depending of the variable <var> 
(a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 ) and <limpoint> is the limit point. 
If the limit depends upon the direction of approach to the <limpoint>, 
the operators }{\f3 limit!+} {\f2  and }{\f3 limit!-} {\f2  may be used. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
limit(x*cot(x),x,0); \par
 \par
  0 \par
 \par
 \par
limit((2x+5)/(3x-2),x,infinity); \par
 \par
  2 \par
  -- \par
  3 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # LPOWER}

${\footnote \pard\plain \sl240 \fs20 $ LPOWER}

+{\footnote \pard\plain \sl240 \fs20 + g8:0797}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;leading power;LPOWER operator;operator}

}{\b\f2 LPOWER}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 lpower} {\f2  operator returns the leading power of an expression with 
respect to a kernel. 1 is returned if the expression does not depend on 
the kernel. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 lpower} {\f4 (<expression>,<kernel>) 
\par 
\par 
}{\f2 \par 
<expression> is ordinarily a polynomial. If }
{\f2\uldb ratarg}{\v\f2 RATARG} 
{\f2  is on, 
a rational expression may also be used, otherwise an error results. 
<kernel> must be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
lpower((x+2*y)**6,y);  \par
 \par
   6 \par
  Y   \par
 \par
 \par
lpower((x + cos(x))**8 + df(x**2,x),cos(x)); \par
			  \par
 \par
 \par
        8 \par
  COS(X)   \par
 \par
 \par
lpower(x**3 + 3*x,y);  \par
 \par
  1 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # LTERM}

${\footnote \pard\plain \sl240 \fs20 $ LTERM}

+{\footnote \pard\plain \sl240 \fs20 + g8:0798}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;leading term;LTERM operator;operator}

}{\b\f2 LTERM}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 lterm} {\f2  operator returns the leading term of an expression with 
respect to a kernel. The expression is returned if it does not depend on 
the kernel. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 lterm} {\f4 (<expression>,<kernel>) 
\par 
\par 
}{\f2 \par 
<expression> is ordinarily a polynomial. If }
{\f2\uldb ratarg}{\v\f2 RATARG} 
{\f2  is on, 
a rational expression may also be used, otherwise an error results. 
<kernel> must be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
lterm((x+2*y)**6,y);  \par
 \par
      6 \par
  64*Y   \par
 \par
 \par
lterm((x + cos(x))**8 + df(x**2,x),cos(x)); \par
			  \par
 \par
 \par
        8 \par
  COS(X)   \par
 \par
 \par
lterm(x**3 + 3*x,y);  \par
 \par
   3 \par
  X  + 3X \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # MAINVAR}

${\footnote \pard\plain \sl240 \fs20 $ MAINVAR}

+{\footnote \pard\plain \sl240 \fs20 + g8:0799}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;main variable;MAINVAR operator;operator}

}{\b\f2 MAINVAR}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 mainvar} {\f2  operator returns the main variable (in the system's 
internal representation) of its argument. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 mainvar} {\f4 (<expression>) 
\par 
\par 
\par 
\par 
}{\f2 <expression> is usually a polynomial, but may be any valid REDUCE 
scalar expression. In the case of a rational function, the main variable 
of the numerator is returned. The main variable returned is a 
}
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
test := (a + b + c)**2;  \par
 \par
           2                    2            2 \par
  TEST := A  + 2*A*B + 2*A*C + B  + 2*B*C + C   \par
 \par
 \par
mainvar(test);  \par
 \par
  A  \par
 \par
 \par
korder c,b,a;  \par
 \par
mainvar(test);  \par
 \par
  C  \par
 \par
 \par
mainvar(2*cos(x)**2);  \par
 \par
  COS(X)  \par
 \par
 \par
mainvar(17);  \par
 \par
  0 \par
 \par
\pard \sl240 }{\f2 The main variable is the first variable in the canonical ordering of 
kernels. Generally, alphabetically ordered functions come first, then 
alphabetically ordered identifiers (variables). Numbers come last, and as 
far as }{\f3 mainvar} {\f2  is concerned belong in the family }{\f3 0} {\f2 . The 
canonical ordering can be changed by the declaration }
{\f2\uldb korder}{\v\f2 KORDER} 
{\f2 , as 
shown above. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MAP}

${\footnote \pard\plain \sl240 \fs20 $ MAP}

+{\footnote \pard\plain \sl240 \fs20 + g8:0800}

 K{\footnote \pard\plain \sl240 \fs20 K composite structure;map;MAP operator;operator}

}{\b\f2 MAP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 map} {\f2  operator applies a uniform evaluation pattern 
to all members of a composite structure: a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 , 
a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  or the arguments of an }
{\f2\uldb operator}{\v\f2 OPERATOR} 
{\f2  expression. 
The evaluation pattern can be a 
unary procedure, an operator, or an algebraic expression with 
one free variable. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 map} {\f4 (<function>,<object>) 
\par 
\par 
}{\f2 \par 
<object> is a list, a matrix or an operator expression. 
\par 
\par 
<function> is 
the name of an operator for a single argument: the operator 
is evaluated once with each element of <object> as its single argument, 
\par 
\par 
or an algebraic expression with exactly one }
{\f2\uldb free variable}{\v\f2 Free_Variable} 
{\f2 , that is 
a variable preceded by the tilde symbol: the expression 
 is evaluated for each element of <object> where the element is 
 substituted for the free variable, 
\par 
\par 
or a replacement }
{\f2\uldb rule}{\v\f2 RULE} 
{\f2  of the form 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 var} {\f4 => }{\f3 rep} {\f4  
\par 
\par 
}{\f2 \par 
where <var> is a variable (a <kernel> without subscript) 
 and <rep> is an expression which contains <var>. 
 Here }{\f3 rep} {\f2  is evaluated for each element of <object> where 
 the element is substituted for }{\f3 var} {\f2 . }{\f3 var} {\f2  may be 
 optionally preceded by a tilde. 
\par 
\par 
The rule form for <function> is needed when more than 
one free variable occurs. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
map(abs,\{1,-2,a,-a\});  \par
 \par
  1,2,abs(a),abs(a)  \par
 \par
 \par
map(int(~w,x), mat((x^2,x^5),(x^4,x^5)));  \par
 \par
 \par
          [  3     6 ] \par
          [ x     x  ] \par
          [----  ----] \par
          [ 3     6  ] \par
          [          ] \par
          [  5     6 ] \par
          [ x     x  ] \par
          [----  ----] \par
  	[ 5     6  ] \par
 \par
 \par
map(~w*6, x^2/3 = y^3/2 -1);  \par
 \par
     2     3 \par
  2*x =3*(y -2) \par
 \par
\pard \sl240 }{\f2 You can use }{\f3 map} {\f2  in nested expressions. It is not allowed to 
apply }{\f3 map} {\f2  for a non-composed object, e.g. an identifier or a number. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MKID}

${\footnote \pard\plain \sl240 \fs20 $ MKID}

+{\footnote \pard\plain \sl240 \fs20 + g8:0801}

 K{\footnote \pard\plain \sl240 \fs20 K identifier;MKID command;command}

}{\b\f2 MKID}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 mkid} {\f2  command constructs an identifier, given a stem and an identifier 
or an integer. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 mkid} {\f4 (<stem>,<leaf>) 
\par 
\par 
}{\f2 \par 
<stem> can be any valid REDUCE identifier that does not include escaped 
special characters. <leaf> may be an integer, including one given by a 
local variable in a }
{\f2\uldb for}{\v\f2 FOR} 
{\f2  loop, or any other legal group of 
characters. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
mkid(x,3);  \par
 \par
  X3  \par
 \par
 \par
factorize(x^15 - 1);  \par
 \par
  \{X - 1, \par
    2 \par
   X  + X + 1, \par
    4    3    2 \par
   X  + X  + X  + X + 1, \par
    8    7    5    4    3 \par
   X  - X  + X  - X  + X   - X + 1\} \par
 \par
 \par
 \par
for i := 1:length ws do write set(mkid(f,i),part(ws,i)); \par
	  \par
 \par
 \par
   8    7    5    4    3 \par
  X  - X  + X  - X  + X  - X + 1 \par
   4    3    2 \par
  X  + X  + X  + X + 1 \par
   2 \par
  X  + X + 1 \par
  X - 1 \par
 \par
\pard \sl240 }{\f2 You can use }{\f3 mkid} {\f2  to construct identifiers from inside procedures. This 
allows you to handle an unknown number of factors, or deal with variable 
amounts of data. It is particularly helpful to attach identifiers to the 
answers returned by }{\f3 factorize} {\f2  and }{\f3 solve} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NPRIMITIVE}

${\footnote \pard\plain \sl240 \fs20 $ NPRIMITIVE}

+{\footnote \pard\plain \sl240 \fs20 + g8:0802}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;primitive part;NPRIMITIVE operator;operator}

}{\b\f2 NPRIMITIVE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 nprimitive} {\f4 (<expression>) or }{\f3 nprimitive} {\f4  
 <simple\_expression> 
\par 
\par 
}{\f2 \par 
This operator returns the numerically-primitive part of any scalar 
expression. In other words, any overall integer factors in the expression 
are removed. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
nprimitive((2x+2y)^2);  \par
 \par
   2            2 \par
  X  + 2*X*Y + Y   \par
 \par
 \par
nprimitive(3*a*b*c);  \par
 \par
  3*A*B*C \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # NUM}

${\footnote \pard\plain \sl240 \fs20 $ NUM}

+{\footnote \pard\plain \sl240 \fs20 + g8:0803}

 K{\footnote \pard\plain \sl240 \fs20 K rational expression;numerator;NUM operator;operator}

}{\b\f2 NUM}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 num} {\f2  operator returns the numerator of its argument. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 num} {\f4 (<expression>) or }{\f3 num} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE scalar expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
num(100/6);  \par
 \par
  50  \par
 \par
 \par
num(a/5 + b/6);  \par
 \par
  6*A + 5*B  \par
 \par
 \par
num(sin(x));  \par
 \par
  SIN(X) \par
 \par
\pard \sl240 }{\f2 }{\f3 num} {\f2 returns the numerator of the expression after it has been simplified 
by REDUCE. As seen in the examples, this includes putting sums of rational 
expressions over a common denominator, and reducing common factors where 
possible. If the expression is not a rational expression, it is returned 
unchanged. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ODESOLVE}

${\footnote \pard\plain \sl240 \fs20 $ ODESOLVE}

+{\footnote \pard\plain \sl240 \fs20 + g8:0804}

 K{\footnote \pard\plain \sl240 \fs20 K solve;differential equation;ODESOLVE operator;operator}

}{\b\f2 ODESOLVE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 odesolve} {\f2  package is a solver for ordinary differential 
equations. At the present time it has still limited capabilities: 
\par 
\par 
1. it can handle only a single scalar equation presented as an 
 algebraic expression or equation, and 
\par 
\par 
2. it can solve only first-order equations of simple types, linear 
 equations with constant coefficients and Euler equations. 
\par 
\par 
These solvable types are exactly those for which Lie symmetry 
techniques give no useful information. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 odesolve} {\f4 (<expr>,<var1>,<var2>) 
\par 
\par 
\par 
\par 
}{\f2 <expr> is a single scalar expression such that <expr>=0 
is the ordinary differential equation (ODE for short) to be solved, or 
is an equivalent }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2 . 
\par 
\par 
<var1> is the name of the dependent variable, 
<var2> is the name of the independent variable. 
\par 
\par 
A differential in <expr> is expressed using the }
{\f2\uldb df}{\v\f2 DF} 
{\f2  
operator. Note that in most cases you must declare explicitly 
<var1> to depend of <var2> using a }
{\f2\uldb depend}{\v\f2 DEPEND} 
{\f2  
declaration -- otherwise the derivative might be evaluated to 
zero on input to }{\f3 odesolve} {\f2 . 
\par 
\par 
The returned value is a list containing the equation giving the general 
solution of the ODE (for simultaneous equations this will be a 
list of equations eventually). It will contain occurrences of 
the operator }{\f3 arbconst} {\f2  for the arbitrary constants in the general 
solution. The arguments of }{\f3 arbconst} {\f2  should be new. 
A counter }{\f3 !!arbconst} {\f2  is used to arrange this. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
depend y,x; \par
 \par
\% A first-order linear equation, with an initial condition \par
 \par
ode:=df(y,x) + y * sin x/cos x - 1/cos x$ \par
 \par
odesolve(ode,y,x);  \par
 \par
  \{y=arbconst(1)*cos(x) + sin(x)\} \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # ONE\_OF}

${\footnote \pard\plain \sl240 \fs20 $ ONE_OF}

+{\footnote \pard\plain \sl240 \fs20 + g8:0805}

 K{\footnote \pard\plain \sl240 \fs20 K ONE_OF type;type}

}{\b\f2 ONE\_OF}{\f2 \tab \tab \tab \tab }{\b\f2 type}{\f2 \par 
\par 
 
The operator }{\f3 one_of} {\f2  is used to represent an indefinite choice 
of one element from a finite set of objects. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
x=one_of\{1,2,5\} \par
\pard \sl240 }{\f2 this equation encodes that x can take one of the values 
1,2 or 5}{\f4 \pard \tx3420  \par
\pard \sl240 }{\f2  
REDUCE generates a }{\f3 one_of} {\f2  form in cases when an implicit 
}{\f3 root_of} {\f2  expression could be converted to an explicit solution set. 
A }{\f3 one_of} {\f2  form can be converted to a }{\f3 solve} {\f2  solution using 
}
{\f2\uldb expand_cases}{\v\f2 EXPAND\_CASES} 
{\f2 . See }
{\f2\uldb root_of}{\v\f2 ROOT\_OF} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PART}

${\footnote \pard\plain \sl240 \fs20 $ PART}

+{\footnote \pard\plain \sl240 \fs20 + g8:0806}

 K{\footnote \pard\plain \sl240 \fs20 K decomposition;PART operator;operator}

}{\b\f2 PART}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 part} {\f2  permits the extraction of various parts or 
operators of expressions and }
{\f2\uldb list}{\v\f2 LIST} 
{\f3 s} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 part} {\f4 (<expression,integer>\{,<integer>\}*) 
\par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE expression or a list, 
integer may be an expression that evaluates to a positive or negative 
integer or 0. A positive integer <n> picks up the n th term, 
counting from the first term toward the end. A negative integer n 
picks up the n th term, counting from the back toward the front. The 
integer 0 picks up the operator (which is }{\f3 LIST} {\f2  when the expression 
is a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 ). 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
part((x + y)**5,4);  \par
 \par
      2  3 \par
  10*X *Y   \par
 \par
 \par
part((x + y)**5,4,2);  \par
 \par
   2 \par
  X   \par
 \par
 \par
part((x + y)**5,4,2,1);  \par
 \par
  X  \par
 \par
 \par
part((x + y)**5,0);  \par
 \par
  PLUS  \par
 \par
 \par
part((x + y)**5,-5);  \par
 \par
        4 \par
  5*X *Y   \par
 \par
 \par
part((x + y)**5,4) := sin(x);  \par
 \par
   5      4         3  2                 4    5 \par
  X  + 5*X *Y + 10*X *Y  + SIN(X) + 5*X*Y  + Y   \par
 \par
 \par
alist := \{x,y,\{aa,bb,cc\},x**2*sqrt(y)\};  \par
 \par
 \par
                                        2 \par
  			 ALIST := \{X,Y,\{AA,BB,CC\},SQRT(Y)*X \}  \par
 \par
 \par
part(alist,3,2);  \par
 \par
  BB  \par
 \par
 \par
part(alist,4,0);  \par
 \par
  TIMES \par
 \par
\pard \sl240 }{\f2 Additional integer arguments after the first one examine the 
terms recursively, as shown above. In the third line, the fourth term 
is picked from the original polynomial, 10x^2y^3, 
then the second term from that, x^2, and finally the first 
component, x. If an integer's absolute value is too large for 
the appropriate expression, a message is given. 
\par 
\par 
}{\f3 part} {\f2 works on the form of the expression as printed, or as it would 
have been printed at that point of the calculation, bearing in mind the 
current switch settings. It is important to realize that the switch settings 
change the operation of }{\f3 part} {\f2 . }
{\f2\uldb pri}{\v\f2 PRI} 
{\f2  must be on when 
}{\f3 part} {\f2  is used. 
\par 
\par 
When }{\f3 part} {\f2  is used on a polynomial expression that has minus signs, the 
}{\f3 +} {\f2  is always returned as the top-level operator. The minus is found 
as a unary operator attached to the negative term. 
\par 
\par 
}{\f3 part} {\f2 can also be used to change the relevant part of the expression or 
list as shown in the sixth example line. The }{\f3 part} {\f2  operator returns the 
changed expression, though original expression is not changed. You can 
also use }{\f3 part} {\f2  to change the operator. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PF}

${\footnote \pard\plain \sl240 \fs20 $ PF}

+{\footnote \pard\plain \sl240 \fs20 + g8:0807}

 K{\footnote \pard\plain \sl240 \fs20 K rational expression;partial fraction;PF operator;operator}

}{\b\f2 PF}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 pf(<expression>,<variable>) 
\par 
\par 
}{\f2 \par 
}{\f3 pf} {\f2 transforms <expression> into a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  of partial fraction 
s 
with respect to the main variable, <variable>. }{\f3 pf} {\f2  does a 
complete partial fraction decomposition, and as the algorithms used are 
fairly unsophisticated (factorization and the extended Euclidean 
algorithm), the code may be unacceptably slow in complicated cases. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
pf(2/((x+1)^2*(x+2)),x);  \par
 \par
      2    -2        2 \par
  	\{-----,-----,------------\}  \par
    X + 2 X + 1  2 \par
                X  + 2*X + 1 \par
 \par
 \par
off exp;  \par
 \par
pf(2/((x+1)^2*(x+2)),x); \par
  \par
 \par
     2    - 2     2 \par
  \{-----,-----,--------\}  \par
   X + 2 X + 1        2 \par
               (X + 1) \par
 \par
 \par
for each j in ws sum j;  \par
 \par
         2 \par
  ---------------- \par
                2 \par
  ( + 2)*(X + 1) \par
 \par
\pard \sl240 }{\f2 \par 
\par 
If you want the denominators in factored form, turn }
{\f2\uldb exp}{\v\f2 EXP} 
{\f2  off, as 
shown in the second example above. As shown in the final example, the 
}
{\f2\uldb for}{\v\f2 FOR} 
{\f2  }{\f3 each} {\f2  construct can be used to recombine the terms. 
Alternatively, one can use the operations on lists to extract any desired 
term. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PROD}

${\footnote \pard\plain \sl240 \fs20 $ PROD}

+{\footnote \pard\plain \sl240 \fs20 + g8:0808}

 K{\footnote \pard\plain \sl240 \fs20 K product;Gosper algorithm;PROD operator;operator}

}{\b\f2 PROD}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 prod} {\f2  returns 
the indefinite or definite product of a given expression. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 prod} {\f4 (<expr>,<k>[,<lolim> [,<uplim> ]]) 
\par 
\par 
\par 
\par 
}{\f2 where <expr> is the expression to be multiplied, <k> is the 
control variable (a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 ), and <lolim> and <uplim> 
uplim are the optional lower and upper limits. If <uplim> is 
not supplied the upper limit is taken as <k>. The 
Gosper algorithm is used. If there is no closed form solution, 
the operator returns the input unchanged. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
prod(k/(k-2),k); \par
 \par
  k*( - k + 1) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # REDUCT}

${\footnote \pard\plain \sl240 \fs20 $ REDUCT}

+{\footnote \pard\plain \sl240 \fs20 + g8:0809}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;reductum;REDUCT operator;operator}

}{\b\f2 REDUCT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 reduct} {\f2  operator returns the remainder of its expression after the 
leading term with respect to the kernel in the second argument is removed. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 reduct} {\f4 (<expression>,<kernel>) 
\par 
\par 
}{\f2 \par 
<expression> is ordinarily a polynomial. If }
{\f2\uldb ratarg}{\v\f2 RATARG} 
{\f2  is on, 
a rational expression may also be used, otherwise an error results. 
<kernel> must be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
reduct((x+y)**3,x);  \par
 \par
        2            2 \par
  Y*(3*X  + 3*X*Y + Y )  \par
 \par
 \par
reduct(x + sin(x)**3,sin(x));  \par
 \par
  X  \par
 \par
 \par
reduct(x + sin(x)**3,y);  \par
 \par
  0 \par
 \par
\pard \sl240 }{\f2 If the expression does not contain the kernel, }{\f3 reduct} {\f2  returns 0. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # REPART}

${\footnote \pard\plain \sl240 \fs20 $ REPART}

+{\footnote \pard\plain \sl240 \fs20 + g8:0810}

 K{\footnote \pard\plain \sl240 \fs20 K complex;real part;REPART operator;operator}

}{\b\f2 REPART}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 repart} {\f4 (<expression>) or }{\f3 repart} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
This operator returns the real part of an expression, if that argument has an 
numerical value. A non-numerical argument is returned as an expression in 
the operators }{\f3 repart} {\f2  and }
{\f2\uldb impart}{\v\f2 IMPART} 
{\f2 . 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
repart(1+i);  \par
 \par
  1  \par
 \par
 \par
repart(a+i*b);  \par
 \par
  REPART(A) - IMPART(B) \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RESULTANT}

${\footnote \pard\plain \sl240 \fs20 $ RESULTANT}

+{\footnote \pard\plain \sl240 \fs20 + g8:0811}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;RESULTANT operator;operator}

}{\b\f2 RESULTANT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 resultant} {\f2  operator computes the resultant of two polynomials with 
respect to a given variable. If the resultant is 0, the polynomials have 
a root in common. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 resultant} {\f4 (<expression>,<expression>,<kernel>) 
\par 
\par 
}{\f2 \par 
<expression> must be a polynomial containing <kernel> ; 
<kernel> must be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
resultant(x**2 + 2*x + 1,x+1,x);  \par
 \par
  0  \par
 \par
 \par
resultant(x**2 + 2*x + 1,x-3,x);  \par
 \par
  16  \par
 \par
 \par
resultant(z**3 + z**2 + 5*z + 5, \par
          z**4 - 6*z**3 + 16*z**2 - 30*z + 55, \par
          z); \par
\pard \sl240   \par
 \par
  0  \par
 \par
 \par
resultant(x**3*y + 4*x*y + 10,y**2 + 6*y + 4,y);  \par
 \par
 \par
   6       5        4        3        2 \par
  Y  + 18*Y  + 120*Y  + 360*Y  + 480*Y  + 288*Y + 64 \par
 \par
\pard \sl240 }{\f2 The resultant is the determinant of the Sylvester matrix, formed from the 
coefficients of the two polynomials in the following way: 
\par 
\par 
Given two polynomials: 
\par 
\par 
\pard \tx3420 }{\f4  \par
    n       n-1  \par
 a x  + a1 x     + ... + an \par
 \par
\pard \sl240 }{\f2 and 
\par 
\par 
\pard \tx3420 }{\f4  \par
    m       m-1  \par
 b x  + b1 x     + ... + bm \par
 \par
\pard \sl240 }{\f2 form the (m+n)x(m+n-1) Sylvester matrix by the following means: 
\par 
\par 
\pard \tx3420 }{\f4  \par
   0.......0 a  a1 .......... an \par
   0....0 a  a1 .......... an  0 \par
       .    .   .   .   \par
   a0 a1 .......... an 0.......0 \par
   0.......0 b  b1 .......... bm \par
   0....0 b  b1 .......... bm  0 \par
       .    .   .   .   \par
   b  b1 .......... bm 0.......0   \par
 \par
\pard \sl240 }{\f2 If the determinant of this matrix is 0, the two polynomials have a common 
root. Finding the resultant of large expressions is time-consuming, due 
to the time needed to find a large determinant. 
\par 
\par 
The sign conventions }{\f3 resultant} {\f2  uses are those given in the article, 
``Computing in Algebraic Extensions,'' by R. Loos, appearing in 
<Computer Algebra--Symbolic and Algebraic Computation>, 2nd ed., 
edited by B. Buchberger, G.E. Collins and R. Loos, and published by 
Springer-Verlag, 1983. 
These are: 
\par 
\par 
\pard \tx3420 }{\f4  \par
  resultant(p(x),q(x),x) = (-1)^\{deg p(x)*deg q(x)\} * resultant(q(x),p(x),x), \par
  resultant(a,p(x),x)    = a^\{deg p(x)\}, \par
  resultant(a,b,x)       = 1 \par
\pard \sl240 }{\f2 where p(x) and q(x) are polynomials which have x as a variable, and 
a and b are free of x. 
\par 
\par 
Error messages are given if }{\f3 resultant} {\f2  is given a non-polynomial 
expression, or a non-kernel variable. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RHS}

${\footnote \pard\plain \sl240 \fs20 $ RHS}

+{\footnote \pard\plain \sl240 \fs20 + g8:0812}

 K{\footnote \pard\plain \sl240 \fs20 K equation;right-hand side;RHS operator;operator}

}{\b\f2 RHS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 rhs} {\f2  operator returns the right-hand side of an }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2 , 
such as those returned in a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  by }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 rhs} {\f4 (<equation>) or }{\f3 rhs} {\f4  <equation> 
\par 
\par 
}{\f2 \par 
<equation> must be an equation of the form left-hand side = right-hand 
side. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
roots := solve(x**2 + 6*x*y + 5x + 3y**2,x);  \par
 \par
 \par
                              2 \par
                     SQRT(24*Y  + 60*Y + 25) + 6*Y + 5 \par
      ROOTS := \{X= - ---------------------------------, \par
                                     2 \par
                             2 \par
                    SQRT(24*Y  + 60*Y + 25) - 6*Y - 5 \par
                 X= ---------------------------------\} \par
                                    2 \par
 \par
 \par
root1 := rhs first roots;  \par
 \par
                      2 \par
             SQRT(24*Y  + 60*Y + 25) + 6*Y + 5 \par
  ROOT1 := - ---------------------------------  \par
                             2 \par
 \par
 \par
root2 := rhs second roots;  \par
 \par
                    2 \par
           SQRT(24*Y  + 60*Y + 25) - 6*Y - 5 \par
  ROOT2 := ---------------------------------- \par
                           2 \par
 \par
\pard \sl240 }{\f2 An error message is given if }{\f3 rhs} {\f2  is applied to something other than an 
equation. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ROOT\_OF}

${\footnote \pard\plain \sl240 \fs20 $ ROOT_OF}

+{\footnote \pard\plain \sl240 \fs20 + g8:0813}

 K{\footnote \pard\plain \sl240 \fs20 K solve;roots;ROOT_OF operator;operator}

}{\b\f2 ROOT\_OF}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
When the operator }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  is unable to find an explicit solution 
or if that solution would be too complicated, the result is presented 
as formal root expression using the internal operator }{\f3 root_of} {\f2  
and a new local variable. An expression with a top level }{\f3 root_of} {\f2  
is implicitly a list with an unknown number of elements since we 
can't always know how many solutions an equation has. If a 
substitution is made into such an expression, closed form solutions 
can emerge. If this occurs, the }{\f3 root_of} {\f2  construct is 
replaced by an operator }
{\f2\uldb one_of}{\v\f2 ONE\_OF} 
{\f2 . At this point it is 
of course possible to transform the result if the original }{\f3 solve} {\f2  
operator expression into a standard }{\f3 solve} {\f2  solution. To 
effect this, the operator }
{\f2\uldb expand_cases}{\v\f2 EXPAND\_CASES} 
{\f2  can be used. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
solve(a*x^7-x^2+1,x); \par
 \par
                 7     2 \par
  \{x=root_of(a*x_  - x_  + 1,x_)\} \par
 \par
 \par
sub(a=0,ws); \par
 \par
  \{x=one_of(1,-1)\} \par
 \par
 \par
expand_cases ws; \par
 \par
  x=1,x=-1 \par
 \par
\pard \sl240 }{\f2 The components of }{\f3 root_of} {\f2  and }{\f3 one_of} {\f2  expressions can be 
processed as usual with operators }
{\f2\uldb arglength}{\v\f2 ARGLENGTH} 
{\f2  and }
{\f2\uldb part}{\v\f2 PART} 
{\f2 . 
A higher power of a }{\f3 root_of} {\f2  expression with a polynomial 
as first argument is simplified by using the polynomial as a side relation. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SELECT}

${\footnote \pard\plain \sl240 \fs20 $ SELECT}

+{\footnote \pard\plain \sl240 \fs20 + g8:0814}

 K{\footnote \pard\plain \sl240 \fs20 K list;map;SELECT operator;operator}

}{\b\f2 SELECT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 select} {\f2  operator extracts from a list 
or from the arguments of an n--ary operator elements corresponding 
to a boolean predicate. The predicate pattern can be a 
unary procedure, an operator or an algebraic expression with 
one }
{\f2\uldb free variable}{\v\f2 Free_Variable} 
{\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 select} {\f4 (<function>,<object>) 
\par 
\par 
}{\f2 \par 
<object> is a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 . 
\par 
\par 
<function> is 
the name of an operator for a single argument: the operator 
 is evaluated once with each element of <object> as its single argument, 
\par 
\par 
or an algebraic expression with exactly one }
{\f2\uldb free variable}{\v\f2 Free_Variable} 
{\f2 , that is 
a variable preceded by the tilde symbol: the expression 
 is evaluated for each element of <object> where the element is 
 substituted for the free variable, 
\par 
\par 
or a replacement }
{\f2\uldb rule}{\v\f2 RULE} 
{\f2  of the form 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 var} {\f4 => }{\f3 rep} {\f4  
\par 
\par 
}{\f2 \par 
where <var> is a variable (a <kernel> without subscript) 
 and <rep> is an expression which contains <var>. 
 Here }{\f3 rep} {\f2  is evaluated for each element of <object> where 
 the element is substituted for }{\f3 var} {\f2 . }{\f3 var} {\f2  may be 
 optionally preceded by a tilde. 
\par 
\par 
The rule form for <function> is needed when more than 
one free variable occurs. The evaluation result of <function> is 
interpreted as }
{\f2\uldb boolean value}{\v\f2 boolean_value} 
{\f2  corresponding to the conventions of 
REDUCE. The result value is built with the leading operator of the 
input expression. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
  select( ~w>0 , \{1,-1,2,-3,3\})  \par
 \par
  \{1,2,3\}  \par
 \par
 \par
  q:=(part((x+y)^5,0):=list) \par
 \par
  select(evenp deg(~w,y),q); \par
 \par
    5      3   2       4 \par
  \{x  ,10*x  *y  ,5*x*y  \} \par
 \par
 \par
  select(evenp deg(~w,x),2x^2+3x^3+4x^4); \par
 \par
 \par
    2   4 \par
  2x +4x \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SHOWRULES}

${\footnote \pard\plain \sl240 \fs20 $ SHOWRULES}

+{\footnote \pard\plain \sl240 \fs20 + g8:0815}

 K{\footnote \pard\plain \sl240 \fs20 K output;rule;SHOWRULES operator;operator}

}{\b\f2 SHOWRULES}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 showrules} {\f4 (<expression>) or 
 }{\f3 showrules} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
}{\f3 showrules} {\f2 returns in }
{\f2\uldb rule}{\v\f2 RULE} 
{\f3 -list} {\f2  form any 
}
{\f2\uldb operator}{\v\f2 OPERATOR} 
{\f2  rules associated with its argument. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
showrules log;  \par
 \par
  \{LOG(E) => 1, \par
   LOG(1) => 0, \par
        ~X \par
   LOG(E   ) => ~X, \par
                     1 \par
   DF(LOG(~X),~X) => --\} \par
                     ~X \par
 \par
\pard \sl240 }{\f2 Such rules can then be manipulated further as with any }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 . For 
example 
}{\f3 rhs first ws;} {\f2  has the value 1. 
\par 
\par 
An operator may have properties that cannot be displayed in such a form, 
such as the fact it is an }
{\f2\uldb odd}{\v\f2 ODD} 
{\f2  function, or has a definition defined 
as a procedure. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SOLVE}

${\footnote \pard\plain \sl240 \fs20 $ SOLVE}

+{\footnote \pard\plain \sl240 \fs20 + g8:0816}

 K{\footnote \pard\plain \sl240 \fs20 K solve;root;equation system;equation solving;equation;SOLVE operator;operator}

}{\b\f2 SOLVE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 solve} {\f2  operator solves a single algebraic }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2  or a 
system of simultaneous equations. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 solve} {\f4 (<expression> [ , <kernel>]) or 
\par 
\par 
}{\f3 solve} {\f4 (\{<expression>,...\} [ ,\{ <kernel> ,...\}] ) 
\par 
\par 
}{\f2  \par 
\par 
If the number of equations equals the number of distinct kernels, the 
optional kernel argument(s) may be omitted. <expression> is either a 
scalar expression or an }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2 . 
When more than one expression is given, 
the }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  of expressions is surrounded by curly braces. 
The optional list 
of }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 s follows, also in curly braces. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
sss := solve(x^2 + 7);  \par
 \par
  Unknown: X \par
  SSS := \{X= - SQRT(7)*I, \par
          X=SQRT(7)*I\} \par
 \par
 \par
rhs first sss;  \par
 \par
  - SQRT(7)*I  \par
 \par
 \par
solve(sin(x^2*y),y);  \par
 \par
     2*ARBINT(1)*PI \par
  \{Y=--------------- \par
            2 \par
           X \par
     PI*(2*ARBINT(1) + 1) \par
   Y=--------------------\} \par
               2 \par
              X \par
 \par
 \par
off allbranch;  \par
 \par
solve(sin(x**2*y),y);  \par
 \par
  \{Y=0\}  \par
 \par
 \par
solve(\{3x + 5y = -4,2*x + y = -10\},\{x,y\}); \par
  \par
 \par
 \par
         22   46 \par
  \{\{X= - --,Y=--\}\}  \par
         7    7 \par
 \par
 \par
solve(\{x + a*y + z,2x + 5\},\{x,y\}); \par
  \par
 \par
 \par
         5      2*Z - 5 \par
  \{\{X= - -,Y= - -------\}\}  \par
         2        2*A \par
 \par
 \par
ab := (x+2)^2*(x^6 + 17x + 1); \par
  \par
 \par
         8      7      6       3       2 \par
  AB := X  + 4*X  + 4*X  + 17*X  + 69*X  + 72*X + 4  \par
 \par
 \par
www := solve(ab,x);  \par
 \par
  \{X=ROOT F(X6 + 17*X + 1),X=-2\}  \par
         O             \par
 \par
 \par
root_multiplicities;  \par
 \par
  \{1,2\} \par
 \par
\pard \sl240 }{\f2 Results of the }{\f3 solve} {\f2  operator are returned as }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f3 s} {\f2  
in a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 . 
You can use the usual list access methods (}
{\f2\uldb first}{\v\f2 FIRST} 
{\f2 , 
}
{\f2\uldb second}{\v\f2 SECOND} 
{\f2 , }
{\f2\uldb third}{\v\f2 THIRD} 
{\f2 , }
{\f2\uldb rest}{\v\f2 REST} 
{\f2  and }
{\f2\uldb part}{\v\f2 PART} 
{\f2 ) to 
extract the desired equation, and then use the operators }
{\f2\uldb rhs}{\v\f2 RHS} 
{\f2  and 
}
{\f2\uldb lhs}{\v\f2 LHS} 
{\f2  to access the right-hand or left-hand expression of the 
equation. When }{\f3 solve} {\f2  is unable to solve an equation, it returns the 
unsolved part as the argument of }{\f3 root_of} {\f2 , with the variable renamed 
to avoid confusion, as shown in the last example above. 
\par 
\par 
For one equation, }{\f3 solve} {\f2  uses square-free factorization, roots of 
unity, and the known inverses of the }
{\f2\uldb log}{\v\f2 LOG} 
{\f2 , }
{\f2\uldb sin}{\v\f2 SIN} 
{\f2 , 
}
{\f2\uldb cos}{\v\f2 COS} 
{\f2 , }
{\f2\uldb acos}{\v\f2 ACOS} 
{\f2 , }
{\f2\uldb asin}{\v\f2 ASIN} 
{\f2 , and 
exponentiation operators. The quadratic, cubic and quartic formulas are 
used if necessary, but these are applied only when the switch 
}
{\f2\uldb fullroots}{\v\f2 FULLROOTS} 
{\f2  is set on; otherwise or when no closed form is available 
the result is returned as 
}
{\f2\uldb root_of}{\v\f2 ROOT\_OF} 
{\f2  expression. The switch }
{\f2\uldb trigform}{\v\f2 TRIGFORM} 
{\f2  
determines which type of cubic and quartic formula is used. 
The multiplicity of each solution is given in a list as 
the system variable }
{\f2\uldb root_multiplicities}{\v\f2 ROOT\_MULTIPLICITIES} 
{\f2 . For systems of 
simultaneous linear equations, matrix inversion is used. For nonlinear 
systems, the Groebner basis method is used. 
\par 
\par 
Linear equation system solving is influenced by the switch }
{\f2\uldb cramer}{\v\f2 CRAMER} 
{\f2 . 
\par 
\par 
Singular systems can be solved when the switch }
{\f2\uldb solvesingular}{\v\f2 SOLVESINGULAR} 
{\f2  is 
on, which is the default setting. An empty list is returned the system of 
equations is inconsistent. For a linear inconsistent system with parameters 
the variable }
{\f2\uldb requirements}{\v\f2 requirements} 
{\f2  constraints 
conditions for the system to become consistent. 
\par 
\par 
For a solvable linear and polynomial system with parameters 
the variable }
{\f2\uldb assumptions}{\v\f2 assumptions} 
{\f2  
contains a list side relations for the parameters: the solution is 
valid only as long as none of these expressions is zero. 
\par 
\par 
If the switch }
{\f2\uldb varopt}{\v\f2 VAROPT} 
{\f2  is on (default), the system rearranges the 
variable sequence for minimal computation time. Without }{\f3 varopt} {\f2  
the user supplied variable sequence is maintained. 
\par 
\par 
If the solution has free variables (dimension of the solution is greater 
than zero), these are represented by }
{\f2\uldb arbcomplex}{\v\f2 ARBCOMPLEX} 
{\f2  expressions 
as long as the switch }
{\f2\uldb arbvars}{\v\f2 ARBVARS} 
{\f2  is on (default). Without 
}{\f3 arbvars} {\f2  no explicit equations are generated for free variables. 
\par 
\par 
\par 
 \par
related: \par
\par 
\tab }
{\f2\uldb allbranch}{\v\f2 ALLBRANCH} 
{\f2 switch 
\par 
\tab }
{\f2\uldb arbvars}{\v\f2 ARBVARS} 
{\f2  switch 
\par 
\tab }
{\f2\uldb assumptions}{\v\f2 assumptions} 
{\f2  variable 
\par 
\tab }
{\f2\uldb fullroots}{\v\f2 FULLROOTS} 
{\f2  switch 
\par 
\tab }
{\f2\uldb requirements}{\v\f2 requirements} 
{\f2  variable 
\par 
\tab }
{\f2\uldb roots}{\v\f2 ROOTS} 
{\f2  operator 
\par 
\tab }
{\f2\uldb root_of}{\v\f2 ROOT\_OF} 
{\f2  operator 
\par 
\tab }
{\f2\uldb trigform}{\v\f2 TRIGFORM} 
{\f2  switch 
\par 
\tab }
{\f2\uldb varopt}{\v\f2 VAROPT} 
{\f2  switch 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SORT}

${\footnote \pard\plain \sl240 \fs20 $ SORT}

+{\footnote \pard\plain \sl240 \fs20 + g8:0817}

 K{\footnote \pard\plain \sl240 \fs20 K sorting;SORT operator;operator}

}{\b\f2 SORT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 sort} {\f2  operator sorts the elements of a list according to 
an arbitrary comparison operator. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 sort} {\f4 (<lst>,<comp>) 
\par 
\par 
}{\f2 \par 
<lst> is a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  of algebraic expressions. 
<comp> is a comparison operator which defines a partial 
ordering among the members of <lst>. <comp> may be 
one of the builtin comparison operators like 
}{\f3 <} {\f2 (}
{\f2\uldb lessp}{\v\f2 LESSP} 
{\f2 ), }{\f3 <=} {\f2 (}
{\f2\uldb leq}{\v\f2 LEQ} 
{\f2 ) 
etc., or <comp> may be the name of a comparison procedure. 
Such a procedure has two arguments, and it returns 
}
{\f2\uldb true}{\v\f2 TRUE} 
{\f2  if the first argument 
ranges before the second one, and 0 or }
{\f2\uldb nil}{\v\f2 NIL} 
{\f2  otherwise. 
The result of }{\f3 sort} {\f2  is a new list which contains the 
elements of <lst> in a sequence corresponding to <comp>. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 procedure ce(a,b); \par
 \par
   if evenp a and not evenp b then 1 else 0; \par
 \par
for i:=1:10 collect random(50)$ \par
 \par
sort(ws,>=);  \par
 \par
  \{41,38,33,30,28,25,20,17,8,5\} \par
 \par
 \par
sort(ws,<);  \par
 \par
  \{5,8,17,20,25,28,30,33,38,41\} \par
 \par
 \par
sort(ws,ce);  \par
 \par
  \{8,20,28,30,38,5,17,25,33,41\} \par
 \par
 \par
  procedure cd(a,b); \par
 \par
  if deg(a,x)>deg(b,x) then 1 else \par
 \par
  if deg(a,x)<deg(b,x) then 0 else \par
 \par
  if deg(a,y)>deg(b,y) then 1 else 0; \par
 \par
sort(\{x^2,y^2,x*y\},cd); \par
 \par
    2      2 \par
  \{x ,x*y,y \} \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # STRUCTR}

${\footnote \pard\plain \sl240 \fs20 $ STRUCTR}

+{\footnote \pard\plain \sl240 \fs20 + g8:0818}

 K{\footnote \pard\plain \sl240 \fs20 K decomposition;STRUCTR operator;operator}

}{\b\f2 STRUCTR}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 structr} {\f2  operator breaks its argument expression into named 
subexpressions. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 structr} {\f4 (<expression> [,<identifier>[,<identifier> ...]]) 
\par 
\par 
}{\f2 \par 
<expression> may be any valid REDUCE scalar expression. 
<identifier> may be any valid REDUCE }{\f3 identifier} {\f2 . The first 
identifier 
is the stem for subexpression names, the second is the name to be assigned 
to the structured expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
structr(sqrt(x**2 + 2*x) + sin(x**2*z));  \par
 \par
 \par
  ANS1 + ANS2 \par
      where \par
                       2 \par
          ANS2 := SIN(X *Z) \par
                             1/2 \par
          ANS1 := ((X + 2)*X) \par
 \par
 \par
ans3;  \par
 \par
  ANS3  \par
 \par
 \par
on fort;  \par
 \par
structr((x+1)**5 + tan(x*y*z),var,aa);  \par
 \par
 \par
  VAR1=TAN(X*Y*Z) \par
  AA=VAR1+X**5+5.*X**4+10.*X**3+10.X**2+5.*X+1 \par
 \par
\pard \sl240 }{\f2 The second argument to }{\f3 structr} {\f2  is optional. If it is not given, the 
default stem }{\f3 ANS} {\f2  is used by REDUCE to construct names for the 
subexpression. The names are only for display purposes: REDUCE does not 
store the names and their values unless the switch }
{\f2\uldb savestructr}{\v\f2 SAVESTRUCTR} 
{\f2  is 
on. 
\par 
\par 
If a third argument is given, the structured expression as a whole is named by 
this argument, when }
{\f2\uldb fort}{\v\f2 FORT} 
{\f2  is on. The expression is not stored 
under this 
name. You can send these structured Fortran expressions to a file with the 
}{\f3 out} {\f2  command. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SUB}

${\footnote \pard\plain \sl240 \fs20 $ SUB}

+{\footnote \pard\plain \sl240 \fs20 + g8:0819}

 K{\footnote \pard\plain \sl240 \fs20 K substitution;SUB operator;operator}

}{\b\f2 SUB}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 sub} {\f2  operator substitutes a new expression for a kernel in an 
expression. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 sub} {\f4 (<kernel>}{\f3 =} {\f4 <expression> 
	 \{,<kernel>}{\f3 =} {\f4 <expression>\}*, 
	 <expression>) or 
\par 
\par 
}{\f3 sub} {\f4 (\{<kernel>}{\f3 =} {\f4 <expression>*, 
	 <kernel>}{\f3 =} {\f3 expression} {\f4 \},<expression>) 
\par 
\par 
}{\f2 \par 
<kernel> must be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 , <expression> can be any REDUCE 
scalar expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
sub(x=3,y=4,(x+y)**3);  \par
 \par
  343  \par
 \par
 \par
x;  \par
 \par
  X  \par
 \par
 \par
sub(\{cos=sin,sin=cos\},cos a+sin b)  \par
 \par
 \par
  COS(B) + SIN(A) \par
 \par
\pard \sl240 }{\f2 Note in the second example that operators can be replaced using the 
}{\f3 sub} {\f2  operator. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SUM}

${\footnote \pard\plain \sl240 \fs20 $ SUM}

+{\footnote \pard\plain \sl240 \fs20 + g8:0820}

 K{\footnote \pard\plain \sl240 \fs20 K summation;Gosper algorithm;SUM operator;operator}

}{\b\f2 SUM}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 sum} {\f2  returns 
the indefinite or definite summation of a given expression. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 sum} {\f4 (<expr>,<k>[,<lolim> [,<uplim> ]]) 
\par 
\par 
\par 
\par 
}{\f2 where <expr> is the expression to be added, <k> is the 
control variable (a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 ), and <lolim> and <uplim> 
are the optional lower and upper limits. If <uplim> is 
not supplied the upper limit is taken as <k>. The Gosper 
algorithm is used. If there is no closed form solution, the operator 
returns the input unchanged. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
sum(4n**3,n);  \par
 \par
   2    2 \par
  n  *(n   + 2*n + 1) \par
 \par
 \par
sum(2a+2k*r,k,0,n-1); \par
 \par
  n*(2*a + n*r - r) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # WS}

${\footnote \pard\plain \sl240 \fs20 $ WS}

+{\footnote \pard\plain \sl240 \fs20 + g8:0821}

 K{\footnote \pard\plain \sl240 \fs20 K interactive;work space;WS operator;operator}

}{\b\f2 WS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 ws} {\f2  operator alone returns the last result; }{\f3 ws} {\f2  with a 
number argument returns the results of the REDUCE statement executed after 
that numbered prompt. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 ws} {\f4 or }{\f3 ws} {\f4 (<number>) 
\par 
\par 
}{\f2 \par 
<number> must be an integer between 1 and the current REDUCE prompt number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4 \pard \sl240 }{\f2 (In the following examples, unlike most others, the numbered 
prompt is shown.)}{\f4 \pard \tx3420   \par
 \par
1: df(sin y,y);  \par
 \par
  COS(Y)  \par
 \par
 \par
2: ws^2;  \par
 \par
        2 \par
  COS(Y)   \par
 \par
 \par
3: df(ws 1,y);  \par
 \par
  -SIN(Y) \par
 \par
\pard \sl240 }{\f2  
\par 
\par 
}{\f3 ws} {\f2 and }{\f3 ws} {\f3 (} {\f2 <number>}{\f3 )} {\f2  can be used anywhere the 
expression they stand for can be used. Calling a number for which no 
result was produced, such as a switch setting, will give an error message. 
\par 
\par 
The current workspace always contains the results of the last REDUCE 
command that produced an expression, even if several input statements 
that do not produce expressions have intervened. For example, if you do 
a differentiation, producing a result expression, then change several 
switches, the operator }{\f3 ws;} {\f2  returns the results of the differentiation. 
The current workspace (}{\f3 ws} {\f2 ) can also be used inside files, though the 
numbered workspace contains only the }{\f3 in} {\f2  command that input the file. 
\par 
\par 
There are three history lists kept in your REDUCE session. The first 
stores raw input, suitable for the statement editor. The second stores 
parsed input, ready to execute and accessible by }
{\f2\uldb input}{\v\f2 INPUT} 
{\f2 . The 
third stores results, when they are produced by statements, which are 
accessible by the }{\f3 ws} {\f2 < n> operator. If your session is very 
long, storage space begins to fill up with these expressions, so it is a 
good idea to end the session once in a while, saving needed expressions to 
files with the }
{\f2\uldb saveas}{\v\f2 SAVEAS} 
{\f2  and }
{\f2\uldb out}{\v\f2 OUT} 
{\f2  commands. 
\par 
\par 
An error message is given if a reference number has not yet been used. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g8}

${\footnote \pard\plain \sl240 \fs20 $ Algebraic Operators}

+{\footnote \pard\plain \sl240 \fs20 + index:0008}
}{\b\f2 Algebraic Operators}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb APPEND operator}
{\v\f2 APPEND}{\f2 \par 
}{\f2 \tab}{\f2\uldb ARBINT operator}
{\v\f2 ARBINT}{\f2 \par 
}{\f2 \tab}{\f2\uldb ARBCOMPLEX operator}
{\v\f2 ARBCOMPLEX}{\f2 \par 
}{\f2 \tab}{\f2\uldb ARGLENGTH operator}
{\v\f2 ARGLENGTH}{\f2 \par 
}{\f2 \tab}{\f2\uldb COEFF operator}
{\v\f2 COEFF}{\f2 \par 
}{\f2 \tab}{\f2\uldb COEFFN operator}
{\v\f2 COEFFN}{\f2 \par 
}{\f2 \tab}{\f2\uldb CONJ operator}
{\v\f2 CONJ}{\f2 \par 
}{\f2 \tab}{\f2\uldb CONTINUED_FRACTION operator}
{\v\f2 CONTINUED_FRACTION}{\f2 \par 
}{\f2 \tab}{\f2\uldb DECOMPOSE operator}
{\v\f2 DECOMPOSE}{\f2 \par 
}{\f2 \tab}{\f2\uldb DEG operator}
{\v\f2 DEG}{\f2 \par 
}{\f2 \tab}{\f2\uldb DEN operator}
{\v\f2 DEN}{\f2 \par 
}{\f2 \tab}{\f2\uldb DF operator}
{\v\f2 DF}{\f2 \par 
}{\f2 \tab}{\f2\uldb EXPAND\_CASES operator}
{\v\f2 EXPAND\_CASES}{\f2 \par 
}{\f2 \tab}{\f2\uldb EXPREAD operator}
{\v\f2 EXPREAD}{\f2 \par 
}{\f2 \tab}{\f2\uldb FACTORIZE operator}
{\v\f2 FACTORIZE}{\f2 \par 
}{\f2 \tab}{\f2\uldb HYPOT operator}
{\v\f2 HYPOT}{\f2 \par 
}{\f2 \tab}{\f2\uldb IMPART operator}
{\v\f2 IMPART}{\f2 \par 
}{\f2 \tab}{\f2\uldb INT operator}
{\v\f2 INT}{\f2 \par 
}{\f2 \tab}{\f2\uldb INTERPOL operator}
{\v\f2 INTERPOL}{\f2 \par 
}{\f2 \tab}{\f2\uldb LCOF operator}
{\v\f2 LCOF}{\f2 \par 
}{\f2 \tab}{\f2\uldb LENGTH operator}
{\v\f2 LENGTH}{\f2 \par 
}{\f2 \tab}{\f2\uldb LHS operator}
{\v\f2 LHS}{\f2 \par 
}{\f2 \tab}{\f2\uldb LIMIT operator}
{\v\f2 LIMIT}{\f2 \par 
}{\f2 \tab}{\f2\uldb LPOWER operator}
{\v\f2 LPOWER}{\f2 \par 
}{\f2 \tab}{\f2\uldb LTERM operator}
{\v\f2 LTERM}{\f2 \par 
}{\f2 \tab}{\f2\uldb MAINVAR operator}
{\v\f2 MAINVAR}{\f2 \par 
}{\f2 \tab}{\f2\uldb MAP operator}
{\v\f2 MAP}{\f2 \par 
}{\f2 \tab}{\f2\uldb MKID command}
{\v\f2 MKID}{\f2 \par 
}{\f2 \tab}{\f2\uldb NPRIMITIVE operator}
{\v\f2 NPRIMITIVE}{\f2 \par 
}{\f2 \tab}{\f2\uldb NUM operator}
{\v\f2 NUM}{\f2 \par 
}{\f2 \tab}{\f2\uldb ODESOLVE operator}
{\v\f2 ODESOLVE}{\f2 \par 
}{\f2 \tab}{\f2\uldb ONE\_OF type}
{\v\f2 ONE\_OF}{\f2 \par 
}{\f2 \tab}{\f2\uldb PART operator}
{\v\f2 PART}{\f2 \par 
}{\f2 \tab}{\f2\uldb PF operator}
{\v\f2 PF}{\f2 \par 
}{\f2 \tab}{\f2\uldb PROD operator}
{\v\f2 PROD}{\f2 \par 
}{\f2 \tab}{\f2\uldb REDUCT operator}
{\v\f2 REDUCT}{\f2 \par 
}{\f2 \tab}{\f2\uldb REPART operator}
{\v\f2 REPART}{\f2 \par 
}{\f2 \tab}{\f2\uldb RESULTANT operator}
{\v\f2 RESULTANT}{\f2 \par 
}{\f2 \tab}{\f2\uldb RHS operator}
{\v\f2 RHS}{\f2 \par 
}{\f2 \tab}{\f2\uldb ROOT\_OF operator}
{\v\f2 ROOT\_OF}{\f2 \par 
}{\f2 \tab}{\f2\uldb SELECT operator}
{\v\f2 SELECT}{\f2 \par 
}{\f2 \tab}{\f2\uldb SHOWRULES operator}
{\v\f2 SHOWRULES}{\f2 \par 
}{\f2 \tab}{\f2\uldb SOLVE operator}
{\v\f2 SOLVE}{\f2 \par 
}{\f2 \tab}{\f2\uldb SORT operator}
{\v\f2 SORT}{\f2 \par 
}{\f2 \tab}{\f2\uldb STRUCTR operator}
{\v\f2 STRUCTR}{\f2 \par 
}{\f2 \tab}{\f2\uldb SUB operator}
{\v\f2 SUB}{\f2 \par 
}{\f2 \tab}{\f2\uldb SUM operator}
{\v\f2 SUM}{\f2 \par 
}{\f2 \tab}{\f2\uldb WS operator}
{\v\f2 WS}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ALGEBRAIC}

${\footnote \pard\plain \sl240 \fs20 $ ALGEBRAIC}

+{\footnote \pard\plain \sl240 \fs20 + g9:0822}

 K{\footnote \pard\plain \sl240 \fs20 K evaluation;ALGEBRAIC command;command}

}{\b\f2 ALGEBRAIC}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 algebraic} {\f2  command changes REDUCE's mode of operation to 
algebraic. When }{\f3 algebraic} {\f2  is used as an operator (with an 
argument inside parentheses) that argument is evaluated in algebraic 
mode, but REDUCE's mode is not changed. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
algebraic;  \par
 \par
symbolic;  \par
 \par
  NIL  \par
 \par
 \par
algebraic(x**2);  \par
 \par
   2 \par
  X   \par
 \par
 \par
x**2;  \par
 \par
    ***** The symbol X has no value. \par
 \par
\pard \sl240 }{\f2 REDUCE's symbolic mode does not know about most algebraic commands. 
Error messages in this mode may also depend on the particular Lisp 
used for the REDUCE implementation. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ANTISYMMETRIC}

${\footnote \pard\plain \sl240 \fs20 $ ANTISYMMETRIC}

+{\footnote \pard\plain \sl240 \fs20 + g9:0823}

 K{\footnote \pard\plain \sl240 \fs20 K ANTISYMMETRIC declaration;declaration}

}{\b\f2 ANTISYMMETRIC}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
When an operator is declared }{\f3 antisymmetric} {\f2 , its arguments are 
reordered to conform to the internal ordering of the system. If an odd 
number of argument interchanges are required to do this ordering, 
the sign of the expression is changed. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 antisymmetric} {\f4 <identifier>\{}{\f3 ,} {\f4 <identifier>\}* 
\par 
\par 
}{\f2 \par 
<identifier> is an identifier that has been declared as an operator. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
operator m,n;  \par
 \par
antisymmetric m,n;  \par
 \par
m(x,n(1,2));  \par
 \par
  - M( - N(2,1),X)  \par
 \par
 \par
operator p;  \par
 \par
antisymmetric p;  \par
 \par
p(a,b,c);  \par
 \par
  P(A,B,C)  \par
 \par
 \par
p(b,a,c);  \par
 \par
  - P(A,B,C) \par
 \par
\pard \sl240 }{\f2 If <identifier> has not been declared an operator, the flag 
}{\f3 antisymmetric} {\f2  is still attached to it. When <identifier> is 
subsequently used as an operator, the message }{\f3 Declare} {\f2  <identifier> 
 }{\f3 operator? (Y or N)} {\f2  is printed. If the user replies }{\f3 y} {\f2 , the 
antisymmetric property of the operator is used. 
\par 
\par 
Note in the first example, identifiers are customarily ordered 
alphabetically, while numbers are ordered from largest to smallest. 
The operators may have any desired number of arguments (less than 128). 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ARRAY}

${\footnote \pard\plain \sl240 \fs20 $ ARRAY}

+{\footnote \pard\plain \sl240 \fs20 + g9:0824}

 K{\footnote \pard\plain \sl240 \fs20 K ARRAY declaration;declaration}

}{\b\f2 ARRAY}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
The }{\f3 array} {\f2  declaration declares a list of identifiers to be of type 
}{\f3 array} {\f2 , and sets all their entries to 0. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 array} {\f4 <identifier>(<dimensions>) 
 \{}{\f3 ,} {\f4 <identifier>(<dimensions>)\}* 
\par 
\par 
}{\f2 \par 
<identifier> may be any valid REDUCE identifier. If the identifier 
was already an array, a warning message is given that the array has been 
redefined. <dimensions> are of form 
 <integer>\{,<integer>\}*. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
array a(2,5),b(3,3,3),c(200);  \par
 \par
array a(3,5);  \par
 \par
  *** ARRAY A REDEFINED  \par
 \par
 \par
a(3,4);  \par
 \par
  0  \par
 \par
 \par
length a;  \par
 \par
  \{4,6\} \par
 \par
\pard \sl240 }{\f2 Arrays are always global, even if defined inside a procedure or block 
statement. Their status as an array remains until the variable is 
reset by }
{\f2\uldb clear}{\v\f2 CLEAR} 
{\f2 . Arrays may not have the same names as operators, 
procedures or scalar variables. 
\par 
\par 
Array elements are referred to by the usual notation: }{\f3 a(i,j)} {\f2  
returns the jth element of the ith row. The }
{\f2\uldb assign}{\v\f2 assign} 
{\f2 ment operator 
}{\f3 :=} {\f2  is used to put values into the array. Arrays as a whole 
cannot be subject to assignment by }
{\f2\uldb let}{\v\f2 LET} 
{\f2  or }{\f3 :=} {\f2  ; the 
assignment operator }{\f3 :=} {\f2  is only valid for individual elements. 
\par 
\par 
When you use }
{\f2\uldb let}{\v\f2 LET} 
{\f2  on an array element, the contents of that 
element become the argument to }{\f3 let} {\f2 . Thus, if the element 
contains a number or some other expression that is not a valid argument 
for this command, you get an error message. If the element contains an 
identifier, the identifier has the substitution rule attached to it 
globally. The same behavior occurs with }
{\f2\uldb clear}{\v\f2 CLEAR} 
{\f2 . If the array 
element contains an identifier or simple_expression, it is cleared. Do 
<not> use }{\f3 clear} {\f2  to try to set an array element to 0. Because 
of the side effects of either }{\f3 let} {\f2  or }{\f3 clear} {\f2 , it is unwise 
to apply either of these to array elements. 
\par 
\par 
Array indices always start with 0, so that the declaration }{\f3 array a(5)} {\f2  
sets aside 6 units of space, indexed from 0 through 5, and initializes 
them to 0. The }
{\f2\uldb length}{\v\f2 LENGTH} 
{\f2  command returns a list of the true number of 
elements in each dimension. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CLEAR}

${\footnote \pard\plain \sl240 \fs20 $ CLEAR}

+{\footnote \pard\plain \sl240 \fs20 + g9:0825}

 K{\footnote \pard\plain \sl240 \fs20 K CLEAR command;command}

}{\b\f2 CLEAR}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 clear} {\f2  command is used to remove assignments or remove substitution 
rules from any expression. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 clear} {\f4 <identifier>\{,<identifier>\}+ or 
\par 
\par 
<let-type statement> }{\f3 clear} {\f4  <identifier> 
\par 
\par 
}{\f2 \par 
<identifier> can be any }{\f3 scalar} {\f2 , }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 , 
or }
{\f2\uldb array}{\v\f2 ARRAY} 
{\f2  variable or 
}
{\f2\uldb procedure}{\v\f2 PROCEDURE} 
{\f2  name. <let-type statement> can be any general 
or specific }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statement (see below in Comments). 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
array a(2,3);  \par
 \par
a(2,2) := 15;  \par
 \par
  A(2,2) := 15  \par
 \par
 \par
clear a;  \par
 \par
a(2,2);  \par
 \par
  Declare A operator? (Y or N)  \par
 \par
 \par
let x = y + z;  \par
 \par
sin(x);  \par
 \par
  SIN(Y + Z)  \par
 \par
 \par
clear x;  \par
 \par
sin(x);  \par
 \par
  SIN(X)  \par
 \par
 \par
let x**5 = 7;  \par
 \par
clear x;  \par
 \par
x**5;  \par
 \par
  7  \par
 \par
 \par
clear x**5;  \par
 \par
x**5;  \par
 \par
   5 \par
  X \par
 \par
\pard \sl240 }{\f2 Although it is not a good idea, operators of the same name but taking 
different numbers of arguments can be defined. Using a }{\f3 clear} {\f2  statement 
on any of these operators clears every one with the same name, even if the 
number of arguments is different. 
\par 
\par 
The }{\f3 clear} {\f2  command is used to ``forget" matrices, arrays, operators 
and scalar variables, returning their identifiers to the pristine state 
to be used for other purposes. When }{\f3 clear} {\f2  is applied to array 
elements, the contents of the array element becomes the argument for 
}{\f3 clear} {\f2 . Thus, you get an error message if the element contains a 
number, or some other expression that is not a legal argument to 
}{\f3 clear} {\f2 . If the element contains an identifier, it is cleared. 
When clear is applied to matrix elements, an error message is returned 
if the element evaluates to a number, otherwise there is no effect. Do 
 not try to use }{\f3 clear} {\f2  to set array or matrix elements to 0. 
You will not be pleased with the results. 
\par 
\par 
If you are trying to clear power or product substitution rules made with 
either }
{\f2\uldb let}{\v\f2 LET} 
{\f2  or }
{\f2\uldb forall}{\v\f2 FORALL} 
{\f2 ...}{\f3 let} {\f2 , you must 
reproduce the rule, exactly as you typed it with the same arguments, up to 
but not including the equal sign, using the word }{\f3 clear} {\f2  instead of 
the word }{\f3 let} {\f2 . This is shown in the last example. Any other type of 
}{\f3 let} {\f2  or }{\f3 forall} {\f2 ...}{\f3 let} {\f2  substitution can be cleared 
with just the variable or operator name. }
{\f2\uldb match}{\v\f2 MATCH} 
{\f2  behaves the same as 
}
{\f2\uldb let}{\v\f2 LET} 
{\f2  in this situation. There is a more complicated example under 
}
{\f2\uldb forall}{\v\f2 FORALL} 
{\f2 . 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CLEARRULES}

${\footnote \pard\plain \sl240 \fs20 $ CLEARRULES}

+{\footnote \pard\plain \sl240 \fs20 + g9:0826}

 K{\footnote \pard\plain \sl240 \fs20 K rule;CLEARRULES command;command}

}{\b\f2 CLEARRULES}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 clearrules} {\f4 <list>\{,<list>\}+ 
\par 
\par 
}{\f2 \par 
The operator }{\f3 clearrules} {\f2  is used to remove previously defined 
}
{\f2\uldb rule}{\v\f2 RULE} 
{\f2  lists from the system. <list> can be an explicit rule 
list, or evaluate to a rule list. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
trig1 := \{cos(~x)*cos(~y) => (cos(x+y)+cos(x-y))/2, \par
          cos(~x)*sin(~y) => (sin(x+y)-sin(x-y))/2, \par
          sin(~x)*sin(~y) => (cos(x-y)-cos(x+y))/2, \par
          cos(~x)^2       => (1+cos(2*x))/2, \par
          sin(~x)^2       => (1-cos(2*x))/2\}$  \par
 \par
let trig1; \par
cos(a)*cos(b);  \par
 \par
  COS(A - B) + COS(A + B) \par
  -----------------------  \par
             2 \par
 \par
 \par
clearrules trig1; \par
cos(a)*cos(b);  \par
 \par
  COS(A)*COS(B) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # DEFINE}

${\footnote \pard\plain \sl240 \fs20 $ DEFINE}

+{\footnote \pard\plain \sl240 \fs20 + g9:0827}

 K{\footnote \pard\plain \sl240 \fs20 K DEFINE command;command}

}{\b\f2 DEFINE}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The command }{\f3 define} {\f2  allows you to supply a new name for an identifier 
or replace it by any valid REDUCE expression. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 define} {\f4 <identifier>}{\f3 =} {\f4 <substitution> 
 \{}{\f3 ,} {\f4 <identifier>}{\f3 =} {\f4 <substitution>\}* 
\par 
\par 
}{\f2 \par 
<identifier> is any valid REDUCE identifier, <substitution> can be a 
number, an identifier, an operator, a reserved word, or an expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
define is= :=, xx=y+z;  \par
 \par
 \par
a is 10;  \par
 \par
  A := 10  \par
 \par
 \par
 \par
xx**2;  \par
 \par
   2             2 \par
  Y   + 2*Y*Z + Z   \par
 \par
 \par
 \par
xx := 10;  \par
 \par
  Y + Z := 10 \par
 \par
\pard \sl240 }{\f2 The renaming is done at the input level, and therefore takes precedence 
over any other replacement or substitution declared for the same identifier. 
It remains in effect until the end of the REDUCE session. Be careful with 
it, since you cannot easily undo it without ending the session. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DEPEND}

${\footnote \pard\plain \sl240 \fs20 $ DEPEND}

+{\footnote \pard\plain \sl240 \fs20 + g9:0828}

 K{\footnote \pard\plain \sl240 \fs20 K dependency;DEPEND declaration;declaration}

}{\b\f2 DEPEND}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
}{\f3 depend} {\f2 declares that its first argument depends on the rest of its 
arguments. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 depend} {\f4 <kernel>\{}{\f3 ,} {\f4 <kernel>\}+ 
\par 
\par 
}{\f2 \par 
<kernel> must be a legal variable name or a prefix operator (see 
}
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 ). 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
depend y,x;  \par
 \par
 \par
df(y**2,x);  \par
 \par
  2*DF(Y,X)*Y  \par
 \par
 \par
 \par
depend z,cos(x),y;  \par
 \par
 \par
df(sin(z),cos(x));  \par
 \par
  COS(Z)*DF(Z,COS(X))  \par
 \par
 \par
 \par
df(z**2,x);  \par
 \par
  2*DF(Z,X)*Z  \par
 \par
 \par
 \par
nodepend z,y;  \par
 \par
 \par
df(z**2,x);  \par
 \par
  2*DF(Z,X)*Z  \par
 \par
 \par
 \par
cc := df(y**2,x);  \par
 \par
  CC := 2*DF(Y,X)*Y  \par
 \par
 \par
 \par
y := tan x;  \par
 \par
  Y := TAN(X);  \par
 \par
 \par
 \par
cc;  \par
 \par
                  2 \par
  2*TAN(X)*(TAN(X)   + 1) \par
 \par
\pard \sl240 }{\f2 Dependencies can be removed by using the declaration }
{\f2\uldb nodepend}{\v\f2 NODEPEND} 
{\f2 . 
The differentiation operator uses this information, as shown in the 
examples above. Linear operators also use knowledge of dependencies 
(see }
{\f2\uldb linear}{\v\f2 LINEAR} 
{\f2 ). Note that dependencies can be nested: Having 
declared y to depend on x, and z 
to depend on y, we 
see that the chain rule was applied to the derivative of a function of 
z with respect to x. If the explicit function of the 
dependency is later entered into the system, terms with }{\f3 DF(Y,X)} {\f2 , 
for example, are expanded when they are displayed again, as shown in the 
last example. The boolean operator }
{\f2\uldb freeof}{\v\f2 FREEOF} 
{\f2  allows you to 
check the dependency between two algebraic objects. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EVEN}

${\footnote \pard\plain \sl240 \fs20 $ EVEN}

+{\footnote \pard\plain \sl240 \fs20 + g9:0829}

 K{\footnote \pard\plain \sl240 \fs20 K EVEN declaration;declaration}

}{\b\f2 EVEN}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 even} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
This declaration is used to declare an operator even in its first 
argument. Expressions involving an operator declared in this manner are 
transformed if the first argument contains a minus sign. Any other 
arguments are not affected. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
        even f;  \par
 \par
        f(-a)  \par
 \par
  F(A)  \par
 \par
 \par
        f(-a,-b)  \par
 \par
  F(A,-B) \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FACTOR_declaration}

${\footnote \pard\plain \sl240 \fs20 $ FACTOR_declaration}

+{\footnote \pard\plain \sl240 \fs20 + g9:0830}

 K{\footnote \pard\plain \sl240 \fs20 K output;FACTOR declaration;declaration}

}{\b\f2 FACTOR}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
When a kernel is declared by }{\f3 factor} {\f2 , all terms involving fixed 
powers of that kernel are printed as a product of the fixed powers and 
the rest of the terms. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 factor} {\f4 <kernel> \{}{\f3 ,} {\f4 <kernel>\}* 
\par 
\par 
}{\f2 \par 
<kernel> must be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2  or a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  of 
}{\f3 kernel} {\f2 s. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := (x + y + z)**2;  \par
 \par
        2                    2            2 \par
  A := X  + 2*X*Y + 2*X*Z + Y  + 2*Y*Z + Z   \par
 \par
 \par
factor y;  \par
 \par
a;  \par
 \par
   2                  2            2 \par
  Y  + 2*Y*(X + Z) + X  + 2*X*Z + Z   \par
 \par
 \par
factor sin(x);  \par
 \par
c := df(sin(x)**4*x**2*z,x);  \par
 \par
               4               3         2 \par
  C := 2*SIN(X) *X*Z + 4*SIN(X) *COS(X)*X *Z  \par
 \par
 \par
remfac sin(x);  \par
 \par
c;  \par
 \par
          3 \par
  2*SIN(X) *X*Z*(2*COS(X)*X + SIN(X)) \par
 \par
\pard \sl240 }{\f2 Use the }{\f3 factor} {\f2  declaration to display variables of interest so that 
you can see their powers more clearly, as shown in the example. Remove 
this special treatment with the declaration }
{\f2\uldb remfac}{\v\f2 REMFAC} 
{\f2 . The 
}{\f3 factor} {\f2  declaration is only effective when the switch }
{\f2\uldb pri}{\v\f2 PRI} 
{\f2  
is on. 
\par 
\par 
The }{\f3 factor} {\f2  declaration is not a factoring command; to factor 
expressions use the }
{\f2\uldb factor}{\v\f2 FACTOR} 
{\f2  switch or the }
{\f2\uldb factorize}{\v\f2 FACTORIZE} 
{\f2  command. 
\par 
\par 
The }{\f3 factor} {\f2  declaration is helpful in such cases as Taylor polynomials 
where the explicit powers of the variable are expected at the top level, not 
buried in various factored forms. 
\par 
\par 
Note that }{\f3 factor} {\f2  does not affect the order of its arguments. You 
should also use }
{\f2\uldb order}{\v\f2 ORDER} 
{\f2  if this is important. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FORALL}

${\footnote \pard\plain \sl240 \fs20 $ FORALL}

+{\footnote \pard\plain \sl240 \fs20 + g9:0831}

 K{\footnote \pard\plain \sl240 \fs20 K substitution;FORALL command;command}

}{\b\f2 FORALL}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 forall} {\f2  or (preferably) }{\f3 for all} {\f2  command is used as a 
modifier for }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statements, indicating the universal applicability 
of the rule, with possible qualifications. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 for all} {\f4 <identifier>\{,<identifier>\}* }{\f3 let} {\f4  
<let statement> 
\par 
\par 
or 
\par 
\par 
}{\f3 for all} {\f4 <identifier>\{,<identifier>\}* 
 }{\f3 such that} {\f4  <condition> }{\f3 let} {\f4  <let statement> 
\par 
\par 
}{\f2 \par 
<identifier> may be any valid REDUCE identifier, <let statement> 
can be an operator, a product or power, or a group or block statement. 
<condition> must be a logical or comparison operator returning true or 
false. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
for all x let f(x) = sin(x**2); \par
  \par
 \par
  Declare F operator ? (Y or N)  \par
 \par
 \par
y  \par
 \par
f(a);  \par
 \par
       2 \par
  SIN(A )  \par
 \par
 \par
operator pos;  \par
 \par
for all x such that x>=0 let pos(x) = sqrt(x + 1);  \par
 \par
pos(5);  \par
 \par
  SQRT(6)  \par
 \par
 \par
pos(-5);  \par
 \par
  POS(-5)  \par
 \par
 \par
clear pos;  \par
 \par
pos(5);  \par
 \par
  Declare POS operator ? (Y or N)  \par
 \par
 \par
for all a such that numberp a let x**a = 1;  \par
 \par
x**4;  \par
 \par
  1  \par
 \par
 \par
clear x**a;  \par
 \par
  *** X**A not found  \par
 \par
 \par
for all a  clear x**a;  \par
 \par
x**4;  \par
 \par
  1  \par
 \par
 \par
for all a such that numberp a clear x**a;  \par
 \par
x**4;  \par
 \par
   4 \par
  X \par
 \par
\pard \sl240 }{\f2 Substitution rules defined by }{\f3 for all} {\f2  or }{\f3 for
all} {\f2 ...}{\f3 such that} {\f2  commands that involve products or powers are 
cleared by reproducing the command, with exactly the same variable names 
used, up to but not including the equal sign, with }
{\f2\uldb clear}{\v\f2 CLEAR} 
{\f2  
replacing }{\f3 let} {\f2 , as shown in the last example. Other substitutions 
involving variables or operator names can be cleared with just the name, 
like any other variable. 
\par 
\par 
The }
{\f2\uldb match}{\v\f2 MATCH} 
{\f2  command can also be used in product and power substitutions. 
The syntax of its use and clearing is exactly like }{\f3 let} {\f2 . A }{\f3 match} {\f2  
substitution only replaces the term if it is exactly like the pattern, for 
example }{\f3 match x**5 = 1} {\f2  replaces only terms of }{\f3 x**5} {\f2  and not 
terms of higher powers. 
\par 
\par 
It is easier to declare your potential operator before defining the 
}{\f3 for all} {\f2  rule, since the system will ask you to declare it an 
operator anyway. Names of declared arrays or matrices or scalar 
variables are invalid as operator names, to avoid ambiguity. Either 
}{\f3 for all} {\f2 ...}{\f3 let} {\f2  statements or procedures are often used to define 
operators. One difference is that procedures implement ``call by value" 
meaning that assignments involving their formal parameters do not change 
the calling variables that replace them. If you use assignment statements 
on the formal parameters in a }{\f3 for all} {\f2 ...}{\f3 let} {\f2  statement, the 
effects are seen in the calling variables. Be careful not to redefine a 
system operator unless you mean it: the statement }{\f3 for all x let
sin(x)=0;} {\f2  has exactly that effect, and the usual definition for sin(x) has 
been lost for the remainder of the REDUCE session. \par 
\par 

\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # INFIX}

${\footnote \pard\plain \sl240 \fs20 $ INFIX}

+{\footnote \pard\plain \sl240 \fs20 + g9:0832}

 K{\footnote \pard\plain \sl240 \fs20 K operator;INFIX declaration;declaration}

}{\b\f2 INFIX}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
}{\f3 infix} {\f2 declares identifiers to be infix operators. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 infix} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
<identifier> can be any valid REDUCE identifier, which has not already 
been declared an operator, array or matrix, and is not reserved by the 
system. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
infix aa;  \par
 \par
for all x,y let aa(x,y) = cos(x)*cos(y) - sin(x)*sin(y);  \par
 \par
x aa y;  \par
 \par
  COS(X)*COS(Y) - SIN(X)*SIN(Y)  \par
 \par
 \par
pi/3 aa pi/2;  \par
 \par
    SQRT(3) \par
  - -------  \par
       2 \par
 \par
 \par
aa(pi,pi);  \par
 \par
  1 \par
 \par
\pard \sl240 }{\f2 A }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statement must be used to attach functionality to 
the operator. Note that the operator is defined in prefix form in 
the }{\f3 let} {\f2  statement. 
After its definition, the operator may be used in either prefix or infix 
mode. The above operator aa finds the cosine of the sum 
of two angles by the formula 
\par 
\par 
cos(x+y) = cos(x)*cos(y) - sin(x)*sin(y). 
\par 
\par 
Precedence may be attached to infix operators with the 
}
{\f2\uldb precedence}{\v\f2 PRECEDENCE} 
{\f2  declaration. 
\par 
\par 
User-defined infix operators may be used in prefix form. If they are used 
in infix form, a space must be left on each side of the operator to avoid 
ambiguity. Infix operators are always binary. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # INTEGER}

${\footnote \pard\plain \sl240 \fs20 $ INTEGER}

+{\footnote \pard\plain \sl240 \fs20 + g9:0833}

 K{\footnote \pard\plain \sl240 \fs20 K INTEGER declaration;declaration}

}{\b\f2 INTEGER}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
The }{\f3 integer} {\f2  declaration must be made immediately after a 
}
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2  (or other variable declaration such as }
{\f2\uldb real}{\v\f2 REAL} 
{\f2  
and }
{\f2\uldb scalar}{\v\f2 SCALAR} 
{\f2 ) and declares local integer variables. They are 
initialized to 0. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 integer} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
<identifier> may be any valid REDUCE identifier, except 
}{\f3 t} {\f2  or }{\f3 nil} {\f2 . 
\par 
\par 
Integer variables remain local, and do not share values with variables of 
the same name outside the }
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2 ...}{\f3 end} {\f2  block. When the 
block is finished, the variables are removed. You may use the words 
}
{\f2\uldb real}{\v\f2 REAL} 
{\f2  or }
{\f2\uldb scalar}{\v\f2 SCALAR} 
{\f2  in the place of }{\f3 integer} {\f2 . 
}{\f3 integer} {\f2  does not indicate typechecking by the 
current REDUCE; it is only for your own information. Declaration 
statements must immediately follow the }{\f3 begin} {\f2 , without a semicolon 
between }{\f3 begin} {\f2  and the first variable declaration. 
\par 
\par 
Any variables used inside }{\f3 begin} {\f2 ...}{\f3 end} {\f2  blocks that were not 
declared }{\f3 scalar} {\f2 , }{\f3 real} {\f2  or }{\f3 integer} {\f2  are global, and any 
change made to them inside the block affects their global value. Any 
}
{\f2\uldb array}{\v\f2 ARRAY} 
{\f2  or }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  declared inside a block is always global. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # KORDER}

${\footnote \pard\plain \sl240 \fs20 $ KORDER}

+{\footnote \pard\plain \sl240 \fs20 + g9:0834}

 K{\footnote \pard\plain \sl240 \fs20 K order;variable order;kernel order;KORDER declaration;declaration}

}{\b\f2 KORDER}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 korder} {\f2  declaration changes the internal canonical ordering of 
kernels. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 korder} {\f4 <kernel>\{}{\f3 ,} {\f4 <kernel>\}* 
\par 
\par 
}{\f2 \par 
<kernel> must be a REDUCE }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2  or a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  of 
}{\f3 kernel} {\f2 s. 
\par 
\par 
The declaration }{\f3 korder} {\f2  changes the internal ordering, but not the print 
ordering, so the effects cannot be seen on output. However, in some 
calculations, the order of the variables can have significant effects on the 
time and space demands of a calculation. If you are doing a demanding 
calculation with several kernels, you can experiment with changing the 
canonical ordering to improve behavior. 
\par 
\par 
The first kernel in the argument list is given the highest priority, the 
second gets the next highest, and so on. Kernels not named in a 
}{\f3 korder} {\f2  ordering otherwise. A new }{\f3 korder} {\f2  declaration replaces 
the previous one. To return to canonical ordering, use the command 
}{\f3 korder nil} {\f2 . 
\par 
\par 
To change the print ordering, use the declaration }
{\f2\uldb order}{\v\f2 ORDER} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LET}

${\footnote \pard\plain \sl240 \fs20 $ LET}

+{\footnote \pard\plain \sl240 \fs20 + g9:0835}

 K{\footnote \pard\plain \sl240 \fs20 K rule;substitution;LET command;command}

}{\b\f2 LET}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 let} {\f2  command defines general or specific substitution rules. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 let} {\f4 <identifier> }{\f3 =} {\f4  <expression>\{,<identifier> 
}{\f3 =} {\f4  <expression>\}* 
\par 
\par 
}{\f2 \par 
<identifier> can be any valid REDUCE identifier except an array, and in 
some cases can be an expression; <expression> can be any valid REDUCE 
expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
let a = sin(x);  \par
 \par
b := a;  \par
 \par
  B := SIN X;  \par
 \par
 \par
let c = a;  \par
 \par
exp(a);  \par
 \par
   SIN(X) \par
  E        \par
 \par
 \par
a := x**2;  \par
 \par
        2 \par
  A := X   \par
 \par
 \par
exp(a);  \par
 \par
    2 \par
   X \par
  E    \par
 \par
 \par
exp(b);  \par
 \par
   SIN(X) \par
  E        \par
 \par
 \par
exp(c);  \par
 \par
    2 \par
   X \par
  E    \par
 \par
 \par
let m + n = p;  \par
 \par
(m + n)**5;  \par
 \par
   5 \par
  P   \par
 \par
 \par
operator h;  \par
 \par
let h(u,v) = u - v;  \par
 \par
h(u,v);  \par
 \par
  U - V  \par
 \par
 \par
h(x,y);  \par
 \par
  H(X,Y)  \par
 \par
 \par
array q(10);  \par
 \par
let q(1) = 15;  \par
 \par
  ***** Substitution for 0 not allowed \par
 \par
\pard \sl240 }{\f2 The }{\f3 let} {\f2  command is also used to activate a }{\f3 rule sets} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 let} {\f4 <list>\{,<list>\}+ 
\par 
\par 
}{\f2 \par 
<list> can be an explicit }
{\f2\uldb rule}{\v\f2 RULE} 
{\f2  }{\f3 list} {\f2 , or evaluate 
to a rule list. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
trig1 := \{cos(~x)*cos(~y) => (cos(x+y)+cos(x-y))/2, \par
          cos(~x)*sin(~y) => (sin(x+y)-sin(x-y))/2, \par
          sin(~x)*sin(~y) => (cos(x-y)-cos(x+y))/2, \par
          cos(~x)^2       => (1+cos(2*x))/2, \par
          sin(~x)^2       => (1-cos(2*x))/2\}$  \par
 \par
let trig1; \par
cos(a)*cos(b);  \par
 \par
  COS(A - B) + COS(A + B) \par
  ------------------------ \par
             2 \par
 \par
\pard \sl240 }{\f2 A }{\f3 let} {\f2  command returns no value, though the substitution rule is 
entered. Assignment rules made by }
{\f2\uldb assign}{\v\f2 assign} 
{\f2  and }{\f3 let} {\f2  
rules are at the 
same level, and cancel each other. There is a difference in their 
operation, however, as shown in the first example: a }{\f3 let} {\f2  assignment 
tracks the changes in what it is assigned to, while a }{\f3 :=} {\f2  assignment 
is fixed at the value it originally had. 
\par 
\par 
The use of expressions as left-hand sides of }{\f3 let} {\f2  statements is a 
little complicated. The rules of operation are: 
\par 
\par 
\tab (i) 
Expressions of the form A*B = C do not change A, B or C, but set A*B to C. 
\par 
\par 
\tab (ii) 
Expressions of the form A+B = C substitute C - B for A, but do not change 
B or C. 
\par 
\par 
\tab (iii) 
Expressions of the form A-B = C substitute B + C for A, but do not change 
B or C. 
\par 
\par 
\tab (iv) 
Expressions of the form A/B = C substitute B*C for A, but do not change B or 
C. 
\par 
\par 
\tab (v) 
Expressions of the form A**N = C substitute C for A**N in every expression of 
a power of A to N or greater. An asymptotic command such as A**N = 0 sets 
all terms involving A to powers greater than or equal to N to 0. Finite 
fields may be generated by requiring modular arithmetic (the }
{\f2\uldb modular}{\v\f2 MODULAR} 
{\f2  
switch) and defining the primitive polynomial via a }{\f3 let} {\f2  statement. 
\par 
\par 
\par 
}{\f3 let} {\f2 substitutions involving expressions are cleared by using 
the }
{\f2\uldb clear}{\v\f2 CLEAR} 
{\f2  command with exactly the same expression. 
\par 
\par 
Note when a simple }{\f3 let} {\f2  statement is used to assign functionality to an 
operator, it is valid only for the exact identifiers used. For the use of the 
}{\f3 let} {\f2  command to attach more general functionality to an operator, 
see }
{\f2\uldb forall}{\v\f2 FORALL} 
{\f2 . 
\par 
\par 
Arrays as a whole cannot be arguments to }{\f3 let} {\f2  statements, but 
matrices as a whole can be legal arguments, provided both arguments are 
matrices. However, it is important to note that the two matrices are then 
linked. Any change to an element of one matrix changes the corresponding 
value in the other. Unless you want this behavior, you should not use 
}{\f3 let} {\f2  for matrices. The assignment operator }
{\f2\uldb assign}{\v\f2 assign} 
{\f2  can be used 
for non-tracking assignments, avoiding the side effects. Matrices are 
redimensioned as needed in }{\f3 let} {\f2  statements. 
\par 
\par 
When array or matrix elements are used as the left-hand side of }{\f3 let} {\f2  
statements, the contents of that element is used as the argument. When the 
contents is a number or some other expression that is not a valid left-hand 
side for }{\f3 let} {\f2 , you get an error message. If the contents is an 
identifier or simple expression, the }{\f3 let} {\f2  rule is globally attached 
to that identifier, and is in effect not only inside the array or matrix, 
but everywhere. Because of such unwanted side effects, you should not 
use }{\f3 let} {\f2  with array or matrix elements. The assignment operator 
}{\f3 :=} {\f2  can be used to put values into array or matrix elements without 
the side effects. 
\par 
\par 
Local variables declared inside }{\f3 begin} {\f2 ...}{\f3 end} {\f2  blocks cannot 
be used as the left-hand side of }{\f3 let} {\f2  statements. However, 
}
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2 ...}{\f3 end} {\f2  blocks themselves can be used as the 
right-hand side of }{\f3 let} {\f2  statements. The construction: 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 for all} {\f4 <vars> 
 }{\f3 let} {\f4 <operator>(<vars>)}{\f3 =} {\f4 <block> 
\par 
\par 
}{\f2 \par 
is an alternative to the 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 procedure} {\f4 <name>(<vars>)}{\f3 ;} {\f4 <block> 
\par 
\par 
}{\f2 \par 
construction. One important difference between the two constructions is that 
the <vars> as formal parameters to a procedure have their global values 
protected against change by the procedure, while the <vars> of a 
}{\f3 let} {\f2  statement are changed globally by its actions. 
\par 
\par 
Be careful in using a construction such as }{\f3 let x = x + 1} {\f2  except inside 
a controlled loop statement. The process of resubstitution continues until 
a stack overflow message is given. 
\par 
\par 
The }{\f3 let} {\f2  statement may be used to make global changes to variables from 
inside procedures. If }{\f3 x} {\f2  is a formal parameter to a procedure, the 
command }{\f3 let x = } {\f2 ... makes the change to the calling variable. 
For example, if a procedure was defined by 
\pard \tx3420 }{\f4  \par
        procedure f(x,y); \par
        let x = 15; \par
\pard \sl240 }{\f2 \par 
\par 
and the procedure was called as 
\pard \tx3420 }{\f4  \par
        f(a,b); \par
\pard \sl240 }{\f2 \par 
\par 
}{\f3 a} {\f2 would have its value changed to 15. Be careful when using }{\f3 let} {\f2  
statements inside procedures to avoid unwanted side effects. 
\par 
\par 
It is also important to be careful when replacing }{\f3 let} {\f2  statements with 
other }{\f3 let} {\f2  statements. The overlapping of these substitutions can be 
unpredictable. Ordinarily the latest-entered rule is the first to be applied. 
Sometimes the previous rule is superseded completely; other times it stays 
around as a special case. The order of entering a set of related }{\f3 let} {\f2  
expressions is very important to their eventual behavior. The best 
approach is to assume that the rules will be applied in an arbitrary order. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LINEAR}

${\footnote \pard\plain \sl240 \fs20 $ LINEAR}

+{\footnote \pard\plain \sl240 \fs20 + g9:0836}

 K{\footnote \pard\plain \sl240 \fs20 K operator;LINEAR declaration;declaration}

}{\b\f2 LINEAR}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
An operator can be declared linear in its first argument over powers of 
its second argument by the declaration }{\f3 linear.} {\f2  
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 linear} {\f4 <operator>\{}{\f3 ,} {\f4 <operator>\}* 
\par 
\par 
}{\f2 \par 
<operator> must have been declared to be an operator. Be careful not 
to use a system operator name, because this command may change its definition. 
The operator being declared must have at least two arguments, and the 
second one must be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
operator f;  \par
 \par
linear f;  \par
 \par
f(0,x);  \par
 \par
  0  \par
 \par
 \par
f(-y,x);  \par
 \par
  - F(1,X)*Y  \par
 \par
 \par
f(y+z,x);  \par
 \par
  F(1,X)*(Y + Z)  \par
 \par
 \par
f(y*z,x);  \par
 \par
  F(1,X)*Y*Z  \par
 \par
 \par
depend z,x;  \par
 \par
f(y*z,x);  \par
 \par
  F(Z,X)*Y  \par
 \par
 \par
f(y/z,x);  \par
 \par
    1 \par
  F(-,X)*Y  \par
    Z \par
 \par
 \par
depend y,x;  \par
 \par
f(y/z,x);  \par
 \par
    Y \par
  F(-,X)  \par
    Z \par
 \par
 \par
nodepend z,x;  \par
 \par
f(y/z,x);  \par
 \par
  F(Y,X) \par
  ------  \par
    Z \par
 \par
 \par
f(2*e**sin(x),x);  \par
 \par
       SIN(X) \par
  2*F(E      ,X) \par
 \par
\pard \sl240 }{\f2 Even when the operator has not had its functionality attached, it exhibits 
linear properties as shown in the examples. Notice the difference when 
dependencies are added. Dependencies are also in effect when the operator's 
first argument contains its second, as in the last line above. 
\par 
\par 
For a fully-developed example of the use of linear operators, refer to the 
article in the <Journal of Computational Physics>, Vol. 14 (1974), pp. 
301-317, ``Analytic Computation of Some Integrals in Fourth Order Quantum 
Electrodynamics," by J.A. Fox and A.C. Hearn. The article includes the 
complete listing of REDUCE procedures used for this work. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LINELENGTH}

${\footnote \pard\plain \sl240 \fs20 $ LINELENGTH}

+{\footnote \pard\plain \sl240 \fs20 + g9:0837}

 K{\footnote \pard\plain \sl240 \fs20 K output;LINELENGTH declaration;declaration}

}{\b\f2 LINELENGTH}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 linelength} {\f2  declaration sets the length of the output line. Default 
is 80. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 linelength} {\f4 <expression> 
\par 
\par 
}{\f2 \par 
To change the linelength, 
<expression> must evaluate to a positive integer less than 128 
(although this varies from system to system), and should not be less than 
20 or so for proper operation. 
\par 
\par 
}{\f3 linelength} {\f2 returns the previous linelength. If you want the current 
linelength value, but not change it, say }{\f3 linelength nil} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LISP}

${\footnote \pard\plain \sl240 \fs20 $ LISP}

+{\footnote \pard\plain \sl240 \fs20 + g9:0838}

 K{\footnote \pard\plain \sl240 \fs20 K LISP command;command}

}{\b\f2 LISP}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 lisp} {\f2  command changes REDUCE's mode of operation to symbolic. When 
}{\f3 lisp} {\f2  is followed by an expression, that expression is evaluated in 
symbolic mode, but REDUCE's mode is not changed. This command is 
equivalent to }
{\f2\uldb symbolic}{\v\f2 SYMBOLIC} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
lisp;  \par
 \par
  NIL  \par
 \par
 \par
car '(a b c d e);  \par
 \par
  A   \par
 \par
 \par
algebraic;  \par
 \par
c := (lisp car '(first second))**2;  \par
 \par
  \par
 \par
            2 \par
  C := FIRST \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # LISTARGP}

${\footnote \pard\plain \sl240 \fs20 $ LISTARGP}

+{\footnote \pard\plain \sl240 \fs20 + g9:0839}

 K{\footnote \pard\plain \sl240 \fs20 K argument;list;LISTARGP declaration;declaration}

}{\b\f2 LISTARGP}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 listargp} {\f4 <operator>\{}{\f3 ,} {\f4 <operator>\}* 
\par 
\par 
}{\f2 \par 
If an operator other than those specifically defined for lists is given a 
single argument that is a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 , then the result of this 
operation will be a list in which that operator is applied to each element 
of the list. 
This process can be inhibited for a specific operator, or list of operators, 
by using the declaration }{\f3 listargp} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
log \{a,b,c\};  \par
 \par
  LOG(A),LOG(B),LOG(C)  \par
 \par
 \par
listargp log;  \par
 \par
log \{a,b,c\};  \par
 \par
  LOG(A,B,C) \par
 \par
\pard \sl240 }{\f2 It is possible to inhibit such distribution globally by turning on the 
switch }
{\f2\uldb listargs}{\v\f2 LISTARGS} 
{\f2 . In addition, if an operator has more than one 
argument, no such distribution occurs, so }{\f3 listargp} {\f2  has no effect. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NODEPEND}

${\footnote \pard\plain \sl240 \fs20 $ NODEPEND}

+{\footnote \pard\plain \sl240 \fs20 + g9:0840}

 K{\footnote \pard\plain \sl240 \fs20 K depend;NODEPEND declaration;declaration}

}{\b\f2 NODEPEND}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 nodepend} {\f2  declaration removes the dependency declared with 
}
{\f2\uldb depend}{\v\f2 DEPEND} 
{\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 nodepend} {\f4 <dep-kernel>\{,<kernel>\}+ 
\par 
\par 
\par 
\par 
}{\f2 <dep-kernel> must be a kernel that has had a dependency declared upon the 
one or more other kernels that are its other arguments. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
depend y,x,z;  \par
 \par
df(sin y,x);  \par
 \par
  COS(Y)*DF(Y,X)  \par
 \par
 \par
df(sin y,x,z);  \par
 \par
  COS(Y)*DF(Y,X,Z) - DF(Y,X)*DF(Y,Z)*SIN(Y)  \par
 \par
 \par
nodepend y,z;  \par
 \par
df(sin y,x);  \par
 \par
  COS(Y)*DF(Y,X)  \par
 \par
 \par
df(sin y,x,z);  \par
 \par
  0 \par
 \par
\pard \sl240 }{\f2 A warning message is printed if the dependency had not been declared by 
}{\f3 depend} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MATCH}

${\footnote \pard\plain \sl240 \fs20 $ MATCH}

+{\footnote \pard\plain \sl240 \fs20 + g9:0841}

 K{\footnote \pard\plain \sl240 \fs20 K substitution;MATCH command;command}

}{\b\f2 MATCH}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 match} {\f2  command is similar to the }
{\f2\uldb let}{\v\f2 LET} 
{\f2  command, except 
that it matches only explicit powers in substitution. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 match} {\f4 <expr> }{\f3 =} {\f4  <expression>\{,<expr> 
 }{\f3 =} {\f4 <expression>\}* 
\par 
\par 
}{\f2 \par 
<expr> is generally a term involving powers, and is limited by 
the rules for the }
{\f2\uldb let}{\v\f2 LET} 
{\f2  command. <expression> may be 
any valid REDUCE scalar expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
match c**2*a**2 = d; \par
(a+c)**4;  \par
 \par
   4       3          3    4 \par
  A   + 4*A *C + 4*A*C  + C  + 6*D  \par
 \par
 \par
match a+b = c;  \par
 \par
a + 2*b;  \par
 \par
  B + C  \par
 \par
 \par
(a + b + c)**2;  \par
 \par
   2     2               2 \par
  A   - B   + 2*B*C + 3*C   \par
 \par
 \par
clear a+b;  \par
 \par
(a + b + c)**2;  \par
 \par
    2                    2            2 \par
  A   + 2*A*B + 2*A*C + B  + 2*B*C + C   \par
 \par
 \par
let p*r = s;  \par
 \par
match p*q = ss;  \par
 \par
(a + p*r)**2;  \par
 \par
   2            2 \par
  A  + 2*A*S + S   \par
 \par
 \par
(a + p*q)**2;  \par
 \par
   2              2  2 \par
  A   + 2*A*SS + P *Q \par
 \par
\pard \sl240 }{\f2 Note in the last example that }{\f3 a + b} {\f2  has been explicitly matched 
after the squaring was done, replacing each single power of }{\f3 a} {\f2  by 
}{\f3 c - b} {\f2 . This kind of substitution, although following the rules, is 
confusing and could lead to unrecognizable results. It is better to use 
}{\f3 match} {\f2  with explicit powers or products only. }{\f3 match} {\f2  should 
not be used inside procedures for the same reasons that }{\f3 let} {\f2  should 
not be. 
\par 
\par 
Unlike }
{\f2\uldb let}{\v\f2 LET} 
{\f2  substitutions, }{\f3 match} {\f2  substitutions are executed 
after all other operations are complete. The last example shows the 
difference. }{\f3 match} {\f2  commands can be cleared by using }
{\f2\uldb clear}{\v\f2 CLEAR} 
{\f2 , 
with exactly the expression that the original }{\f3 match} {\f2  took. 
}{\f3 match} {\f2  commands can also be done more generally with }{\f3 for all} {\f2  
or }
{\f2\uldb forall}{\v\f2 FORALL} 
{\f2 ...}{\f3 such that} {\f2  commands. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NONCOM}

${\footnote \pard\plain \sl240 \fs20 $ NONCOM}

+{\footnote \pard\plain \sl240 \fs20 + g9:0842}

 K{\footnote \pard\plain \sl240 \fs20 K operator;non commutative;commutative;NONCOM declaration;declaration}

}{\b\f2 NONCOM}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
}{\f3 noncom} {\f2 declares that already-declared operators are noncommutative 
under multiplication. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 noncom} {\f4 <operator>\{,<operator>\}* 
\par 
\par 
}{\f2 \par 
<operator> must have been declared an }
{\f2\uldb operator}{\v\f2 OPERATOR} 
{\f2 , or a warning 
message is given. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
operator f,h;  \par
 \par
noncom f;  \par
 \par
f(a)*f(b) - f(b)*f(a);  \par
 \par
  F(A)*F(B) - F(B)*F(A)  \par
 \par
 \par
h(a)*h(b) - h(b)*h(a);  \par
 \par
  0  \par
 \par
 \par
operator comm;  \par
 \par
for all x,y such that x neq y and ordp(x,y) \par
        let f(x)*f(y) = f(y)*f(x) + comm(x,y); \par
\pard \sl240  \par
 \par
f(1)*f(2);  \par
 \par
  F(1)*F(2)  \par
 \par
 \par
f(2)*f(1);  \par
 \par
  COMM(2,1) + F(1)*F(2) \par
 \par
\pard \sl240 }{\f2 The last example introduces the commutator of }{\f4 f(x)}{\f2  and }{\f4 f(y)}{\f2  
for all x and y. The equality check is to prevent an infinite loop. The 
operator f can have other functionality attached to it if desired, or it 
can remain an indeterminate operator. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NONZERO}

${\footnote \pard\plain \sl240 \fs20 $ NONZERO}

+{\footnote \pard\plain \sl240 \fs20 + g9:0843}

 K{\footnote \pard\plain \sl240 \fs20 K operator;NONZERO declaration;declaration}

}{\b\f2 NONZERO}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 nonzero} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
If an }
{\f2\uldb operator}{\v\f2 OPERATOR} 
{\f2  }{\f3 f} {\f2  is declared }
{\f2\uldb odd}{\v\f2 ODD} 
{\f2 , then }{\f3 f(0)} {\f2  
is replaced by zero unless }{\f3 f} {\f2  is also declared non zero by the 
declaration }{\f3 nonzero} {\f2 . 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
        odd f;  \par
 \par
        f(0)  \par
 \par
  0  \par
 \par
 \par
        nonzero f;  \par
 \par
        f(0)  \par
 \par
  F(0) \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ODD}

${\footnote \pard\plain \sl240 \fs20 $ ODD}

+{\footnote \pard\plain \sl240 \fs20 + g9:0844}

 K{\footnote \pard\plain \sl240 \fs20 K operator;ODD declaration;declaration}

}{\b\f2 ODD}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 odd} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
This declaration is used to declare an operator odd in its first 
argument. Expressions involving an operator declared in this manner are 
transformed if the first argument contains a minus sign. Any other 
arguments are not affected. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
        odd f;  \par
 \par
        f(-a)  \par
 \par
  -F(A)  \par
 \par
 \par
        f(-a,-b)  \par
 \par
  -F(A,-B)  \par
 \par
 \par
        f(a,-b)  \par
 \par
  F(A,-B) \par
 \par
\pard \sl240 }{\f2 \par 
\par 
If say }{\f3 f} {\f2  is declared odd, then }{\f3 f(0)} {\f2  is replaced by zero 
unless }{\f3 f} {\f2  is also declared non zero by the declaration 
}
{\f2\uldb nonzero}{\v\f2 NONZERO} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # OFF}

${\footnote \pard\plain \sl240 \fs20 $ OFF}

+{\footnote \pard\plain \sl240 \fs20 + g9:0845}

 K{\footnote \pard\plain \sl240 \fs20 K switch;OFF command;command}

}{\b\f2 OFF}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 off} {\f2  command is used to turn switches off. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 off} {\f4 <switch>\{,<switch>\}* 
\par 
\par 
}{\f2 \par 
<switch> can be any }{\f3 switch} {\f2  name. There is no problem if the 
switch is already off. If the switch name is mistyped, an error message is 
given. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ON}

${\footnote \pard\plain \sl240 \fs20 $ ON}

+{\footnote \pard\plain \sl240 \fs20 + g9:0846}

 K{\footnote \pard\plain \sl240 \fs20 K switch;ON command;command}

}{\b\f2 ON}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 on} {\f2  command is used to turn switches on. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 on} {\f4 <switch>\{,<switch>\}* 
\par 
\par 
}{\f2 \par 
<switch> can be any }{\f3 switch} {\f2  name. There is no problem if the 
switch is already on. If the switch name is mistyped, an error message is 
given. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # OPERATOR}

${\footnote \pard\plain \sl240 \fs20 $ OPERATOR}

+{\footnote \pard\plain \sl240 \fs20 + g9:0847}

 K{\footnote \pard\plain \sl240 \fs20 K OPERATOR declaration;declaration}

}{\b\f2 OPERATOR}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
Use the }{\f3 operator} {\f2  declaration to declare your own operators. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 operator} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
<identifier> can be any valid REDUCE identifier, which is not the name 
of a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 , }
{\f2\uldb array}{\v\f2 ARRAY} 
{\f2 , scalar variable or previously-defined 
operator. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
operator dis,fac;  \par
 \par
let dis(~x,~y) = sqrt(x^2 + y^2);  \par
 \par
dis(1,2);  \par
 \par
  SQRT(5)  \par
 \par
 \par
dis(a,10);  \par
 \par
        2 \par
  SQRT(A  + 100)  \par
 \par
 \par
on rounded;  \par
 \par
dis(1.5,7.2);  \par
 \par
  7.35459040329 \par
 \par
 \par
let fac(~n) = if n=0 then 1 \par
               else if not(fixp n and n>0) \par
                then rederr "choose non-negative integer" \par
               else for i := 1:n product i; \par
\pard \sl240   \par
 \par
fac(5);  \par
 \par
  120  \par
 \par
 \par
fac(-2);  \par
 \par
  ***** choose non-negative integer \par
 \par
\pard \sl240 }{\f2 The first operator is the Euclidean distance metric, the distance of point 
}{\f4 (x,y)}{\f2  from the origin. The second operator is the factorial. 
\par 
\par 
Operators can have various properties assigned to them; they can be 
declared }
{\f2\uldb infix}{\v\f2 INFIX} 
{\f2 , }
{\f2\uldb linear}{\v\f2 LINEAR} 
{\f2 , }
{\f2\uldb symmetric}{\v\f2 SYMMETRIC} 
{\f2 , 
}
{\f2\uldb antisymmetric}{\v\f2 ANTISYMMETRIC} 
{\f2 , or }
{\f2\uldb noncom}{\v\f2 NONCOM} 
{\f3 mutative} {\f2 . 
The default operator is prefix, nonlinear, and commutative. 
Precedence can also be assigned to operators using the declaration 
}
{\f2\uldb precedence}{\v\f2 PRECEDENCE} 
{\f2 . 
\par 
\par 
Functionality is assigned to an operator by a }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statement or 
a }
{\f2\uldb forall}{\v\f2 FORALL} 
{\f2 ...}{\f3 let} {\f2  statement, 
(or possibly by a procedure with the name 
of the operator). Be careful not to redefine a system operator by 
accident. REDUCE permits you to redefine system operators, giving you a 
warning message that the operator was already defined. This flexibility 
allows you to add mathematical rules that do what you want them to do, but 
can produce odd or erroneous behavior if you are not careful. 
\par 
\par 
You can declare operators from inside }
{\f2\uldb procedure}{\v\f2 PROCEDURE} 
{\f2 s, as long as they 
are not local variables. Operators defined inside procedures are global. 
A formal parameter may be declared as an operator, and has the effect of 
declaring the calling variable as the operator. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ORDER}

${\footnote \pard\plain \sl240 \fs20 $ ORDER}

+{\footnote \pard\plain \sl240 \fs20 + g9:0848}

 K{\footnote \pard\plain \sl240 \fs20 K output;variable order;order;ORDER declaration;declaration}

}{\b\f2 ORDER}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 order} {\f2  declaration changes the order of precedence of kernels for 
display purposes only. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 order} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
<kernel> must be a valid }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2  or }
{\f2\uldb operator}{\v\f2 OPERATOR} 
{\f2  name 
complete with argument or a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  of such objects. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
x + y + z + cos(a);  \par
 \par
  COS(A) + X + Y + Z  \par
 \par
 \par
order z,y,x,cos(a);  \par
 \par
x + y + z + cos(a);  \par
 \par
  Z + Y + X + COS(A)  \par
 \par
 \par
(x + y)**2;  \par
 \par
   2            2 \par
  Y  + 2*Y*X + X   \par
 \par
 \par
order nil;  \par
 \par
(z + cos(z))**2;  \par
 \par
        2                 2 \par
  COS(Z)  + 2*COS(Z)*Z + Z \par
 \par
\pard \sl240 }{\f2 }{\f3 order} {\f2 affects the printing order of the identifiers only; internal 
order is unchanged. Change internal order of evaluation with the 
declaration }
{\f2\uldb korder}{\v\f2 KORDER} 
{\f2 . You can use }{\f3 order} {\f2  to feature variables 
or functions you are particularly interested in. 
\par 
\par 
Declarations made with }{\f3 order} {\f2  are cumulative: kernels in new order 
declarations are ordered behind those in previous declarations, and 
previous declarations retain their relative order. Of course, specific 
kernels named in new declarations are removed from previous ones and given 
the new priority. Return to the standard canonical printing order with the 
statement }{\f3 order nil} {\f2 . 
\par 
\par 
The print order specified by }{\f3 order} {\f2  commands is not in effect if the 
switch }
{\f2\uldb pri}{\v\f2 PRI} 
{\f2  is off. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PRECEDENCE}

${\footnote \pard\plain \sl240 \fs20 $ PRECEDENCE}

+{\footnote \pard\plain \sl240 \fs20 + g9:0849}

 K{\footnote \pard\plain \sl240 \fs20 K operator;PRECEDENCE declaration;declaration}

}{\b\f2 PRECEDENCE}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 precedence} {\f2  declaration attaches a precedence to an infix operator. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 precedence} {\f4 <operator>,<known\_operator> 
\par 
\par 
}{\f2 \par 
<operator> should have been declared an operator but may be a REDUCE 
identifier that is not already an operator, array, or matrix. 
<known\_operator> must be a system infix operator or have had its 
precedence already declared. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
operator f,h;  \par
 \par
precedence f,+;  \par
 \par
precedence h,*;  \par
 \par
a + f(1,2)*c;  \par
 \par
  (1 F 2)*C + A  \par
 \par
 \par
a + h(1,2)*c;  \par
 \par
  1 H 2*C + A  \par
 \par
 \par
a*1 f 2*c;  \par
 \par
  A F 2*C  \par
 \par
 \par
a*1 h 2*c;  \par
 \par
  1 H 2*A*C \par
 \par
\pard \sl240 }{\f2 The operator whose precedence is being declared is inserted into the infix 
operator precedence list at the next higher place than <known\_operator>. 
\par 
\par 
Attaching a precedence to an operator has the side effect of declaring the 
operator to be infix. If the identifier argument for }{\f3 precedence} {\f2  has 
not been declared to be an operator, an attempt to use it causes an error 
message. After declaring it to be an operator, it becomes an infix operator 
with the precedence previously given. Infix operators may be used in prefix 
form; if they are used in infix form, a space must be left on each side of 
the operator to avoid ambiguity. Declared infix operators are always binary. 
\par 
\par 
To see the infix operator precedence list, enter symbolic mode and type 
}{\f3 preclis!*;} {\f2 . The lowest precedence operator is listed first. 
\par 
\par 
All prefix operators have precedence higher than infix operators. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PRECISION}

${\footnote \pard\plain \sl240 \fs20 $ PRECISION}

+{\footnote \pard\plain \sl240 \fs20 + g9:0850}

 K{\footnote \pard\plain \sl240 \fs20 K floating point;rounded;PRECISION declaration;declaration}

}{\b\f2 PRECISION}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 precision} {\f2  declaration sets the number of decimal places used when 
}
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on. Default is system dependent, and normally about 12. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 precision} {\f4 (<integer>) or }{\f3 precision} {\f4  <integer> 
\par 
\par 
}{\f2 \par 
<integer> must be a positive integer. When <integer> is 0, the 
current precision is displayed, but not changed. There is no upper limit, 
but precision of greater than several hundred causes unpleasantly slow 
operation on numeric calculations. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
7/9;  \par
 \par
  0.777777777778  \par
 \par
 \par
precision 20;  \par
 \par
  20  \par
 \par
 \par
7/9;  \par
 \par
  0.77777777777777777778  \par
 \par
 \par
sin(pi/4);  \par
 \par
  0.7071067811865475244 \par
 \par
\pard \sl240 }{\f2 Trailing zeroes are dropped, so sometimes fewer than 20 decimal places are 
printed as in the last example. Turn on the switch }
{\f2\uldb fullprec}{\v\f2 FULLPREC} 
{\f2  if 
you want to print all significant digits. The }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  mode 
carries calculations to two more places than given by }{\f3 precision} {\f2 , and 
rounds off. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PRINT\_PRECISION}

${\footnote \pard\plain \sl240 \fs20 $ PRINT_PRECISION}

+{\footnote \pard\plain \sl240 \fs20 + g9:0851}

 K{\footnote \pard\plain \sl240 \fs20 K rounded;floating point;output;PRINT_PRECISION declaration;declaration}

}{\b\f2 PRINT\_PRECISION}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 print_precision} {\f4 (<integer>) 
 or }{\f3 print_precision} {\f4  <integer> 
\par 
\par 
}{\f2 \par 
In }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  mode, numbers are normally printed to the specified 
precision. If the user wishes to print such numbers with less precision, 
the printing precision can be set by the declaration }{\f3 print_precision} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
1/3;  \par
 \par
  0.333333333333  \par
 \par
 \par
print_precision 5;  \par
 \par
1/3  \par
 \par
  0.33333 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # REAL}

${\footnote \pard\plain \sl240 \fs20 $ REAL}

+{\footnote \pard\plain \sl240 \fs20 + g9:0852}

 K{\footnote \pard\plain \sl240 \fs20 K REAL declaration;declaration}

}{\b\f2 REAL}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
The }{\f3 real} {\f2  declaration must be made immediately after a 
}
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2  (or other variable declaration such as }
{\f2\uldb integer}{\v\f2 INTEGER} 
{\f2  
and }
{\f2\uldb scalar}{\v\f2 SCALAR} 
{\f2 ) and declares local integer variables. They are 
initialized to zero. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 real} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
<identifier> may be any valid REDUCE identifier, except 
}{\f3 t} {\f2  or }{\f3 nil} {\f2 . 
\par 
\par 
Real variables remain local, and do not share values with variables of the 
same name outside the }
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2 ...}{\f3 end} {\f2  block. When the 
block is finished, the variables are removed. You may use the words 
}
{\f2\uldb integer}{\v\f2 INTEGER} 
{\f2  or }
{\f2\uldb scalar}{\v\f2 SCALAR} 
{\f2  in the place of }{\f3 real} {\f2 . 
}{\f3 real} {\f2  does not indicate typechecking by the current REDUCE; it is 
only for your own information. Declaration statements must immediately 
follow the }{\f3 begin} {\f2 , without a semicolon between }{\f3 begin} {\f2  and the 
first variable declaration. 
\par 
\par 
Any variables used inside a }{\f3 begin} {\f2 ...}{\f3 end} {\f2  }
{\f2\uldb block}{\v\f2 block} 
{\f2  
that were not declared }{\f3 scalar} {\f2 , }{\f3 real} {\f2  or }{\f3 integer} {\f2  are 
global, and any change made to them inside the block affects their global 
value. Any }
{\f2\uldb array}{\v\f2 ARRAY} 
{\f2  or }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  declared inside a block is always 
global. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # REMFAC}

${\footnote \pard\plain \sl240 \fs20 $ REMFAC}

+{\footnote \pard\plain \sl240 \fs20 + g9:0853}

 K{\footnote \pard\plain \sl240 \fs20 K output;factor;REMFAC declaration;declaration}

}{\b\f2 REMFAC}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 remfac} {\f2  declaration removes the special factoring treatment of its 
arguments that was declared with }
{\f2\uldb factor}{\v\f2 FACTOR} 
{\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 remfac} {\f4 <kernel>\{,<kernel>\}+ 
\par 
\par 
}{\f2 \par 
<kernel> must be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2  or }
{\f2\uldb operator}{\v\f2 OPERATOR} 
{\f2  name that 
was declared as special with the }
{\f2\uldb factor}{\v\f2 FACTOR} 
{\f2  declaration. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SCALAR}

${\footnote \pard\plain \sl240 \fs20 $ SCALAR}

+{\footnote \pard\plain \sl240 \fs20 + g9:0854}

 K{\footnote \pard\plain \sl240 \fs20 K SCALAR declaration;declaration}

}{\b\f2 SCALAR}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
The }{\f3 scalar} {\f2  declaration must be made immediately after a 
}
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2  (or other variable declaration such as }
{\f2\uldb integer}{\v\f2 INTEGER} 
{\f2  
and }
{\f2\uldb real}{\v\f2 REAL} 
{\f2 ) and declares local scalar variables. They are 
initialized to 0. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 scalar} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
<identifier> may be any valid REDUCE identifier, except }{\f3 t} {\f2  or 
}{\f3 nil} {\f2 . 
\par 
\par 
Scalar variables remain local, and do not share values with variables of 
the same name outside the }
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2 ...}{\f3 end} {\f2  }
{\f2\uldb block}{\v\f2 block} 
{\f2 . 
When the block is finished, the variables are removed. You may use the 
words }
{\f2\uldb real}{\v\f2 REAL} 
{\f2  or }
{\f2\uldb integer}{\v\f2 INTEGER} 
{\f2  in the place of }{\f3 scalar} {\f2 . 
}{\f3 real} {\f2  and }{\f3 integer} {\f2  do not indicate typechecking by the current 
REDUCE; they are only for your own information. Declaration statements 
must immediately follow the }{\f3 begin} {\f2 , without a semicolon between 
}{\f3 begin} {\f2  and the first variable declaration. 
\par 
\par 
Any variables used inside }{\f3 begin} {\f2 ...}{\f3 end} {\f2  blocks that were not 
declared }{\f3 scalar} {\f2 , }{\f3 real} {\f2  or }{\f3 integer} {\f2  are global, and any 
change made to them inside the block affects their global value. Arrays 
declared inside a block are always global. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SCIENTIFIC\_NOTATION}

${\footnote \pard\plain \sl240 \fs20 $ SCIENTIFIC_NOTATION}

+{\footnote \pard\plain \sl240 \fs20 + g9:0855}

 K{\footnote \pard\plain \sl240 \fs20 K rounded;floating point;output;SCIENTIFIC_NOTATION declaration;declaration}

}{\b\f2 SCIENTIFIC\_NOTATION}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 scientific_notation} {\f4 (<m>) or 
}{\f3 scientific_notation} {\f4 (\{<m>,<n>\}) 
\par 
\par 
}{\f2 \par 
<m> and <n> are positive integers. 
}{\f3 scientific_notation} {\f2  controls the output format of floating point 
numbers. At the default settings, any number with five or less digits 
before the decimal point is printed in a fixed-point notation, e.g., 
12345.6. Numbers with more than five digits are printed in scientific 
notation, e.g., 1.234567E+5. Similarly, by default, any number with 
eleven or more zeros after the decimal point is printed in scientific 
notation. 
\par 
\par 
When }{\f3 scientific_notation} {\f2  is called with the numerical argument 
 m a number with more than m digits before the decimal point, 
or m or more zeros after the decimal point, is printed in scientific 
notation. When }{\f3 scientific_notation} {\f2  is called with a list 
\{<m>,<n>\}, a number with more than m digits before the 
decimal point, or n or more zeros after the decimal point is 
printed in scientific notation. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
on rounded; \par
 \par
 \par
12345.6; \par
 \par
  12345.6 \par
 \par
 \par
 \par
123456.5; \par
 \par
  1.234565e+5 \par
 \par
 \par
 \par
0.00000000000000012; \par
 \par
  1.2e-16 \par
 \par
 \par
 \par
scientific_notation 20; \par
 \par
  5,11 \par
 \par
 \par
 \par
5: 123456.7; \par
 \par
  123456.7 \par
 \par
 \par
 \par
0.00000000000000012; \par
 \par
  0.00000000000000012 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # SHARE}

${\footnote \pard\plain \sl240 \fs20 $ SHARE}

+{\footnote \pard\plain \sl240 \fs20 + g9:0856}

 K{\footnote \pard\plain \sl240 \fs20 K SHARE declaration;declaration}

}{\b\f2 SHARE}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
The }{\f3 share} {\f2  declaration allows access to its arguments by both 
algebraic and symbolic modes. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 share} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
<identifier> can be any valid REDUCE identifier. 
\par 
\par 
Programming in }
{\f2\uldb symbolic}{\v\f2 SYMBOLIC} 
{\f2  as well as algebraic mode allows 
you a wider range 
of techniques than just algebraic mode alone. Expressions do not cross the 
boundary since they have different representations, unless the }{\f3 share} {\f2  
declaration is used. For more information on using symbolic mode, see 
the <REDUCE User's Manual>, and the <Standard Lisp Report>. 
\par 
\par 
You should be aware that a previously-declared array is destroyed by the 
}{\f3 share} {\f2  declaration. Scalar variables retain their values. You can 
share a declared }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  that has not yet 
been dimensioned so that it can be 
used by both modes. Values that are later put into the matrix are 
accessible from symbolic mode too, but not by the usual matrix reference 
mechanism. In symbolic mode, a matrix is stored as a list whose first 
element is }
{\f2\uldb MAT}{\v\f2 MAT} 
{\f2 , and whose next elements are the rows of the matrix 
stored as lists of the individual elements. Access in symbolic mode is by 
the operators }
{\f2\uldb first}{\v\f2 FIRST} 
{\f2 , }
{\f2\uldb second}{\v\f2 SECOND} 
{\f2 , }
{\f2\uldb third}{\v\f2 THIRD} 
{\f2  and 
}
{\f2\uldb rest}{\v\f2 REST} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SYMBOLIC}

${\footnote \pard\plain \sl240 \fs20 $ SYMBOLIC}

+{\footnote \pard\plain \sl240 \fs20 + g9:0857}

 K{\footnote \pard\plain \sl240 \fs20 K SYMBOLIC command;command}

}{\b\f2 SYMBOLIC}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 symbolic} {\f2  command changes REDUCE's mode of operation to symbolic. 
When }{\f3 symbolic} {\f2  is followed by an expression, that expression is 
evaluated in symbolic mode, but REDUCE's mode is not changed. It is 
equivalent to the }
{\f2\uldb lisp}{\v\f2 LISP} 
{\f2  command. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
symbolic;  \par
 \par
  NIL  \par
 \par
 \par
cdr '(a b c);  \par
 \par
  (B C)  \par
 \par
 \par
algebraic;  \par
 \par
x + symbolic car '(y z);  \par
 \par
  X + Y \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # SYMMETRIC}

${\footnote \pard\plain \sl240 \fs20 $ SYMMETRIC}

+{\footnote \pard\plain \sl240 \fs20 + g9:0858}

 K{\footnote \pard\plain \sl240 \fs20 K operator;SYMMETRIC declaration;declaration}

}{\b\f2 SYMMETRIC}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
When an operator is declared }{\f3 symmetric} {\f2 , its arguments are reordered 
to conform to the internal ordering of the system. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 symmetric} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
<identifier> is an identifier that has been declared an operator. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
operator m,n;  \par
 \par
symmetric m,n;  \par
 \par
m(y,a,sin(x));  \par
 \par
  M(SIN(X),A,Y)  \par
 \par
 \par
n(z,m(b,a,q));  \par
 \par
  N(M(A,B,Q),Z) \par
 \par
\pard \sl240 }{\f2 If <identifier> has not been declared to be an operator, the flag 
}{\f3 symmetric} {\f2  is still attached to it. When <identifier> is 
subsequently used as an operator, the message }{\f3 Declare} {\f2 <identifier> 
 }{\f3 operator ? (Y or N)} {\f2  is printed. If the user replies }{\f3 y} {\f2 , the 
symmetric property of the operator is used. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TR}

${\footnote \pard\plain \sl240 \fs20 $ TR}

+{\footnote \pard\plain \sl240 \fs20 + g9:0859}

 K{\footnote \pard\plain \sl240 \fs20 K trace;TR declaration;declaration}

}{\b\f2 TR}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 tr} {\f2  declaration is used to trace system or user-written procedures. 
It is only useful to those with a good knowledge of both Lisp and the 
internal formats used by REDUCE. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 tr} {\f4 <name>\{,<name>\}* 
\par 
\par 
}{\f2 \par 
<name> is the name of a REDUCE system procedure or one of your own 
procedures. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4 \pard \sl240 }{\f2 The system procedure }{\f3 prepsq} {\f2  is traced, 
 which prepares REDUCE standard 
forms for printing by converting them to a Lisp prefix form.}{\f4 \pard \tx3420   \par
 \par
tr prepsq;  \par
 \par
  (PREPSQ)  \par
 \par
 \par
x**2 + y;  \par
 \par
  PREPSQ entry: \par
    Arg 1: (((((X . 2) . 1) ((Y . 1) . 1)) . 1) \par
  PREPSQ return value = (PLUS (EXPT X 2) Y) \par
  PREPSQ entry: \par
    Arg 1: (1 . 1) \par
  PREPSQ return value = 1 \par
   2 \par
  X  + Y \par
 \par
 \par
untr prepsq;  \par
 \par
  (PREPSQ) \par
 \par
\pard \sl240 }{\f2  
\par 
\par 
This example is for a PSL-based system; the above format will vary if 
other Lisp systems are used. 
\par 
\par 
When a procedure is traced, the first lines show entry to the procedure and 
the arguments it is given. The value returned by the procedure is printed 
upon exit. If you are tracing several procedures, with a call to one of 
them inside the other, the inner trace will be indented showing procedure 
nesting. There are no trace options. However, the format of the trace 
depends on the underlying Lisp system used. The trace can be removed with 
the command }
{\f2\uldb untr}{\v\f2 UNTR} 
{\f2 . Note that }{\f3 trace} {\f2 , below, is a matrix 
operator, while }{\f3 tr} {\f2  does procedure tracing. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # UNTR}

${\footnote \pard\plain \sl240 \fs20 $ UNTR}

+{\footnote \pard\plain \sl240 \fs20 + g9:0860}

 K{\footnote \pard\plain \sl240 \fs20 K trace;UNTR declaration;declaration}

}{\b\f2 UNTR}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 untr} {\f2  declaration is used to remove a trace from system or 
user-written procedures declared with }
{\f2\uldb tr}{\v\f2 TR} 
{\f2 . It is only useful to 
those with a good knowledge of both Lisp and the internal formats used by 
REDUCE. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 untr} {\f4 <name>\{,<name>\}* 
\par 
\par 
}{\f2 \par 
<name> is the name of a REDUCE system procedure or one of your own 
procedures that has previously been the argument of a }{\f3 tr} {\f2  
declaration. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # VARNAME}

${\footnote \pard\plain \sl240 \fs20 $ VARNAME}

+{\footnote \pard\plain \sl240 \fs20 + g9:0861}

 K{\footnote \pard\plain \sl240 \fs20 K VARNAME declaration;declaration}

}{\b\f2 VARNAME}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
The declaration }{\f3 varname} {\f2  instructs REDUCE to use its argument as the 
default Fortran (when }
{\f2\uldb fort}{\v\f2 FORT} 
{\f2  is on) or }
{\f2\uldb structr}{\v\f2 STRUCTR} 
{\f2  identifier 
and identifier stem, rather than using }{\f3 ANS} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 varname} {\f4 <identifier> 
\par 
\par 
}{\f2 \par 
<identifier> can be any combination of one or more alphanumeric 
characters. Try to avoid REDUCE reserved words. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
varname ident;  \par
 \par
  IDENT  \par
 \par
 \par
on fort;  \par
 \par
x**2 + 1;  \par
 \par
  IDENT=X**2+1.  \par
 \par
 \par
off fort,exp;  \par
 \par
structr(((x+y)**2 + z)**3);  \par
 \par
        3 \par
  IDENT2 \par
      where \par
                         2 \par
         IDENT2 := IDENT1  + Z \par
  IDENT1 := X + Y \par
 \par
\pard \sl240 }{\f2 }
{\f2\uldb exp}{\v\f2 EXP} 
{\f2 was turned off so that }
{\f2\uldb structr}{\v\f2 STRUCTR} 
{\f2  could show the 
structure. If }{\f3 exp} {\f2  had been on, the expression would have been 
expanded into a polynomial. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # WEIGHT}

${\footnote \pard\plain \sl240 \fs20 $ WEIGHT}

+{\footnote \pard\plain \sl240 \fs20 + g9:0862}

 K{\footnote \pard\plain \sl240 \fs20 K WEIGHT command;command}

}{\b\f2 WEIGHT}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 weight} {\f2  command is used to attach weights to kernels for asymptotic 
constraints. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 weight} {\f4 <kernel> }{\f3 =} {\f4 <number> 
\par 
\par 
}{\f2 \par 
<kernel> must be a REDUCE }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 , <number> must be a 
positive integer, not 0. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := (x+y)**4;  \par
 \par
        4      3        2  2        3    4 \par
  A := X  + 4*X *Y + 6*X *Y  + 4*X*Y  + Y   \par
 \par
 \par
weight x=2,y=3;  \par
 \par
wtlevel 8;  \par
 \par
a;  \par
 \par
   4 \par
  X   \par
 \par
 \par
wtlevel 10;  \par
 \par
a;  \par
 \par
   2     2             2 \par
  X *(6*Y  + 4*X*Y  + X )  \par
 \par
 \par
int(x**2,x);  \par
 \par
  ***** X invalid as KERNEL \par
 \par
\pard \sl240 }{\f2 Weights and }
{\f2\uldb wtlevel}{\v\f2 WTLEVEL} 
{\f2  are used for asymptotic constraints, where 
higher-order terms are considered insignificant. 
\par 
\par 
Weights are originally equivalent to 0 until set by a }{\f3 weight} {\f2  
command. To remove a weight from a kernel, use the }
{\f2\uldb clear}{\v\f2 CLEAR} 
{\f2  
command. Weights once assigned cannot be changed without clearing the 
identifier. Once a weight is assigned to a kernel, it is no longer a 
kernel and cannot be used in any REDUCE commands or operators that require 
kernels, until the weight is cleared. Note that terms are ordered by 
greatest weight. 
\par 
\par 
The weight level of the system is set by }
{\f2\uldb wtlevel}{\v\f2 WTLEVEL} 
{\f2 , initially at 
2. Since no kernels have weights, no effect from }{\f3 wtlevel} {\f2  can be 
seen. Once you assign weights to kernels, you must set }{\f3 wtlevel} {\f2  
correctly for the desired operation. When weighted variables appear in a 
term, their weights are summed for the total weight of the term (powers of 
variables multiply their weights). When a term exceeds the weight level 
of the system, it is discarded from the result expression. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # WHERE}

${\footnote \pard\plain \sl240 \fs20 $ WHERE}

+{\footnote \pard\plain \sl240 \fs20 + g9:0863}

 K{\footnote \pard\plain \sl240 \fs20 K substitution;WHERE operator;operator}

}{\b\f2 WHERE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 where} {\f2  operator provides an infix notation for one-time 
substitutions for kernels in expressions. 
 \par
syntax: \par
}{\f4 \par 
\par 
<expression> }{\f3 where} {\f4  <kernel> 
 }{\f3 =} {\f4 <expression> 
 \{,<kernel> }{\f3 =} {\f4 <expression>\}* 
\par 
\par 
}{\f2 \par 
<expression> can be any REDUCE scalar expression, <kernel> must 
be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 . Alternatively a }
{\f2\uldb rule}{\v\f2 RULE} 
{\f2  or a }{\f3 rule list} {\f2  
can be a member of the right-hand part of a }{\f3 where} {\f2  expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
x**2 + 17*x*y + 4*y**2 where x=1,y=2;  \par
 \par
 \par
  51  \par
 \par
 \par
for i := 1:5 collect x**i*q where q= for j := 1:i product j; \par
  \par
 \par
 \par
        2    3     4      5 \par
  \{X,2*X ,6*X ,24*X ,120*X \}  \par
 \par
 \par
x**2 + y + z where z=y**3,y=3;  \par
 \par
   2    3 \par
  X  + Y  + 3 \par
 \par
\pard \sl240 }{\f2 Substitution inside a }{\f3 where} {\f2  expression has no effect upon the values 
of the kernels outside the expression. The }{\f3 where} {\f2  operator has the 
lowest precedence of all the infix operators, which are lower than prefix 
operators, so that the substitutions apply to the entire expression 
preceding the }{\f3 where} {\f2  operator. However, }{\f3 where} {\f2  is applied 
before command keywords such as }{\f3 then} {\f2 , }{\f3 repeat} {\f2 , or }{\f3 do} {\f2 . 
\par 
\par 
A }
{\f2\uldb rule}{\v\f2 RULE} 
{\f2  or a }{\f3 rule set} {\f2  in the right-hand part of the 
}{\f3 where} {\f2  expression act as if the rules were activated by }
{\f2\uldb let}{\v\f2 LET} 
{\f2  
immediately before the evaluation of the expression and deactivated 
by }
{\f2\uldb clearrules}{\v\f2 CLEARRULES} 
{\f2  immediately afterwards. 
\par 
\par 
}{\f3 where} {\f2 gives you a natural notation for auxiliary variables in 
expressions. As the second example shows, the substitute expression can be 
a command to be evaluated. The substitute assignments are made in 
parallel, rather than sequentially, as the last example shows. The 
expression resulting from the first round of substitutions is not 
reexamined to see if any further such substitutions can be made. 
}{\f3 where} {\f2  can also be used to define auxiliary variables in 
}
{\f2\uldb procedure}{\v\f2 PROCEDURE} 
{\f2  definitions. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # WHILE}

${\footnote \pard\plain \sl240 \fs20 $ WHILE}

+{\footnote \pard\plain \sl240 \fs20 + g9:0864}

 K{\footnote \pard\plain \sl240 \fs20 K loop;WHILE command;command}

}{\b\f2 WHILE}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 while} {\f2  command causes a statement to be repeatedly executed until a 
given condition is true. If the condition is initially false, the statement 
is not executed at all. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 while} {\f4 <condition> }{\f3 do} {\f4  <statement> 
\par 
\par 
}{\f2 \par 
<condition> is given by a logical operator, <statement> must be a 
single REDUCE statement, or a }
{\f2\uldb group}{\v\f2 group} 
{\f2  (}{\f3 <<} {\f2 ...}{\f3 >>} {\f2 ) or 
}
{\f2\uldb begin}{\v\f2 BEGIN} 
{\f2 ...}{\f3 end} {\f2  }
{\f2\uldb block}{\v\f2 block} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := 10;  \par
 \par
  A := 10  \par
 \par
 \par
while a <= 12 do <<write a; a := a + 1>>; \par
  \par
 \par
 \par
  10  \par
 \par
 \par
                                          11  \par
 \par
                                          12  \par
 \par
while a < 5 do <<write a; a := a + 1>>; \par
  \par
 \par
 \par
      nothing is printed \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # WTLEVEL}

${\footnote \pard\plain \sl240 \fs20 $ WTLEVEL}

+{\footnote \pard\plain \sl240 \fs20 + g9:0865}

 K{\footnote \pard\plain \sl240 \fs20 K WTLEVEL command;command}

}{\b\f2 WTLEVEL}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
In conjunction with }
{\f2\uldb weight}{\v\f2 WEIGHT} 
{\f2 , }{\f3 wtlevel} {\f2  is used to implement 
asymptotic constraints. Its default value is 2. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 wtlevel} {\f4 <expression> 
\par 
\par 
}{\f2 \par 
To change the weight level, <expression> must evaluate to a positive 
integer that is the greatest weight term to be retained in expressions 
involving kernels with weight assignments. }{\f3 wtlevel} {\f2  returns the 
new weight level. If you want the current weight level, but not 
change it, say }{\f3 wtlevel nil} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
(x+y)**4;           \par
  \par
 \par
   4      3        2  2        3    4 \par
  X  + 4*X *Y + 6*X *Y  + 4*X*Y  + Y   \par
 \par
 \par
weight x=2,y=3;  \par
 \par
wtlevel 8;  \par
 \par
(x+y)**4;  \par
 \par
   4 \par
  X   \par
 \par
 \par
wtlevel 10;  \par
 \par
(x+y)**4;  \par
 \par
   2     2            2 \par
  X *(6*Y  + 4*X*Y + X )  \par
 \par
 \par
int(x**2,x);  \par
 \par
  ***** X invalid as KERNEL \par
 \par
\pard \sl240 }{\f2 }{\f3 wtlevel} {\f2 is used in conjunction with the command }
{\f2\uldb weight}{\v\f2 WEIGHT} 
{\f2  to 
enable asymptotic constraints. Weight of a term is computed by multiplying 
the weights of each variable in it by the power to which it has been 
raised, and adding the resulting weights for each variable. If the weight 
of the term is greater than }{\f3 wtlevel} {\f2 , the term is dropped from the 
expression, and not used in any further computation involving the 
expression. 
\par 
\par 
Once a weight has been attached to a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 , it is no longer 
recognized by the system as a kernel, though still a variable. It cannot 
be used in REDUCE commands and operators that need kernels. The weight 
attachment can be undone with a }
{\f2\uldb clear}{\v\f2 CLEAR} 
{\f2  command. }{\f3 wtlevel} {\f2  can 
be changed as desired. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g9}

${\footnote \pard\plain \sl240 \fs20 $ Declarations}

+{\footnote \pard\plain \sl240 \fs20 + index:0009}
}{\b\f2 Declarations}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb ALGEBRAIC command}
{\v\f2 ALGEBRAIC}{\f2 \par 
}{\f2 \tab}{\f2\uldb ANTISYMMETRIC declaration}
{\v\f2 ANTISYMMETRIC}{\f2 \par 
}{\f2 \tab}{\f2\uldb ARRAY declaration}
{\v\f2 ARRAY}{\f2 \par 
}{\f2 \tab}{\f2\uldb CLEAR command}
{\v\f2 CLEAR}{\f2 \par 
}{\f2 \tab}{\f2\uldb CLEARRULES command}
{\v\f2 CLEARRULES}{\f2 \par 
}{\f2 \tab}{\f2\uldb DEFINE command}
{\v\f2 DEFINE}{\f2 \par 
}{\f2 \tab}{\f2\uldb DEPEND declaration}
{\v\f2 DEPEND}{\f2 \par 
}{\f2 \tab}{\f2\uldb EVEN declaration}
{\v\f2 EVEN}{\f2 \par 
}{\f2 \tab}{\f2\uldb FACTOR declaration}
{\v\f2 FACTOR_declaration}{\f2 \par 
}{\f2 \tab}{\f2\uldb FORALL command}
{\v\f2 FORALL}{\f2 \par 
}{\f2 \tab}{\f2\uldb INFIX declaration}
{\v\f2 INFIX}{\f2 \par 
}{\f2 \tab}{\f2\uldb INTEGER declaration}
{\v\f2 INTEGER}{\f2 \par 
}{\f2 \tab}{\f2\uldb KORDER declaration}
{\v\f2 KORDER}{\f2 \par 
}{\f2 \tab}{\f2\uldb LET command}
{\v\f2 LET}{\f2 \par 
}{\f2 \tab}{\f2\uldb LINEAR declaration}
{\v\f2 LINEAR}{\f2 \par 
}{\f2 \tab}{\f2\uldb LINELENGTH declaration}
{\v\f2 LINELENGTH}{\f2 \par 
}{\f2 \tab}{\f2\uldb LISP command}
{\v\f2 LISP}{\f2 \par 
}{\f2 \tab}{\f2\uldb LISTARGP declaration}
{\v\f2 LISTARGP}{\f2 \par 
}{\f2 \tab}{\f2\uldb NODEPEND declaration}
{\v\f2 NODEPEND}{\f2 \par 
}{\f2 \tab}{\f2\uldb MATCH command}
{\v\f2 MATCH}{\f2 \par 
}{\f2 \tab}{\f2\uldb NONCOM declaration}
{\v\f2 NONCOM}{\f2 \par 
}{\f2 \tab}{\f2\uldb NONZERO declaration}
{\v\f2 NONZERO}{\f2 \par 
}{\f2 \tab}{\f2\uldb ODD declaration}
{\v\f2 ODD}{\f2 \par 
}{\f2 \tab}{\f2\uldb OFF command}
{\v\f2 OFF}{\f2 \par 
}{\f2 \tab}{\f2\uldb ON command}
{\v\f2 ON}{\f2 \par 
}{\f2 \tab}{\f2\uldb OPERATOR declaration}
{\v\f2 OPERATOR}{\f2 \par 
}{\f2 \tab}{\f2\uldb ORDER declaration}
{\v\f2 ORDER}{\f2 \par 
}{\f2 \tab}{\f2\uldb PRECEDENCE declaration}
{\v\f2 PRECEDENCE}{\f2 \par 
}{\f2 \tab}{\f2\uldb PRECISION declaration}
{\v\f2 PRECISION}{\f2 \par 
}{\f2 \tab}{\f2\uldb PRINT\_PRECISION declaration}
{\v\f2 PRINT\_PRECISION}{\f2 \par 
}{\f2 \tab}{\f2\uldb REAL declaration}
{\v\f2 REAL}{\f2 \par 
}{\f2 \tab}{\f2\uldb REMFAC declaration}
{\v\f2 REMFAC}{\f2 \par 
}{\f2 \tab}{\f2\uldb SCALAR declaration}
{\v\f2 SCALAR}{\f2 \par 
}{\f2 \tab}{\f2\uldb SCIENTIFIC\_NOTATION declaration}
{\v\f2 SCIENTIFIC\_NOTATION}{\f2 \par 
}{\f2 \tab}{\f2\uldb SHARE declaration}
{\v\f2 SHARE}{\f2 \par 
}{\f2 \tab}{\f2\uldb SYMBOLIC command}
{\v\f2 SYMBOLIC}{\f2 \par 
}{\f2 \tab}{\f2\uldb SYMMETRIC declaration}
{\v\f2 SYMMETRIC}{\f2 \par 
}{\f2 \tab}{\f2\uldb TR declaration}
{\v\f2 TR}{\f2 \par 
}{\f2 \tab}{\f2\uldb UNTR declaration}
{\v\f2 UNTR}{\f2 \par 
}{\f2 \tab}{\f2\uldb VARNAME declaration}
{\v\f2 VARNAME}{\f2 \par 
}{\f2 \tab}{\f2\uldb WEIGHT command}
{\v\f2 WEIGHT}{\f2 \par 
}{\f2 \tab}{\f2\uldb WHERE operator}
{\v\f2 WHERE}{\f2 \par 
}{\f2 \tab}{\f2\uldb WHILE command}
{\v\f2 WHILE}{\f2 \par 
}{\f2 \tab}{\f2\uldb WTLEVEL command}
{\v\f2 WTLEVEL}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # IN}

${\footnote \pard\plain \sl240 \fs20 $ IN}

+{\footnote \pard\plain \sl240 \fs20 + g10:0866}

 K{\footnote \pard\plain \sl240 \fs20 K input;IN command;command}

}{\b\f2 IN}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 in} {\f2  command takes a list of file names and inputs each file into 
the system. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 in} {\f4 <filename>\{,<filename>\}* 
\par 
\par 
}{\f2 \par 
<filename> must be in the current directory, or be a valid pathname. 
If the file name is not an identifier, double quote marks (}{\f3 "} {\f2 ) are 
needed around the file name. 
\par 
\par 
A message is given if the file cannot be found, or has a mistake 
in it. 
\par 
\par 
Ending the command with a semicolon causes the file to be echoed to the 
screen; ending it with a dollar sign does not echo the file. If you want 
some but not all of a file echoed, turn the switch }
{\f2\uldb echo}{\v\f2 ECHO} 
{\f2  on or off 
in the file. 
\par 
\par 
An efficient way to develop procedures in REDUCE is to write them into a file 
using a system editor of your choice, and then input the 
files into an active REDUCE session. REDUCE reparses the procedure as 
it takes information from the file, overwriting the previous procedure 
definition. When it accepts the procedure, it echoes its name to the screen. 
Data can also be input to the system from files. 
\par 
\par 
Files to be read in should always end in }
{\f2\uldb end}{\v\f2 END} 
{\f3 ;} {\f2  to avoid 
end-of-file problems. Note that this is an additional }{\f3 end;} {\f2  to any 
ending procedures in the file. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # INPUT}

${\footnote \pard\plain \sl240 \fs20 $ INPUT}

+{\footnote \pard\plain \sl240 \fs20 + g10:0867}

 K{\footnote \pard\plain \sl240 \fs20 K interactive;INPUT command;command}

}{\b\f2 INPUT}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 input} {\f2  command returns the input expression to the REDUCE numbered 
prompt that is its argument. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 input} {\f4 (<number>) or }{\f3 input} {\f4  <number> 
\par 
\par 
\par 
\par 
}{\f2 <number> must be between 1 and the current REDUCE prompt number. 
\par 
\par 
An expression brought back by }{\f3 input} {\f2  can be reexecuted with new 
values or switch settings, or used as an argument in another expression. 
The command }
{\f2\uldb ws}{\v\f2 WS} 
{\f2  brings back the results of a numbered REDUCE 
statement. Two lists contain every input and every output statement since 
the beginning of the session. If your session is very long, storage space 
begins to fill up with these expressions, so it is a good idea to end the 
session once in a while, saving needed expressions to files with the 
}
{\f2\uldb saveas}{\v\f2 SAVEAS} 
{\f2  and }
{\f2\uldb out}{\v\f2 OUT} 
{\f2  commands. 
\par 
\par 
Switch settings and }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statements can also be reexecuted by using 
}{\f3 input} {\f2 . 
\par 
\par 
An error message is given if a number is called for that has not yet been used. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # OUT}

${\footnote \pard\plain \sl240 \fs20 $ OUT}

+{\footnote \pard\plain \sl240 \fs20 + g10:0868}

 K{\footnote \pard\plain \sl240 \fs20 K open;output;OUT command;command}

}{\b\f2 OUT}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 out} {\f2  command directs output to the filename that is its argument, 
until another }{\f3 out} {\f2  changes the output file, or }
{\f2\uldb shut}{\v\f2 SHUT} 
{\f2  closes it. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 out} {\f4 <filename> or }{\f3 out "} {\f4 <pathname> }{\f3 "} {\f4  or }{\f3 out t} {\f4  
\par 
\par 
}{\f2 \par 
<filename> must be in the current directory, or be a valid complete 
file description for your system. If the file name is not 
in the current directory, quote marks are needed around the file name. 
If the file already exists, a message is printed allowing you to decide 
whether to supersede the contents of the file with new material. 
\par 
\par 
To restore output to the terminal, type }{\f3 out t} {\f2 , or }
{\f2\uldb shut}{\v\f2 SHUT} 
{\f2  the 
file. When you use }{\f3 out t} {\f2 , the file remains available, and if you 
open it again (with another }{\f3 out} {\f2 ), new material is appended rather 
than overwriting. 
\par 
\par 
To write a file using }{\f3 out} {\f2  that can be input at a later time, the 
switch }
{\f2\uldb nat}{\v\f2 NAT} 
{\f2  must be turned off, so that the standard linear form 
is saved that can be read in by }
{\f2\uldb in}{\v\f2 IN} 
{\f2 . If }{\f3 nat} {\f2  is on, exponents 
are printed on the line above the expression, which causes trouble 
when REDUCE tries to read the file. 
\par 
\par 
There is a slight complication if you are using the }{\f3 out} {\f2  command from 
inside a file to create another file. The }
{\f2\uldb echo}{\v\f2 ECHO} 
{\f2  switch is normally 
off at the top-level and on while reading files (so you can see what is 
being read in). If you create a file using }{\f3 out} {\f2  at the top-level, 
the result lines are printed into the file as you want them. But if you 
create such a file from inside a file, the }{\f3 echo} {\f2  switch is on, and 
every line is echoed, first as you typed it, then as REDUCE parsed it, and 
then once more for the file. Therefore, when you create a file from 
a file, you need to turn }{\f3 echo} {\f2  off explicitly before the }{\f3 out} {\f2  
command, and turn it back on when you }{\f3 shut} {\f2  the created file, so your 
executing file echoes as it should. This behavior also means that as you 
watch the file execute, you cannot see the lines that are being put into 
the }{\f3 out} {\f2  file. As soon as you turn }{\f3 echo} {\f2  on, you can see 
output again. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SHUT}

${\footnote \pard\plain \sl240 \fs20 $ SHUT}

+{\footnote \pard\plain \sl240 \fs20 + g10:0869}

 K{\footnote \pard\plain \sl240 \fs20 K close;output;SHUT command;command}

}{\b\f2 SHUT}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 shut} {\f2  command closes output files. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 shut} {\f4 <filename>\{,<filename>\}* 
\par 
\par 
}{\f2 \par 
<filename> must have been a file opened by }
{\f2\uldb out}{\v\f2 OUT} 
{\f2 . 
\par 
\par 
A file that has been opened by }
{\f2\uldb out}{\v\f2 OUT} 
{\f2  must be }{\f3 shut} {\f2  before it is 
brought in by }
{\f2\uldb in}{\v\f2 IN} 
{\f2 . Files that have been opened by }{\f3 out} {\f2  should 
always be }{\f3 shut} {\f2  before the end of the REDUCE session, to avoid either 
loss of information or the printing of extraneous information into the file. 
In most systems, terminating a session by }
{\f2\uldb bye}{\v\f2 BYE} 
{\f2  closes all open 
output files. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g10}

${\footnote \pard\plain \sl240 \fs20 $ Input and Output}

+{\footnote \pard\plain \sl240 \fs20 + index:0010}
}{\b\f2 Input and Output}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb IN command}
{\v\f2 IN}{\f2 \par 
}{\f2 \tab}{\f2\uldb INPUT command}
{\v\f2 INPUT}{\f2 \par 
}{\f2 \tab}{\f2\uldb OUT command}
{\v\f2 OUT}{\f2 \par 
}{\f2 \tab}{\f2\uldb SHUT command}
{\v\f2 SHUT}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ACOS}

${\footnote \pard\plain \sl240 \fs20 $ ACOS}

+{\footnote \pard\plain \sl240 \fs20 + g11:0870}

 K{\footnote \pard\plain \sl240 \fs20 K arccosine;ACOS operator;operator}

}{\b\f2 ACOS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 acos} {\f2  operator returns the arccosine of its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 acos} {\f4 (<expression>) or }{\f3 acos} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
acos(ab);  \par
 \par
  ACOS(AB)  \par
 \par
 \par
acos 15;  \par
 \par
  ACOS(15)  \par
 \par
 \par
df(acos(x*y),x);  \par
 \par
           2  2 \par
  SQRT( - X *Y  + 1)*Y \par
  --------------------  \par
        2  2 \par
       X *Y  - 1 \par
 \par
 \par
on rounded;  \par
 \par
res := acos(sqrt(2)/2);  \par
 \par
  RES := 0.785398163397  \par
 \par
 \par
res-pi/4;  \par
 \par
  0 \par
 \par
\pard \sl240 }{\f2 An explicit numeric value is not given unless the switch }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is 
on and the argument has an absolute numeric value less than or equal to 1. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ACOSH}

${\footnote \pard\plain \sl240 \fs20 $ ACOSH}

+{\footnote \pard\plain \sl240 \fs20 + g11:0871}

 K{\footnote \pard\plain \sl240 \fs20 K hyperbolic arccosine;ACOSH operator;operator}

}{\b\f2 ACOSH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
}{\f3 acosh} {\f2 represents the hyperbolic arccosine of its argument. It takes 
an arbitrary scalar expression as its argument. The derivative of 
}{\f3 acosh} {\f2  is known to the system. Numerical values may also be found by 
turning on the switch }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 acosh} {\f4 (<expression>) or }{\f3 acosh} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
acosh a;  \par
 \par
  ACOSH(A)  \par
 \par
 \par
acosh(0);  \par
 \par
  ACOSH(0)  \par
 \par
 \par
df(acosh(a**2),a);  \par
 \par
          4 \par
  2*SQRT(A  - 1)*A \par
  ----------------  \par
        4 \par
       A  - 1 \par
 \par
 \par
int(acosh(x),x);  \par
 \par
  INT(ACOSH(X),X) \par
 \par
\pard \sl240 }{\f2 You may attach functionality by defining }{\f3 acosh} {\f2  to be the inverse of 
}{\f3 cosh} {\f2 . This is done by the commands 
\pard \tx3420 }{\f4  \par
        put('cosh,'inverse,'acosh); \par
        put('acosh,'inverse,'cosh); \par
\pard \sl240 }{\f2 \par 
\par 
You can write a procedure to attach integrals or other 
functions to }{\f3 acosh} {\f2 . You may wish to add a check to see that its 
argument is properly restricted. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ACOT}

${\footnote \pard\plain \sl240 \fs20 $ ACOT}

+{\footnote \pard\plain \sl240 \fs20 + g11:0872}

 K{\footnote \pard\plain \sl240 \fs20 K arccotangent;ACOT operator;operator}

}{\b\f2 ACOT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
}{\f3 acot} {\f2 represents the arccotangent of its argument. It takes 
an arbitrary scalar expression as its argument. The derivative of 
}{\f3 acot} {\f2  is known to the system. Numerical values may also be found by 
turning on the switch }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 acot} {\f4 (<expression>) or }{\f3 acot} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
You can add functionality yourself with }{\f3 let} {\f2  and procedures. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ACOTH}

${\footnote \pard\plain \sl240 \fs20 $ ACOTH}

+{\footnote \pard\plain \sl240 \fs20 + g11:0873}

 K{\footnote \pard\plain \sl240 \fs20 K hyperbolic cotangent;ACOTH operator;operator}

}{\b\f2 ACOTH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
}{\f3 acoth} {\f2 represents the inverse hyperbolic cotangent of its argument. 
It takes an arbitrary scalar expression as its argument. The derivative 
of }{\f3 acoth} {\f2  is known to the system. Numerical values may also be found 
by turning on the switch }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 acoth} {\f4 (<expression>) or }{\f3 acoth} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, 
matrix or vector expression. <simple\_expression> must be a single 
identifier or begin with a prefix operator name. You can add 
functionality yourself with }{\f3 let} {\f2  and procedures. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ACSC}

${\footnote \pard\plain \sl240 \fs20 $ ACSC}

+{\footnote \pard\plain \sl240 \fs20 + g11:0874}

 K{\footnote \pard\plain \sl240 \fs20 K arccosecant;ACSC operator;operator}

}{\b\f2 ACSC}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 acsc} {\f2  operator returns the arccosecant of its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 acsc} {\f4 (<expression>) or }{\f3 acsc} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
acsc(ab);  \par
 \par
  ACSC(AB)  \par
 \par
 \par
acsc 15;  \par
 \par
  ACSC(15)  \par
 \par
 \par
df(acsc(x*y),x);  \par
 \par
         2  2 \par
  -SQRT(X *Y  - 1) \par
  ----------------  \par
       2  2 \par
   X*(X *Y  - 1) \par
 \par
 \par
on rounded;  \par
 \par
res := acsc(2/sqrt(3));  \par
 \par
  RES := 1.0471975512  \par
 \par
 \par
res-pi/3;  \par
 \par
  0 \par
 \par
\pard \sl240 }{\f2 An explicit numeric value is not given unless the switch }{\f3 rounded} {\f2  is 
on and the argument has an absolute numeric value less than or equal to 1. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ACSCH}

${\footnote \pard\plain \sl240 \fs20 $ ACSCH}

+{\footnote \pard\plain \sl240 \fs20 + g11:0875}

 K{\footnote \pard\plain \sl240 \fs20 K arccosecant;ACSCH operator;operator}

}{\b\f2 ACSCH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 acsch} {\f2  operator returns the hyperbolic arccosecant of its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 acsch} {\f4 (<expression>) or }{\f3 acsch} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
acsch(ab);  \par
 \par
  ACSCH(AB)  \par
 \par
 \par
acsch 15;  \par
 \par
  ACSCH(15)  \par
 \par
 \par
df(acsch(x*y),x);  \par
 \par
         2  2 \par
  -SQRT(X *Y  + 1) \par
  ----------------  \par
       2  2 \par
   X*(X *Y  + 1) \par
 \par
 \par
on rounded;  \par
 \par
res := acsch(3);  \par
 \par
  RES := 0.327450150237 \par
 \par
\pard \sl240 }{\f2 An explicit numeric value is not given unless the switch }{\f3 rounded} {\f2  is 
on and the argument has an absolute numeric value less than or equal to 1. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ASEC}

${\footnote \pard\plain \sl240 \fs20 $ ASEC}

+{\footnote \pard\plain \sl240 \fs20 + g11:0876}

 K{\footnote \pard\plain \sl240 \fs20 K arccosecant;ASEC operator;operator}

}{\b\f2 ASEC}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 asec} {\f2  operator returns the arccosecant of its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 asec} {\f4 (<expression>) or }{\f3 asec} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
asec(ab);  \par
 \par
  ASEC(AB)  \par
 \par
 \par
asec 15;  \par
 \par
  ASEC(15)  \par
 \par
 \par
df(asec(x*y),x);  \par
 \par
        2  2 \par
  SQRT(X *Y  - 1) \par
  ---------------  \par
       2  2 \par
   X*(X *Y  - 1) \par
 \par
 \par
on rounded;  \par
 \par
res := asec sqrt(2);  \par
 \par
  RES := 0.785398163397  \par
 \par
 \par
res-pi/4;  \par
 \par
  0 \par
 \par
\pard \sl240 }{\f2 An explicit numeric value is not given unless the switch }{\f3 rounded} {\f2  is 
on and the argument has an absolute numeric value greater or equal to 1. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ASECH}

${\footnote \pard\plain \sl240 \fs20 $ ASECH}

+{\footnote \pard\plain \sl240 \fs20 + g11:0877}

 K{\footnote \pard\plain \sl240 \fs20 K hyperbolic arccosecant;ASECH operator;operator}

}{\b\f2 ASECH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
}{\f3 asech} {\f2 represents the hyperbolic arccosecant of its argument. It takes 
an arbitrary scalar expression as its argument. The derivative of 
}{\f3 asech} {\f2  is known to the system. Numerical values may also be found by 
turning on the switch }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 asech} {\f4 (<expression>) or }{\f3 asech} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
asech a;  \par
 \par
  ASECH(A)  \par
 \par
 \par
asech(1);  \par
 \par
  0  \par
 \par
 \par
df(acosh(a**2),a);  \par
 \par
            4 \par
  2*SQRT(- A  + 1) \par
  ----------------  \par
         4 \par
     A*(A  - 1) \par
 \par
 \par
int(asech(x),x);  \par
 \par
  INT(ASECH(X),X) \par
 \par
\pard \sl240 }{\f2 You may attach functionality by defining }{\f3 asech} {\f2  to be the inverse of 
}{\f3 sech} {\f2 . This is done by the commands 
\pard \tx3420 }{\f4  \par
        put('sech,'inverse,'asech); \par
        put('asech,'inverse,'sech); \par
\pard \sl240 }{\f2 \par 
\par 
You can write a procedure to attach integrals or other 
functions to }{\f3 asech} {\f2 . You may wish to add a check to see that its 
argument is properly restricted. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ASIN}

${\footnote \pard\plain \sl240 \fs20 $ ASIN}

+{\footnote \pard\plain \sl240 \fs20 + g11:0878}

 K{\footnote \pard\plain \sl240 \fs20 K arcsine;ASIN operator;operator}

}{\b\f2 ASIN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 asin} {\f2  operator returns the arcsine of its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 asin} {\f4 (<expression>) or }{\f3 asin} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
asin(givenangle);  \par
 \par
  ASIN(GIVENANGLE)  \par
 \par
 \par
asin(5);  \par
 \par
  ASIN(5)  \par
 \par
 \par
df(asin(2*x),x);  \par
 \par
                 2 \par
    2*SQRT( - 4*X  + 1)) \par
  - --------------------  \par
             2 \par
          4*X  - 1 \par
 \par
 \par
on rounded;  \par
 \par
asin .5;  \par
 \par
  0.523598775598  \par
 \par
 \par
asin(sqrt(3));  \par
 \par
  ASIN(1.73205080757)  \par
 \par
 \par
asin(sqrt(3)/2);  \par
 \par
  1.04719755120  \par
 \par
\pard \sl240 }{\f2 A numeric value is not returned by }{\f3 asin} {\f2  unless the switch 
}{\f3 rounded} {\f2  is on and its argument has an absolute value less than or 
equal to 1. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ASINH}

${\footnote \pard\plain \sl240 \fs20 $ ASINH}

+{\footnote \pard\plain \sl240 \fs20 + g11:0879}

 K{\footnote \pard\plain \sl240 \fs20 K hyperbolic arcsine;ASINH operator;operator}

}{\b\f2 ASINH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 asinh} {\f2  operator returns the hyperbolic arcsine of its argument. 
The derivative of }{\f3 asinh} {\f2  and some simple transformations are known 
to the system. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 asinh} {\f4 (<expression>) or }{\f3 asinh} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
asinh d;  \par
 \par
  ASINH(D)  \par
 \par
 \par
asinh(1);  \par
 \par
  ASINH(1)  \par
 \par
 \par
df(asinh(2*x),x);  \par
 \par
            2 \par
  2*SQRT(4*X  + 1)) \par
  -----------------  \par
         2 \par
      4*X  + 1 \par
 \par
\pard \sl240 }{\f2 You may attach further functionality by defining }{\f3 asinh} {\f2  to be the 
inverse of }{\f3 sinh} {\f2 . This is done by the commands 
\pard \tx3420 }{\f4  \par
        put('sinh,'inverse,'asinh); \par
        put('asinh,'inverse,'sinh); \par
\pard \sl240 }{\f2 \par 
\par 
A numeric value is not returned by }{\f3 asinh} {\f2  unless the switch 
}{\f3 rounded} {\f2  is on and its argument evaluates to a number. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ATAN}

${\footnote \pard\plain \sl240 \fs20 $ ATAN}

+{\footnote \pard\plain \sl240 \fs20 + g11:0880}

 K{\footnote \pard\plain \sl240 \fs20 K arctangent;ATAN operator;operator}

}{\b\f2 ATAN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 atan} {\f2  operator returns the arctangent of its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 atan} {\f4 (<expression>) or }{\f3 atan} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
atan(middle);  \par
 \par
  ATAN(MIDDLE)  \par
 \par
 \par
on rounded;  \par
 \par
atan 45;  \par
 \par
  1.54857776147  \par
 \par
 \par
off rounded;  \par
 \par
int(atan(x),x);  \par
 \par
                     2 \par
  2*ATAN(X)*X - LOG(X  + 1) \par
  -------------------------  \par
              2 \par
 \par
 \par
df(atan(y**2),y);  \par
 \par
   2*Y \par
  ------- \par
   4 \par
  Y  + 1 \par
 \par
\pard \sl240 }{\f2 A numeric value is not returned by }{\f3 atan} {\f2  unless the switch 
}
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on and its argument evaluates to a number. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ATANH}

${\footnote \pard\plain \sl240 \fs20 $ ATANH}

+{\footnote \pard\plain \sl240 \fs20 + g11:0881}

 K{\footnote \pard\plain \sl240 \fs20 K hyperbolic arctangent;ATANH operator;operator}

}{\b\f2 ATANH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 atanh} {\f2  operator returns the hyperbolic arctangent of its argument. 
The derivative of }{\f3 asinh} {\f2  and some simple transformations are known 
to the system. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 atanh} {\f4 (<expression>) or }{\f3 atanh} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
atanh aa;  \par
 \par
  ATANH(AA)  \par
 \par
 \par
atanh(1);  \par
 \par
  ATANH(1)  \par
 \par
 \par
df(atanh(x*y),y);  \par
 \par
     - X \par
  ---------- \par
   2  2 \par
  X *Y  - 1 \par
 \par
\pard \sl240 }{\f2 A numeric value is not returned by }{\f3 asinh} {\f2  unless the switch 
}{\f3 rounded} {\f2  is on and its argument evaluates to a number. 
You may attach additional functionality by defining }{\f3 atanh} {\f2  to be the 
inverse of }{\f3 tanh} {\f2 . This is done by the commands 
\par 
\par 
\pard \tx3420 }{\f4  \par
        put('tanh,'inverse,'atanh); \par
        put('atanh,'inverse,'tanh); \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ATAN2}

${\footnote \pard\plain \sl240 \fs20 $ ATAN2}

+{\footnote \pard\plain \sl240 \fs20 + g11:0882}

 K{\footnote \pard\plain \sl240 \fs20 K ATAN2 operator;operator}

}{\b\f2 ATAN2}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 atan2} {\f4 (<expression>,<expression>) 
\par 
\par 
}{\f2 \par 
<expression> is any valid scalar REDUCE expression. In 
}
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  mode, if a numerical value exists, }{\f3 atan2} {\f2  returns 
the principal value of the arc tangent of the second argument divided by 
the first in the range [-pi,+pi] radians, using the signs of both 
arguments to determine the quadrant of the return value. An expression in 
terms of }{\f3 atan2} {\f2  is returned in other cases. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
atan2(3,2);  \par
 \par
  ATAN2(3,2);  \par
 \par
 \par
on rounded;  \par
 \par
atan2(3,2);  \par
 \par
  0.982793723247  \par
 \par
 \par
atan2(a,b);  \par
 \par
  ATAN2(A,B);  \par
 \par
 \par
atan2(1,0);  \par
 \par
  1.57079632679 \par
 \par
\pard \sl240 }{\f2 }{\f3 atan2} {\f2 returns a numeric value only if }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on. Then 
}{\f3 atan2} {\f2  is calculated to the current degree of floating point precision. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # COS}

${\footnote \pard\plain \sl240 \fs20 $ COS}

+{\footnote \pard\plain \sl240 \fs20 + g11:0883}

 K{\footnote \pard\plain \sl240 \fs20 K COS operator;operator}

}{\b\f2 COS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 cos} {\f2  operator returns the cosine of its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 cos} {\f4 (<expression>) or }{\f3 cos} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> is any valid scalar REDUCE expression, 
<simple\_expression> is a single identifier or begins with a prefix 
operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
 \par
cos abc;  \par
 \par
  COS(ABC)  \par
 \par
 \par
 \par
cos(pi);  \par
 \par
  -1  \par
 \par
 \par
 \par
cos 4;  \par
 \par
  COS(4)  \par
 \par
 \par
 \par
on rounded;  \par
 \par
 \par
cos(4);  \par
 \par
  - 0.653643620864  \par
 \par
 \par
 \par
cos log 5;  \par
 \par
  - 0.0386319699339 \par
 \par
\pard \sl240 }{\f2 }{\f3 cos} {\f2 returns a numeric value only if }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on. Then the 
cosine is calculated to the current degree of floating point precision. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # COSH}

${\footnote \pard\plain \sl240 \fs20 $ COSH}

+{\footnote \pard\plain \sl240 \fs20 + g11:0884}

 K{\footnote \pard\plain \sl240 \fs20 K hyperbolic cosine;COSH operator;operator}

}{\b\f2 COSH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 cosh} {\f2  operator returns the hyperbolic cosine of its argument. 
The derivative of }{\f3 cosh} {\f2  and some simple transformations are known 
to the system. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 cosh} {\f4 (<expression>) or }{\f3 cosh} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
cosh b;  \par
 \par
  COSH(B)  \par
 \par
 \par
 \par
cosh(0);  \par
 \par
  1  \par
 \par
 \par
 \par
df(cosh(x*y),x);  \par
 \par
  SINH(X*Y)*Y  \par
 \par
 \par
 \par
int(cosh(x),x);  \par
 \par
  SINH(X) \par
 \par
\pard \sl240 }{\f2 You may attach further functionality by defining its inverse (see 
}
{\f2\uldb acosh}{\v\f2 ACOSH} 
{\f2 ). 
A numeric value is not returned by }{\f3 cosh} {\f2  unless the switch 
}
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on and its argument evaluates to a number. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # COT}

${\footnote \pard\plain \sl240 \fs20 $ COT}

+{\footnote \pard\plain \sl240 \fs20 + g11:0885}

 K{\footnote \pard\plain \sl240 \fs20 K COT operator;operator}

}{\b\f2 COT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
}{\f3 cot} {\f2  represents the cotangent of its argument. It takes an arbitrary 
scalar expression as its argument. The derivative of }{\f3 acot} {\f2  and some 
simple properties are known to the system. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 cot} {\f4 (<expression>) or }{\f3 cot} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression. <simple\_expression> 
must be a single identifier or begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
cot(a)*tan(a);  \par
 \par
  COT(A)*TAN(A))  \par
 \par
 \par
cot(1);  \par
 \par
  COT(1)  \par
 \par
 \par
df(cot(2*x),x);  \par
 \par
               2 \par
  - 2*(COT(2*X)   + 1) \par
 \par
\pard \sl240 }{\f2 Numerical values of expressions involving }{\f3 cot} {\f2  may be found by 
turning on the switch }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2 . 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # COTH}

${\footnote \pard\plain \sl240 \fs20 $ COTH}

+{\footnote \pard\plain \sl240 \fs20 + g11:0886}

 K{\footnote \pard\plain \sl240 \fs20 K hyperbolic cotangent;COTH operator;operator}

}{\b\f2 COTH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 coth} {\f2  operator returns the hyperbolic cotangent of its argument. 
The derivative of }{\f3 coth} {\f2  and some simple transformations are known 
to the system. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 coth} {\f4 (<expression>) or }{\f3 coth} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression. <simple\_expression> 
must be a single identifier or begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
df(coth(x*y),x);  \par
 \par
                2 \par
  - Y*(COTH(X*Y)   - 1)  \par
 \par
 \par
 \par
coth acoth z;  \par
 \par
  Z \par
 \par
\pard \sl240 }{\f2 You can write }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statements and procedures to add further 
functionality to }{\f3 coth} {\f2  if you wish. Numerical values of expressions 
involving }{\f3 coth} {\f2  may also be found by turning on the switch 
}
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2 . 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CSC}

${\footnote \pard\plain \sl240 \fs20 $ CSC}

+{\footnote \pard\plain \sl240 \fs20 + g11:0887}

 K{\footnote \pard\plain \sl240 \fs20 K cosecant;CSC operator;operator}

}{\b\f2 CSC}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 csc} {\f2  operator returns the cosecant of its argument. 
The derivative of }{\f3 csc} {\f2  and some simple transformations are known 
to the system. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 csc} {\f4 (<expression>) or }{\f3 csc} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression. <simple\_expression> 
must be a single identifier or begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
csc(q)*sin(q);  \par
 \par
  CSC(Q)*SIN(Q)  \par
 \par
 \par
 \par
df(csc(x*y),x);  \par
 \par
  -COT(X*Y)*CSC(X*Y)*Y \par
 \par
\pard \sl240 }{\f2 You can write }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statements and procedures to add further 
functionality to }{\f3 csc} {\f2  if you wish. Numerical values of expressions 
involving }{\f3 csc} {\f2  may also be found by turning on the switch 
}
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2 . 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CSCH}

${\footnote \pard\plain \sl240 \fs20 $ CSCH}

+{\footnote \pard\plain \sl240 \fs20 + g11:0888}

 K{\footnote \pard\plain \sl240 \fs20 K hyperbolic cosecan;CSCH operator;operator}

}{\b\f2 CSCH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 cosh} {\f2  operator returns the hyperbolic cosecant of its argument. 
The derivative of }{\f3 csch} {\f2  and some simple transformations are known 
to the system. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 csch} {\f4 (<expression>) or }{\f3 csch} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
csch b;  \par
 \par
  CSCH(B)  \par
 \par
 \par
 \par
csch(0);  \par
 \par
  0  \par
 \par
 \par
 \par
df(csch(x*y),x);  \par
 \par
  - COTH(X*Y)*CSCH(X*Y)*Y  \par
 \par
 \par
 \par
int(csch(x),x);  \par
 \par
  INT(CSCH(X),X) \par
 \par
\pard \sl240 }{\f2 A numeric value is not returned by }{\f3 csch} {\f2  unless the switch 
}
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on and its argument evaluates to a number. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ERF}

${\footnote \pard\plain \sl240 \fs20 $ ERF}

+{\footnote \pard\plain \sl240 \fs20 + g11:0889}

 K{\footnote \pard\plain \sl240 \fs20 K error function;ERF operator;operator}

}{\b\f2 ERF}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 erf} {\f2  operator represents the error function, defined by 
\par 
\par 
erf(x) = (2/sqrt(pi))*int(e^(-x^2),x) 
\par 
\par 
A limited number of its properties are known to the system, including the 
fact that it is an odd function. Its derivative is known, and from this, 
some integrals may be computed. However, a complete integration procedure 
for this operator is not currently included. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
erf(0);  \par
 \par
  0  \par
 \par
 \par
erf(-a);  \par
 \par
  - ERF(A)  \par
 \par
 \par
df(erf(x**2),x);  \par
 \par
  4*SQRT(PI)*X \par
  ------------  \par
       4 \par
      X \par
     E  *PI \par
 \par
 \par
 \par
int(erf(x),x);  \par
 \par
    2 \par
   X \par
  E  *ERF(X)*PI*X + SQRT(PI) \par
  --------------------------- \par
              2 \par
             X \par
            E  *PI \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # EXP}

${\footnote \pard\plain \sl240 \fs20 $ EXP}

+{\footnote \pard\plain \sl240 \fs20 + g11:0890}

 K{\footnote \pard\plain \sl240 \fs20 K exponential function;EXP operator;operator}

}{\b\f2 EXP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 exp} {\f2  operator returns }{\f3 e} {\f2  raised to the power of its argument. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 exp} {\f4 (<expression>) or }{\f3 exp} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE scalar expression. 
<simple\_expression> must be a single identifier or begin with a 
prefix operator. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
exp(sin(x));  \par
 \par
   SIN X \par
  E       \par
 \par
 \par
exp(11);  \par
 \par
   11 \par
  E    \par
 \par
 \par
on rounded;  \par
 \par
exp sin(pi/3);  \par
 \par
  2.37744267524 \par
 \par
\pard \sl240 }{\f2 Numeric values are returned only when }{\f3 rounded} {\f2  is on. 
The single letter }{\f3 e} {\f2  with the exponential operator }{\f3 ^} {\f2  or 
}{\f3 **} {\f2  may be substituted for }{\f3 exp} {\f2  without change of function. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SEC}

${\footnote \pard\plain \sl240 \fs20 $ SEC}

+{\footnote \pard\plain \sl240 \fs20 + g11:0891}

 K{\footnote \pard\plain \sl240 \fs20 K SEC operator;operator}

}{\b\f2 SEC}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 sec} {\f2  operator returns the secant of its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 sec} {\f4 (<expression>) or }{\f3 sec} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> is any valid scalar REDUCE expression, 
<simple\_expression> is a single identifier or begins with a prefix 
operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
 \par
sec abc;  \par
 \par
  SEC(ABC)  \par
 \par
 \par
 \par
sec(pi);  \par
 \par
  -1  \par
 \par
 \par
 \par
sec 4;  \par
 \par
  SEC(4)  \par
 \par
 \par
 \par
on rounded;  \par
 \par
 \par
sec(4);  \par
 \par
  - 1.52988565647  \par
 \par
 \par
 \par
sec log 5;  \par
 \par
  - 25.8852966005 \par
 \par
\pard \sl240 }{\f2 }{\f3 sec} {\f2 returns a numeric value only if }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on. Then the 
secant is calculated to the current degree of floating point precision. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SECH}

${\footnote \pard\plain \sl240 \fs20 $ SECH}

+{\footnote \pard\plain \sl240 \fs20 + g11:0892}

 K{\footnote \pard\plain \sl240 \fs20 K hyperbolic secant;SECH operator;operator}

}{\b\f2 SECH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 sech} {\f2  operator returns the hyperbolic secant of its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 sech} {\f4 (<expression>) or }{\f3 sech} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> is any valid scalar REDUCE expression, 
<simple\_expression> is a single identifier or begins with a prefix 
operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
sech abc;  \par
 \par
  SECH(ABC)  \par
 \par
 \par
 \par
sech(0);  \par
 \par
  1  \par
 \par
 \par
 \par
sech 4;  \par
 \par
  SECH(4)  \par
 \par
 \par
 \par
on rounded;  \par
 \par
 \par
sech(4);  \par
 \par
  0.0366189934737  \par
 \par
 \par
 \par
sech log 5;  \par
 \par
  0.384615384615 \par
 \par
\pard \sl240 }{\f2 }{\f3 sech} {\f2 returns a numeric value only if }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on. Then the 
expression is calculated to the current degree of floating point precision. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SIN}

${\footnote \pard\plain \sl240 \fs20 $ SIN}

+{\footnote \pard\plain \sl240 \fs20 + g11:0893}

 K{\footnote \pard\plain \sl240 \fs20 K sine;SIN operator;operator}

}{\b\f2 SIN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 sin} {\f2  operator returns the sine of its argument. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 sin} {\f4 (<expression>) or }{\f3 sin} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> is any valid scalar REDUCE expression, 
<simple\_expression> is a single identifier or begins with a prefix 
operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
sin aa;  \par
 \par
  SIN(AA)  \par
 \par
 \par
sin(pi/2);  \par
 \par
  1  \par
 \par
 \par
on rounded;  \par
 \par
sin 3;  \par
 \par
  0.14112000806  \par
 \par
 \par
sin(pi/2);  \par
 \par
  1.0 \par
 \par
\pard \sl240 }{\f2 }{\f3 sin} {\f2 returns a numeric value only if }{\f3 rounded} {\f2  is on. 
Then the sine is calculated to the current degree of floating point precision. 
The argument in this case is assumed to be in radians. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SINH}

${\footnote \pard\plain \sl240 \fs20 $ SINH}

+{\footnote \pard\plain \sl240 \fs20 + g11:0894}

 K{\footnote \pard\plain \sl240 \fs20 K hyperbolic sine;SINH operator;operator}

}{\b\f2 SINH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 sinh} {\f2  operator returns the hyperbolic sine of its argument. 
The derivative of }{\f3 sinh} {\f2  and some simple transformations are known 
to the system. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 sinh} {\f4 (<expression>) or }{\f3 sinh} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
sinh b;  \par
 \par
  SINH(B)  \par
 \par
 \par
 \par
sinh(0);  \par
 \par
  0  \par
 \par
 \par
df(sinh(x**2),x);  \par
 \par
          2 \par
  2*COSH(X )*X  \par
 \par
 \par
int(sinh(4*x),x);  \par
 \par
  COSH(4*X) \par
  ---------  \par
      4 \par
 \par
 \par
on rounded;  \par
 \par
sinh 4;  \par
 \par
  27.2899171971 \par
 \par
\pard \sl240 }{\f2 You may attach further functionality by defining its inverse (see 
}
{\f2\uldb asinh}{\v\f2 ASINH} 
{\f2 ). 
A numeric value is not returned by }{\f3 sinh} {\f2  unless the switch 
}
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on and its argument evaluates to a number. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TAN}

${\footnote \pard\plain \sl240 \fs20 $ TAN}

+{\footnote \pard\plain \sl240 \fs20 + g11:0895}

 K{\footnote \pard\plain \sl240 \fs20 K TAN operator;operator}

}{\b\f2 TAN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 tan} {\f2  operator returns the tangent of its argument. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 tan} {\f4 (<expression>) or }{\f3 tan} {\f4  <simple\_expression> 
\par 
\par 
\par 
\par 
}{\f2 <expression> is any valid scalar REDUCE expression, 
<simple\_expression> is a single identifier or begins with a prefix 
operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
tan a;  \par
 \par
  TAN(A)  \par
 \par
 \par
tan(pi/5);  \par
 \par
      PI \par
  TAN(--)  \par
      5 \par
 \par
 \par
on rounded; \par
tan(pi/5);  \par
 \par
  0.726542528005 \par
 \par
\pard \sl240 }{\f2 }{\f3 tan} {\f2 returns a numeric value only if }{\f3 rounded} {\f2  is on. Then the 
tangent is calculated to the current degree of floating point accuracy. 
\par 
\par 
When }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on, 
no check is made to see if the argument of }{\f3 tan} {\f2  is a multiple of 
}{\f4 pi/2}{\f2 , for which the tangent goes to positive or negative infinity. 
(Of course, since REDUCE uses a fixed-point representation of }{\f4 pi/2}{\f2 , 
it produces a large but not infinite number.) You need to make a check for 
multiples of }{\f4 pi/2}{\f2  in any program you use that might possibly ask 
for the tangent of such a quantity. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TANH}

${\footnote \pard\plain \sl240 \fs20 $ TANH}

+{\footnote \pard\plain \sl240 \fs20 + g11:0896}

 K{\footnote \pard\plain \sl240 \fs20 K hyperbolic tangent;TANH operator;operator}

}{\b\f2 TANH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 tanh} {\f2  operator returns the hyperbolic tangent of its argument. 
The derivative of }{\f3 tanh} {\f2  and some simple transformations are known 
to the system. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 tanh} {\f4 (<expression>) or }{\f3 tanh} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> may be any scalar REDUCE expression, not an array, matrix or 
vector expression. <simple\_expression> must be a single identifier or 
begin with a prefix operator name. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
tanh b;  \par
 \par
  TANH(B)  \par
 \par
 \par
tanh(0);  \par
 \par
  0  \par
 \par
 \par
df(tanh(x*y),x);  \par
 \par
                 2 \par
  Y*( - TANH(X*Y)  + 1)  \par
 \par
 \par
int(tanh(x),x);  \par
 \par
       2*X \par
  LOG(E    + 1) - X  \par
 \par
 \par
on rounded; tanh 2;  \par
 \par
  0.964027580076 \par
 \par
\pard \sl240 }{\f2 You may attach further functionality by defining its inverse (see 
}
{\f2\uldb atanh}{\v\f2 ATANH} 
{\f2 ). 
A numeric value is not returned by }{\f3 tanh} {\f2  unless the switch 
}
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on and its argument evaluates to a number. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g11}

${\footnote \pard\plain \sl240 \fs20 $ Elementary Functions}

+{\footnote \pard\plain \sl240 \fs20 + index:0011}
}{\b\f2 Elementary Functions}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb ACOS operator}
{\v\f2 ACOS}{\f2 \par 
}{\f2 \tab}{\f2\uldb ACOSH operator}
{\v\f2 ACOSH}{\f2 \par 
}{\f2 \tab}{\f2\uldb ACOT operator}
{\v\f2 ACOT}{\f2 \par 
}{\f2 \tab}{\f2\uldb ACOTH operator}
{\v\f2 ACOTH}{\f2 \par 
}{\f2 \tab}{\f2\uldb ACSC operator}
{\v\f2 ACSC}{\f2 \par 
}{\f2 \tab}{\f2\uldb ACSCH operator}
{\v\f2 ACSCH}{\f2 \par 
}{\f2 \tab}{\f2\uldb ASEC operator}
{\v\f2 ASEC}{\f2 \par 
}{\f2 \tab}{\f2\uldb ASECH operator}
{\v\f2 ASECH}{\f2 \par 
}{\f2 \tab}{\f2\uldb ASIN operator}
{\v\f2 ASIN}{\f2 \par 
}{\f2 \tab}{\f2\uldb ASINH operator}
{\v\f2 ASINH}{\f2 \par 
}{\f2 \tab}{\f2\uldb ATAN operator}
{\v\f2 ATAN}{\f2 \par 
}{\f2 \tab}{\f2\uldb ATANH operator}
{\v\f2 ATANH}{\f2 \par 
}{\f2 \tab}{\f2\uldb ATAN2 operator}
{\v\f2 ATAN2}{\f2 \par 
}{\f2 \tab}{\f2\uldb COS operator}
{\v\f2 COS}{\f2 \par 
}{\f2 \tab}{\f2\uldb COSH operator}
{\v\f2 COSH}{\f2 \par 
}{\f2 \tab}{\f2\uldb COT operator}
{\v\f2 COT}{\f2 \par 
}{\f2 \tab}{\f2\uldb COTH operator}
{\v\f2 COTH}{\f2 \par 
}{\f2 \tab}{\f2\uldb CSC operator}
{\v\f2 CSC}{\f2 \par 
}{\f2 \tab}{\f2\uldb CSCH operator}
{\v\f2 CSCH}{\f2 \par 
}{\f2 \tab}{\f2\uldb ERF operator}
{\v\f2 ERF}{\f2 \par 
}{\f2 \tab}{\f2\uldb EXP operator}
{\v\f2 EXP}{\f2 \par 
}{\f2 \tab}{\f2\uldb SEC operator}
{\v\f2 SEC}{\f2 \par 
}{\f2 \tab}{\f2\uldb SECH operator}
{\v\f2 SECH}{\f2 \par 
}{\f2 \tab}{\f2\uldb SIN operator}
{\v\f2 SIN}{\f2 \par 
}{\f2 \tab}{\f2\uldb SINH operator}
{\v\f2 SINH}{\f2 \par 
}{\f2 \tab}{\f2\uldb TAN operator}
{\v\f2 TAN}{\f2 \par 
}{\f2 \tab}{\f2\uldb TANH operator}
{\v\f2 TANH}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SWITCHES}

${\footnote \pard\plain \sl240 \fs20 $ SWITCHES}

+{\footnote \pard\plain \sl240 \fs20 + g12:0897}

 K{\footnote \pard\plain \sl240 \fs20 K SWITCHES introduction;introduction}

}{\b\f2 SWITCHES}{\f2 \tab \tab \tab \tab }{\b\f2 introduction}{\f2 \par 
\par 
 
Switches are set on or off using the commands }
{\f2\uldb on}{\v\f2 ON} 
{\f2  or 
}
{\f2\uldb off}{\v\f2 OFF} 
{\f2 , respectively. 
The default setting of the switches described in this section is 
}
{\f2\uldb off}{\v\f2 OFF} 
{\f2  unless stated otherwise. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ALGINT}

${\footnote \pard\plain \sl240 \fs20 $ ALGINT}

+{\footnote \pard\plain \sl240 \fs20 + g12:0898}

 K{\footnote \pard\plain \sl240 \fs20 K integration;ALGINT switch;switch}

}{\b\f2 ALGINT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 algint} {\f2  switch is on, the algebraic integration module (which 
must be loaded from the REDUCE library) is used for integration. 
\par 
\par 
Loading }{\f3 algint} {\f2  from the library automatically turns on the 
}{\f3 algint} {\f2  switch. An error message will be given if }{\f3 algint} {\f2  is 
turned on when the }{\f3 algint} {\f2  has not been loaded from the library. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ALLBRANCH}

${\footnote \pard\plain \sl240 \fs20 $ ALLBRANCH}

+{\footnote \pard\plain \sl240 \fs20 + g12:0899}

 K{\footnote \pard\plain \sl240 \fs20 K ALLBRANCH switch;switch}

}{\b\f2 ALLBRANCH}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
When }{\f3 allbranch} {\f2  is on, the operator }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  selects all 
branches of solutions. 
When }{\f3 allbranch} {\f2  is off, it selects only the principal 
branches. Default is }{\f3 on} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
solve(log(sin(x+3)),x);  \par
 \par
  \{X=2*ARBINT(1)*PI - ASIN(1) - 3, \par
   X=2*ARBINT(1)*PI + ASIN(1) + PI - 3\} \par
 \par
 \par
off allbranch;  \par
 \par
solve(log(sin(x+3)),x);  \par
 \par
  X=ASIN(1) - 3 \par
 \par
\pard \sl240 }{\f2 }
{\f2\uldb arbint}{\v\f2 ARBINT} 
{\f2 (1) indicates an arbitrary integer, which is given a 
unique identifier by REDUCE, showing that there are infinitely many 
solutions of this type. When }{\f3 allbranch} {\f2  is off, the single 
canonical solution is given. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ALLFAC}

${\footnote \pard\plain \sl240 \fs20 $ ALLFAC}

+{\footnote \pard\plain \sl240 \fs20 + g12:0900}

 K{\footnote \pard\plain \sl240 \fs20 K output;ALLFAC switch;switch}

}{\b\f2 ALLFAC}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 allfac} {\f2  switch, when on, causes REDUCE to factor out automatically 
common products in the output of expressions. Default is }{\f3 on} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
x + x*y**3 + x**2*cos(z);  \par
 \par
                 3 \par
  X*(COS(Z)*X + Y   + 1)  \par
 \par
 \par
off allfac;  \par
 \par
x + x*y**3 + x**2*cos(z);  \par
 \par
          2      3 \par
  COS(Z)*X  + X*Y   + X \par
 \par
\pard \sl240 }{\f2 The }{\f3 allfac} {\f2  switch has no effect when }{\f3 pri} {\f2  is off. Although the 
switch setting stays as it was, printing behavior is as if it were off. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ARBVARS}

${\footnote \pard\plain \sl240 \fs20 $ ARBVARS}

+{\footnote \pard\plain \sl240 \fs20 + g12:0901}

 K{\footnote \pard\plain \sl240 \fs20 K solve;ARBVARS switch;switch}

}{\b\f2 ARBVARS}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 arbvars} {\f2  is on, the solutions of singular or underdetermined 
systems of equations are presented in terms of arbitrary complex variables 
(see }
{\f2\uldb arbcomplex}{\v\f2 ARBCOMPLEX} 
{\f2 ). Otherwise, the solution is parametrized in 
terms of some of the input variables. Default is }{\f3 on} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
solve(\{2x + y,4x + 2y\},\{x,y\});  \par
 \par
         arbcomplex(1) \par
  \{\{x= - -------------,y=arbcomplex(1)\}\}  \par
               2 \par
 \par
 \par
solve(\{sqrt(x)+ y**3-1\},\{x,y\});				 \par
 \par
 \par
                            6       3 \par
  		   \{\{y=arbcomplex(2),x=y   - 2*y   + 1\}\}  \par
 \par
 \par
off arbvars;  \par
 \par
solve(\{2x + y,4x + 2y\},\{x,y\});  \par
 \par
         y \par
  \{\{x= - -\}\}  \par
         2 \par
 \par
 \par
solve(\{sqrt(x)+ y**3-1\},\{x,y\});				 \par
 \par
 \par
            6       3 \par
  		   \{\{x=y   - 2*y   + 1\}\}  \par
 \par
\pard \sl240 }{\f2 With }{\f3 arbvars} {\f2  off, the return value }{\f3 \{\{\}\}} {\f2  means that the 
equations given to }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  imply no relation among the input 
variables. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # BALANCED\_MOD}

${\footnote \pard\plain \sl240 \fs20 $ BALANCED_MOD}

+{\footnote \pard\plain \sl240 \fs20 + g12:0902}

 K{\footnote \pard\plain \sl240 \fs20 K modular;BALANCED_MOD switch;switch}

}{\b\f2 BALANCED\_MOD}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
}
{\f2\uldb modular}{\v\f2 MODULAR} 
{\f2 numbers are normally produced in the range [0,...<n>), 
where 
<n> is the current modulus. With }{\f3 balanced_mod} {\f2  on, the range 
[-<n>/2,<n>/2], or more precisely 
[-floor((<n>-1)/2), ceiling((<n>-1)/2)], is used instead. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
setmod 7;  \par
 \par
  1  \par
 \par
 \par
on modular;  \par
 \par
4;  \par
 \par
  4  \par
 \par
 \par
on balanced_mod;  \par
 \par
4;  \par
 \par
  -3 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # BFSPACE}

${\footnote \pard\plain \sl240 \fs20 $ BFSPACE}

+{\footnote \pard\plain \sl240 \fs20 + g12:0903}

 K{\footnote \pard\plain \sl240 \fs20 K floating point;output;BFSPACE switch;switch}

}{\b\f2 BFSPACE}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
Floating point numbers are normally printed in a compact notation (either 
fixed point or in scientific notation if }
{\f2\uldb SCIENTIFIC_NOTATION}{\v\f2 SCIENTIFIC\_NOTATION} 
{\f2  
has been used). In some (but not all) cases, it helps comprehensibility 
if spaces are inserted in the number at regular intervals. The switch 
}{\f3 bfspace} {\f2 , if on, will cause a blank to be inserted in the number after 
every five characters. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
1.2345678;  \par
 \par
  1.2345678  \par
 \par
 \par
on bfspace;  \par
 \par
1.2345678;  \par
 \par
  1.234 5678 \par
 \par
\pard \sl240 }{\f2 \par 
\par 
}{\f3 bfspace} {\f2 is normally off. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # COMBINEEXPT}

${\footnote \pard\plain \sl240 \fs20 $ COMBINEEXPT}

+{\footnote \pard\plain \sl240 \fs20 + g12:0904}

 K{\footnote \pard\plain \sl240 \fs20 K exponent simplification;COMBINEEXPT switch;switch}

}{\b\f2 COMBINEEXPT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
REDUCE is in general poor at surd simplification. However, when the 
switch }{\f3 combineexpt} {\f2  is on, the system attempts to combine 
exponentials whenever possible. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
3^(1/2)*3^(1/3)*3^(1/6);  \par
 \par
           1/3  1/6 \par
  SQRT(3)*3   *3     \par
 \par
 \par
on combineexpt;  \par
 \par
ws;  \par
 \par
  1 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # COMBINELOGS}

${\footnote \pard\plain \sl240 \fs20 $ COMBINELOGS}

+{\footnote \pard\plain \sl240 \fs20 + g12:0905}

 K{\footnote \pard\plain \sl240 \fs20 K logarithm;COMBINELOGS switch;switch}

}{\b\f2 COMBINELOGS}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
In many cases it is desirable to expand product arguments of logarithms, 
or collect a sum of logarithms into a single logarithm. Since these are 
inverse operations, it is not possible to provide rules for doing both at 
the same time and preserve the REDUCE concept of idempotent evaluation. 
As an alternative, REDUCE provides two switches }
{\f2\uldb expandlogs}{\v\f2 EXPANDLOGS} 
{\f2  and 
}{\f3 combinelogs} {\f2  to carry out these operations. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on expandlogs;  \par
 \par
log(x*y);  \par
 \par
  LOG(X) + LOG(Y)  \par
 \par
 \par
on combinelogs;  \par
 \par
ws;  \par
 \par
  LOG(X*Y) \par
 \par
\pard \sl240 }{\f2 \par 
\par 
At the present time, it is possible to have both switches on at once, 
which could lead to infinite recursion. However, an expression is 
switched from one form to the other in this case. Users should not rely 
on this behavior, since it may change in the next release. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # COMP}

${\footnote \pard\plain \sl240 \fs20 $ COMP}

+{\footnote \pard\plain \sl240 \fs20 + g12:0906}

 K{\footnote \pard\plain \sl240 \fs20 K compiler;COMP switch;switch}

}{\b\f2 COMP}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 comp} {\f2  is on, any succeeding function definitions are compiled 
into a faster-running form. Default is }{\f3 off} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4 \pard \sl240 }{\f2 The following procedure finds Fibonacci numbers recursively. 
Create a new file ``refib" in your current directory with the following 
lines in it:}{\f4 \pard \tx3420   \par
 \par
procedure refib(n); \par
   if fixp n and n >= 0 then \par
     if n <= 1 then 1 \par
       else refib(n-1) + refib(n-2) \par
    else rederr "nonnegative integer only"; \par
 \par
end; \par
\pard \sl240  \par
\pard \sl240 }{\f2 Now load REDUCE and run the following:}{\f4 \pard \tx3420  \par
 \par
on time;  \par
 \par
  Time: 100 ms  \par
 \par
 \par
 \par
in "refib"$  \par
 \par
  Time: 0 ms  \par
 \par
 \par
 \par
  \par
 \par
  REFIB  \par
 \par
 \par
 \par
  \par
 \par
  Time: 260 ms  \par
 \par
 \par
 \par
  \par
 \par
  Time: 20 ms  \par
 \par
 \par
 \par
refib(80);  \par
 \par
  37889062373143906  \par
 \par
 \par
 \par
  \par
 \par
  Time: 14840 ms  \par
 \par
 \par
 \par
on comp;  \par
 \par
  Time: 80 ms  \par
 \par
 \par
 \par
in "refib"$  \par
 \par
  Time: 20 ms  \par
 \par
 \par
 \par
  \par
 \par
  REFIB  \par
 \par
 \par
 \par
  \par
 \par
  Time: 640 ms  \par
 \par
 \par
 \par
refib(80);  \par
 \par
  37889062373143906  \par
 \par
 \par
 \par
  \par
 \par
  Time: 10940 ms \par
 \par
\pard \sl240 }{\f2  
\par 
\par 
Note that the compiled procedure runs faster. Your time messages will 
differ depending upon which system you have. Compiled functions remain so 
for the duration of the REDUCE session, and are then lost. They must be 
recompiled if wanted in another session. With the switch }
{\f2\uldb time}{\v\f2 TIME} 
{\f2  on 
as shown above, the CPU time used in executing the command is returned in 
milliseconds. Be careful not to leave }{\f3 comp} {\f2  on unless you want it, 
as it makes the processing of procedures much slower. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # COMPLEX}

${\footnote \pard\plain \sl240 \fs20 $ COMPLEX}

+{\footnote \pard\plain \sl240 \fs20 + g12:0907}

 K{\footnote \pard\plain \sl240 \fs20 K complex;COMPLEX switch;switch}

}{\b\f2 COMPLEX}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 complex} {\f2  switch is on, full complex arithmetic is used in 
simplification, function evaluation, and factorization. Default is }{\f3 off} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
factorize(a**2 + b**2);  \par
 \par
     2     2 \par
  \{\{A   + B ,1\}\}  \par
 \par
 \par
on complex;  \par
 \par
 \par
factorize(a**2 + b**2);  \par
 \par
  \{\{A + I*B,1\},\{A - I*B,1\}\}  \par
 \par
 \par
 \par
(x**2 + y**2)/(x + i*y);  \par
 \par
  X - I*Y  \par
 \par
 \par
 \par
on rounded;  \par
 \par
      *** Domain mode COMPLEX changed to COMPLEX_FLOAT  \par
 \par
 \par
 \par
sqrt(-17);  \par
 \par
  4.12310562562*I  \par
 \par
 \par
 \par
log(7*i);  \par
 \par
  1.94591014906 + 1.57079632679*I \par
 \par
\pard \sl240 }{\f2 Complex floating-point can be done by turning on }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  in 
addition to }{\f3 complex} {\f2 . With }{\f3 complex} {\f2  off however, REDUCE knows 
that i is the square root of -1 but will not 
carry out more complicated complex operations. If you want complex 
denominators cleared by multiplication by their conjugates, turn on the 
switch }
{\f2\uldb rationalize}{\v\f2 RATIONALIZE} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CREF}

${\footnote \pard\plain \sl240 \fs20 $ CREF}

+{\footnote \pard\plain \sl240 \fs20 + g12:0908}

 K{\footnote \pard\plain \sl240 \fs20 K cross reference;CREF switch;switch}

}{\b\f2 CREF}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
The switch }{\f3 cref} {\f2  invokes the CREF cross-reference program that 
processes a set of procedure definitions to produce a summary of their 
entry points, undefined procedures, non-local variables and so on. The 
program will also check that procedures are called with a consistent 
number of arguments, and print a diagnostic message otherwise. 
\par 
\par 
The output is alphabetized on the first seven characters of each function 
name. 
\par 
\par 
To invoke the cross-reference program, }{\f3 cref} {\f2  is first turned on. 
This causes the program to load and the cross-referencing process to 
begin. After all the required definitions are loaded, turning }{\f3 cref} {\f2  
off will cause a cross-reference listing to be produced. 
\par 
\par 
Algebraic procedures in REDUCE are treated as if they were symbolic, so 
that algebraic constructs will actually appear as calls to symbolic 
functions, such as }{\f3 aeval} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CRAMER}

${\footnote \pard\plain \sl240 \fs20 $ CRAMER}

+{\footnote \pard\plain \sl240 \fs20 + g12:0909}

 K{\footnote \pard\plain \sl240 \fs20 K solve;linear system;matrix;CRAMER switch;switch}

}{\b\f2 CRAMER}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 cramer} {\f2  switch is on, }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  inversion 
and linear equation 
solving (operator }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2 ) is done by Cramer's rule, through exterior 
multiplication. Default is }{\f3 off} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on time;  \par
 \par
  Time: 80 ms  \par
 \par
 \par
off output;  \par
 \par
  Time: 100 ms  \par
 \par
 \par
mm := mat((a,b,c,d,f),(a,a,c,f,b),(b,c,a,c,d), (c,c,a,b,f), \par
          (d,a,d,e,f)); \par
\pard \sl240   \par
 \par
  Time: 300 ms  \par
 \par
 \par
inverse := 1/mm;  \par
 \par
  Time: 18460 ms  \par
 \par
 \par
on cramer;  \par
 \par
  Time: 80 ms  \par
 \par
 \par
cramersinv := 1/mm;  \par
 \par
  Time: 9260 ms \par
 \par
\pard \sl240 }{\f2 Your time readings will vary depending on the REDUCE version you use. 
After you invert the matrix, turn on }
{\f2\uldb output}{\v\f2 OUTPUT} 
{\f2  and ask for one of 
the elements of the inverse matrix, such as }{\f3 cramersinv(3,2)} {\f2 , so that 
you can see the size of the expressions produced. 
\par 
\par 
Inversion of matrices and the solution of linear equations with dense 
symbolic entries in many variables is generally considerably faster with 
}{\f3 cramer} {\f2  on. However, inversion of numeric-valued matrices is 
slower. Consider the matrices you're inverting before deciding whether to 
turn }{\f3 cramer} {\f2  on or off. A substantial portion of the time in matrix 
inversion is given to formatting the results for printing. To save this 
time, turn }{\f3 output} {\f2  off, as shown in this example or terminate the 
expression with a dollar sign instead of a semicolon. The results are 
still available to you in the workspace associated with your prompt 
number, or you can assign them to an identifier for further use. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DEFN}

${\footnote \pard\plain \sl240 \fs20 $ DEFN}

+{\footnote \pard\plain \sl240 \fs20 + g12:0910}

 K{\footnote \pard\plain \sl240 \fs20 K lisp;DEFN switch;switch}

}{\b\f2 DEFN}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the switch }{\f3 defn} {\f2  is on, the Standard Lisp equivalent of the 
input statement or procedure is printed, but not evaluated. Default is 
}{\f3 off} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
on defn;  \par
 \par
 \par
17/3;  \par
 \par
  (AEVAL (LIST 'QUOTIENT 17 3))  \par
 \par
 \par
 \par
df(sin(x),x,2);           \par
  \par
 \par
  (AEVAL (LIST 'DF (LIST 'SIN 'X) 'X 2))  \par
 \par
 \par
procedure coshval(a); \par
   begin scalar g; \par
      g := (exp(a) + exp(-a))/2; \par
      return g \par
   end; \par
\pard \sl240   \par
 \par
  (AEVAL  \par
    (PROGN  \par
      (FLAG '(COSHVAL) 'OPFN)  \par
      (DE COSHVAL (A)  \par
        (PROG (G)  \par
          (SETQ G  \par
            (AEVAL  \par
               (LIST  \par
                  'QUOTIENT  \par
                  (LIST  \par
                     'PLUS  \par
                     (LIST 'EXP A)  \par
                     (LIST 'EXP (LIST 'MINUS A)))  \par
                  2)))  \par
         (RETURN G)))) )  \par
 \par
 \par
 \par
coshval(1);  \par
 \par
  (AEVAL (LIST 'COSHVAL 1))  \par
 \par
 \par
 \par
off defn;  \par
 \par
 \par
coshval(1);  \par
 \par
  Declare COSHVAL operator? (Y or N)  \par
 \par
 \par
 \par
n  \par
 \par
procedure coshval(a); \par
   begin scalar g; \par
      g := (exp(a) + exp(-a))/2; \par
      return g \par
   end; \par
\pard \sl240   \par
 \par
  COSHVAL  \par
 \par
 \par
 \par
on rounded;  \par
 \par
 \par
coshval(1);  \par
 \par
  1.54308063482 \par
 \par
\pard \sl240 }{\f2 The above function }{\f3 coshval} {\f2  finds the hyperbolic cosine (cosh) of its 
argument. When }{\f3 defn} {\f2  is on, you can see the Standard Lisp equivalent 
of the function, but it is not entered into the system as shown by the 
message }{\f3 Declare COSHVAL operator?} {\f2 . It must be reentered with 
}{\f3 defn} {\f2  off to be recognized. This procedure is used as an example; a 
more efficient procedure would eliminate the unnecessary local variable 
with 
\pard \tx3420 }{\f4  \par
      procedure coshval(a); \par
         (exp(a) + exp(-a))/2; \par
\pard \sl240 }{\f2 \par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DEMO}

${\footnote \pard\plain \sl240 \fs20 $ DEMO}

+{\footnote \pard\plain \sl240 \fs20 + g12:0911}

 K{\footnote \pard\plain \sl240 \fs20 K output;interactive;DEMO switch;switch}

}{\b\f2 DEMO}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 demo} {\f2  switch is used for interactive files, causing the system 
to pause after each command in the file until you type a }{\f3 Return} {\f2 . 
Default is }{\f3 off} {\f2 . 
\par 
\par 
The switch }{\f3 demo} {\f2  has no effect on top level interactive 
statements. Use it when you want to slow down operations in a file so 
you can see what is happening. 
\par 
\par 
You can either include the }{\f3 on demo} {\f2  command in the file, or enter 
it from the top level before bringing in any file. Unlike the 
}
{\f2\uldb pause}{\v\f2 PAUSE} 
{\f2  command, }{\f3 on demo} {\f2  does not permit you to interrupt 
the file for questions of your own. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DFPRINT}

${\footnote \pard\plain \sl240 \fs20 $ DFPRINT}

+{\footnote \pard\plain \sl240 \fs20 + g12:0912}

 K{\footnote \pard\plain \sl240 \fs20 K derivative;output;DFPRINT switch;switch}

}{\b\f2 DFPRINT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 dfprint} {\f2  is on, expressions in the differentiation operator 
}
{\f2\uldb df}{\v\f2 DF} 
{\f2  are printed in a more ``natural'' notation, with the 
differentiation variables appearing as subscripts. In addition, if the 
switch }
{\f2\uldb noarg}{\v\f2 NOARG} 
{\f2  is on (the default), the arguments of the 
differentiated operator are suppressed. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
operator f;  \par
 \par
df(f x,x);  \par
 \par
  DF(F(X),X);  \par
 \par
 \par
on dfprint;  \par
 \par
ws;  \par
 \par
  F   \par
   X \par
 \par
 \par
df(f(x,y),x,y);  \par
 \par
  F   \par
   Y \par
 \par
 \par
off noarg;  \par
 \par
ws;  \par
 \par
  F(X,Y) \par
        X \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # DIV}

${\footnote \pard\plain \sl240 \fs20 $ DIV}

+{\footnote \pard\plain \sl240 \fs20 + g12:0913}

 K{\footnote \pard\plain \sl240 \fs20 K output;DIV switch;switch}

}{\b\f2 DIV}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 div} {\f2  is on, the system divides any simple factors found in 
the denominator of an expression into the numerator. Default is }{\f3 off} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
on div;  \par
 \par
 \par
a := x**2/y**2;  \par
 \par
        2   -2 \par
  A := X  *Y    \par
 \par
 \par
 \par
b := a/(3*z);  \par
 \par
       1  2   -2    -1 \par
  B := -*X  *Y    *Z    \par
       3 \par
 \par
 \par
 \par
off div;  \par
 \par
 \par
a;  \par
 \par
   2 \par
  X \par
  --- \par
   2 \par
  Y \par
 \par
 \par
 \par
b;  \par
 \par
     2 \par
    X \par
  -------                                        \par
     2 \par
  3*Y  *Z \par
 \par
\pard \sl240 }{\f2 The }{\f3 div} {\f2  switch only has effect when the }
{\f2\uldb pri}{\v\f2 PRI} 
{\f2  switch is on. 
When }{\f3 pri} {\f2  is off, regardless of the setting of }{\f3 div} {\f2 , the 
printing behavior is as if }{\f3 div} {\f2  were off. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ECHO}

${\footnote \pard\plain \sl240 \fs20 $ ECHO}

+{\footnote \pard\plain \sl240 \fs20 + g12:0914}

 K{\footnote \pard\plain \sl240 \fs20 K output;ECHO switch;switch}

}{\b\f2 ECHO}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 echo} {\f2  switch is normally off for top-level entry, and on when files 
are brought in. If }{\f3 echo} {\f2  is turned on at the top level, your input 
statements are echoed to the screen (thus appearing twice). Default 
}{\f3 off} {\f2  (but note default }{\f3 on} {\f2  for files). 
\par 
\par 
If you want to display certain portions of a file and not others, use the 
commands }{\f3 off echo} {\f2  and }{\f3 on echo} {\f2  inside the file. If you want 
no display of the file, use the input command 
\par 
\par 
	}{\f3 in} {\f2  filename}{\f3 $} {\f2  
\par 
\par 
rather than using the semicolon delimiter. 
\par 
\par 
Be careful when you use commands within a file to generate another file. 
Since }{\f3 echo} {\f2  is on for files, the output file echoes input statements 
(unlike its behavior from the top level). You should explicitly turn off 
}{\f3 echo} {\f2  when writing output, and turn it back on when you're done. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ERRCONT}

${\footnote \pard\plain \sl240 \fs20 $ ERRCONT}

+{\footnote \pard\plain \sl240 \fs20 + g12:0915}

 K{\footnote \pard\plain \sl240 \fs20 K error handling;ERRCONT switch;switch}

}{\b\f2 ERRCONT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 errcont} {\f2  switch is on, error conditions do not stop file 
execution. Error messages will be printed whether }{\f3 errcont} {\f2  is on or 
off. 
\par 
\par 
Default is }{\f3 off} {\f2 . 
\par 
\par 
The following describes what happens when an error occurs in a file under 
each setting of }{\f3 errcont} {\f2  and }{\f3 int} {\f2 : 
\par 
\par 
Both off: Message is printed and parsing continues, but no further 
statements are executed; no commands from keyboard accepted except bye or 
end; 
\par 
\par 
}{\f3 errcont} {\f2 off, }{\f3 int} {\f2  on: Message is printed, and you are asked 
if you wish to continue. (This is the default behavior); 
\par 
\par 
}{\f3 errcont} {\f2 on, }{\f3 int} {\f2  off: Message is printed, and file continues 
to execute without pause; 
\par 
\par 
Both on: Message is printed, and file continues to execute without pause. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EVALLHSEQP}

${\footnote \pard\plain \sl240 \fs20 $ EVALLHSEQP}

+{\footnote \pard\plain \sl240 \fs20 + g12:0916}

 K{\footnote \pard\plain \sl240 \fs20 K equation;EVALLHSEQP switch;switch}

}{\b\f2 EVALLHSEQP}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
Under normal circumstances, the right-hand-side of an }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2  
is evaluated but not the left-hand-side. This also applies to any 
substitutions made by the }
{\f2\uldb sub}{\v\f2 SUB} 
{\f2  operator. If both sides are to be 
evaluated, the switch }{\f3 evallhseqp} {\f2  should be turned on. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EXP_switch}

${\footnote \pard\plain \sl240 \fs20 $ EXP_switch}

+{\footnote \pard\plain \sl240 \fs20 + g12:0917}

 K{\footnote \pard\plain \sl240 \fs20 K simplification;EXP switch;switch}

}{\b\f2 EXP}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 exp} {\f2  switch is on, powers and products of expressions are 
expanded. Default is }{\f3 on} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
(x+1)**3;  \par
 \par
   3      2 \par
  X  + 3*X  + 3*X + 1  \par
 \par
 \par
(a + b*i)*(c + d*i);  \par
 \par
  A*C + A*D*I + B*C*I - B*D  \par
 \par
 \par
off exp;  \par
 \par
(x+1)**3;  \par
 \par
         3 \par
  (X + 1)   \par
 \par
 \par
(a + b*i)*(c + d*i);  \par
 \par
  (A + B*I)*(C + D*I)  \par
 \par
 \par
length((x+1)**2/(y+1));  \par
 \par
  2 \par
 \par
\pard \sl240 }{\f2 Note that REDUCE knows that i^2 = -1. 
When }{\f3 exp} {\f2  is off, equivalent expressions may not simplify to the same 
form, although zero expressions still simplify to zero. Several operators 
that expect a polynomial argument behave differently when }{\f3 exp} {\f2  is 
off, such as }
{\f2\uldb length}{\v\f2 LENGTH} 
{\f2 . Be cautious about leaving }{\f3 exp} {\f2  off. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EXPANDLOGS}

${\footnote \pard\plain \sl240 \fs20 $ EXPANDLOGS}

+{\footnote \pard\plain \sl240 \fs20 + g12:0918}

 K{\footnote \pard\plain \sl240 \fs20 K logarithm;EXPANDLOGS switch;switch}

}{\b\f2 EXPANDLOGS}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
In many cases it is desirable to expand product arguments of logarithms, 
or collect a sum of logarithms into a single logarithm. Since these are 
inverse operations, it is not possible to provide rules for doing both at 
the same time and preserve the REDUCE concept of idempotent evaluation. 
As an alternative, REDUCE provides two switches }{\f3 expandlogs} {\f2  and 
}
{\f2\uldb combinelogs}{\v\f2 COMBINELOGS} 
{\f2  to carry out these operations. Both are off by default. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on expandlogs;  \par
 \par
log(x*y);  \par
 \par
  LOG(X) + LOG(Y)  \par
 \par
 \par
on combinelogs;  \par
 \par
ws;  \par
 \par
  LOG(X*Y) \par
 \par
\pard \sl240 }{\f2 \par 
\par 
At the present time, it is possible to have both switches on at once, 
which could lead to infinite recursion. However, an expression is 
switched from one form to the other in this case. Users should not rely 
on this behavior, since it may change in the next release. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EZGCD}

${\footnote \pard\plain \sl240 \fs20 $ EZGCD}

+{\footnote \pard\plain \sl240 \fs20 + g12:0919}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;greatest common divisor;EZGCD switch;switch}

}{\b\f2 EZGCD}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 ezgcd} {\f2  and }
{\f2\uldb gcd}{\v\f2 GCD} 
{\f2  are on, greatest common divisors are 
computed using the EZ GCD algorithm that uses modular arithmetic (and is 
usually faster). Default is }{\f3 off} {\f2 . 
\par 
\par 
As a side effect of the gcd calculation, the expressions involved are 
factored, though not the heavy-duty factoring of }
{\f2\uldb factorize}{\v\f2 FACTORIZE} 
{\f2 . The 
EZ GCD algorithm was introduced in a paper by J. Moses and D.Y.Y. Yun in 
<Proceedings of the ACM>, 1973, pp. 159-166. 
\par 
\par 
Note that the }
{\f2\uldb gcd}{\v\f2 GCD} 
{\f2  switch must also be on for }{\f3 ezgcd} {\f2  to have 
effect. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FACTOR}

${\footnote \pard\plain \sl240 \fs20 $ FACTOR}

+{\footnote \pard\plain \sl240 \fs20 + g12:0920}

 K{\footnote \pard\plain \sl240 \fs20 K output;FACTOR switch;switch}

}{\b\f2 FACTOR}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 factor} {\f2  switch is on, input expressions and results are 
automatically factored. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
on factor;  \par
 \par
 \par
aa := 3*x**3*a + 6*x**2*y*a + 3*x**3*b + 6*x**2*y*b \par
 \par
+ x*y*a + 2*y**2*a + x*y*b + 2*y**2*b; \par
			  \par
 \par
 \par
                    2 \par
  AA := (A + B)*(3*X  + Y)*(X + 2*Y)  \par
 \par
 \par
off factor;  \par
 \par
aa;  \par
 \par
       3        2                  2         3        2 \par
  3*A*X  + 6*A*X *Y + A*X*Y + 2*A*Y   + 3*B*X  + 6*B*X *Y \par
 \par
 \par
+ B*X*Y + 2*B*Y^\{2\}  \par
 \par
on factor;  \par
 \par
ab := x**2 - 2;  \par
 \par
         2 \par
  AB := X  - 2 \par
 \par
\pard \sl240 }{\f2 REDUCE factors univariate and multivariate polynomials with 
integer coefficients, finding any factors that also have integer coefficients. 
The factoring is done by reducing multivariate problems to univariate 
ones with symbolic coefficients, and then solving the univariate ones modulo 
small primes. The results of these calculations are merged to 
determine the factors of the original polynomial. The factorizer normally 
selects evaluation points and primes using a random number generator. 
Thus, the detailed factoring behavior may be different each time any 
particular problem is tackled. 
\par 
\par 
When the }{\f3 factor} {\f2  switch is turned on, the }
{\f2\uldb exp}{\v\f2 EXP} 
{\f2  switch is 
turned off, and when the }{\f3 factor} {\f2  switch is turned off, the 
}
{\f2\uldb exp}{\v\f2 EXP} 
{\f2  switch is turned on, whether it was on previously or not. 
\par 
\par 
When the switch }
{\f2\uldb trfac}{\v\f2 TRFAC} 
{\f2  is on, informative messages are generated at 
each call to the factorizer. The }
{\f2\uldb trallfac}{\v\f2 TRALLFAC} 
{\f2  switch causes the 
production of a more verbose trace message. It takes precedence over 
}{\f3 trfac} {\f2  if they are both on. 
\par 
\par 
To factor a polynomial explicitly and store the results, use the operator 
}
{\f2\uldb factorize}{\v\f2 FACTORIZE} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FAILHARD}

${\footnote \pard\plain \sl240 \fs20 $ FAILHARD}

+{\footnote \pard\plain \sl240 \fs20 + g12:0921}

 K{\footnote \pard\plain \sl240 \fs20 K integration;FAILHARD switch;switch}

}{\b\f2 FAILHARD}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 failhard} {\f2  switch is on, the integration operator }
{\f2\uldb int}{\v\f2 INT} 
{\f2  
terminates with an error message if the integral cannot be done in closed 
terms. 
Default is off. 
\par 
\par 
Use the }{\f3 failhard} {\f2  switch when you are dealing with complicated integrals 
and want to know immediately if REDUCE was unable to handle them. The 
integration operator sometimes returns a formal integration form that is 
more complicated than the original expression, when it is unable to 
complete the integration. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FORT}

${\footnote \pard\plain \sl240 \fs20 $ FORT}

+{\footnote \pard\plain \sl240 \fs20 + g12:0922}

 K{\footnote \pard\plain \sl240 \fs20 K FORTRAN;FORT switch;switch}

}{\b\f2 FORT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 fort} {\f2  is on, output is given Fortran-compatible syntax. Default 
is }{\f3 off} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on fort;  \par
 \par
df(sin(7*x + y),x);  \par
 \par
  ANS=7.*COS(7*X+Y)  \par
 \par
 \par
on rounded;  \par
 \par
b := log(sin(pi/5 + n*pi));  \par
 \par
  	       B=LOG(SIN(3.14159265359*N+0.628318530718)) \par
 \par
\pard \sl240 }{\f2 REDUCE results can be written to a file (using }
{\f2\uldb out}{\v\f2 OUT} 
{\f2 ) and used as data 
by Fortran programs when }{\f3 fort} {\f2  is in effect. }{\f3 fort} {\f2  knows about 
correct statement length, continuation characters, defining a symbol when 
it is first used, and other Fortran details. 
\par 
\par 
The }
{\f2\uldb GENTRAN}{\v\f2 GENTRAN} 
{\f2  package offers many more possibilities than the 
}{\f3 fort} {\f2  switch. It produces Fortran (or C or Ratfor) code from REDUCE 
procedures or structured specifications, including facilities for producing 
double precision output. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FORTUPPER}

${\footnote \pard\plain \sl240 \fs20 $ FORTUPPER}

+{\footnote \pard\plain \sl240 \fs20 + g12:0923}

 K{\footnote \pard\plain \sl240 \fs20 K FORTRAN;FORTUPPER switch;switch}

}{\b\f2 FORTUPPER}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 fortupper} {\f2  is on, any Fortran-style output appears in upper case. 
Default is }{\f3 off} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on fort;  \par
 \par
df(sin(7*x + y),x);  \par
 \par
  ans=7.*cos(7*x+y)  \par
 \par
 \par
on fortupper;  \par
 \par
df(sin(7*x + y),x);  \par
 \par
  ANS=7.*COS(7*X+Y)  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # FULLPREC}

${\footnote \pard\plain \sl240 \fs20 $ FULLPREC}

+{\footnote \pard\plain \sl240 \fs20 + g12:0924}

 K{\footnote \pard\plain \sl240 \fs20 K rounded;precision;FULLPREC switch;switch}

}{\b\f2 FULLPREC}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
Trailing zeroes of rounded numbers to the full system precision are 
normally not printed. If this information is needed, for example to get a 
more understandable indication of the accuracy of certain data, the switch 
}{\f3 fullprec} {\f2  can be turned on. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
1/2;  \par
 \par
  0.5  \par
 \par
 \par
on fullprec;  \par
 \par
ws;  \par
 \par
  0.500000000000 \par
 \par
\pard \sl240 }{\f2 This is just an output options which neither influences 
the accuracy of the computation nor does it give additional 
information about the precision of the results. 
See also }
{\f2\uldb scientific_notation}{\v\f2 SCIENTIFIC\_NOTATION} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FULLROOTS}

${\footnote \pard\plain \sl240 \fs20 $ FULLROOTS}

+{\footnote \pard\plain \sl240 \fs20 + g12:0925}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;solve;FULLROOTS switch;switch}

}{\b\f2 FULLROOTS}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
Since roots of cubic and quartic polynomials can often be very 
messy, a switch }{\f3 fullroots} {\f2  controls the production 
of results in closed form. }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  will apply the 
formulas for explicit forms for degrees 3 and 4 only if 
}{\f3 fullroots} {\f2  is }{\f3 on} {\f2 . Otherwise the result forms 
are built using }
{\f2\uldb root_of}{\v\f2 ROOT\_OF} 
{\f2 . Default is }{\f3 off} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # GC}

${\footnote \pard\plain \sl240 \fs20 $ GC}

+{\footnote \pard\plain \sl240 \fs20 + g12:0926}

 K{\footnote \pard\plain \sl240 \fs20 K memory;GC switch;switch}

}{\b\f2 GC}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
With the }{\f3 gc} {\f2  switch, you can turn the garbage collection messages on 
or off. The form of the message depends on the particular Lisp used for 
the REDUCE implementation. 
\par 
\par 
See }
{\f2\uldb reclaim}{\v\f2 RECLAIM} 
{\f2  for an explanation of garbage collection. REDUCE does 
garbage collection when needed even if you have turned the notices off. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # GCD_switch}

${\footnote \pard\plain \sl240 \fs20 $ GCD_switch}

+{\footnote \pard\plain \sl240 \fs20 + g12:0927}

 K{\footnote \pard\plain \sl240 \fs20 K rational expression;greatest common divisor;GCD switch;switch}

}{\b\f2 GCD}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 gcd} {\f2  is on, common factors in numerators and denominators of 
expressions are canceled. Default is }{\f3 off} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
(2*(f*h)**2 - f**2*g*h - (f*g)**2 - f*h**3 + f*h*g**2 \par
   - h**4 + g*h**3)/(f**2*h - f**2*g - f*h**2 + 2*f*g*h \par
   - f*g**2 - g*h**2 + g**2*h); \par
\pard \sl240   \par
 \par
   2  2    2          2  2      2        3      3    4 \par
  F *G  + F *G*H - 2*F *H  - F*G *H + F*H  - G*H  + H \par
  ----------------------------------------------------  \par
    2      2        2                2    2        2 \par
   F *G - F *H + F*G  - 2*F*G*H + F*H  - G *H + G*H \par
 \par
 \par
on gcd;  \par
 \par
ws;  \par
 \par
                 2 \par
  F*G + 2*F*H + H \par
  ----------------  \par
       F + G \par
 \par
 \par
e2 := a*c + a*d + b*c + b*d;  \par
 \par
  E2 := A*C + A*D + B*C + B*D  \par
 \par
 \par
off exp;  \par
 \par
e2;  \par
 \par
  (A + B)*(C + D) \par
 \par
\pard \sl240 }{\f2 Even with }{\f3 gcd} {\f2  off, a check is automatically made for common variable 
and numerical products in the numerators and denominators of expression, 
and the appropriate cancellations made. Thus the example demonstrating the 
use of }{\f3 gcd} {\f2  is somewhat complicated. Note when }
{\f2\uldb exp}{\v\f2 EXP} 
{\f2  is off, 
}{\f3 gcd} {\f2  has the side effect of factoring the expression. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # HORNER}

${\footnote \pard\plain \sl240 \fs20 $ HORNER}

+{\footnote \pard\plain \sl240 \fs20 + g12:0928}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;output;HORNER switch;switch}

}{\b\f2 HORNER}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 horner} {\f2  switch is on, polynomial expressions are printed 
in Horner's form for faster and safer numerical evaluation. Default 
is }{\f3 off} {\f2 . The leading variable of the expression is selected as 
Horner variable. To select the Horner variable explicitly use the 
}
{\f2\uldb korder}{\v\f2 KORDER} 
{\f2  declaration. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on horner; \par
 \par
(13p-4q)^3; \par
 \par
           3            2 \par
  ( - 64)*q   + p*(624*q   + p*(( - 2028)*q + p*2197)) \par
 \par
 \par
korder q; \par
 \par
ws; \par
 \par
        3                  2 \par
  2197*p   + q*(( - 2028)*p   + q*(624*p + q*(-64))) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # IFACTOR}

${\footnote \pard\plain \sl240 \fs20 $ IFACTOR}

+{\footnote \pard\plain \sl240 \fs20 + g12:0929}

 K{\footnote \pard\plain \sl240 \fs20 K factorize;integer;IFACTOR switch;switch}

}{\b\f2 IFACTOR}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 ifactor} {\f2  switch is on, any integer terms appearing as a result 
of the }
{\f2\uldb factorize}{\v\f2 FACTORIZE} 
{\f2  command are factored themselves into primes. Default 
is }{\f3 off} {\f2 . If the argument of }{\f3 factorize} {\f2  is an integer, 
}{\f3 ifactor} {\f2  has no effect, since the integer is always factored. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
factorize(4*x**2 + 28*x + 48);  \par
 \par
  \{\{4,1\},\{X + 4,1\},\{X + 3,1\}\}  \par
 \par
 \par
factorize(22587);  \par
 \par
  \{\{3,1\},\{7529,1\}\}  \par
 \par
 \par
on ifactor;  \par
 \par
factorize(4*x**2 + 28*x + 48);  \par
 \par
  \{\{2,2\},\{X + 4,1\},\{X + 3,1\}\}  \par
 \par
 \par
factorize(22587);  \par
 \par
  \{\{3,1\},\{7529,1\}\}  \par
 \par
\pard \sl240 }{\f2 Constant terms that appear within nonconstant 
polynomial factors are not factored. 
\par 
\par 
The }{\f3 ifactor} {\f2  switch affects only factoring done specifically 
with }
{\f2\uldb factorize}{\v\f2 FACTORIZE} 
{\f2 , not on factoring done automatically when the 
}
{\f2\uldb factor}{\v\f2 FACTOR} 
{\f2  switch is on. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # INT_switch}

${\footnote \pard\plain \sl240 \fs20 $ INT_switch}

+{\footnote \pard\plain \sl240 \fs20 + g12:0930}

 K{\footnote \pard\plain \sl240 \fs20 K interactive;INT switch;switch}

}{\b\f2 INT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 int} {\f2  switch specifies an interactive mode of operation. Default 
}{\f3 on} {\f2 . 
\par 
\par 
There is no reason to turn }{\f3 int} {\f2  off during interactive calculations, 
since there are no benefits to be gained. If you do have }{\f3 int} {\f2  off 
while inputting a file, and REDUCE finds an error, it prints the message 
``Continuing with parsing only." In this state, REDUCE accepts only 
}
{\f2\uldb end}{\v\f2 END} 
{\f3 ;} {\f2  or }
{\f2\uldb bye}{\v\f2 BYE} 
{\f3 ;} {\f2  from the keyboard; 
everything else is ignored, even the command }{\f3 on int} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # INTSTR}

${\footnote \pard\plain \sl240 \fs20 $ INTSTR}

+{\footnote \pard\plain \sl240 \fs20 + g12:0931}

 K{\footnote \pard\plain \sl240 \fs20 K output;INTSTR switch;switch}

}{\b\f2 INTSTR}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
If }{\f3 intstr} {\f2  (for ``internal structure'') is on, arguments of an 
operator are printed in a more structured form. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
operator f;  \par
 \par
f(2x+2y);  \par
 \par
  F(2*X + 2*Y)  \par
 \par
 \par
on intstr;  \par
 \par
ws;  \par
 \par
  F(2*(X + Y)) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # LCM}

${\footnote \pard\plain \sl240 \fs20 $ LCM}

+{\footnote \pard\plain \sl240 \fs20 + g12:0932}

 K{\footnote \pard\plain \sl240 \fs20 K rational expression;LCM switch;switch}

}{\b\f2 LCM}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 lcm} {\f2  switch instructs REDUCE to compute the least common multiple 
of denominators whenever rational expressions occur. Default is }{\f3 on} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
off lcm;  \par
 \par
z := 1/(x**2 - y**2) + 1/(x-y)**2;   \par
			  \par
 \par
 \par
              2*X*(X - Y) \par
  Z := -------------------------  \par
        4      3          3    4 \par
       X  - 2*X *Y + 2*X*Y  - Y \par
 \par
 \par
on lcm;  \par
 \par
z;  \par
 \par
         2*X*(X - Y) \par
  -------------------------  \par
   4      3          3    4 \par
  X  - 2*X *Y + 2*X*Y  - Y \par
 \par
 \par
zz := 1/(x**2 - y**2) + 1/(x-y)**2; \par
			  \par
 \par
 \par
                 2*X \par
  ZZ := ---------------------  \par
         3    2        2    3 \par
        X  - X *Y - X*Y  + Y \par
 \par
 \par
on gcd;  \par
 \par
z;  \par
 \par
           2*X \par
  ---------------------- \par
   3    2        2    3 \par
  X  - X *Y - X*Y  + Y \par
 \par
\pard \sl240 }{\f2 Note that }{\f3 lcm} {\f2  has effect only when rational expressions are first 
combined. It does not examine existing structures for simplifications on 
display. That is shown above when z is entered with 
}{\f3 lcm} {\f2  off. It remains unsimplified even after }{\f3 lcm} {\f2  is turned 
back on. However, a new variable containing the same expression is 
simplified on entry. The switch }
{\f2\uldb gcd}{\v\f2 GCD} 
{\f2  does examine existing 
structures, as shown in the last example line above. 
\par 
\par 
Full greatest common divisor calculations become expensive if work with 
large rational expressions is required. A considerable savings of time 
can be had if a full gcd check is made only when denominators are combined, 
and only a partial check for numerators. This is the effect of the }{\f3 lcm} {\f2  
switch. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LESSSPACE}

${\footnote \pard\plain \sl240 \fs20 $ LESSSPACE}

+{\footnote \pard\plain \sl240 \fs20 + g12:0933}

 K{\footnote \pard\plain \sl240 \fs20 K output;LESSSPACE switch;switch}

}{\b\f2 LESSSPACE}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
You can turn on the switch }{\f3 lessspace} {\f2  if you want fewer 
blank lines in your output. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LIMITEDFACTORS}

${\footnote \pard\plain \sl240 \fs20 $ LIMITEDFACTORS}

+{\footnote \pard\plain \sl240 \fs20 + g12:0934}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;factorize;LIMITEDFACTORS switch;switch}

}{\b\f2 LIMITEDFACTORS}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
To get limited factorization in cases where it is too expensive to use 
full multivariate polynomial factorization, the switch 
}{\f3 limitedfactors} {\f2  can be turned on. In that case, only ``inexpensive'' 
factoring operations, such as square-free factorization, will be used 
when }
{\f2\uldb factorize}{\v\f2 FACTORIZE} 
{\f2  is called. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a := (y-x)^2*(y^3+2x*y+5)*(y^2-3x*y+7)$  \par
 \par
factorize a;  \par
 \par
              2 \par
  \{- 3*X*Y + Y  + 7,1\} \par
            3 \par
  \{2*X*Y + Y  + 5,1\}, \par
  \{X - Y,2\}\} \par
 \par
 \par
on limitedfactors;  \par
 \par
factorize a;  \par
 \par
        2  2        4        3          5      3      2 \par
  \{- 6*X *Y  - 3*X*Y  + 2*X*Y  - X*Y + Y  + 7*Y  + 5*Y  + 35,1\}, \par
  \{X - Y,2\}\} \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # LIST_switch}

${\footnote \pard\plain \sl240 \fs20 $ LIST_switch}

+{\footnote \pard\plain \sl240 \fs20 + g12:0935}

 K{\footnote \pard\plain \sl240 \fs20 K LIST switch;switch}

}{\b\f2 LIST}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
The }{\f3 list} {\f2  switch causes REDUCE to print each term in any sum on 
separate lines. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
x**2*(y**2 + 2*y) + x*(y**2 + z)/(2*a); \par
			  \par
 \par
 \par
            2              2 \par
  X*(2*A*X*Y  + 4*A*X*Y + Y  +Z) \par
  ------------------------------  \par
               2*A \par
 \par
 \par
on list;  \par
 \par
ws;  \par
 \par
             2 \par
  (X*(2*A*X*Y \par
    + 4*A*X*Y \par
       2 \par
    + Y \par
    + Z))/(2*A) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # LISTARGS}

${\footnote \pard\plain \sl240 \fs20 $ LISTARGS}

+{\footnote \pard\plain \sl240 \fs20 + g12:0936}

 K{\footnote \pard\plain \sl240 \fs20 K operator;argument;list;LISTARGS switch;switch}

}{\b\f2 LISTARGS}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
If an operator other than those specifically defined for lists is given a 
single argument that is a list, then the result of this operation will be 
a list in which that operator is applied to each element of the list. 
This process can be inhibited globally by turning on the switch 
}{\f3 listargs} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
log \{a,b,c\};  \par
 \par
  LOG(A),LOG(B),LOG(C)  \par
 \par
 \par
on listargs;  \par
 \par
log \{a,b,c\};  \par
 \par
  LOG(A,B,C) \par
 \par
\pard \sl240 }{\f2 It is possible to inhibit such distribution for a specific operator by 
using the declaration }
{\f2\uldb listargp}{\v\f2 LISTARGP} 
{\f2 . In addition, if an operator has 
more than one argument, no such distribution occurs, so }{\f3 listargs} {\f2  
has no effect. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MCD}

${\footnote \pard\plain \sl240 \fs20 $ MCD}

+{\footnote \pard\plain \sl240 \fs20 + g12:0937}

 K{\footnote \pard\plain \sl240 \fs20 K rational expression;MCD switch;switch}

}{\b\f2 MCD}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 mcd} {\f2  is on, sums and differences of rational expressions are put 
on a common denominator. Default is }{\f3 on} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
a/(x+1) + b/5;  \par
 \par
  5*A + B*X + B \par
  -------------  \par
    5*(X + 1) \par
 \par
 \par
off mcd;  \par
 \par
a/(x+1) + b/5;  \par
 \par
         -1 \par
  (X + 1)  *A + 1/5*B  \par
 \par
 \par
1/6 + 1/7;  \par
 \par
  13/42 \par
 \par
\pard \sl240 }{\f2 Even with }{\f3 mcd} {\f2  off, rational expressions involving only numbers are still 
put over a common denominator. 
\par 
\par 
Turning }{\f3 mcd} {\f2  off is useful when explicit negative powers are needed, 
or if no greatest common divisor calculations are desired, or when 
differentiating complicated rational expressions. Results when }{\f3 mcd} {\f2  
is off are no longer in canonical form, and expressions equivalent to zero 
may not simplify to 0. Some operations, such as factoring cannot be done 
while }{\f3 mcd} {\f2  is off. This option should therefore be used with some 
caution. Turning }{\f3 mcd} {\f2  off is most valuable in intermediate parts of 
a complicated calculation, and should be turned back on for the last stage. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MODULAR}

${\footnote \pard\plain \sl240 \fs20 $ MODULAR}

+{\footnote \pard\plain \sl240 \fs20 + g12:0938}

 K{\footnote \pard\plain \sl240 \fs20 K modular;MODULAR switch;switch}

}{\b\f2 MODULAR}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 modular} {\f2  is on, polynomial coefficients are reduced by the 
modulus set by }
{\f2\uldb setmod}{\v\f2 SETMOD} 
{\f2 . If no modulus has been set, }{\f3 modular} {\f2  
has no effect. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
setmod 2;  \par
 \par
  1  \par
 \par
 \par
on modular;  \par
 \par
(x+y)**2;  \par
 \par
   2    2 \par
  X  + Y   \par
 \par
 \par
145*x**2 + 20*x**3 + 17 + 15*x*y; \par
			  \par
 \par
 \par
   2 \par
  X  + X*Y + 1 \par
 \par
\pard \sl240 }{\f2 Modular operations are only conducted on the coefficients, not the 
exponents. The modulus is not restricted to being prime. When the modulus 
is prime, division by a number not relatively prime to the modulus results 
in a <Zero divisor> error message. When the modulus is a composite 
number, division by a power of the modulus results in an error message, but 
division by an integer which is a factor of the modulus does not. 
The representation of modular number can be influenced by 
}
{\f2\uldb balanced_mod}{\v\f2 BALANCED\_MOD} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MSG}

${\footnote \pard\plain \sl240 \fs20 $ MSG}

+{\footnote \pard\plain \sl240 \fs20 + g12:0939}

 K{\footnote \pard\plain \sl240 \fs20 K output;MSG switch;switch}

}{\b\f2 MSG}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 msg} {\f2  is off, the printing of warning messages is suppressed. Error 
messages are still printed. 
\par 
\par 
Warning messages include those about redimensioning an }
{\f2\uldb array}{\v\f2 ARRAY} 
{\f2  
or declaring an }
{\f2\uldb operator}{\v\f2 OPERATOR} 
{\f2  where one is expected. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MULTIPLICITIES}

${\footnote \pard\plain \sl240 \fs20 $ MULTIPLICITIES}

+{\footnote \pard\plain \sl240 \fs20 + g12:0940}

 K{\footnote \pard\plain \sl240 \fs20 K solve;MULTIPLICITIES switch;switch}

}{\b\f2 MULTIPLICITIES}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  is applied to a set of equations with multiple roots, 
solution multiplicities are normally stored in the global variable 
}
{\f2\uldb root_multiplicities}{\v\f2 ROOT\_MULTIPLICITIES} 
{\f2  rather than the solution list. If you want 
the multiplicities explicitly displayed, the switch }{\f3 multiplicities} {\f2  
should be turned on. In this case, }{\f3 root_multiplicities} {\f2  has no value. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
solve(x^2=2x-1,x);  \par
 \par
  X=1  \par
 \par
 \par
root_multiplicities;  \par
 \par
  2  \par
 \par
 \par
on multiplicities;  \par
 \par
solve(x^2=2x-1,x);  \par
 \par
  X=1,X=1  \par
 \par
 \par
root_multiplicities;  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # NAT}

${\footnote \pard\plain \sl240 \fs20 $ NAT}

+{\footnote \pard\plain \sl240 \fs20 + g12:0941}

 K{\footnote \pard\plain \sl240 \fs20 K output;NAT switch;switch}

}{\b\f2 NAT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 nat} {\f2  is on, output is printed to the screen in natural form, with 
raised exponents. }{\f3 nat} {\f2  should be turned off when outputting expressions 
to a file for future input. Default is }{\f3 on} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
(x + y)**3;  \par
 \par
   3      2          2    3 \par
  X  + 3*X *Y + 3*X*Y  + Y   \par
 \par
 \par
off nat;  \par
 \par
(x + y)**3;  \par
 \par
  X**3 + 3*X**2*Y + 3*X*Y**2 + Y**3$  \par
 \par
 \par
on fort;  \par
 \par
(x + y)**3;  \par
 \par
  ANS=X**3+3.*X**2*Y+3.*X*Y**2+Y**3 \par
 \par
\pard \sl240 }{\f2 With }{\f3 nat} {\f2  off, a dollar sign is printed at the end of each expression. 
An output file written with }{\f3 nat} {\f2  off is ready to be read into REDUCE 
using the command }
{\f2\uldb in}{\v\f2 IN} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NERO}

${\footnote \pard\plain \sl240 \fs20 $ NERO}

+{\footnote \pard\plain \sl240 \fs20 + g12:0942}

 K{\footnote \pard\plain \sl240 \fs20 K output;NERO switch;switch}

}{\b\f2 NERO}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 nero} {\f2  is on, zero assignments (such as matrix elements) are not 
printed. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
matrix a; \par
a := mat((1,0),(0,1));  \par
 \par
  A(1,1) := 1 \par
  A(1,2) := 0 \par
  A(2,1) := 0 \par
  A(2,2) := 1 \par
 \par
 \par
on nero;  \par
 \par
a;  \par
 \par
  MAT(1,1) := 1 \par
  MAT(2,2) := 1 \par
 \par
 \par
a(1,2); \pard \sl240 }{\f2 nothing is printed.}{\f4 \pard \tx3420  \par
 \par
 \par
b := 0; \pard \sl240 }{\f2 nothing is printed.}{\f4 \pard \tx3420  \par
 \par
 \par
off nero;  \par
 \par
b := 0;  \par
 \par
  B := 0 \par
 \par
\pard \sl240 }{\f2  
\par 
\par 
}{\f3 nero} {\f2 is often used when dealing with large sparse matrices, to avoid 
being overloaded with zero assignments. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NOARG}

${\footnote \pard\plain \sl240 \fs20 $ NOARG}

+{\footnote \pard\plain \sl240 \fs20 + g12:0943}

 K{\footnote \pard\plain \sl240 \fs20 K derivative;output;NOARG switch;switch}

}{\b\f2 NOARG}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }
{\f2\uldb dfprint}{\v\f2 DFPRINT} 
{\f2  is on, expressions in the differentiation operator 
}
{\f2\uldb df}{\v\f2 DF} 
{\f2  are printed in a more ``natural'' notation, with the 
differentiation variables appearing as subscripts. When }{\f3 noarg} {\f2  
is on (the default), the arguments of the differentiated operator are also 
suppressed. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
operator f;  \par
 \par
df(f x,x);  \par
 \par
  DF(F(X),X);  \par
 \par
 \par
on dfprint;  \par
 \par
ws;  \par
 \par
  F   \par
   X \par
 \par
 \par
off noarg;  \par
 \par
ws;  \par
 \par
  F(X) \par
      X \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # NOLNR}

${\footnote \pard\plain \sl240 \fs20 $ NOLNR}

+{\footnote \pard\plain \sl240 \fs20 + g12:0944}

 K{\footnote \pard\plain \sl240 \fs20 K integration;NOLNR switch;switch}

}{\b\f2 NOLNR}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 nolnr} {\f2  is on, the linear properties of the integration operator 
}
{\f2\uldb int}{\v\f2 INT} 
{\f2  are suppressed if the integral cannot be found in closed terms. 
\par 
\par 
REDUCE uses the linear properties of integration to attempt to break down 
an integral into manageable pieces. If an integral cannot be found in 
closed terms, these pieces are returned. When the }{\f3 nolnr} {\f2  switch is off, 
as many of the pieces as possible are integrated. When it is on, if any piece 
fails, the rest of them remain unevaluated. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NOSPLIT}

${\footnote \pard\plain \sl240 \fs20 $ NOSPLIT}

+{\footnote \pard\plain \sl240 \fs20 + g12:0945}

 K{\footnote \pard\plain \sl240 \fs20 K output;NOSPLIT switch;switch}

}{\b\f2 NOSPLIT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
Under normal circumstances, the printing routines try to break an expression 
across lines at a natural point. This is a fairly expensive process. If 
you are not overly concerned about where the end-of-line breaks come, you 
can speed up the printing of expressions by turning off the switch 
}{\f3 nosplit} {\f2 . This switch is normally on. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NUMVAL}

${\footnote \pard\plain \sl240 \fs20 $ NUMVAL}

+{\footnote \pard\plain \sl240 \fs20 + g12:0946}

 K{\footnote \pard\plain \sl240 \fs20 K rounded;NUMVAL switch;switch}

}{\b\f2 NUMVAL}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
With }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  on, elementary functions with numerical arguments 
will return a numerical answer where appropriate. If you wish to inhibit 
this evaluation, }{\f3 numval} {\f2  should be turned off. It is normally on. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
cos 3.4;  \par
 \par
  - 0.966798192579  \par
 \par
 \par
off numval;  \par
 \par
cos 3.4;  \par
 \par
  COS(3.4) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # OUTPUT}

${\footnote \pard\plain \sl240 \fs20 $ OUTPUT}

+{\footnote \pard\plain \sl240 \fs20 + g12:0947}

 K{\footnote \pard\plain \sl240 \fs20 K output;OUTPUT switch;switch}

}{\b\f2 OUTPUT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 output} {\f2  is off, no output is printed from any REDUCE calculation. 
The calculations have their usual effects other than printing. Default is 
}{\f3 on} {\f2 . 
\par 
\par 
Turn output }{\f3 off} {\f2  if you do not wish to see output when executing 
large files, or to save the time REDUCE spends formatting large expressions 
for display. Results are still available with }
{\f2\uldb ws}{\v\f2 WS} 
{\f2 , or in their 
assigned variables. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # OVERVIEW}

${\footnote \pard\plain \sl240 \fs20 $ OVERVIEW}

+{\footnote \pard\plain \sl240 \fs20 + g12:0948}

 K{\footnote \pard\plain \sl240 \fs20 K factorize;OVERVIEW switch;switch}

}{\b\f2 OVERVIEW}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 overview} {\f2  is on, the amount of detail reported by the factorizer 
switches }
{\f2\uldb trfac}{\v\f2 TRFAC} 
{\f2  and }
{\f2\uldb trallfac}{\v\f2 TRALLFAC} 
{\f2  is reduced. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PERIOD}

${\footnote \pard\plain \sl240 \fs20 $ PERIOD}

+{\footnote \pard\plain \sl240 \fs20 + g12:0949}

 K{\footnote \pard\plain \sl240 \fs20 K integer;output;PERIOD switch;switch}

}{\b\f2 PERIOD}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 period} {\f2  is on, periods are added after integers in 
Fortran-compatible output (when }
{\f2\uldb fort}{\v\f2 FORT} 
{\f2  is on). There is no effect 
when }{\f3 fort} {\f2  is off. Default is }{\f3 on} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PRECISE}

${\footnote \pard\plain \sl240 \fs20 $ PRECISE}

+{\footnote \pard\plain \sl240 \fs20 + g12:0950}

 K{\footnote \pard\plain \sl240 \fs20 K square root;simplification;PRECISE switch;switch}

}{\b\f2 PRECISE}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 precise} {\f2  switch is on, simplification of roots of even 
powers returns absolute values, a more precise answer mathematically. 
Default is }{\f3 on} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
sqrt(x**2);  \par
 \par
  X  \par
 \par
 \par
(x**2)**(1/4);  \par
 \par
  SQRT(X)  \par
 \par
 \par
on precise;  \par
 \par
sqrt(x**2);  \par
 \par
  ABS(X)  \par
 \par
 \par
(x**2)**(1/4);  \par
 \par
  SQRT(ABS(X)) \par
 \par
\pard \sl240 }{\f2 In many types of mathematical work, simplification of powers and surds can 
proceed by the fastest means of simplifying the exponents arithmetically. 
When it is important to you that the positive root be returned, turn 
}{\f3 precise} {\f2  on. One situation where this is important is when graphing 
square-root expressions such as sqrt(x^2+y^2) to 
avoid a spike caused by REDUCE simplifying 
sqrt(y^2) to y when x is 
zero. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PRET}

${\footnote \pard\plain \sl240 \fs20 $ PRET}

+{\footnote \pard\plain \sl240 \fs20 + g12:0951}

 K{\footnote \pard\plain \sl240 \fs20 K output;PRET switch;switch}

}{\b\f2 PRET}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 pret} {\f2  is on, input is printed in standard REDUCE format and then 
evaluated. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on pret;  \par
 \par
 (x+1)^3;  \par
 \par
   (x + 1)**3; \par
   3      2 \par
  X  + 3*X  + 3*X + 1 \par
 \par
 \par
 \par
procedure fac(n); \par
   if not (fixp(n) and n>=0) \par
     then rederr "Choose nonneg. integer only" \par
    else for i := 0:n-1 product i+1; \par
\pard \sl240   \par
 \par
  procedure fac n; \par
     if not (fixp n and n>=0) \par
       then rederr "Choose nonneg. integer only" \par
      else for i := 0:n - 1 product i + 1; \par
  FAC \par
 \par
 \par
 \par
fac 5;  \par
 \par
  fac 5; \par
  120 \par
 \par
\pard \sl240 }{\f2 Note that all input is converted to lower case except strings (which keep 
the same case) all operators with a single argument have had the 
parentheses removed, and all infix operators have had a space added on each 
side. In addition, syntactical constructs like 
}{\f3 if} {\f2 ...}{\f3 then} {\f2 ...}{\f3 else} {\f2  are printed in a standard format. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PRI}

${\footnote \pard\plain \sl240 \fs20 $ PRI}

+{\footnote \pard\plain \sl240 \fs20 + g12:0952}

 K{\footnote \pard\plain \sl240 \fs20 K output;PRI switch;switch}

}{\b\f2 PRI}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 pri} {\f2  is on, the declarations }
{\f2\uldb order}{\v\f2 ORDER} 
{\f2  and }
{\f2\uldb factor}{\v\f2 FACTOR} 
{\f2  can 
be used, and the switches }
{\f2\uldb allfac}{\v\f2 ALLFAC} 
{\f2 , }
{\f2\uldb div}{\v\f2 DIV} 
{\f2 , }
{\f2\uldb rat}{\v\f2 RAT} 
{\f2 , 
and }
{\f2\uldb revpri}{\v\f2 REVPRI} 
{\f2  take effect when they are on. Default is }{\f3 on} {\f2 . 
\par 
\par 
Printing of expressions is faster with }{\f3 pri} {\f2  off. The expressions are 
then returned in one standard form, without any of the display options that 
can be used to feature or display various parts of the expression. You can 
also gain insight into REDUCE's representation of expressions with 
}{\f3 pri} {\f2  off. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RAISE}

${\footnote \pard\plain \sl240 \fs20 $ RAISE}

+{\footnote \pard\plain \sl240 \fs20 + g12:0953}

 K{\footnote \pard\plain \sl240 \fs20 K character;input;RAISE switch;switch}

}{\b\f2 RAISE}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 raise} {\f2  is on, lower case letters are automatically converted to 
upper case on input. }{\f3 raise} {\f2  is normally on. 
\par 
\par 
This conversion affects the internal representation of the letter, and is 
independent of the case with which a letter is printed, which is normally 
lower case. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RAT}

${\footnote \pard\plain \sl240 \fs20 $ RAT}

+{\footnote \pard\plain \sl240 \fs20 + g12:0954}

 K{\footnote \pard\plain \sl240 \fs20 K output;RAT switch;switch}

}{\b\f2 RAT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 rat} {\f2  switch is on, and kernels have been selected to display 
with the }
{\f2\uldb factor}{\v\f2 FACTOR} 
{\f2  declaration, the denominator is printed with each 
term rather than one common denominator at the end of an expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
(x+1)/x + x**2/sin y;         \par
  \par
 \par
                       3 \par
  SIN(Y)*X + SIN(Y) + X \par
  ---------------------- factor x;  \par
         SIN(Y)*X \par
 \par
 \par
(x+1)/x + x**2/sin y;         \par
  \par
 \par
   3 \par
  X  + X*SIN(Y) + SIN(Y) \par
  ---------------------- on rat;   \par
         X*SIN(Y) \par
 \par
 \par
(x+1)/x + x**2/sin y;        \par
  \par
 \par
     2 \par
    X           -1 \par
  ------ + 1 + X \par
  SIN(Y) \par
 \par
\pard \sl240 }{\f2 The }{\f3 rat} {\f2  switch only has effect when the }
{\f2\uldb pri}{\v\f2 PRI} 
{\f2  switch is on. 
When }{\f3 pri} {\f2  is off, regardless of the setting of }{\f3 rat} {\f2 , the 
printing behavior is as if }{\f3 rat} {\f2  were off. }{\f3 rat} {\f2  only has 
effect upon the display of expressions, not their internal form. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RATARG}

${\footnote \pard\plain \sl240 \fs20 $ RATARG}

+{\footnote \pard\plain \sl240 \fs20 + g12:0955}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;rational expression;RATARG switch;switch}

}{\b\f2 RATARG}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 ratarg} {\f2  is on, rational expressions can be given to operators 
such as }
{\f2\uldb coeff}{\v\f2 COEFF} 
{\f2  and }
{\f2\uldb lterm}{\v\f2 LTERM} 
{\f2  that normally require 
polynomials in one of their arguments. When }{\f3 ratarg} {\f2  is off, rational 
expressions cause an error message. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
aa := x/y**2 + 1/x + y/x**2;  \par
  \par
 \par
         3      2    3 \par
        X  + X*Y  + Y \par
  AA := --------------  \par
             2  2 \par
            X *Y \par
 \par
 \par
coeff(aa,x);  \par
 \par
         3      2    3 \par
        X  + X*Y  + Y \par
  ***** -------------- invalid as POLYNOMIAL \par
             2  2 \par
            X *Y \par
 \par
 \par
on ratarg;  \par
 \par
coeff(aa,x);                 \par
  \par
 \par
   Y  1      1 \par
  \{--,--,0,-----\} \par
    2  2    2  2 \par
   X  X    X *Y \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # RATIONAL}

${\footnote \pard\plain \sl240 \fs20 $ RATIONAL}

+{\footnote \pard\plain \sl240 \fs20 + g12:0956}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;rational expression;RATIONAL switch;switch}

}{\b\f2 RATIONAL}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 rational} {\f2  is on, polynomial expressions with rational coefficients 
are produced. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
x/2 + 3*y/4;  \par
 \par
  2*X + 3*Y \par
  ---------  \par
      4 \par
 \par
 \par
(x**2 + 5*x + 17)/2;  \par
 \par
   2 \par
  X  + 5*X + 17 \par
  -------------  \par
        2 \par
 \par
 \par
on rational;  \par
 \par
x/2 + 3y/4;  \par
 \par
  1      3 \par
  -*(X + -*Y)  \par
  2      2 \par
 \par
 \par
(x**2 + 5*x + 17)/2;  \par
 \par
  1   2 \par
  -*(X  + 5*X + 17) \par
  2 \par
 \par
\pard \sl240 }{\f2 By using }{\f3 rational} {\f2 , polynomial expressions with rational 
coefficients can be used in some commands that expect polynomials. With 
}{\f3 rational} {\f2  off, such a polynomial becomes a rational expression, with 
denominator the least common multiple of the denominators of the rational 
number coefficients. \par 
\par 

\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RATIONALIZE}

${\footnote \pard\plain \sl240 \fs20 $ RATIONALIZE}

+{\footnote \pard\plain \sl240 \fs20 + g12:0957}

 K{\footnote \pard\plain \sl240 \fs20 K complex;simplification;rational expression;RATIONALIZE switch;switch}

}{\b\f2 RATIONALIZE}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 rationalize} {\f2  switch is on, denominators of rational expressions 
that contain complex numbers or root expressions are simplified by 
multiplication by their conjugates. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
qq := (1+sqrt(3))/(sqrt(3)-7);  \par
 \par
        SQRT(3) + 1 \par
  QQ := -----------  \par
        SQRT(3) - 7 \par
 \par
 \par
on rationalize;  \par
 \par
qq;  \par
 \par
  - 4*SQRT(3) - 5 \par
  ---------------  \par
        23 \par
 \par
 \par
2/(4 + 6**(1/3));  \par
 \par
   2/3      1/3 \par
  6    - 4*6    + 16 \par
  ------------------  \par
          35 \par
 \par
 \par
(i-1)/(i+3);  \par
 \par
  2*I - 1 \par
  -------  \par
     5 \par
 \par
 \par
off rationalize;  \par
 \par
(i-1)/(i+3);  \par
 \par
  I - 1 \par
  ------ \par
  I + 3 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # RATPRI}

${\footnote \pard\plain \sl240 \fs20 $ RATPRI}

+{\footnote \pard\plain \sl240 \fs20 + g12:0958}

 K{\footnote \pard\plain \sl240 \fs20 K rational expression;output;RATPRI switch;switch}

}{\b\f2 RATPRI}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 ratpri} {\f2  switch is on, rational expressions and fractions are 
printed as two lines separated by a fraction bar, rather than in a linear 
style. Default is }{\f3 on} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
3/17;  \par
 \par
  3 \par
  --  \par
  17 \par
 \par
 \par
2/b + 3/y;  \par
 \par
  3*B + 2*Y \par
  ---------  \par
     B*Y \par
 \par
 \par
off ratpri;  \par
 \par
3/17;  \par
 \par
  3/17  \par
 \par
 \par
2/b + 3/y;  \par
 \par
  (3*B + 2*Y)/(B*Y) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # REVPRI}

${\footnote \pard\plain \sl240 \fs20 $ REVPRI}

+{\footnote \pard\plain \sl240 \fs20 + g12:0959}

 K{\footnote \pard\plain \sl240 \fs20 K output;REVPRI switch;switch}

}{\b\f2 REVPRI}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When the }{\f3 revpri} {\f2  switch is on, terms are printed in reverse order from 
the normal printing order. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
x**5 + x**2 + 18 + sqrt(y);  \par
 \par
             5    2 \par
  SQRT(Y) + X  + X  + 18  \par
 \par
 \par
a + b + c + w;  \par
 \par
  A + B + C + W  \par
 \par
 \par
on revpri;  \par
 \par
x**5 + x**2 + 18 + sqrt(y);  \par
 \par
        2    5 \par
  17 + X  + X  + SQRT(Y)  \par
 \par
 \par
a + b + c + w;  \par
 \par
  W + C + B + A \par
 \par
\pard \sl240 }{\f2 Turn }{\f3 revpri} {\f2  on when you want to display a polynomial in ascending 
rather than descending order. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RLISP88}

${\footnote \pard\plain \sl240 \fs20 $ RLISP88}

+{\footnote \pard\plain \sl240 \fs20 + g12:0960}

 K{\footnote \pard\plain \sl240 \fs20 K lisp;RLISP88 switch;switch}

}{\b\f2 RLISP88}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
Rlisp '88 is a superset of the Rlisp that has been traditionally used for 
the support of REDUCE. It is fully documented in the book Marti, J.B., 
``RLISP '88: An Evolutionary Approach to Program Design and Reuse'', 
World Scientific, Singapore (1993). It supports different looping 
constructs from the traditional Rlisp, and treats ``-'' as a letter unless 
separated by spaces. Turning on the switch }{\f3 rlisp88} {\f2  converts to 
Rlisp '88 parsing conventions in symbolic mode, and enables the use of 
Rlisp '88 extensions. Turning off the switch reverts to the traditional 
Rlisp and the previous mode ( (}
{\f2\uldb symbolic}{\v\f2 SYMBOLIC} 
{\f2  or }
{\f2\uldb algebraic}{\v\f2 ALGEBRAIC} 
{\f2 ) 
in force before }{\f3 rlisp88} {\f2  was turned on. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ROUNDALL}

${\footnote \pard\plain \sl240 \fs20 $ ROUNDALL}

+{\footnote \pard\plain \sl240 \fs20 + g12:0961}

 K{\footnote \pard\plain \sl240 \fs20 K floating point;rational expression;rounded;ROUNDALL switch;switch}

}{\b\f2 ROUNDALL}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
In }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  mode, rational numbers are normally converted to a 
floating point representation. If }{\f3 roundall} {\f2  is off, this conversion 
does not occur. }{\f3 roundall} {\f2  is normally }{\f3 on} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
1/2;  \par
 \par
  0.5  \par
 \par
 \par
off roundall;  \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # ROUNDBF}

${\footnote \pard\plain \sl240 \fs20 $ ROUNDBF}

+{\footnote \pard\plain \sl240 \fs20 + g12:0962}

 K{\footnote \pard\plain \sl240 \fs20 K ROUNDBF switch;switch}

}{\b\f2 ROUNDBF}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
When }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  is on, the normal defaults cause underflows to be 
converted to zero. If you really want the small number that results in 
such cases, }{\f3 roundbf} {\f2  can be turned on. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
exp(-100000.1^2);  \par
 \par
  0  \par
 \par
 \par
on roundbf;  \par
 \par
exp(-100000.1^2);  \par
 \par
  1.18441281937E-4342953505 \par
 \par
\pard \sl240 }{\f2 If a polynomial is input in }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  mode at the default 
precision into any }
{\f2\uldb roots}{\v\f2 ROOTS} 
{\f2  function, and it is not possible to 
represent any of the coefficients of the polynomial precisely in the 
system floating point representation, the switch }{\f3 roundbf} {\f2  will be 
automatically turned on. All rounded computation will use the internal 
bigfloat representation until the user subsequently turns }{\f3 roundbf} {\f2  
off. (A message is output to indicate that this condition is in effect.) 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ROUNDED}

${\footnote \pard\plain \sl240 \fs20 $ ROUNDED}

+{\footnote \pard\plain \sl240 \fs20 + g12:0963}

 K{\footnote \pard\plain \sl240 \fs20 K floating point;ROUNDED switch;switch}

}{\b\f2 ROUNDED}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 rounded} {\f2  is on, floating-point arithmetic is enabled, with 
precision initially at a system default value, which is usually 12 digits. 
The precise number can be found by the command }
{\f2\uldb precision}{\v\f2 PRECISION} 
{\f2 (0). 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
pi;  \par
 \par
  PI  \par
 \par
 \par
35/217;  \par
 \par
  5 \par
  --  \par
  31 \par
 \par
 \par
on rounded;  \par
 \par
pi;  \par
 \par
  3.14159265359  \par
 \par
 \par
35/217;  \par
 \par
  0.161  \par
 \par
 \par
sqrt(3);  \par
 \par
  1.73205080756 \par
 \par
\pard \sl240 }{\f2 \par 
\par 
If more than the default number of decimal places are required, use the 
}
{\f2\uldb precision}{\v\f2 PRECISION} 
{\f2  command to set the required number. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SAVESTRUCTR}

${\footnote \pard\plain \sl240 \fs20 $ SAVESTRUCTR}

+{\footnote \pard\plain \sl240 \fs20 + g12:0964}

 K{\footnote \pard\plain \sl240 \fs20 K STRUCTR OPERATOR;SAVESTRUCTR switch;switch}

}{\b\f2 SAVESTRUCTR}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 savestructr} {\f2  is on, results of the }
{\f2\uldb structr}{\v\f2 STRUCTR} 
{\f2  command are 
returned as a list whose first element is the representation for the 
expression and the remaining elements are equations showing the 
relationships of the generated variables. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
off exp;  \par
 \par
structr((x+y)^3 + sin(x)^2);  \par
 \par
  ANS3 \par
     where \par
                    3       2 \par
        ANS3 := ANS1  + ANS2 \par
        ANS2 := SIN(X) \par
        ANS1 := X + Y \par
 \par
 \par
ans3;  \par
 \par
  ANS3  \par
 \par
 \par
on savestructr;  \par
 \par
structr((x+y)^\{3\} + sin(x)^\{2\});  \par
 \par
                3       2 \par
  ANS3,ANS3=ANS1  + ANS2 ,ANS2=SIN(X),ANS1=X + Y  \par
 \par
 \par
ans3 where rest ws;  \par
 \par
         3         2 \par
  (X + Y)  + SIN(X) \par
 \par
\pard \sl240 }{\f2 In normal operation, }
{\f2\uldb structr}{\v\f2 STRUCTR} 
{\f2  is only a display command. With 
}{\f3 savestructr} {\f2  on, you can access the various parts of the expression 
produced by }{\f3 structr} {\f2 . 
\par 
\par 
The generic system names use the stem }{\f3 ANS} {\f2 . You can change this to your 
own stem by the command }
{\f2\uldb varname}{\v\f2 VARNAME} 
{\f2 . REDUCE adds integers to this stem 
to make unique identifiers. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SOLVESINGULAR}

${\footnote \pard\plain \sl240 \fs20 $ SOLVESINGULAR}

+{\footnote \pard\plain \sl240 \fs20 + g12:0965}

 K{\footnote \pard\plain \sl240 \fs20 K solve;SOLVESINGULAR switch;switch}

}{\b\f2 SOLVESINGULAR}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 solvesingular} {\f2  is on, singular or underdetermined systems of 
linear equations are solved, using arbitrary real, complex or integer 
variables in the answer. Default is }{\f3 on} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
solve(\{2x + y,4x + 2y\},\{x,y\});  \par
 \par
         ARBCOMPLEX(1) \par
  \{\{X= - -------------,Y=ARBCOMPLEX(1)\}\}  \par
               2 \par
 \par
 \par
solve(\{7x + 15y - z,x - y - z\},\{x,y,z\});  \par
 \par
 \par
      8*ARBCOMPLEX(3) \par
  \{\{X=---------------- \par
            11 \par
         3*ARBCOMPLEX(3) \par
    Y= - ---------------- \par
               11 \par
    Z=ARBCOMPLEX(3)\}\} \par
 \par
 \par
off solvesingular;  \par
 \par
solve(\{2x + y,4x + 2y\},\{x,y\});  \par
 \par
  ***** SOLVE given singular equations  \par
 \par
 \par
solve(\{7x + 15y - z,x - y - z\},\{x,y,z\});  \par
 \par
 \par
  ***** SOLVE given singular equations \par
 \par
\pard \sl240 }{\f2 The integer following the identifier }
{\f2\uldb arbcomplex}{\v\f2 ARBCOMPLEX} 
{\f2  above is assigned by 
the system, and serves to identify the variable uniquely. It has no other 
significance. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TIME}

${\footnote \pard\plain \sl240 \fs20 $ TIME}

+{\footnote \pard\plain \sl240 \fs20 + g12:0966}

 K{\footnote \pard\plain \sl240 \fs20 K time;TIME switch;switch}

}{\b\f2 TIME}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 time} {\f2  is on, the system time used in executing each REDUCE 
statement is printed after the answer is printed. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on time;  \par
 \par
  Time: 4940 ms  \par
 \par
 \par
df(sin(x**2 + y),y);  \par
 \par
            2 \par
  COS(X  + Y ) \par
  Time: 180 ms \par
 \par
 \par
solve(x**2 - 6*y,x);  \par
 \par
  \{X= - SQRT(Y)*SQRT(6), \par
   X=SQRT(Y)*SQRT(6)\} \par
  Time: 320 ms \par
 \par
\pard \sl240 }{\f2 When }{\f3 time} {\f2  is first turned on, the time since the beginning of the 
REDUCE session is printed. After that, the time used in computation, 
(usually in milliseconds, though this is system dependent) is printed after 
the results of each command. Idle time or time spent typing in commands is 
not counted. If }{\f3 time} {\f2  is turned off, the first reading after it is 
turned on again gives the time elapsed since it was turned off. The time 
printed is CPU or wall clock time, depending on the system. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TRALLFAC}

${\footnote \pard\plain \sl240 \fs20 $ TRALLFAC}

+{\footnote \pard\plain \sl240 \fs20 + g12:0967}

 K{\footnote \pard\plain \sl240 \fs20 K factorize;TRALLFAC switch;switch}

}{\b\f2 TRALLFAC}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 trallfac} {\f2  is on, a more detailed trace of factorizer calls is 
generated. 
\par 
\par 
The }{\f3 trallfac} {\f2  switch takes precedence over }
{\f2\uldb trfac}{\v\f2 TRFAC} 
{\f2  if they are 
both on. }{\f3 trfac} {\f2  gives a factorization trace with less detail in it. 
When the }
{\f2\uldb factor}{\v\f2 FACTOR} 
{\f2  switch is on also, all input polynomials are sent to 
the factorizer automatically and trace information is generated. The 
}
{\f2\uldb out}{\v\f2 OUT} 
{\f2  command saves the results of the factoring, but not the trace. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TRFAC}

${\footnote \pard\plain \sl240 \fs20 $ TRFAC}

+{\footnote \pard\plain \sl240 \fs20 + g12:0968}

 K{\footnote \pard\plain \sl240 \fs20 K factorize;TRFAC switch;switch}

}{\b\f2 TRFAC}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 trfac} {\f2  is on, a narrative trace of any calls to the factorizer is 
generated. Default is }{\f3 off} {\f2 . 
\par 
\par 
When the switch }
{\f2\uldb factor}{\v\f2 FACTOR} 
{\f2  is on, and }{\f3 trfac} {\f2  is on, every input 
polynomial is sent to the factorizer, and a trace generated. With 
}{\f3 factor} {\f2  off, only polynomials that are explicitly factored with the 
command }
{\f2\uldb factorize}{\v\f2 FACTORIZE} 
{\f2  generate trace information. 
\par 
\par 
The }
{\f2\uldb out}{\v\f2 OUT} 
{\f2  command saves the results of the factoring, but not 
the trace. The }
{\f2\uldb trallfac}{\v\f2 TRALLFAC} 
{\f2  switch gives trace information to a 
greater level of detail. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TRIGFORM}

${\footnote \pard\plain \sl240 \fs20 $ TRIGFORM}

+{\footnote \pard\plain \sl240 \fs20 + g12:0969}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;solve;TRIGFORM switch;switch}

}{\b\f2 TRIGFORM}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }
{\f2\uldb fullroots}{\v\f2 FULLROOTS} 
{\f2  is on, }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  will compute the 
roots of a cubic or quartic polynomial is closed form. When 
}{\f3 trigform} {\f2  is on, the roots will be expressed by trigonometric 
forms. Otherwise nested surds are used. Default is }{\f3 on} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TRINT}

${\footnote \pard\plain \sl240 \fs20 $ TRINT}

+{\footnote \pard\plain \sl240 \fs20 + g12:0970}

 K{\footnote \pard\plain \sl240 \fs20 K integration;TRINT switch;switch}

}{\b\f2 TRINT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 trint} {\f2  is on, a narrative tracing various steps in the 
integration process is produced. 
\par 
\par 
The }
{\f2\uldb out}{\v\f2 OUT} 
{\f2  command saves the results of the integration, but not the 
trace. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TRNONLNR}

${\footnote \pard\plain \sl240 \fs20 $ TRNONLNR}

+{\footnote \pard\plain \sl240 \fs20 + g12:0971}

 K{\footnote \pard\plain \sl240 \fs20 K solve;TRNONLNR switch;switch}

}{\b\f2 TRNONLNR}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 trnonlnr} {\f2  is on, a narrative tracing various steps in 
the process for solving non-linear equations is produced. 
\par 
\par 
}{\f3 trnonlnr} {\f2 can only be used after the solve package has been loaded 
(e.g., by an explicit call of }
{\f2\uldb load_package}{\v\f2 LOAD\_PACKAGE} 
{\f2 ). The }
{\f2\uldb out}{\v\f2 OUT} 
{\f2  
command saves the results of the equation solving, but not the trace. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # VAROPT}

${\footnote \pard\plain \sl240 \fs20 $ VAROPT}

+{\footnote \pard\plain \sl240 \fs20 + g12:0972}

 K{\footnote \pard\plain \sl240 \fs20 K solve;VAROPT switch;switch}

}{\b\f2 VAROPT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
When }{\f3 varopt} {\f2  is on, the sequence of variables is optimized by 
}
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  with respect to execution speed. Otherwise, the sequence 
given in the call to }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  is preserved. Default is }{\f3 on} {\f2 . 
\par 
\par 
In combination with the switch }
{\f2\uldb arbvars}{\v\f2 ARBVARS} 
{\f2 , }{\f3 varopt} {\f2  can be used 
to control variable elimination. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
off arbvars;  \par
 \par
solve(\{x+2z,x-3y\},\{x,y,z\});				 \par
 \par
           x      x \par
  		   \{\{y=-,z= - -\}\}  \par
           3      2 \par
 \par
 \par
solve(\{x*y=1,z=x\},\{x,y,z\});				 \par
 \par
               1 \par
  		   \{\{z=x,y=-\}\}  \par
               x \par
 \par
 \par
off varopt;  \par
 \par
solve(\{x+2z,x-3y\},\{x,y,z\});				 \par
 \par
                       2*z \par
  		   \{\{x= - 2*z,y= - ---\}\}  \par
                        3 \par
 \par
 \par
solve(\{x*y=1,z=x\},\{x,y,z\});				 \par
 \par
           1 \par
  		   \{\{y=-,x=z\}\}  \par
           z \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # g12}

${\footnote \pard\plain \sl240 \fs20 $ General Switches}

+{\footnote \pard\plain \sl240 \fs20 + index:0012}
}{\b\f2 General Switches}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb SWITCHES introduction}
{\v\f2 SWITCHES}{\f2 \par 
}{\f2 \tab}{\f2\uldb ALGINT switch}
{\v\f2 ALGINT}{\f2 \par 
}{\f2 \tab}{\f2\uldb ALLBRANCH switch}
{\v\f2 ALLBRANCH}{\f2 \par 
}{\f2 \tab}{\f2\uldb ALLFAC switch}
{\v\f2 ALLFAC}{\f2 \par 
}{\f2 \tab}{\f2\uldb ARBVARS switch}
{\v\f2 ARBVARS}{\f2 \par 
}{\f2 \tab}{\f2\uldb BALANCED\_MOD switch}
{\v\f2 BALANCED\_MOD}{\f2 \par 
}{\f2 \tab}{\f2\uldb BFSPACE switch}
{\v\f2 BFSPACE}{\f2 \par 
}{\f2 \tab}{\f2\uldb COMBINEEXPT switch}
{\v\f2 COMBINEEXPT}{\f2 \par 
}{\f2 \tab}{\f2\uldb COMBINELOGS switch}
{\v\f2 COMBINELOGS}{\f2 \par 
}{\f2 \tab}{\f2\uldb COMP switch}
{\v\f2 COMP}{\f2 \par 
}{\f2 \tab}{\f2\uldb COMPLEX switch}
{\v\f2 COMPLEX}{\f2 \par 
}{\f2 \tab}{\f2\uldb CREF switch}
{\v\f2 CREF}{\f2 \par 
}{\f2 \tab}{\f2\uldb CRAMER switch}
{\v\f2 CRAMER}{\f2 \par 
}{\f2 \tab}{\f2\uldb DEFN switch}
{\v\f2 DEFN}{\f2 \par 
}{\f2 \tab}{\f2\uldb DEMO switch}
{\v\f2 DEMO}{\f2 \par 
}{\f2 \tab}{\f2\uldb DFPRINT switch}
{\v\f2 DFPRINT}{\f2 \par 
}{\f2 \tab}{\f2\uldb DIV switch}
{\v\f2 DIV}{\f2 \par 
}{\f2 \tab}{\f2\uldb ECHO switch}
{\v\f2 ECHO}{\f2 \par 
}{\f2 \tab}{\f2\uldb ERRCONT switch}
{\v\f2 ERRCONT}{\f2 \par 
}{\f2 \tab}{\f2\uldb EVALLHSEQP switch}
{\v\f2 EVALLHSEQP}{\f2 \par 
}{\f2 \tab}{\f2\uldb EXP switch}
{\v\f2 EXP_switch}{\f2 \par 
}{\f2 \tab}{\f2\uldb EXPANDLOGS switch}
{\v\f2 EXPANDLOGS}{\f2 \par 
}{\f2 \tab}{\f2\uldb EZGCD switch}
{\v\f2 EZGCD}{\f2 \par 
}{\f2 \tab}{\f2\uldb FACTOR switch}
{\v\f2 FACTOR}{\f2 \par 
}{\f2 \tab}{\f2\uldb FAILHARD switch}
{\v\f2 FAILHARD}{\f2 \par 
}{\f2 \tab}{\f2\uldb FORT switch}
{\v\f2 FORT}{\f2 \par 
}{\f2 \tab}{\f2\uldb FORTUPPER switch}
{\v\f2 FORTUPPER}{\f2 \par 
}{\f2 \tab}{\f2\uldb FULLPREC switch}
{\v\f2 FULLPREC}{\f2 \par 
}{\f2 \tab}{\f2\uldb FULLROOTS switch}
{\v\f2 FULLROOTS}{\f2 \par 
}{\f2 \tab}{\f2\uldb GC switch}
{\v\f2 GC}{\f2 \par 
}{\f2 \tab}{\f2\uldb GCD switch}
{\v\f2 GCD_switch}{\f2 \par 
}{\f2 \tab}{\f2\uldb HORNER switch}
{\v\f2 HORNER}{\f2 \par 
}{\f2 \tab}{\f2\uldb IFACTOR switch}
{\v\f2 IFACTOR}{\f2 \par 
}{\f2 \tab}{\f2\uldb INT switch}
{\v\f2 INT_switch}{\f2 \par 
}{\f2 \tab}{\f2\uldb INTSTR switch}
{\v\f2 INTSTR}{\f2 \par 
}{\f2 \tab}{\f2\uldb LCM switch}
{\v\f2 LCM}{\f2 \par 
}{\f2 \tab}{\f2\uldb LESSSPACE switch}
{\v\f2 LESSSPACE}{\f2 \par 
}{\f2 \tab}{\f2\uldb LIMITEDFACTORS switch}
{\v\f2 LIMITEDFACTORS}{\f2 \par 
}{\f2 \tab}{\f2\uldb LIST switch}
{\v\f2 LIST_switch}{\f2 \par 
}{\f2 \tab}{\f2\uldb LISTARGS switch}
{\v\f2 LISTARGS}{\f2 \par 
}{\f2 \tab}{\f2\uldb MCD switch}
{\v\f2 MCD}{\f2 \par 
}{\f2 \tab}{\f2\uldb MODULAR switch}
{\v\f2 MODULAR}{\f2 \par 
}{\f2 \tab}{\f2\uldb MSG switch}
{\v\f2 MSG}{\f2 \par 
}{\f2 \tab}{\f2\uldb MULTIPLICITIES switch}
{\v\f2 MULTIPLICITIES}{\f2 \par 
}{\f2 \tab}{\f2\uldb NAT switch}
{\v\f2 NAT}{\f2 \par 
}{\f2 \tab}{\f2\uldb NERO switch}
{\v\f2 NERO}{\f2 \par 
}{\f2 \tab}{\f2\uldb NOARG switch}
{\v\f2 NOARG}{\f2 \par 
}{\f2 \tab}{\f2\uldb NOLNR switch}
{\v\f2 NOLNR}{\f2 \par 
}{\f2 \tab}{\f2\uldb NOSPLIT switch}
{\v\f2 NOSPLIT}{\f2 \par 
}{\f2 \tab}{\f2\uldb NUMVAL switch}
{\v\f2 NUMVAL}{\f2 \par 
}{\f2 \tab}{\f2\uldb OUTPUT switch}
{\v\f2 OUTPUT}{\f2 \par 
}{\f2 \tab}{\f2\uldb OVERVIEW switch}
{\v\f2 OVERVIEW}{\f2 \par 
}{\f2 \tab}{\f2\uldb PERIOD switch}
{\v\f2 PERIOD}{\f2 \par 
}{\f2 \tab}{\f2\uldb PRECISE switch}
{\v\f2 PRECISE}{\f2 \par 
}{\f2 \tab}{\f2\uldb PRET switch}
{\v\f2 PRET}{\f2 \par 
}{\f2 \tab}{\f2\uldb PRI switch}
{\v\f2 PRI}{\f2 \par 
}{\f2 \tab}{\f2\uldb RAISE switch}
{\v\f2 RAISE}{\f2 \par 
}{\f2 \tab}{\f2\uldb RAT switch}
{\v\f2 RAT}{\f2 \par 
}{\f2 \tab}{\f2\uldb RATARG switch}
{\v\f2 RATARG}{\f2 \par 
}{\f2 \tab}{\f2\uldb RATIONAL switch}
{\v\f2 RATIONAL}{\f2 \par 
}{\f2 \tab}{\f2\uldb RATIONALIZE switch}
{\v\f2 RATIONALIZE}{\f2 \par 
}{\f2 \tab}{\f2\uldb RATPRI switch}
{\v\f2 RATPRI}{\f2 \par 
}{\f2 \tab}{\f2\uldb REVPRI switch}
{\v\f2 REVPRI}{\f2 \par 
}{\f2 \tab}{\f2\uldb RLISP88 switch}
{\v\f2 RLISP88}{\f2 \par 
}{\f2 \tab}{\f2\uldb ROUNDALL switch}
{\v\f2 ROUNDALL}{\f2 \par 
}{\f2 \tab}{\f2\uldb ROUNDBF switch}
{\v\f2 ROUNDBF}{\f2 \par 
}{\f2 \tab}{\f2\uldb ROUNDED switch}
{\v\f2 ROUNDED}{\f2 \par 
}{\f2 \tab}{\f2\uldb SAVESTRUCTR switch}
{\v\f2 SAVESTRUCTR}{\f2 \par 
}{\f2 \tab}{\f2\uldb SOLVESINGULAR switch}
{\v\f2 SOLVESINGULAR}{\f2 \par 
}{\f2 \tab}{\f2\uldb TIME switch}
{\v\f2 TIME}{\f2 \par 
}{\f2 \tab}{\f2\uldb TRALLFAC switch}
{\v\f2 TRALLFAC}{\f2 \par 
}{\f2 \tab}{\f2\uldb TRFAC switch}
{\v\f2 TRFAC}{\f2 \par 
}{\f2 \tab}{\f2\uldb TRIGFORM switch}
{\v\f2 TRIGFORM}{\f2 \par 
}{\f2 \tab}{\f2\uldb TRINT switch}
{\v\f2 TRINT}{\f2 \par 
}{\f2 \tab}{\f2\uldb TRNONLNR switch}
{\v\f2 TRNONLNR}{\f2 \par 
}{\f2 \tab}{\f2\uldb VAROPT switch}
{\v\f2 VAROPT}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # COFACTOR}

${\footnote \pard\plain \sl240 \fs20 $ COFACTOR}

+{\footnote \pard\plain \sl240 \fs20 + g13:0973}

 K{\footnote \pard\plain \sl240 \fs20 K matrix;COFACTOR operator;operator}

}{\b\f2 COFACTOR}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 cofactor} {\f2  returns the cofactor of the element in row 
<row> and column <column> of a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . Errors occur 
if <row> or <column> do not evaluate to integer expressions or if 
the matrix is not square. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 cofactor} {\f4 (<matrix\_expression>,<row>,<column>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
cofactor(mat((a,b,c),(d,e,f),(p,q,r)),2,2);  \par
 \par
 \par
  A*R - C*P  \par
 \par
 \par
cofactor(mat((a,b,c),(d,e,f)),1,1);  \par
 \par
 \par
  ***** non-square matrix \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # DET}

${\footnote \pard\plain \sl240 \fs20 $ DET}

+{\footnote \pard\plain \sl240 \fs20 + g13:0974}

 K{\footnote \pard\plain \sl240 \fs20 K determinant;matrix;DET operator;operator}

}{\b\f2 DET}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 det} {\f2  operator returns the determinant of its 
(square }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 ) argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 det} {\f4 (<expression>) or }{\f3 det} {\f4  <expression> 
\par 
\par 
}{\f2 \par 
<expression> must evaluate to a square matrix. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
matrix m,n;  \par
 \par
 \par
m := mat((a,b),(c,d));  \par
 \par
  M(1,1) := A \par
  M(1,2) := B \par
  M(2,1) := C \par
  M(2,2) := D \par
                                  \par
 \par
 \par
det m;  \par
 \par
  A*D - B*C  \par
 \par
 \par
n := mat((1,2),(1,2));  \par
 \par
  N(1,1) := 1 \par
  N(1,2) := 2 \par
  N(2,1) := 1 \par
  N(2,2) := 2 \par
                                  \par
 \par
 \par
 \par
det(n);  \par
 \par
  0  \par
 \par
 \par
 \par
det(5);  \par
 \par
  5 \par
 \par
\pard \sl240 }{\f2 Given a numerical argument, }{\f3 det} {\f2  returns the number. However, given a 
variable name that has not been declared of type matrix, or a non-square 
matrix, }{\f3 det} {\f2  returns an error message. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MAT}

${\footnote \pard\plain \sl240 \fs20 $ MAT}

+{\footnote \pard\plain \sl240 \fs20 + g13:0975}

 K{\footnote \pard\plain \sl240 \fs20 K matrix;MAT operator;operator}

}{\b\f2 MAT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 mat} {\f2  operator is used to represent a two-dimensional 
}
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 mat} {\f4 ((<expr>\{,<expr>\}*) \{(<expr>\{}{\f3 ,} {\f4 <expr>\}*)\}*) 
\par 
\par 
}{\f2 \par 
<expr> may be any valid REDUCE scalar expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
mat((1,2),(3,4));  \par
 \par
  MAT(1,1) := 1 \par
  MAT(2,3) := 2 \par
  MAT(2,1) := 3 \par
  MAT(2,2) := 4 \par
 \par
 \par
mat(2,1);  \par
 \par
  ***** Matrix mismatch \par
  Cont? (Y or N)  \par
 \par
 \par
matrix qt;  \par
 \par
qt := ws;  \par
 \par
  QT(1,1) := 1 \par
  QT(1,2) := 2 \par
  QT(2,1) := 3 \par
  QT(2,2) := 4  \par
 \par
 \par
matrix a,b;  \par
 \par
a := mat((x),(y),(z));  \par
 \par
  A(1,1) := X \par
  A(2,1) := Y \par
  A(3,1) := Z  \par
 \par
 \par
b := mat((sin x,cos x,1));  \par
 \par
  B(1,1) := SIN(X) \par
  B(1,2) := COS(X) \par
  B(1,3) := 1 \par
 \par
\pard \sl240 }{\f2 Matrices need not have a size declared (unlike arrays). }{\f3 mat} {\f2  
redimensions a matrix variable as needed. It is necessary, of course, 
that all rows be the same length. An anonymous matrix, as shown in the 
first example, must be named before it can be referenced (note error 
message). When using }{\f3 mat} {\f2  to fill a 1 x n 
matrix, the row of values must be inside a second set of parentheses, to 
eliminate ambiguity. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MATEIGEN}

${\footnote \pard\plain \sl240 \fs20 $ MATEIGEN}

+{\footnote \pard\plain \sl240 \fs20 + g13:0976}

 K{\footnote \pard\plain \sl240 \fs20 K eigenvalue;matrix;MATEIGEN operator;operator}

}{\b\f2 MATEIGEN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 mateigen} {\f2  operator calculates the eigenvalue equation and the 
corresponding eigenvectors of a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 mateigen} {\f4 (<matrix-id>,<tag-id>) 
\par 
\par 
}{\f2 \par 
<matrix-id> must be a declared matrix of values, and <tag-id> must be 
a legal REDUCE identifier. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
aa := mat((2,5),(1,0))\$  \par
 \par
mateigen(aa,alpha);  \par
 \par
         2 \par
  \{\{ALPHA  - 2*ALPHA - 5, \par
    1, \par
                5*ARBCOMPLEX(1) \par
    MAT(1,1) := ---------------, \par
                   ALPHA - 2 \par
    MAT(2,1) := ARBCOMPLEX(1) \par
    \}\} \par
 \par
 \par
charpoly := first first ws;  \par
 \par
                   2 \par
  CHARPOLY := ALPHA  - 2*ALPHA - 5  \par
 \par
 \par
bb := mat((1,0,1),(1,1,0),(0,0,1))\$  \par
 \par
mateigen(bb,lamb);  \par
 \par
  \{\{LAMB - 1,3, \par
    [      0      ] \par
    [ARBCOMPLEX(2)] \par
    [      0      ] \par
    \}\} \par
 \par
\pard \sl240 }{\f2 The }{\f3 mateigen} {\f2  operator returns a list of lists of three 
elements. The first element is a square free factor of the characteristic 
polynomial; the second element is its multiplicity; and the third element 
is the corresponding eigenvector. If the characteristic polynomial can be 
completely factored, the product of the first elements of all the sublists 
will produce the minimal polynomial. You can access the various parts of 
the answer with the usual list access operators. 
\par 
\par 
If the matrix is degenerate, more than one eigenvector can be produced for 
the same eigenvalue, as shown by more than one arbitrary variable in the 
eigenvector. The identification numbers of the arbitrary complex variables 
shown in the examples above may not be the same as yours. Note that since 
}{\f3 lambda} {\f2  is a reserved word in REDUCE, you cannot use it as a 
tag-id for this operator. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MATRIX}

${\footnote \pard\plain \sl240 \fs20 $ MATRIX}

+{\footnote \pard\plain \sl240 \fs20 + g13:0977}

 K{\footnote \pard\plain \sl240 \fs20 K MATRIX declaration;declaration}

}{\b\f2 MATRIX}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
Identifiers are declared to be of type }{\f3 matrix} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 matrix} {\f4 <identifier> \tab option (<index>,<index>) 
\par 
\par 
\{,<identifier> \tab option 
 (<index>,<index>)\}* 
\par 
\par 
}{\f2 \par 
<identifier> must not be an already-defined operator or array or 
the name of a scalar variable. Dimensions are optional, and if used appear 
inside parentheses. <index> must be a positive integer. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
matrix a,b(1,4),c(4,4);  \par
 \par
b(1,1);  \par
 \par
  0  \par
 \par
 \par
a(1,1);  \par
 \par
  ***** Matrix A not set  \par
 \par
 \par
a := mat((x0,y0),(x1,y1));  \par
 \par
  A(1,1) := X0 \par
  A(1,2) := Y0 \par
  A(2,1) := X0 \par
  A(2,2) := X1 \par
 \par
 \par
length a;  \par
 \par
  \{2,2\}  \par
 \par
 \par
b := a**2;  \par
 \par
              2 \par
  B(1,1) := X0  + X1*Y0 \par
  B(1,2) := Y0*(X0 + Y1) \par
  B(2,1) := X1*(X0 + Y1) \par
                      2 \par
  B(2,2) := X1*Y0 + Y1 \par
 \par
\pard \sl240 }{\f2 When a matrix variable has not been dimensioned, matrix elements cannot be 
referenced until the matrix is set by the }
{\f2\uldb mat}{\v\f2 MAT} 
{\f2  operator. When a 
matrix is dimensioned in its declaration, matrix elements are set to 0. 
Matrix elements cannot stand for themselves. When you use }
{\f2\uldb let}{\v\f2 LET} 
{\f2  on 
a matrix element, there is no effect unless the element contains a 
constant, in which case an error message is returned. The same behavior 
occurs with }
{\f2\uldb clear}{\v\f2 CLEAR} 
{\f2 . Do <not> use }
{\f2\uldb clear}{\v\f2 CLEAR} 
{\f2  to try to 
set a matrix element to 0. }
{\f2\uldb let}{\v\f2 LET} 
{\f2  statements can be applied to 
matrices as a whole, if the right-hand side of the expression is a matrix 
expression, and the left-hand side identifier has been declared to be a matrix. 
\par 
\par 
Arithmetical operators apply to matrices of the correct dimensions. The 
operators }{\f3 +} {\f2  and }{\f3 -} {\f2  can be used with matrices of the same 
dimensions. The operator }{\f3 *} {\f2  can be used to multiply 
m x n matrices by n x p 
matrices. Matrix multiplication is non-commutative. Scalars can also be 
multiplied with matrices, with the result that each element of the matrix 
is multiplied by the scalar. The operator }{\f3 /} {\f2  applied to two 
matrices computes the first matrix multiplied by the inverse of the 
second, if the inverse exists, and produces an error message otherwise. 
Matrices can be divided by scalars, which results in dividing each element 
of the matrix. Scalars can also be divided by matrices when the matrices 
are invertible, and the result is the multiplication of the scalar by the 
inverse of the matrix. Matrix inverses can by found by }{\f3 1/A} {\f2  or 
}{\f3 /A} {\f2 , where }{\f3 A} {\f2  is a matrix. Square matrices can be raised to 
positive integer powers, and also to negative integer powers if they are 
nonsingular. 
\par 
\par 
When a matrix variable is assigned to the results of a calculation, the 
matrix is redimensioned if necessary. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NULLSPACE}

${\footnote \pard\plain \sl240 \fs20 $ NULLSPACE}

+{\footnote \pard\plain \sl240 \fs20 + g13:0978}

 K{\footnote \pard\plain \sl240 \fs20 K matrix;NULLSPACE operator;operator}

}{\b\f2 NULLSPACE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 nullspace} {\f4 (<matrix\_expression>) 
\par 
\par 
}{\f2 \par 
<nullspace> calculates for its }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  argument, 
}{\f3 a} {\f2 , a list of 
linear independent vectors (a basis) whose linear combinations satisfy the 
equation }{\f4 a x = 0}{\f2 . The basis is provided in a form such that as many 
upper components as possible are isolated. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
nullspace mat((1,2,3,4),(5,6,7,8));  \par
 \par
 \par
         \{ \par
           [ 1  ] \par
           [    ] \par
           [ 0  ] \par
           [    ] \par
           [ - 3] \par
           [    ] \par
           [ 2  ] \par
           , \par
           [ 0  ] \par
           [    ] \par
           [ 1  ] \par
           [    ] \par
           [ - 2] \par
           [    ] \par
           [ 1  ] \par
          \} \par
 \par
\pard \sl240 }{\f2 Note that with }{\f3 b := nullspace a} {\f2 , the expression }{\f3 length b} {\f2  is 
the nullity/ of A, and that }{\f3 second length a - length b} {\f2  
calculates the rank/ of A. The rank of a matrix expression can 
also be found more directly by the }
{\f2\uldb rank}{\v\f2 RANK} 
{\f2  operator. 
\par 
\par 
In addition to the REDUCE matrix form, }{\f3 nullspace} {\f2  accepts as input a 
matrix given as a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  of lists, that is interpreted as a row matrix. If 
that form of input is chosen, the vectors in the result will be 
represented by lists as well. This additional input syntax facilitates 
the use of }{\f3 nullspace} {\f2  in applications different from classical linear 
algebra. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RANK}

${\footnote \pard\plain \sl240 \fs20 $ RANK}

+{\footnote \pard\plain \sl240 \fs20 + g13:0979}

 K{\footnote \pard\plain \sl240 \fs20 K matrix;RANK operator;operator}

}{\b\f2 RANK}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 rank} {\f4 (<matrix\_expression>) 
\par 
\par 
}{\f2 \par 
}{\f3 rank} {\f2 calculates the rank of its matrix argument. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
rank mat((a,b,c),(d,e,f));  \par
 \par
  2 \par
 \par
\pard \sl240 }{\f2 The argument to }{\f3 rank} {\f2  can also be a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  of lists, interpreted 
either as a row matrix or a set of equations. If that form of input is 
chosen, the vectors in the result will be represented by lists as well. 
This additional input syntax facilitates the use of }{\f3 rank} {\f2  in 
applications different from classical linear algebra. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TP}

${\footnote \pard\plain \sl240 \fs20 $ TP}

+{\footnote \pard\plain \sl240 \fs20 + g13:0980}

 K{\footnote \pard\plain \sl240 \fs20 K matrix;transpose;TP operator;operator}

}{\b\f2 TP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 tp} {\f2  operator returns the transpose of its }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  
 argument. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 tp} {\f4 <identifier> or }{\f3 tp} {\f4 (<identifier>) 
\par 
\par 
}{\f2 \par 
<identifier> must be a matrix, which either has had its dimensions set 
in its declaration, or has had values put into it by }{\f3 mat} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
matrix m,n;  \par
 \par
m := mat((1,2,3),(4,5,6))$  \par
 \par
n := tp m;  \par
 \par
  N(1,1) := 1 \par
  N(1,2) := 4 \par
  N(2,1) := 2 \par
  N(2,2) := 5 \par
  N(3,1) := 3 \par
  N(3,2) := 6 \par
 \par
\pard \sl240 }{\f2 In an assignment statement involving }{\f3 tp} {\f2 , the matrix identifier on the 
left-hand side is redimensioned to the correct size for the transpose. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TRACE}

${\footnote \pard\plain \sl240 \fs20 $ TRACE}

+{\footnote \pard\plain \sl240 \fs20 + g13:0981}

 K{\footnote \pard\plain \sl240 \fs20 K matrix;TRACE operator;operator}

}{\b\f2 TRACE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 trace} {\f2  operator finds the trace of its }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  argument. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 trace} {\f4 (<expression>) or }{\f3 trace} {\f4  <simple\_expression> 
\par 
\par 
}{\f2 \par 
<expression> or <simple\_expression> must evaluate to a square 
matrix. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
matrix a;  \par
 \par
a := mat((x1,y1),(x2,y2))\$  \par
 \par
trace a;  \par
 \par
  X1 + Y2 \par
 \par
\pard \sl240 }{\f2 The trace is the sum of the entries along the diagonal of a square matrix. 
Given a non-matrix expression, or a non-square matrix, }{\f3 trace} {\f2  returns 
an error message. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g13}

${\footnote \pard\plain \sl240 \fs20 $ Matrix Operations}

+{\footnote \pard\plain \sl240 \fs20 + index:0013}
}{\b\f2 Matrix Operations}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb COFACTOR operator}
{\v\f2 COFACTOR}{\f2 \par 
}{\f2 \tab}{\f2\uldb DET operator}
{\v\f2 DET}{\f2 \par 
}{\f2 \tab}{\f2\uldb MAT operator}
{\v\f2 MAT}{\f2 \par 
}{\f2 \tab}{\f2\uldb MATEIGEN operator}
{\v\f2 MATEIGEN}{\f2 \par 
}{\f2 \tab}{\f2\uldb MATRIX declaration}
{\v\f2 MATRIX}{\f2 \par 
}{\f2 \tab}{\f2\uldb NULLSPACE operator}
{\v\f2 NULLSPACE}{\f2 \par 
}{\f2 \tab}{\f2\uldb RANK operator}
{\v\f2 RANK}{\f2 \par 
}{\f2 \tab}{\f2\uldb TP operator}
{\v\f2 TP}{\f2 \par 
}{\f2 \tab}{\f2\uldb TRACE operator}
{\v\f2 TRACE}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Groebner_bases}

${\footnote \pard\plain \sl240 \fs20 $ Groebner_bases}

+{\footnote \pard\plain \sl240 \fs20 + g14:0982}

 K{\footnote \pard\plain \sl240 \fs20 K Kredel-Weispfenning algorithm;Faugere-Gianni-Lazard-Mora algorithm;Hollmann algorithm;Buchberger algorithm;Groebner bases;Groebner bases introduction;introducti
on}

}{\b\f2 GROEBNER BASES}{\f2 \tab \tab \tab \tab }{\b\f2 introduction}{\f2 \par 
\par 
 
The GROEBNER package calculates }{\f3 Groebner bases} {\f2  using the 
 }{\f3 Buchberger algorithm} {\f2  and provides related algorithms 
for arithmetic with ideal bases, such as ideal quotients, 
Hilbert polynomials ( }{\f3 Hollmann algorithm} {\f2 ), 
basis conversion ( 
 }{\f3 Faugere-Gianni-Lazard-Mora algorithm} {\f2 ), independent 
variable set ( }{\f3 Kredel-Weispfenning algorithm} {\f2 ). 
\par 
\par 
Some routines of the Groebner package are used by }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  - in 
that context the package is loaded automatically. However, if you 
want to use the package by explicit calls you must load it by 
\pard \tx3420 }{\f4  \par
    load_package groebner; \par
\pard \sl240 }{\f2 \par 
\par 
For the common parameter setting of most operators in this package 
see }
{\f2\uldb ideal parameters}{\v\f2 Ideal_Parameters} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Ideal_Parameters}

${\footnote \pard\plain \sl240 \fs20 $ Ideal_Parameters}

+{\footnote \pard\plain \sl240 \fs20 + g14:0983}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;Ideal Parameters concept;concept}

}{\b\f2 IDEAL PARAMETERS}{\f2 \par 
\par 
 
 \par 
\par 
Most operators of the }{\f3 Groebner} {\f2  package compute expressions in a 
polynomial ring which given as <R>[<var>,<var>,...] where 
<R> is the current REDUCE coefficient domain. All algebraically 
exact domains of REDUCE are supported. The package can operate over rings 
and fields. The operation mode is distinguished automatically. In 
general the ring mode is a bit faster than the field mode. The factoring 
variant can be applied only over domains which allow you factoring of 
multivariate polynomials. 
\par 
\par 
The variable sequence <var> is either declared explicitly as argument 
in form of a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  in }
{\f2\uldb torder}{\v\f2 torder} 
{\f2 , or it is extracted 
automatically from the expressions. In the second case the current REDUCE 
system order is used (see }
{\f2\uldb korder}{\v\f2 KORDER} 
{\f2 ) for arranging the variables. 
If some kernels should play the role of formal parameters (the ground 
domain <R> then is the polynomial ring over these), the variable 
sequences must be given explicitly. 
\par 
\par 
All REDUCE }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 s can be used as variables. But please note, 
that all variables are considered as independent. E.g. when using 
}{\f3 sin(a)} {\f2  and }{\f3 cos(a)} {\f2  as variables, the basic relation 
}{\f3 sin(a)^2+cos(a)^2-1=0} {\f2  must be explicitly added to an equation set 
because the Groebner operators don't include such knowledge automatically. 
\par 
\par 
The terms (monomials) in polynomials are arranged according to the current 
}
{\f2\uldb term order}{\v\f2 Term_order} 
{\f2 . Note that the algebraic properties of the computed 
results only are valid as long as neither the ordering nor the variable 
sequence changes. 
\par 
\par 
The input expressions <exp> can be polynomials <p>, rational 
functions <n>/<d> or equations <lh>=<rh> built from 
polynomials or rational functions. Apart from the }{\f3 tracing} {\f2  
algorithms }
{\f2\uldb groebnert}{\v\f2 groebnert} 
{\f2  and }
{\f2\uldb preducet}{\v\f2 preducet} 
{\f2 , where the equations 
have a specific meaning, equations are converted to simple expressions by 
taking the difference of the left-hand and right-hand sides 
<lh>-<rh>=><p>. Rational functions are converted to 
polynomials by converting the expression to a common denominator form 
first, and then using the numerator only <n>=><p>. So eventual 
zeros of the denominators are ignored. 
\par 
\par 
A basis on input or output of an algorithm is coded as }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  of 
expressions \{<exp>,<exp>,...\} . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Term_order}

${\footnote \pard\plain \sl240 \fs20 $ Term_order}

+{\footnote \pard\plain \sl240 \fs20 + g15:0984}

 K{\footnote \pard\plain \sl240 \fs20 K distributive polynomials;Term order introduction;introduction}

}{\b\f2 TERM ORDER}{\f2 \tab \tab \tab \tab }{\b\f2 introduction}{\f2 \par 
\par 
 
 \par 
\par 
For all }{\f3 Groebner} {\f2  operations the polynomials are 
represented in distributive form: a sum of terms (monomials). 
The terms are ordered corresponding to the actual }{\f3 term order} {\f2  
which is set by the }
{\f2\uldb torder}{\v\f2 torder} 
{\f2  operator, and to the 
actual variable sequence which is either given as explicit 
parameter or by the system }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2  order. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # torder}

${\footnote \pard\plain \sl240 \fs20 $ torder}

+{\footnote \pard\plain \sl240 \fs20 + g15:0985}

 K{\footnote \pard\plain \sl240 \fs20 K torder operator;operator}

}{\b\f2 TORDER}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The operator }{\f3 torder} {\f2  sets the actual variable sequence and term order. 
\par 
\par 
1. simple term order: 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 torder} {\f4 (<vl>, <m>) 
\par 
\par 
}{\f2 \par 
where <vl> is a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  of variables (}
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 s) and 
<m> is the name of a simple }
{\f2\uldb term order}{\v\f2 Term_order} 
{\f2  mode 
}
{\f2\uldb lex term order}{\v\f2 lex_term_order} 
{\f2 , }
{\f2\uldb gradlex term order}{\v\f2 gradlex_term_order} 
{\f2 , 
}
{\f2\uldb revgradlex term order}{\v\f2 revgradlex_term_order} 
{\f2  or another implemented parameterless mode. 
\par 
\par 
2. stepped term order: 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 torder} {\f4 (<vl>,<m>,<n>) 
\par 
\par 
\par 
\par 
}{\f2 where <m> is the name of a two step term order, one of 
}
{\f2\uldb gradlexgradlex term order}{\v\f2 gradlexgradlex_term_order} 
{\f2 , }
{\f2\uldb gradlexrevgradlex term order}{\v\f2 gradlexrevgradlex_term_order} 
{\f2 , 
}
{\f2\uldb lexgradlex term order}{\v\f2 lexgradlex_term_order} 
{\f2  or }
{\f2\uldb lexrevgradlex term order}{\v\f2 lexrevgradlex_term_order} 
{\f2 , and 
<n> is a positive integer. 
\par 
\par 
3. weighted term order 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 torder} {\f4 (<vl>, }{\f3 weighted} {\f4 , <n>,<n>,...); 
\par 
\par 
}{\f2 \par 
where the <n> are positive integers, see }
{\f2\uldb weighted term order}{\v\f2 weighted_term_order} 
{\f2 . 
\par 
\par 
4. matrix term order 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 torder} {\f4 (<vl>, }{\f3 matrix} {\f4 , <m>); 
\par 
\par 
}{\f2 \par 
where <m> is a matrix with integer elements, see 
}
{\f2\uldb torder_compile}{\v\f2 torder_compile} 
{\f2 . 
\par 
\par 
5. compiled term order 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 torder} {\f4 (<vl>, }{\f3 co} {\f4 ); 
\par 
\par 
}{\f2 \par 
where <co> is the name of a routine generated by 
}
{\f2\uldb torder_compile}{\v\f2 torder_compile} 
{\f2 . 
\par 
\par 
}{\f3 torder} {\f2 sets the variable sequence and the term order mode. If the 
an empty list is used as variable sequence, the automatic variable extraction 
is activated. The defaults are the empty variable list an the 
}
{\f2\uldb lex term order}{\v\f2 lex_term_order} 
{\f2 . 
The previous setting is returned as a list. 
\par 
\par 
Alternatively to the above syntax the arguments of }{\f3 torder} {\f2  may be 
collected in a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  and passed as one argument to 
}{\f3 torder} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # torder_compile}

${\footnote \pard\plain \sl240 \fs20 $ torder_compile}

+{\footnote \pard\plain \sl240 \fs20 + g15:0986}

 K{\footnote \pard\plain \sl240 \fs20 K term order;torder_compile operator;operator}

}{\b\f2 TORDER_COMPILE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
A matrix can be converted into 
a compilable LISP program for faster execution by using 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 torder_compile} {\f4 (<name>,<mat>) 
\par 
\par 
}{\f2 \par 
where <name> is an identifier for the new term order and <mat> 
is an integer matrix to be used as }
{\f2\uldb matrix term order}{\v\f2 matrix_term_order} 
{\f2 . Afterwards 
the term order can be activated by using <name> in a }
{\f2\uldb torder}{\v\f2 torder} 
{\f2  
expression. The resulting program is compiled if the switch }
{\f2\uldb comp}{\v\f2 COMP} 
{\f2  
is on, or if the }{\f3 torder_compile} {\f2  expression is part of a compiled 
module. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # lex_term_order}

${\footnote \pard\plain \sl240 \fs20 $ lex_term_order}

+{\footnote \pard\plain \sl240 \fs20 + g15:0987}

 K{\footnote \pard\plain \sl240 \fs20 K variable elimination;term order;lex term order concept;concept}

}{\b\f2 LEX TERM ORDER}{\f2 \par 
\par 
 
 \par 
\par 
The terms are ordered lexicographically: two terms t1 t2 
are compared for their degrees 
along the fixed variable sequence: t1 is higher than t2 
if the first different degree is higher in t1. 
This order has the }{\f3 elimination property} {\f2  
for }{\f3 groebner basis} {\f2  calculations. 
If the ideal has a univariate polynomial in the last 
variable the groebner basis will contain 
such polynomial. }{\f3 Lex} {\f2  is best 
suited for solving of polynomial equation systems. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gradlex_term_order}

${\footnote \pard\plain \sl240 \fs20 $ gradlex_term_order}

+{\footnote \pard\plain \sl240 \fs20 + g15:0988}

 K{\footnote \pard\plain \sl240 \fs20 K term order;gradlex term order concept;concept}

}{\b\f2 GRADLEX TERM ORDER}{\f2 \par 
\par 
 
 \par 
\par 
The terms are ordered first with their total 
degree, and if the total degree is identical 
the comparison is }
{\f2\uldb lex term order}{\v\f2 lex_term_order} 
{\f2 . 
With }{\f3 groebner} {\f2  basis calculations this term order 
produces polynomials of lowest degree. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # revgradlex_term_order}

${\footnote \pard\plain \sl240 \fs20 $ revgradlex_term_order}

+{\footnote \pard\plain \sl240 \fs20 + g15:0989}

 K{\footnote \pard\plain \sl240 \fs20 K term order;revgradlex term order concept;concept}

}{\b\f2 REVGRADLEX TERM ORDER}{\f2 \par 
\par 
 
 \par 
\par 
The terms are ordered first with their total 
degree (degree sum), and if the total degree is identical 
the comparison is the inverse of }
{\f2\uldb lex term order}{\v\f2 lex_term_order} 
{\f2 . 
With }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  and }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  
calculations this term order 
is similar to }
{\f2\uldb gradlex term order}{\v\f2 gradlex_term_order} 
{\f2 ; it is known 
as most efficient ordering with respect to computing time. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gradlexgradlex_term_order}

${\footnote \pard\plain \sl240 \fs20 $ gradlexgradlex_term_order}

+{\footnote \pard\plain \sl240 \fs20 + g15:0990}

 K{\footnote \pard\plain \sl240 \fs20 K term order;gradlexgradlex term order concept;concept}

}{\b\f2 GRADLEXGRADLEX TERM ORDER}{\f2 \par 
\par 
 
 \par 
\par 
The terms are separated into two groups where the 
second parameter of the }
{\f2\uldb torder}{\v\f2 torder} 
{\f2  call determines 
the length of the first group. For a comparison first 
the total degrees of both variable groups are compared. 
If both are equal 
}
{\f2\uldb gradlex term order}{\v\f2 gradlex_term_order} 
{\f2  comparison is applied to the first 
group, and if that does not decide }
{\f2\uldb gradlex term order}{\v\f2 gradlex_term_order} 
{\f2  
is applied for the second group. This order has the elimination 
property for the variable groups. It can be used e.g. for 
separating variables from parameters. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gradlexrevgradlex_term_order}

${\footnote \pard\plain \sl240 \fs20 $ gradlexrevgradlex_term_order}

+{\footnote \pard\plain \sl240 \fs20 + g15:0991}

 K{\footnote \pard\plain \sl240 \fs20 K term order;gradlexrevgradlex term order concept;concept}

}{\b\f2 GRADLEXREVGRADLEX TERM ORDER}{\f2 \par 
\par 
 
 \par 
\par 
Similar to }
{\f2\uldb gradlexgradlex term order}{\v\f2 gradlexgradlex_term_order} 
{\f2 , but using 
}
{\f2\uldb revgradlex term order}{\v\f2 revgradlex_term_order} 
{\f2  for the second group. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # lexgradlex_term_order}

${\footnote \pard\plain \sl240 \fs20 $ lexgradlex_term_order}

+{\footnote \pard\plain \sl240 \fs20 + g15:0992}

 K{\footnote \pard\plain \sl240 \fs20 K term order;lexgradlex term order concept;concept}

}{\b\f2 LEXGRADLEX TERM ORDER}{\f2 \par 
\par 
 
 \par 
\par 
Similar to }
{\f2\uldb gradlexgradlex term order}{\v\f2 gradlexgradlex_term_order} 
{\f2 , but using 
}
{\f2\uldb lex term order}{\v\f2 lex_term_order} 
{\f2  for the first group. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # lexrevgradlex_term_order}

${\footnote \pard\plain \sl240 \fs20 $ lexrevgradlex_term_order}

+{\footnote \pard\plain \sl240 \fs20 + g15:0993}

 K{\footnote \pard\plain \sl240 \fs20 K term order;lexrevgradlex term order concept;concept}

}{\b\f2 LEXREVGRADLEX TERM ORDER}{\f2 \par 
\par 
 
 \par 
\par 
Similar to }
{\f2\uldb gradlexgradlex term order}{\v\f2 gradlexgradlex_term_order} 
{\f2 , but using 
}
{\f2\uldb lex term order}{\v\f2 lex_term_order} 
{\f2  for the first group 
}
{\f2\uldb revgradlex term order}{\v\f2 revgradlex_term_order} 
{\f2  for the second group. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # weighted_term_order}

${\footnote \pard\plain \sl240 \fs20 $ weighted_term_order}

+{\footnote \pard\plain \sl240 \fs20 + g15:0994}

 K{\footnote \pard\plain \sl240 \fs20 K term order;weighted term order concept;concept}

}{\b\f2 WEIGHTED TERM ORDER}{\f2 \par 
\par 
 
 \par 
\par 
establishes a graduated ordering 
similar to }
{\f2\uldb gradlex term order}{\v\f2 gradlex_term_order} 
{\f2 , where the exponents first are 
multiplied by the given weights. If there are less weight values than 
variables, the weight list is extended by ones. If the weighted degree 
comparison is not decidable, the 
}
{\f2\uldb lex term order}{\v\f2 lex_term_order} 
{\f2  is used. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # graded_term_order}

${\footnote \pard\plain \sl240 \fs20 $ graded_term_order}

+{\footnote \pard\plain \sl240 \fs20 + g15:0995}

 K{\footnote \pard\plain \sl240 \fs20 K term order;graded term order concept;concept}

}{\b\f2 GRADED TERM ORDER}{\f2 \par 
\par 
 
 \par 
\par 
establishes a cascaded term ordering: first a graduated ordering 
similar to }
{\f2\uldb gradlex term order}{\v\f2 gradlex_term_order} 
{\f2  is used, where the exponents first are 
multiplied by the given weights. If there are less weight values than 
variables, the weight list is extended by ones. If the weighted degree 
comparison is not decidable, the term ordering described in the following 
parameters of the }
{\f2\uldb torder}{\v\f2 torder} 
{\f2  command is used. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # matrix_term_order}

${\footnote \pard\plain \sl240 \fs20 $ matrix_term_order}

+{\footnote \pard\plain \sl240 \fs20 + g15:0996}

 K{\footnote \pard\plain \sl240 \fs20 K term order;matrix term order concept;concept}

}{\b\f2 MATRIX TERM ORDER}{\f2 \par 
\par 
 
 \par 
\par 
Any arbitrary term order mode can be installed by a matrix with 
integer elements where the row length corresponds to the variable 
number. The matrix must have at least as many rows as columns. 
It must have full rank, and the top nonzero element of each column 
must be positive. 
\par 
\par 
The matrix }{\f3 term order mode} {\f2  
defines a term order where the exponent vectors of the monomials are 
first multiplied by the matrix and the resulting vectors are compared 
lexicographically. 
\par 
\par 
If the switch }
{\f2\uldb comp}{\v\f2 COMP} 
{\f2  is on, the matrix is converted into 
a compiled LISP program for faster execution. A matrix can also be 
compiled explicitly, see }
{\f2\uldb torder_compile}{\v\f2 torder_compile} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g15}

${\footnote \pard\plain \sl240 \fs20 $ Term order}

+{\footnote \pard\plain \sl240 \fs20 + index:0015}
}{\b\f2 Term order}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb Term order introduction}
{\v\f2 Term_order}{\f2 \par 
}{\f2 \tab}{\f2\uldb torder operator}
{\v\f2 torder}{\f2 \par 
}{\f2 \tab}{\f2\uldb torder_compile operator}
{\v\f2 torder_compile}{\f2 \par 
}{\f2 \tab}{\f2\uldb lex term order concept}
{\v\f2 lex_term_order}{\f2 \par 
}{\f2 \tab}{\f2\uldb gradlex term order concept}
{\v\f2 gradlex_term_order}{\f2 \par 
}{\f2 \tab}{\f2\uldb revgradlex term order concept}
{\v\f2 revgradlex_term_order}{\f2 \par 
}{\f2 \tab}{\f2\uldb gradlexgradlex term order concept}
{\v\f2 gradlexgradlex_term_order}{\f2 \par 
}{\f2 \tab}{\f2\uldb gradlexrevgradlex term order concept}
{\v\f2 gradlexrevgradlex_term_order}{\f2 \par 
}{\f2 \tab}{\f2\uldb lexgradlex term order concept}
{\v\f2 lexgradlex_term_order}{\f2 \par 
}{\f2 \tab}{\f2\uldb lexrevgradlex term order concept}
{\v\f2 lexrevgradlex_term_order}{\f2 \par 
}{\f2 \tab}{\f2\uldb weighted term order concept}
{\v\f2 weighted_term_order}{\f2 \par 
}{\f2 \tab}{\f2\uldb graded term order concept}
{\v\f2 graded_term_order}{\f2 \par 
}{\f2 \tab}{\f2\uldb matrix term order concept}
{\v\f2 matrix_term_order}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gvars}

${\footnote \pard\plain \sl240 \fs20 $ gvars}

+{\footnote \pard\plain \sl240 \fs20 + g16:0997}

 K{\footnote \pard\plain \sl240 \fs20 K gvars operator;operator}

}{\b\f2 GVARS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 gvars} {\f4 (\{<exp>,<exp>,... \}) 
\par 
\par 
\par 
\par 
}{\f2 where <exp> are expressions or }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2 s. 
\par 
\par 
}{\f3 gvars} {\f2 extracts from the expressions the }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f3 s} {\f2  
which can 
play the role of variables for a }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  or }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  
calculation. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebner}

${\footnote \pard\plain \sl240 \fs20 $ groebner}

+{\footnote \pard\plain \sl240 \fs20 + g16:0998}

 K{\footnote \pard\plain \sl240 \fs20 K Buchberger algorithm;groebner operator;operator}

}{\b\f2 GROEBNER}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 groebner} {\f4 (\{}{\f3 exp} {\f4 , ...\}) 
\par 
\par 
\par 
\par 
}{\f2 where \{}{\f3 exp} {\f2 , ... \}is a list of 
expressions or equations. 
\par 
\par 
The operator }{\f3 groebner} {\f2  implements the Buchberger algorithm 
for computing Groebner bases for a given set of 
expressions with respect to the given set of variables in the order 
given. As a side effect, the sequence of variables is stored as a REDUCE list 
in the shared variable }
{\f2\uldb gvarslast}{\v\f2 gvarslast} 
{\f2  - this is important in cases 
where the algorithm rearranges the variable sequence because }
{\f2\uldb groebopt}{\v\f2 groebopt} 
{\f2  
is }{\f3 on} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
   groebner(\{x**2+y**2-1,x-y\})  \par
 \par
  \{X - Y,2*Y**2 -1\} \par
 \par
\pard \sl240 }{\f2  \par
related: \par
\par 
\tab }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2 operator 
\par 
\tab  }
{\f2\uldb gvarslast}{\v\f2 gvarslast} 
{\f2  variable 
\par 
\tab  }
{\f2\uldb groebopt}{\v\f2 groebopt} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb groebprereduce}{\v\f2 groebprereduce} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb groebfullreduction}{\v\f2 groebfullreduction} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb gltbasis}{\v\f2 gltbasis} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb gltb}{\v\f2 gltb} 
{\f2  variable 
\par 
\tab  }
{\f2\uldb glterms}{\v\f2 glterms} 
{\f2  variable 
\par 
\tab  }
{\f2\uldb groebstat}{\v\f2 groebstat} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb trgroeb}{\v\f2 trgroeb} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb trgroebs}{\v\f2 trgroebs} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb groebprot}{\v\f2 groebprot} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb groebprotfile}{\v\f2 groebprotfile} 
{\f2  variable 
\par 
\tab  }
{\f2\uldb groebnert}{\v\f2 groebnert} 
{\f2  operator 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebner\_walk}

${\footnote \pard\plain \sl240 \fs20 $ groebner_walk}

+{\footnote \pard\plain \sl240 \fs20 + g16:0999}

 K{\footnote \pard\plain \sl240 \fs20 K groebner_walk operator;operator}

}{\b\f2 GROEBNER\_WALK}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The operator }{\f3 groebner_walk} {\f2  computes a }{\f3 lex} {\f2  basis 
from a given }{\f3 graded} {\f2  (or }{\f3 weighted} {\f2 ) one. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 groebner_walk} {\f4 (<g>) 
\par 
\par 
}{\f2 \par 
where <g> is a }{\f3 graded} {\f2  basis (or }{\f3 weighted} {\f2  basis 
with a weight vector with one repeated element) of the polynomial ideal. 
}{\f3 Groebner_walk} {\f2  computes a sequence of monomial bases, each 
time lifting the full system to a complete basis. }{\f3 Groebner_walk} {\f2  
should be called only in cases, where a normal }{\f3 kex} {\f2  computation 
would take too much computer time. 
\par 
\par 
The operator }
{\f2\uldb torder}{\v\f2 torder} 
{\f2  has to be called before in order to 
define the variable sequence and the term order mode of <g>. 
\par 
\par 
The variable }
{\f2\uldb gvarslast}{\v\f2 gvarslast} 
{\f2  is not set. 
\par 
\par 
Do not call }{\f3 groebner_walk} {\f2  with }{\f3 on} {\f2  }
{\f2\uldb groebopt}{\v\f2 groebopt} 
{\f2 . 
\par 
\par 
}{\f3 Groebner_walk} {\f2 includes some overhead (such as e. g. 
computation with division). On the other hand, sometimes 
}{\f3 groebner_walk} {\f2  is faster than a direct }{\f3 lex} {\f2  computation. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebopt}

${\footnote \pard\plain \sl240 \fs20 $ groebopt}

+{\footnote \pard\plain \sl240 \fs20 + g16:1000}

 K{\footnote \pard\plain \sl240 \fs20 K groebopt switch;switch}

}{\b\f2 GROEBOPT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
If }{\f3 groebopt} {\f2  is set ON, the sequence of variables is optimized 
with respect to execution speed of }{\f3 groebner} {\f2  calculations; 
note that the final list of variables is available in }
{\f2\uldb gvarslast}{\v\f2 gvarslast} 
{\f2 . 
By default }{\f3 groebopt} {\f2  is off, conserving the original variable 
sequence. 
\par 
\par 
An explicitly declared dependency using the }
{\f2\uldb depend}{\v\f2 DEPEND} 
{\f2  
declaration supersedes the variable optimization. 
 \par
examples: \par
\pard \tx3420 }{\f4 \pard \sl240 }{\f2 \par 
\par 
guarantees that a will be placed in front of x and y. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gvarslast}

${\footnote \pard\plain \sl240 \fs20 $ gvarslast}

+{\footnote \pard\plain \sl240 \fs20 + g16:1001}

 K{\footnote \pard\plain \sl240 \fs20 K gvarslast variable;variable}

}{\b\f2 GVARSLAST}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
After a }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  or }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  calculation 
the actual variable sequence is stored in the variable 
}{\f3 gvarslast} {\f2 . If }
{\f2\uldb groebopt}{\v\f2 groebopt} 
{\f2  is }{\f3 on} {\f2  
}{\f3 gvarslast} {\f2  shows the variable sequence after reordering. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebprereduce}

${\footnote \pard\plain \sl240 \fs20 $ groebprereduce}

+{\footnote \pard\plain \sl240 \fs20 + g16:1002}

 K{\footnote \pard\plain \sl240 \fs20 K groebprereduce switch;switch}

}{\b\f2 GROEBPREREDUCE}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
If }{\f3 groebprereduce} {\f2  set ON, }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  
and }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  try to simplify the 
input expressions: if the head term of an input expression is a 
multiple of the head term of another expression, it can be reduced; 
these reductions are done cyclicly as long as possible in order to 
shorten the main part of the algorithm. 
\par 
\par 
By default }{\f3 groebprereduce} {\f2  is off. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebfullreduction}

${\footnote \pard\plain \sl240 \fs20 $ groebfullreduction}

+{\footnote \pard\plain \sl240 \fs20 + g16:1003}

 K{\footnote \pard\plain \sl240 \fs20 K groebfullreduction switch;switch}

}{\b\f2 GROEBFULLREDUCTION}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
If }{\f3 groebfullreduction} {\f2  set off, the polynomial reduction steps during 
}
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  and }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  are limited to the pure head 
term reduction; subsequent terms are reduced otherwise. 
\par 
\par 
By default }{\f3 groebfullreduction} {\f2  is on. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gltbasis}

${\footnote \pard\plain \sl240 \fs20 $ gltbasis}

+{\footnote \pard\plain \sl240 \fs20 + g16:1004}

 K{\footnote \pard\plain \sl240 \fs20 K gltbasis switch;switch}

}{\b\f2 GLTBASIS}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
If }{\f3 gltbasis} {\f2  set on, the leading terms of the result basis 
of a }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  or }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  calculation are 
extracted. They are collected as a basis of monomials, which is 
available as value of the global variable }
{\f2\uldb gltb}{\v\f2 gltb} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gltb}

${\footnote \pard\plain \sl240 \fs20 $ gltb}

+{\footnote \pard\plain \sl240 \fs20 + g16:1005}

 K{\footnote \pard\plain \sl240 \fs20 K gltb variable;variable}

}{\b\f2 GLTB}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
See }
{\f2\uldb gltbasis}{\v\f2 gltbasis} 
{\f2  
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # glterms}

${\footnote \pard\plain \sl240 \fs20 $ glterms}

+{\footnote \pard\plain \sl240 \fs20 + g16:1006}

 K{\footnote \pard\plain \sl240 \fs20 K glterms variable;variable}

}{\b\f2 GLTERMS}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
If the expressions in a }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  or }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  
call contain parameters (symbols 
which are not member of the variable list), the share variable 
}{\f3 glterms} {\f2  is set to a list of expression which during the 
calculation were assumed to be nonzero. The calculated bases 
are valid only under the assumption that all these expressions do 
not vanish. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebstat}

${\footnote \pard\plain \sl240 \fs20 $ groebstat}

+{\footnote \pard\plain \sl240 \fs20 + g16:1007}

 K{\footnote \pard\plain \sl240 \fs20 K groebstat switch;switch}

}{\b\f2 GROEBSTAT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
if }{\f3 groebstat} {\f2  is on, a summary of the 
}
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  or }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  computation is printed 
at the end 
including the computing time, the number of intermediate 
H polynomials and the counters for the criteria hits. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # trgroeb}

${\footnote \pard\plain \sl240 \fs20 $ trgroeb}

+{\footnote \pard\plain \sl240 \fs20 + g16:1008}

 K{\footnote \pard\plain \sl240 \fs20 K trgroeb switch;switch}

}{\b\f2 TRGROEB}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
if }{\f3 trgroeb} {\f2  is on, intermediate H polynomials are 
printed during a }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  
or }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  calculation. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # trgroebs}

${\footnote \pard\plain \sl240 \fs20 $ trgroebs}

+{\footnote \pard\plain \sl240 \fs20 + g16:1009}

 K{\footnote \pard\plain \sl240 \fs20 K trgroebs switch;switch}

}{\b\f2 TRGROEBS}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
if }{\f3 trgroebs} {\f2  is on, intermediate H and S polynomials are 
printed during a }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  or }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  calculation. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gzerodim_}

${\footnote \pard\plain \sl240 \fs20 $ gzerodim_}

+{\footnote \pard\plain \sl240 \fs20 + g16:1010}

 K{\footnote \pard\plain \sl240 \fs20 K gzerodim? operator;operator}

}{\b\f2 GZERODIM?}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 gzerodim!?} {\f4 (<basis>) 
\par 
\par 
\par 
\par 
}{\f2 where <bas> is a Groebner basis in the current 
}
{\f2\uldb term order}{\v\f2 Term_order} 
{\f2  with the actual setting 
(see }
{\f2\uldb ideal parameters}{\v\f2 Ideal_Parameters} 
{\f2 ). 
\par 
\par 
}{\f3 gzerodim!?} {\f2 tests whether the ideal spanned by the given basis 
has dimension zero. If yes, the number of zeros is returned, 
}
{\f2\uldb nil}{\v\f2 NIL} 
{\f2  otherwise. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gdimension}

${\footnote \pard\plain \sl240 \fs20 $ gdimension}

+{\footnote \pard\plain \sl240 \fs20 + g16:1011}

 K{\footnote \pard\plain \sl240 \fs20 K groebner;ideal dimension;gdimension operator;operator}

}{\b\f2 GDIMENSION}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 gdimension} {\f4 (<bas>) 
\par 
\par 
\par 
\par 
}{\f2 where <bas> is a }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  basis in the current 
term order (see }
{\f2\uldb ideal parameters}{\v\f2 Ideal_Parameters} 
{\f2 ). 
}{\f3 gdimension} {\f2  computes the dimension of the ideal 
spanned by the given basis and returns the dimension as an integer 
number. The Kredel-Weispfenning algorithm is used: the dimension 
is the length of the longest independent variable set, 
see }
{\f2\uldb gindependent_sets}{\v\f2 gindependent\_sets} 
{\f2  
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gindependent\_sets}

${\footnote \pard\plain \sl240 \fs20 $ gindependent_sets}

+{\footnote \pard\plain \sl240 \fs20 + g16:1012}

 K{\footnote \pard\plain \sl240 \fs20 K Kredel-Weispfenning algorithm;groebner;ideal dimension;ideal variables;gindependent_sets operator;operator}

}{\b\f2 GINDEPENDENT\_SETS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 gindependent_sets} {\f4 (<bas>) 
\par 
\par 
\par 
\par 
}{\f2 where <bas> is a }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  basis in any }{\f3 term order} {\f2  
(which must be the current }{\f3 term order} {\f2 ) with the specified 
variables (see }
{\f2\uldb ideal parameters}{\v\f2 Ideal_Parameters} 
{\f2 ). 
\par 
\par 
}{\f3 Gindependent_sets} {\f2 computes the maximal 
left independent variable sets of the ideal, that are 
the variable sets which play the role of free parameters in the 
current ideal basis. Each set is a list which is a subset of the 
variable list. The result is a list of these sets. For an 
ideal with dimension zero the list is empty. 
The Kredel-Weispfenning algorithm is used. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # dd_groebner}

${\footnote \pard\plain \sl240 \fs20 $ dd_groebner}

+{\footnote \pard\plain \sl240 \fs20 + g16:1013}

 K{\footnote \pard\plain \sl240 \fs20 K dd_groebner operator;operator}

}{\b\f2 DD_GROEBNER}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
For a homogeneous system of polynomials under 
}
{\f2\uldb graded term order}{\v\f2 graded_term_order} 
{\f2 , }
{\f2\uldb gradlex term order}{\v\f2 gradlex_term_order} 
{\f2 , 
}
{\f2\uldb revgradlex term order}{\v\f2 revgradlex_term_order} 
{\f2  \par 
\par 
or }
{\f2\uldb weighted term order}{\v\f2 weighted_term_order} 
{\f2  
a Groebner Base can be computed with limiting the grade 
of the intermediate S polynomials: 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 dd_groebner} {\f4 (<d1>,<d2>,<plist>) 
\par 
\par 
}{\f2 \par 
where <d1> is a non negative integer and <d2> is an integer 
or ``infinity". A pair of polynomials is considered 
only if the grade of the lcm of their head terms is between 
<d1> and <d2>. 
For the term orders }{\f3 graded} {\f2  or }{\f3 weighted} {\f2  the (first) weight 
vector is used for the grade computation. Otherwise the total 
degree of a term is used. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # glexconvert}

${\footnote \pard\plain \sl240 \fs20 $ glexconvert}

+{\footnote \pard\plain \sl240 \fs20 + g16:1014}

 K{\footnote \pard\plain \sl240 \fs20 K univariate polynomial;term order;ideal variables;glexconvert operator;operator}

}{\b\f2 GLEXCONVERT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 glexconvert} {\f4 (<bas>[,<vars>][,MAXDEG=<mx>] 
[,NEWVARS=<nv>]) 
\par 
\par 
\par 
\par 
}{\f2 where <bas> is a }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  basis 
in the current term order, <mx> (optional) is a positive 
integer and <nvl> (optional) is a list of variables 
(see }
{\f2\uldb ideal parameters}{\v\f2 Ideal_Parameters} 
{\f2 ). 
\par 
\par 
The operator }{\f3 glexconvert} {\f2  converts the basis 
of a zero-dimensional ideal (finite number 
of isolated solutions) from arbitrary ordering into a basis under 
}
{\f2\uldb lex term order}{\v\f2 lex_term_order} 
{\f2 . 
\par 
\par 
The parameter <newvars> defines the new variable sequence. 
If omitted, the 
original variable sequence is used. If only a subset of variables is 
specified here, the partial ideal basis is evaluated. 
\par 
\par 
If <newvars> is a list with one element, the minimal 
 }{\f3 univariate polynomial} {\f2  is computed. 
\par 
\par 
<maxdeg> is an upper limit for the degrees. The algorithm stops with 
an error message, if this limit is reached. 
\par 
\par 
A warning occurs, if the ideal is not zero dimensional. 
\par 
\par 
During the call the }{\f3 term order} {\f2  of the input basis must 
be active. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # greduce}

${\footnote \pard\plain \sl240 \fs20 $ greduce}

+{\footnote \pard\plain \sl240 \fs20 + g16:1015}

 K{\footnote \pard\plain \sl240 \fs20 K greduce operator;operator}

}{\b\f2 GREDUCE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 greduce} {\f4 (exp, \{exp1, exp2, ... , expm\}) 
\par 
\par 
\par 
\par 
}{\f2 where exp is an expression, and \{exp1, exp2, ... , expm\} is 
a list of expressions or equations. 
\par 
\par 
}{\f3 greduce} {\f2 is functionally equivalent with a call to 
}
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  and then a call to }
{\f2\uldb preduce}{\v\f2 preduce} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # preduce}

${\footnote \pard\plain \sl240 \fs20 $ preduce}

+{\footnote \pard\plain \sl240 \fs20 + g16:1016}

 K{\footnote \pard\plain \sl240 \fs20 K preduce operator;operator}

}{\b\f2 PREDUCE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 preduce} {\f4 (<p>, \{<exp>, ... \}) 
\par 
\par 
\par 
\par 
}{\f2 where <p> is an expression, and \{<exp>, ... \}is 
a list of expressions or equations. 
\par 
\par 
}{\f3 Preduce} {\f2 computes the remainder of }{\f3 exp} {\f2  
modulo the given set of polynomials resp. equations. 
This result is unique (canonical) only if the given set 
is a }{\f3 groebner} {\f2  basis under the current }
{\f2\uldb term order}{\v\f2 Term_order} 
{\f2  
\par 
\par 
see also: }
{\f2\uldb preducet}{\v\f2 preducet} 
{\f2  operator. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # idealquotient}

${\footnote \pard\plain \sl240 \fs20 $ idealquotient}

+{\footnote \pard\plain \sl240 \fs20 + g16:1017}

 K{\footnote \pard\plain \sl240 \fs20 K idealquotient operator;operator}

}{\b\f2 IDEALQUOTIENT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 idealquotient} {\f4 (\{<exp>, ...\}, <d>) 
\par 
\par 
\par 
\par 
}{\f2 where \{<exp>,...\} is a list of 
expressions or equations, <d> is a single expression or equation. 
\par 
\par 
}{\f3 Idealquotient} {\f2 computes the ideal quotient: 
ideal spanned by the expressions \{<exp>,...\} 
divided by the single polynomial/expression <f>. The result 
is the }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  basis of the quotient ideal. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # hilbertpolynomial}

${\footnote \pard\plain \sl240 \fs20 $ hilbertpolynomial}

+{\footnote \pard\plain \sl240 \fs20 + g16:1018}

 K{\footnote \pard\plain \sl240 \fs20 K Hollmann algorithm;hilbertpolynomial operator;operator}

}{\b\f2 HILBERTPOLYNOMIAL}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 hilbertpolynomial(<bas>) 
\par 
\par 
\par 
\par 
}{\f2 where <bas> is a }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  basis in the 
current }
{\f2\uldb term order}{\v\f2 Term_order} 
{\f2 . 
\par 
\par 
The degree of the }{\f3 Hilbert polynomial} {\f2  is the 
dimension of the ideal spanned by the basis. For an 
ideal of dimension zero the Hilbert polynomial is a 
constant which is the number of common zeros of the 
ideal (including eventual multiplicities). 
The }{\f3 Hollmann algorithm} {\f2  is used. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # saturation}

${\footnote \pard\plain \sl240 \fs20 $ saturation}

+{\footnote \pard\plain \sl240 \fs20 + g16:1019}

 K{\footnote \pard\plain \sl240 \fs20 K saturation operator;operator}

}{\b\f2 SATURATION}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 saturation} {\f4 (\{<exp>, ...\}, <p>) 
\par 
\par 
\par 
\par 
}{\f2 where \{<exp>,...\} is a list of 
expressions or equations, <p> is a single polynomial. 
\par 
\par 
}{\f3 Saturation} {\f2 computes the quotient of the polynomial <p> 
and a power (with unknown but finite exponent) of the ideal built from 
\{<exp>, ...\}. The result is the computed quotient. }{\f3 Saturation} {\f2  
calls }
{\f2\uldb idealquotient}{\v\f2 idealquotient} 
{\f2  several times until the result does not change 
any more. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g16}

${\footnote \pard\plain \sl240 \fs20 $ Basic Groebner operators}

+{\footnote \pard\plain \sl240 \fs20 + index:0016}
}{\b\f2 Basic Groebner operators}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb gvars operator}
{\v\f2 gvars}{\f2 \par 
}{\f2 \tab}{\f2\uldb groebner operator}
{\v\f2 groebner}{\f2 \par 
}{\f2 \tab}{\f2\uldb groebner\_walk operator}
{\v\f2 groebner\_walk}{\f2 \par 
}{\f2 \tab}{\f2\uldb groebopt switch}
{\v\f2 groebopt}{\f2 \par 
}{\f2 \tab}{\f2\uldb gvarslast variable}
{\v\f2 gvarslast}{\f2 \par 
}{\f2 \tab}{\f2\uldb groebprereduce switch}
{\v\f2 groebprereduce}{\f2 \par 
}{\f2 \tab}{\f2\uldb groebfullreduction switch}
{\v\f2 groebfullreduction}{\f2 \par 
}{\f2 \tab}{\f2\uldb gltbasis switch}
{\v\f2 gltbasis}{\f2 \par 
}{\f2 \tab}{\f2\uldb gltb variable}
{\v\f2 gltb}{\f2 \par 
}{\f2 \tab}{\f2\uldb glterms variable}
{\v\f2 glterms}{\f2 \par 
}{\f2 \tab}{\f2\uldb groebstat switch}
{\v\f2 groebstat}{\f2 \par 
}{\f2 \tab}{\f2\uldb trgroeb switch}
{\v\f2 trgroeb}{\f2 \par 
}{\f2 \tab}{\f2\uldb trgroebs switch}
{\v\f2 trgroebs}{\f2 \par 
}{\f2 \tab}{\f2\uldb gzerodim? operator}
{\v\f2 gzerodim_}{\f2 \par 
}{\f2 \tab}{\f2\uldb gdimension operator}
{\v\f2 gdimension}{\f2 \par 
}{\f2 \tab}{\f2\uldb gindependent\_sets operator}
{\v\f2 gindependent\_sets}{\f2 \par 
}{\f2 \tab}{\f2\uldb dd_groebner operator}
{\v\f2 dd_groebner}{\f2 \par 
}{\f2 \tab}{\f2\uldb glexconvert operator}
{\v\f2 glexconvert}{\f2 \par 
}{\f2 \tab}{\f2\uldb greduce operator}
{\v\f2 greduce}{\f2 \par 
}{\f2 \tab}{\f2\uldb preduce operator}
{\v\f2 preduce}{\f2 \par 
}{\f2 \tab}{\f2\uldb idealquotient operator}
{\v\f2 idealquotient}{\f2 \par 
}{\f2 \tab}{\f2\uldb hilbertpolynomial operator}
{\v\f2 hilbertpolynomial}{\f2 \par 
}{\f2 \tab}{\f2\uldb saturation operator}
{\v\f2 saturation}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebnerf}

${\footnote \pard\plain \sl240 \fs20 $ groebnerf}

+{\footnote \pard\plain \sl240 \fs20 + g17:1020}

 K{\footnote \pard\plain \sl240 \fs20 K groebnerf operator;operator}

}{\b\f2 GROEBNERF}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 groebnerf} {\f4 (\{<exp>, ...\}[,\{\},\{<nz>, ... \}]); 
\par 
\par 
\par 
\par 
}{\f2 where \{<exp>, ... \}is a list of expressions or 
equations, and \{<nz>,... \}is 
an optional list of polynomials to be considered as non zero 
for this calculation. An empty list must be passed as second argument 
if the non-zero list is specified. 
\par 
\par 
}{\f3 groebnerf} {\f2 tries to separate polynomials into individual factors and 
to branch the computation in a recursive manner (factorization tree). 
The result is a list of partial Groebner bases. 
Multiplicities (one factor with a higher power, the same partial basis 
twice) are deleted as early as possible in order to speed up the 
calculation. 
\par 
\par 
The third parameter of }{\f3 groebnerf} {\f2  declares some polynomials 
nonzero. If any of these is found in a branch of the calculation 
the branch is canceled. 
\par 
\par 
 \par
example: \par
\pard \tx3420 }{\f4  \par
groebnerf(\{ 3*x**2*y+2*x*y+y+9*x**2+5*x = 3,   \par
            2*x**3*y-x*y-y+6*x**3-2*x**2-3*x = -3,  \par
            x**3*y+x**2*y+3*x**3+2*x**2 \}, \{y,x\}); \par
 \par
       \{\{Y - 3,X\}, \par
 \par
                      2 \par
    \{2*Y + 2*X - 1,2*X  - 5*X - 5\}\} \par
\pard \sl240 }{\f2  \par
related: \par
\par 
\tab }
{\f2\uldb groebresmax}{\v\f2 groebresmax} 
{\f2 variable 
\par 
\tab  }
{\f2\uldb groebmonfac}{\v\f2 groebmonfac} 
{\f2  variable 
\par 
\tab  }
{\f2\uldb groebrestriction}{\v\f2 groebrestriction} 
{\f2  variable 
\par 
\tab  }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  operator 
\par 
\tab  }
{\f2\uldb gvarslast}{\v\f2 gvarslast} 
{\f2  variable 
\par 
\tab  }
{\f2\uldb groebopt}{\v\f2 groebopt} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb groebprereduce}{\v\f2 groebprereduce} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb groebfullreduction}{\v\f2 groebfullreduction} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb gltbasis}{\v\f2 gltbasis} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb gltb}{\v\f2 gltb} 
{\f2  variable 
\par 
\tab  }
{\f2\uldb glterms}{\v\f2 glterms} 
{\f2  variable 
\par 
\tab  }
{\f2\uldb groebstat}{\v\f2 groebstat} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb trgroeb}{\v\f2 trgroeb} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb trgroebs}{\v\f2 trgroebs} 
{\f2  switch 
\par 
\tab  }
{\f2\uldb groebnert}{\v\f2 groebnert} 
{\f2  operator 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebmonfac}

${\footnote \pard\plain \sl240 \fs20 $ groebmonfac}

+{\footnote \pard\plain \sl240 \fs20 + g17:1021}

 K{\footnote \pard\plain \sl240 \fs20 K groebmonfac variable;variable}

}{\b\f2 GROEBMONFAC}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
The variable }{\f3 groebmonfac} {\f2  is connected to 
the handling of monomial factors. A monomial factor is a product 
of variable powers as a factor, e.g. x**2*y in x**3*y - 
2*x**2*y**2. A monomial factor represents a solution of the type 
 x = 0 or y = 0 with a certain multiplicity. With 
}
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  the multiplicity of monomial factors is lowered 
to the value of the shared variable }{\f3 groebmonfac} {\f2  
which by default is 1 (= monomial factors remain present, but their 
multiplicity is brought down). With 
}{\f3 groebmonfac} {\f2 := 0 
the monomial factors are suppressed completely. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebresmax}

${\footnote \pard\plain \sl240 \fs20 $ groebresmax}

+{\footnote \pard\plain \sl240 \fs20 + g17:1022}

 K{\footnote \pard\plain \sl240 \fs20 K groebresmax variable;variable}

}{\b\f2 GROEBRESMAX}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
The variable }{\f3 groebresmax} {\f2  
controls during }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  calculations 
the number of partial results. Its default value is 300. If 
more partial results are calculated, the calculation is 
terminated. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebrestriction}

${\footnote \pard\plain \sl240 \fs20 $ groebrestriction}

+{\footnote \pard\plain \sl240 \fs20 + g17:1023}

 K{\footnote \pard\plain \sl240 \fs20 K groebrestriction variable;variable}

}{\b\f2 GROEBRESTRICTION}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
During }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  calculations 
irrelevant branches can be excluded 
by setting the variable }{\f3 groebrestriction} {\f2 . The 
following restrictions are implemented: 
 \par
syntax: \par
}{\f4  \par 
\par 
}{\f3 groebrestriction} {\f4 := }{\f3 nonnegative} {\f4  
\par 
\par 
}{\f3 groebrestriction} {\f4 := }{\f3 positive} {\f4  
\par 
\par 
}{\f3 groebrestriction} {\f4 := }{\f3 zeropoint} {\f4  
\par 
\par 
}{\f2 \par 
With }{\f3 nonnegative} {\f2  branches are excluded where one 
polynomial has no nonnegative real zeros; with }{\f3 positive} {\f2  
the restriction is sharpened to positive zeros only. 
The restriction }{\f3 zeropoint} {\f2  excludes all branches 
which do not have the origin (0,0,...0) in their solution 
set. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g17}

${\footnote \pard\plain \sl240 \fs20 $ Factorizing Groebner bases}

+{\footnote \pard\plain \sl240 \fs20 + index:0017}
}{\b\f2 Factorizing Groebner bases}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb groebnerf operator}
{\v\f2 groebnerf}{\f2 \par 
}{\f2 \tab}{\f2\uldb groebmonfac variable}
{\v\f2 groebmonfac}{\f2 \par 
}{\f2 \tab}{\f2\uldb groebresmax variable}
{\v\f2 groebresmax}{\f2 \par 
}{\f2 \tab}{\f2\uldb groebrestriction variable}
{\v\f2 groebrestriction}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebprot}

${\footnote \pard\plain \sl240 \fs20 $ groebprot}

+{\footnote \pard\plain \sl240 \fs20 + g18:1024}

 K{\footnote \pard\plain \sl240 \fs20 K groebprot switch;switch}

}{\b\f2 GROEBPROT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
If }{\f3 groebprot} {\f2  is }{\f3 ON} {\f2  the computation steps during 
}
{\f2\uldb preduce}{\v\f2 preduce} 
{\f2 , }
{\f2\uldb greduce}{\v\f2 greduce} 
{\f2  and }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  
are collected in a list which is assigned to the variable 
}
{\f2\uldb groebprotfile}{\v\f2 groebprotfile} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebprotfile}

${\footnote \pard\plain \sl240 \fs20 $ groebprotfile}

+{\footnote \pard\plain \sl240 \fs20 + g18:1025}

 K{\footnote \pard\plain \sl240 \fs20 K groebprotfile variable;variable}

}{\b\f2 GROEBPROTFILE}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
See }
{\f2\uldb groebprot}{\v\f2 groebprot} 
{\f2  switch. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # groebnert}

${\footnote \pard\plain \sl240 \fs20 $ groebnert}

+{\footnote \pard\plain \sl240 \fs20 + g18:1026}

 K{\footnote \pard\plain \sl240 \fs20 K groebnert operator;operator}

}{\b\f2 GROEBNERT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 groebnert} {\f4 (\{<v>=<exp>,...\}) 
\par 
\par 
\par 
\par 
}{\f2 where <v> are }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f3 s} {\f2  (simple or indexed variables), 
<exp> are polynomials. 
\par 
\par 
}{\f3 groebnert} {\f2 is functionally equivalent to a }
{\f2\uldb groebner}{\v\f2 groebner} 
{\f2  
call for \{<exp>,...\}, but the result is a set of 
equations where the left-hand sides are the basis elements while 
the right-hand sides are the same values expressed as combinations 
of the input formulas, expressed in terms of the names <v> 
 \par
example: \par
\pard \tx3420 }{\f4  \par
    groebnert(\{p1=2*x**2+4*y**2-100,p2=2*x-y+1\}); \par
 \par
   GB1 := \{2*X - Y + 1=P2, \par
 \par
           2 \par
        9*Y  - 2*Y - 199= - 2*X*P2 - Y*P2 + 2*P1 + P2\} \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # preducet}

${\footnote \pard\plain \sl240 \fs20 $ preducet}

+{\footnote \pard\plain \sl240 \fs20 + g18:1027}

 K{\footnote \pard\plain \sl240 \fs20 K preducet operator;operator}

}{\b\f2 PREDUCET}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 preduce} {\f4 (<p>,\{<v>=<exp>...\}) 
\par 
\par 
}{\f2 \par 
where <p> is an expression, <v> are kernels 
(simple or indexed variables), 
}{\f3 exp} {\f2  are polynomials. 
\par 
\par 
}{\f3 preducet} {\f2 computes the remainder of <p> modulo \{<exp>,...\} 
similar to }
{\f2\uldb preduce}{\v\f2 preduce} 
{\f2 , but the result is an equation 
which expresses the remainder as combination of the polynomials. 
 \par
example: \par
\pard \tx3420 }{\f4  \par
                              \par
   GB2 := \{G1=2*X - Y + 1,G2=9*Y**2  - 2*Y - 199\} \par
   preducet(q=x**2,gb2); \par
 \par
 - 16*Y + 208= - 18*X*G1 - 9*Y*G1 + 36*Q + 9*G1 - G2 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g18}

${\footnote \pard\plain \sl240 \fs20 $ Tracing Groebner bases}

+{\footnote \pard\plain \sl240 \fs20 + index:0018}
}{\b\f2 Tracing Groebner bases}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb groebprot switch}
{\v\f2 groebprot}{\f2 \par 
}{\f2 \tab}{\f2\uldb groebprotfile variable}
{\v\f2 groebprotfile}{\f2 \par 
}{\f2 \tab}{\f2\uldb groebnert operator}
{\v\f2 groebnert}{\f2 \par 
}{\f2 \tab}{\f2\uldb preducet operator}
{\v\f2 preducet}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Module}

${\footnote \pard\plain \sl240 \fs20 $ Module}

+{\footnote \pard\plain \sl240 \fs20 + g19:1028}

 K{\footnote \pard\plain \sl240 \fs20 K Module concept;concept}

}{\b\f2 MODULE}{\f2 \par 
\par 
 
Given a polynomial ring, e.g. R=Z[x,y,...] and an integer n>1. 
The vectors with n elements of R form a free MODULE under 
elementwise addition and multiplication with elements of R. 
\par 
\par 
For a submodule given by a finite basis a Groebner basis 
can be computed, and the facilities of the GROEBNER package 
are available except the operators }
{\f2\uldb groebnerf}{\v\f2 groebnerf} 
{\f2  
and }{\f3 groesolve} {\f2 . The vectors are encoded using auxiliary 
variables which represent the unit vectors in the module. 
These are declared in the share variable }
{\f2\uldb gmodule}{\v\f2 gmodule} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gmodule}

${\footnote \pard\plain \sl240 \fs20 $ gmodule}

+{\footnote \pard\plain \sl240 \fs20 + g19:1029}

 K{\footnote \pard\plain \sl240 \fs20 K gmodule variable;variable}

}{\b\f2 GMODULE}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
The vectors of a free }
{\f2\uldb module}{\v\f2 Module} 
{\f2  over a polynomial ring R 
are encoded as linear combinations with unit vectors of 
M which are represented by auxiliary variables. These 
must be collected in the variable }{\f3 gmodule} {\f2  before 
any call to an operator of the Groebner package. 
\par 
\par 
\pard \tx3420 }{\f4  \par
   torder(\{x,y,v1,v2,v3\})$ \par
   gmodule := \{v1,v2,v3\}$ \par
   g:=groebner(\{x^2*v1 + y*v2,x*y*v1 - v3,2y*v1 + y*v3\}); \par
\pard \sl240 }{\f2 compute the Groebner basis of the submodule 
\par 
\par 
\pard \tx3420 }{\f4  \par
      ([x^2,y,0],[xy,0,-1],[0,2y,y]) \par
\pard \sl240 }{\f2 The members of the list }{\f3 gmodule} {\f2  are automatically 
appended to the end of the variable list, if they are not 
yet members there. They take part in the actual term ordering. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g19}

${\footnote \pard\plain \sl240 \fs20 $ Groebner Bases for Modules}

+{\footnote \pard\plain \sl240 \fs20 + index:0019}
}{\b\f2 Groebner Bases for Modules}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb Module concept}
{\v\f2 Module}{\f2 \par 
}{\f2 \tab}{\f2\uldb gmodule variable}
{\v\f2 gmodule}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gsort}

${\footnote \pard\plain \sl240 \fs20 $ gsort}

+{\footnote \pard\plain \sl240 \fs20 + g20:1030}

 K{\footnote \pard\plain \sl240 \fs20 K distributive polynomials;gsort operator;operator}

}{\b\f2 GSORT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 gsort} {\f4 (<p>) 
\par 
\par 
}{\f2 \par 
where <p> is a polynomial or a list of polynomials. 
\par 
\par 
The polynomials are reordered and sorted corresponding to 
the current }
{\f2\uldb term order}{\v\f2 Term_order} 
{\f2 . 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
  torder lex; \par
   \par
  gsort(x**2+2x*y+y**2,\{y,x\});  \par
 \par
  y**2+2y*x+x**2 \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gsplit}

${\footnote \pard\plain \sl240 \fs20 $ gsplit}

+{\footnote \pard\plain \sl240 \fs20 + g20:1031}

 K{\footnote \pard\plain \sl240 \fs20 K distributive polynomials;gsplit operator;operator}

}{\b\f2 GSPLIT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 gsplit} {\f4 (<p>[,<vars>]); 
\par 
\par 
}{\f2 \par 
where <p> is a polynomial or a list of polynomials. 
\par 
\par 
The polynomial is reordered corresponding to the 
the current }
{\f2\uldb term order}{\v\f2 Term_order} 
{\f2  and then 
separated into leading term and reductum. Result is 
a list with the leading term as first and the reductum 
as second element. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
  torder lex; \par
   \par
  gsplit(x**2+2x*y+y**2,\{y,x\});  \par
 \par
  \{y**2,2y*x+x**2\} \par
 \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gspoly}

${\footnote \pard\plain \sl240 \fs20 $ gspoly}

+{\footnote \pard\plain \sl240 \fs20 + g20:1032}

 K{\footnote \pard\plain \sl240 \fs20 K distributive polynomials;gspoly operator;operator}

}{\b\f2 GSPOLY}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 gspoly} {\f4 (<p1>,<p2>); 
\par 
\par 
\par 
\par 
}{\f2 where <p1> and <p2> are polynomials. 
\par 
\par 
The }{\f3 subtraction} {\f2  polynomial of p1 and p2 is computed 
corresponding to the method of the Buchberger algorithm for 
computing }{\f3 groebner bases} {\f2 : p1 and p2 are multiplied 
with terms such that when subtracting them the leading terms 
cancel each other. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g20}

${\footnote \pard\plain \sl240 \fs20 $ Computing with distributive polynomials}

+{\footnote \pard\plain \sl240 \fs20 + index:0020}
}{\b\f2 Computing with distributive polynomials}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb gsort operator}
{\v\f2 gsort}{\f2 \par 
}{\f2 \tab}{\f2\uldb gsplit operator}
{\v\f2 gsplit}{\f2 \par 
}{\f2 \tab}{\f2\uldb gspoly operator}
{\v\f2 gspoly}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g14}

${\footnote \pard\plain \sl240 \fs20 $ Groebner package}

+{\footnote \pard\plain \sl240 \fs20 + index:0014}
}{\b\f2 Groebner package}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb Groebner bases introduction}
{\v\f2 Groebner_bases}{\f2 \par 
}{\f2 \tab}{\f2\uldb Ideal Parameters concept}
{\v\f2 Ideal_Parameters}{\f2 \par 
}{\f2 \tab}{\f2\uldb Term order}
{\v\f2 g15}{\f2 \par 
}{\f2 \tab}{\f2\uldb Basic Groebner operators}
{\v\f2 g16}{\f2 \par 
}{\f2 \tab}{\f2\uldb Factorizing Groebner bases}
{\v\f2 g17}{\f2 \par 
}{\f2 \tab}{\f2\uldb Tracing Groebner bases}
{\v\f2 g18}{\f2 \par 
}{\f2 \tab}{\f2\uldb Groebner Bases for Modules}
{\v\f2 g19}{\f2 \par 
}{\f2 \tab}{\f2\uldb Computing with distributive polynomials}
{\v\f2 g20}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # HEPHYS}

${\footnote \pard\plain \sl240 \fs20 $ HEPHYS}

+{\footnote \pard\plain \sl240 \fs20 + g21:1033}

 K{\footnote \pard\plain \sl240 \fs20 K HEPHYS introduction;introduction}

}{\b\f2 HEPHYS}{\f2 \tab \tab \tab \tab }{\b\f2 introduction}{\f2 \par 
\par 
 
The High-energy Physics package is historic for REDUCE, since REDUCE 
originated as a program to aid in computations with Dirac expressions. 
The commutation algebra of the gamma matrices is independent of their 
representation, and is a natural subject for symbolic mathematics. Dirac 
theory is applied to beta decay and the computation of 
cross-sections and scattering. The high-energy physics operators are 
available in the REDUCE main program, rather than as a module which must 
be loaded. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # HE_dot}

${\footnote \pard\plain \sl240 \fs20 $ HE_dot}

+{\footnote \pard\plain \sl240 \fs20 + g21:1034}

 K{\footnote \pard\plain \sl240 \fs20 K HE-dot operator;operator}

}{\b\f2 .}{\f2 \tab }{\b\f2 HE-DOT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The . operator is used to denote the scalar product of two Lorentz 
four-vectors. 
 \par
syntax: \par
}{\f4 \par 
\par 
<vector> }{\f3 .} {\f4  <vector> 
\par 
\par 
}{\f2 \par 
<vector> must be an identifier declared to be of type }{\f3 vector} {\f2  to have 
the scalar product definition. When applied to arguments that are not 
vectors, the }
{\f2\uldb cons}{\v\f2 CONS} 
{\f2  operator is used, 
whose symbol is also ``dot.'' 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
vector aa,bb,cc;  \par
 \par
let aa.bb = 0;  \par
 \par
aa.bb;  \par
 \par
  0  \par
 \par
 \par
aa.cc;  \par
 \par
  AA.CC  \par
 \par
 \par
q := aa.cc;  \par
 \par
  Q := AA.CC  \par
 \par
 \par
q;  \par
 \par
  AA.CC \par
 \par
\pard \sl240 }{\f2 Since vectors are special high-energy physics entities that do not contain 
values, the . product will not return a true scalar product. You can 
assign a scalar identifier to the result of a . operation, or assign a . 
operation to have the value of the scalar you supply, as shown above. Note 
that the result of a . operation is a scalar, not a vector. 
\par 
\par 
The metric tensor g(u,v) can be represented by }{\f3 u.v} {\f2 . If contraction 
over the indices is required, }{\f3 u} {\f2  and }{\f3 v} {\f2  should be declared to 
be of type }
{\f2\uldb index}{\v\f2 INDEX} 
{\f2 . 
\par 
\par 
The dot operator has the highest precedence of the infix operators, so 
expressions involving . and other operators have the scalar product 
evaluated first before other operations are done. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EPS}

${\footnote \pard\plain \sl240 \fs20 $ EPS}

+{\footnote \pard\plain \sl240 \fs20 + g21:1035}

 K{\footnote \pard\plain \sl240 \fs20 K EPS operator;operator}

}{\b\f2 EPS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 eps} {\f2  operator denotes the completely antisymmetric tensor of 
order 4 and its contraction with Lorentz four-vectors, as used in 
high-energy physics calculations. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 eps} {\f4 (<vector-expr>,<vector-expr>,<vector-expr>, 
<vector-expr>) 
\par 
\par 
}{\f2 \par 
<vector-expr> must be a valid vector expression, and may be an index. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
vector g0,g1,g2,g3;  \par
 \par
eps(g1,g0,g2,g3);  \par
 \par
  - EPS(G0,G1,G2,G3);  \par
 \par
 \par
eps(g1,g2,g0,g3);  \par
 \par
  EPS(G0,G1,G2,G3);  \par
 \par
 \par
eps(g1,g2,g3,g1);  \par
 \par
  0 \par
 \par
\pard \sl240 }{\f2 Vector identifiers are ordered alphabetically by REDUCE. When an odd number 
of transpositions is required to restore the canonical order to the four 
arguments of }{\f3 eps} {\f2 , the term is ordered and carries a minus sign. When an 
even number of transpositions is required, the term is returned ordered and 
positive. When one of the arguments is repeated, the value 0 is returned. 
A contraction of the form 
eps(_i j mu nu p_mu q_nu) 
is represented by }{\f3 eps(i,j,p,q)} {\f2  when }{\f3 i} {\f2  and }{\f3 j} {\f2  have been 
declared to be of type }
{\f2\uldb index}{\v\f2 INDEX} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # G}

${\footnote \pard\plain \sl240 \fs20 $ G}

+{\footnote \pard\plain \sl240 \fs20 + g21:1036}

 K{\footnote \pard\plain \sl240 \fs20 K G operator;operator}

}{\b\f2 G}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
}{\f3 g} {\f2  is an n-ary operator used to denote a product of gamma matrices 
contracted with Lorentz four-vectors, in high-energy physics. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 g} {\f4 (<identifier>,<vector-expr> 
\{,<vector-expr>\}*) 
\par 
\par 
}{\f2 \par 
<identifier> is a scalar identifier representing a fermion line 
identifier, <vector-expr> can be any valid vector expression, 
representing a vector or a gamma matrix. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
vector aa,bb,cc;  \par
 \par
vector a;  \par
 \par
g(line1,aa,bb);  \par
 \par
  AA.BB  \par
 \par
 \par
g(line2,aa,a);  \par
 \par
  0  \par
 \par
 \par
g(id,aa,bb,cc);  \par
 \par
  0  \par
 \par
 \par
g(li1,aa,bb) + k;  \par
 \par
  AA.BB + K  \par
 \par
 \par
let aa.bb = m*k;  \par
 \par
g(ln1,aa)*g(ln1,bb);  \par
 \par
  K*M  \par
 \par
 \par
g(ln1,aa)*g(ln2,bb);  \par
 \par
  0 \par
 \par
\pard \sl240 }{\f2 The vector }{\f3 A} {\f2  is reserved in arguments of }{\f3 g} {\f2  to denote the 
special gamma matrix gamma_5. It must be declared to 
be a vector before you use it. 
\par 
\par 
Gamma matrix expressions are associated with fermion lines in a Feynman 
diagram. If more than one line occurs in an expression, the gamma 
matrices involved are separate (operating in independent spin space), as 
shown in the last two example lines above. A product of gamma matrices 
associated with a single line can be entered either as a single }{\f3 g} {\f2  
command with several vector arguments, or as products of separate }{\f3 g} {\f2  
commands each with a single argument. 
\par 
\par 
While the product of vectors is not defined, the product, sum and 
difference of several gamma expressions are defined, as is the product of 
a gamma expression with a scalar. If an expression involving gamma 
matrices includes a scalar, the scalar is treated as if it were the 
product of itself with a unit 4 x 4 matrix. 
\par 
\par 
Dirac expressions are evaluated by computing the trace of the expression 
using the commutation algebra of gamma matrices. The algorithms used are 
described in articles by J. S. R. Chisholm in <Il Nuovo Cimento X,> Vol. 
30, p. 426, 1963, and J. Kahane, <Journal of Mathematical Physics>, 
Vol. 9, p. 1732, 1968. The trace is then divided by 4 to distinguish 
between the trace of a scalar and the trace of an expression that is the 
product of a scalar with a unit 4 x 4 matrix. 
\par 
\par 
Trace calculations may be prevented over any line identifier by declaring it 
to be }
{\f2\uldb nospur}{\v\f2 NOSPUR} 
{\f2 . If it is later desired to evaluate these traces, 
the declaration can be undone with the }
{\f2\uldb spur}{\v\f2 SPUR} 
{\f2  declaration. 
\par 
\par 
The notation of Bjorken and Drell, <Relativistic Quantum Mechanics,> 
1964, is assumed in all operations involving gamma matrices. For an 
example of the use of }{\f3 g} {\f2  in a calculation, see the <REDUCE 
User's Manual>. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # INDEX}

${\footnote \pard\plain \sl240 \fs20 $ INDEX}

+{\footnote \pard\plain \sl240 \fs20 + g21:1037}

 K{\footnote \pard\plain \sl240 \fs20 K INDEX declaration;declaration}

}{\b\f2 INDEX}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
The declaration }{\f3 index} {\f2  flags a four-vector as an index for subsequent 
high-energy physics calculations. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 index} {\f4 <vector-id>\{,<vector-id>\}* 
\par 
\par 
}{\f2 \par 
<vector-id> must have been declared of type }{\f3 vector} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
vector aa,bb,cc;  \par
 \par
index uu;  \par
 \par
let aa.bb = 0;  \par
 \par
(aa.uu)*(bb.uu);  \par
 \par
  0  \par
 \par
 \par
(aa.uu)*(cc.uu);  \par
 \par
  AA.CC \par
 \par
\pard \sl240 }{\f2 Index variables are used to represent contraction over components of 
vectors when scalar products are taken by the . operator, as well as 
indicating contraction for the }
{\f2\uldb eps}{\v\f2 EPS} 
{\f2  operator or metric tensor. 
\par 
\par 
The special status of a vector as an index can be revoked with the 
declaration }
{\f2\uldb remind}{\v\f2 REMIND} 
{\f2 . The object remains a vector, however. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MASS}

${\footnote \pard\plain \sl240 \fs20 $ MASS}

+{\footnote \pard\plain \sl240 \fs20 + g21:1038}

 K{\footnote \pard\plain \sl240 \fs20 K MASS command;command}

}{\b\f2 MASS}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 mass} {\f2  command associates a scalar variable as a mass with 
the corresponding vector variable, in high-energy physics calculations. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 mass} {\f4 <vector-var>}{\f3 =} {\f4 <scalar-var> 
\{,<vector-var>}{\f3 =} {\f4 <scalar-var>\}* 
\par 
\par 
}{\f2 \par 
<vector-var> can be a declared vector variable; }{\f3 mass} {\f2  will declare 
it to be of type }{\f3 vector} {\f2  if it is not. This may override an existing 
matrix variable by that name. <scalar-var> must be a scalar variable. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
vector bb,cc;  \par
 \par
mass cc=m;  \par
 \par
mshell cc;  \par
 \par
cc.cc;  \par
 \par
   2 \par
  M \par
 \par
\pard \sl240 }{\f2 Once a mass has been attached to a vector with a }{\f3 mass} {\f2  declaration, 
the }
{\f2\uldb mshell}{\v\f2 MSHELL} 
{\f2  declaration puts the associated particle ``on the mass 
shell.'' Subsequent scalar (.) products of the vector with itself will be 
replaced by the square of the mass expression. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MSHELL}

${\footnote \pard\plain \sl240 \fs20 $ MSHELL}

+{\footnote \pard\plain \sl240 \fs20 + g21:1039}

 K{\footnote \pard\plain \sl240 \fs20 K MSHELL command;command}

}{\b\f2 MSHELL}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 mshell} {\f2  command puts particles on the mass shell in high-energy 
physics calculations. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 mshell} {\f4 <vector-var>\{,<vector-var>\}* 
\par 
\par 
}{\f2 \par 
<vector-var> must have had a mass attached to it by a }
{\f2\uldb mass}{\v\f2 MASS} 
{\f2  
declaration. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
vector v1,v2;  \par
 \par
mass v1=m,v2=q;  \par
 \par
mshell v1;  \par
 \par
v1.v1;  \par
 \par
   2 \par
  M   \par
 \par
 \par
v2.v2;  \par
 \par
  V2.V2  \par
 \par
 \par
mshell v2;  \par
 \par
v1.v1*v2.v2;  \par
 \par
   2  2 \par
  M *Q \par
 \par
\pard \sl240 }{\f2 Even though a mass is attached to a vector variable representing a 
particle, the replacement does not take place until the }{\f3 mshell} {\f2  
declaration is given for that vector variable. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NOSPUR}

${\footnote \pard\plain \sl240 \fs20 $ NOSPUR}

+{\footnote \pard\plain \sl240 \fs20 + g21:1040}

 K{\footnote \pard\plain \sl240 \fs20 K NOSPUR declaration;declaration}

}{\b\f2 NOSPUR}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
The }{\f3 nospur} {\f2  declaration prevents the trace calculation over the given 
line identifiers in high-energy physics calculations. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 nospur} {\f4 <line-id>\{,<line-id>\}* 
\par 
\par 
}{\f2 \par 
<line-id> is a scalar identifier that will be used as a line identifier. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
vector a1,b1,c1;  \par
 \par
g(line1,a1,b1)*g(line2,b1,c1);  \par
 \par
  A1.B1*B1.C1  \par
 \par
 \par
nospur line2;  \par
 \par
g(line1,a1,b1)*g(line2,b1,c1);  \par
 \par
  A1.B1*G(LINE2,B1,C1) \par
 \par
\pard \sl240 }{\f2 Nospur declarations can be removed by making the declaration }
{\f2\uldb spur}{\v\f2 SPUR} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # REMIND}

${\footnote \pard\plain \sl240 \fs20 $ REMIND}

+{\footnote \pard\plain \sl240 \fs20 + g21:1041}

 K{\footnote \pard\plain \sl240 \fs20 K REMIND declaration;declaration}

}{\b\f2 REMIND}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
The }{\f3 remind} {\f2  declaration removes the special status of its arguments 
as indices, which was set in the }
{\f2\uldb index}{\v\f2 INDEX} 
{\f2  declaration, in 
high-energy physics calculations. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 remind} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
<identifier> must have been declared to be of type }
{\f2\uldb index}{\v\f2 INDEX} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SPUR}

${\footnote \pard\plain \sl240 \fs20 $ SPUR}

+{\footnote \pard\plain \sl240 \fs20 + g21:1042}

 K{\footnote \pard\plain \sl240 \fs20 K SPUR declaration;declaration}

}{\b\f2 SPUR}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
The }{\f3 spur} {\f2  declaration removes the special exemption from trace 
calculations that was declared by }
{\f2\uldb nospur}{\v\f2 NOSPUR} 
{\f2 , in high-energy physics 
calculations. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 spur} {\f4 <line-id>\{,<line-id>\}* 
\par 
\par 
}{\f2 \par 
<line-id> must be a line-identifier that has previously been declared 
}{\f3 nospur} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # VECDIM}

${\footnote \pard\plain \sl240 \fs20 $ VECDIM}

+{\footnote \pard\plain \sl240 \fs20 + g21:1043}

 K{\footnote \pard\plain \sl240 \fs20 K VECDIM command;command}

}{\b\f2 VECDIM}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The command }{\f3 vecdim} {\f2  changes the vector dimension from 4 to an arbitrary 
integer or symbol. Used in high-energy physics calculations. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 vecdim} {\f4 <dimension> 
\par 
\par 
}{\f2 \par 
<dimension> must be either an integer or a valid scalar identifier that 
does not have a floating-point value. 
\par 
\par 
The }
{\f2\uldb eps}{\v\f2 EPS} 
{\f2  operator and the gamma_5 
symbol (}{\f3 A} {\f2 ) are not properly defined in anything except four 
dimensions and will print an error message if you use them that way. The 
other high-energy physics operators should work without problem. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # VECTOR}

${\footnote \pard\plain \sl240 \fs20 $ VECTOR}

+{\footnote \pard\plain \sl240 \fs20 + g21:1044}

 K{\footnote \pard\plain \sl240 \fs20 K VECTOR declaration;declaration}

}{\b\f2 VECTOR}{\f2 \tab \tab \tab \tab }{\b\f2 declaration}{\f2 \par 
\par 
 
The }{\f3 vector} {\f2  declaration declares that its arguments are of type }{\f3 vector} {\f2 . 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 vector} {\f4 <identifier>\{,<identifier>\}* 
\par 
\par 
}{\f2 \par 
<identifier> must be a valid REDUCE identifier. It may have already been 
used for a matrix, array, operator or scalar variable. After an identifier 
has been declared to be a vector, it may not be used as a scalar variable. 
\par 
\par 
Vectors are special entities for high-energy physics calculations. You 
cannot put values into their coordinates; they do not have coordinates. 
They are legal arguments for the high-energy physics operators 
}
{\f2\uldb eps}{\v\f2 EPS} 
{\f2 , }
{\f2\uldb g}{\v\f2 G} 
{\f2  and }{\f3 .} {\f2  (dot). Vector variables are 
used to represent gamma matrices and gamma matrices contracted with Lorentz 
4-vectors, since there are no Dirac variables per se in the system. 
Vectors do follow the usual vector rules for arithmetic operations: 
}{\f3 +} {\f2  and }{\f3 -} {\f2  operate upon two or more vectors, producing a 
vector; }{\f3 *} {\f2  and }{\f3 /} {\f2  cannot be used between vectors; the 
scalar product is represented by the . operator; and the product of a 
scalar and vector expression is well defined, and is a vector. 
\par 
\par 
You can represent components of vectors by including representations of unit 
vectors in your system. For instance, letting }{\f3 E0} {\f2  represent the unit 
vector (1,0,0,0), the command 
\par 
\par 
}{\f3 V1.E0 := 0;} {\f2 would set up the substitution of zero for the first component of the vector 
}{\f3 V1} {\f2 . 
\par 
\par 
Identifiers that are declared by the }{\f3 index} {\f2  and }{\f3 mass} {\f2  declarations are 
automatically declared to be vectors. 
\par 
\par 
The following errors can occur in calculations using the high energy 
physics package: 
\par 
\par 
}{\f3 A represents only gamma5 in vector expressions} {\f2 You have tried to use A in some way other than gamma5 in a 
high-energy physics expression. 
\par 
\par 
\par 
}{\f3 Gamma5 not allowed unless vecdim is 4} {\f2 You have used gamma_5 in a high-energy physics 
computation involving a vector dimension other than 4. 
\par 
\par 
\par 
<ID> }{\f3 has no mass} {\f2  
\par 
\par 
One of the arguments to }
{\f2\uldb mshell}{\v\f2 MSHELL} 
{\f2  has had no mass assigned to it, in 
high-energy physics calculations. 
\par 
\par 
\par 
}{\f3 Missing arguments for G operator} {\f2 A line symbol is missing in a gamma matrix expression in high-energy physics 
calculations. 
\par 
\par 
\par 
}{\f3 Unmatched index} {\f2 <list> 
\par 
\par 
The parser has found unmatched indices during the evaluation of a 
gamma matrix expression in high-energy physics calculations. 
\par 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g21}

${\footnote \pard\plain \sl240 \fs20 $ High Energy Physics}

+{\footnote \pard\plain \sl240 \fs20 + index:0021}
}{\b\f2 High Energy Physics}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb HEPHYS introduction}
{\v\f2 HEPHYS}{\f2 \par 
}{\f2 \tab}{\f2\uldb HE-dot operator}
{\v\f2 HE_dot}{\f2 \par 
}{\f2 \tab}{\f2\uldb EPS operator}
{\v\f2 EPS}{\f2 \par 
}{\f2 \tab}{\f2\uldb G operator}
{\v\f2 G}{\f2 \par 
}{\f2 \tab}{\f2\uldb INDEX declaration}
{\v\f2 INDEX}{\f2 \par 
}{\f2 \tab}{\f2\uldb MASS command}
{\v\f2 MASS}{\f2 \par 
}{\f2 \tab}{\f2\uldb MSHELL command}
{\v\f2 MSHELL}{\f2 \par 
}{\f2 \tab}{\f2\uldb NOSPUR declaration}
{\v\f2 NOSPUR}{\f2 \par 
}{\f2 \tab}{\f2\uldb REMIND declaration}
{\v\f2 REMIND}{\f2 \par 
}{\f2 \tab}{\f2\uldb SPUR declaration}
{\v\f2 SPUR}{\f2 \par 
}{\f2 \tab}{\f2\uldb VECDIM command}
{\v\f2 VECDIM}{\f2 \par 
}{\f2 \tab}{\f2\uldb VECTOR declaration}
{\v\f2 VECTOR}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Numeric_Package}

${\footnote \pard\plain \sl240 \fs20 $ Numeric_Package}

+{\footnote \pard\plain \sl240 \fs20 + g22:1045}

 K{\footnote \pard\plain \sl240 \fs20 K Numeric Package introduction;introduction}

}{\b\f2 NUMERIC PACKAGE}{\f2 \tab \tab \tab \tab }{\b\f2 introduction}{\f2 \par 
\par 
 
The numeric package supplies algorithms based on approximation 
techniques of numerical mathematics. The algorithms use 
the }
{\f2\uldb rounded}{\v\f2 ROUNDED} 
{\f2  mode arithmetic of REDUCE, including 
the variable precision feature which is exploited in some 
algorithms in an adaptive manner in order to reach the 
desired accuracy. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Interval}

${\footnote \pard\plain \sl240 \fs20 $ Interval}

+{\footnote \pard\plain \sl240 \fs20 + g22:1046}

 K{\footnote \pard\plain \sl240 \fs20 K Interval type;type}

}{\b\f2 INTERVAL}{\f2 \tab \tab \tab \tab }{\b\f2 type}{\f2 \par 
\par 
 
Intervals are generally coded as lower bound and 
upper bound connected by the operator }{\f3 ..} {\f2 , usually 
associated to a variable in an 
equation. 
\par 
\par 
 \par
syntax: \par
}{\f4 <var> = (<low> .. <high>) 
\par 
\par 
}{\f2 \par 
where <var> is a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2  and <low>, <high> are 
numbers or expression which evaluate to numbers with <low><=<high>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4 \pard \sl240 }{\f2 means that the variable x is taken in the range from 2.5 up to 
3.5. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # numeric_accuracy}

${\footnote \pard\plain \sl240 \fs20 $ numeric_accuracy}

+{\footnote \pard\plain \sl240 \fs20 + g22:1047}

 K{\footnote \pard\plain \sl240 \fs20 K numeric accuracy concept;concept}

}{\b\f2 NUMERIC ACCURACY}{\f2 \par 
\par 
 
The keyword parameters }{\f3 accuracy=a} {\f2  and }{\f3 iterations=i} {\f2 , 
where }{\f3 a} {\f2 and }{\f3 i} {\f2  must be positive integer numbers, control the 
iterative algorithms: the iteration is continued until 
the local error is below 10**-a; if that is impossible 
within }{\f3 i} {\f2  steps, the iteration is terminated with an 
error message. The values reached so far are then returned 
as the result. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TRNUMERIC}

${\footnote \pard\plain \sl240 \fs20 $ TRNUMERIC}

+{\footnote \pard\plain \sl240 \fs20 + g22:1048}

 K{\footnote \pard\plain \sl240 \fs20 K TRNUMERIC switch;switch}

}{\b\f2 TRNUMERIC}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
Normally the algorithms produce only a minimum of printed 
output during their operation. In cases of an unsuccessful 
or unexpected long operation a }{\f3 trace of the iteration} {\f2  can be 
printed by setting }{\f3 trnumeric} {\f2  }{\f3 on} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # num_min}

${\footnote \pard\plain \sl240 \fs20 $ num_min}

+{\footnote \pard\plain \sl240 \fs20 + g22:1049}

 K{\footnote \pard\plain \sl240 \fs20 K Fletcher Reeves;steepest descent;minimum;num_min operator;operator}

}{\b\f2 NUM_MIN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The Fletcher Reeves version of the }{\f3 steepest descent} {\f2  
algorithms is used to find the }{\f3 minimum} {\f2  of a 
function of one or more variables. The 
function must have continuous partial derivatives with respect to all 
variables. The starting point of the search can be 
specified; if not, random values are taken instead. 
The steepest descent algorithms in general find only local 
minima. 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 num_min} {\f4 (<exp>, 
 <var>[=<val>] [,<var>[=<val>] ... 
 [,accuracy=<a>] [,iterations=<i>]) 
\par 
\par 
or 
\par 
\par 
}{\f3 num_min} {\f4 (exp, \{
 <var>[=<val>] [,<var>[=<val>] ...] \}
 [,accuracy=<a>] [,iterations=<i>]) 
\par 
\par 
}{\f2 \par 
where <exp> is a function expression, 
<var> are the variables in <exp> and 
<val> are the (optional) start values. 
For <a> and <i> see }
{\f2\uldb numeric accuracy}{\v\f2 numeric_accuracy} 
{\f2 . 
\par 
\par 
}{\f3 Num_min} {\f2 tries to find the next local minimum along the descending 
path starting at the given point. The result is a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  
with the minimum function value as first element followed by a list 
of }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f3 s} {\f2 , where the variables are equated to the coordinates 
of the result point. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
num_min(sin(x)+x/5, x) \par
 \par
  \{4.9489585606,\{X=29.643767785\}\} \par
 \par
 \par
num_min(sin(x)+x/5, x=0) \par
 \par
  \{ - 1.3342267466,\{X= - 1.7721582671\}\} \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # num_solve}

${\footnote \pard\plain \sl240 \fs20 $ num_solve}

+{\footnote \pard\plain \sl240 \fs20 + g22:1050}

 K{\footnote \pard\plain \sl240 \fs20 K Jacobian matrix;root;Newton iteration;equation system;equation solving;num_solve operator;operator}

}{\b\f2 NUM_SOLVE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
An adaptively damped Newton iteration is used to find 
an approximative root of a function (function vector) or the 
solution of an }
{\f2\uldb equation}{\v\f2 EQUATION} 
{\f2  (equation system). The expressions 
must have continuous derivatives for all variables. 
A starting point for the iteration can be given. If not given 
random values are taken instead. When the number of 
forms is not equal to the number of variables, the 
Newton method cannot be applied. Then the minimum 
of the sum of absolute squares is located instead. 
\par 
\par 
With }
{\f2\uldb complex}{\v\f2 COMPLEX} 
{\f2  on, solutions with imaginary parts can be 
found, if either the expression(s) or the starting point 
contain a nonzero imaginary part. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 num_solve} {\f4 (<exp>, <var>[=<val>][,accuracy=<a>][,iterations=<i>]) 
\par 
\par 
or 
\par 
\par 
}{\f3 num_solve} {\f4 (\{<exp>,...,<exp>\}, <var>[=<val>],...,<var>[=<val>] 
 [,accuracy=<a>][,iterations=<i>]) 
\par 
\par 
or 
\par 
\par 
}{\f3 num_solve} {\f4 (\{<exp>,...,<exp>\}, \{<var>[=<val>],...,<var>[=<val>]\} 
 [,accuracy=<a>][,iterations=<i>]) 
 \par 
\par 
\par 
\par 
}{\f2 where <exp> are function expressions, 
 <var> are the variables, 
 <val> are optional start values. 
For <a> and <i> see }
{\f2\uldb numeric accuracy}{\v\f2 numeric_accuracy} 
{\f2 . 
 \par 
\par 
}{\f3 num_solve} {\f2 tries to find a zero/solution of the expression(s). 
Result is a list of equations, where the variables are 
equated to the coordinates of the result point. 
 \par 
\par 
The }{\f3 Jacobian matrix} {\f2  is stored as side effect the shared 
variable }{\f3 jacobian} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
num_solve(\{sin x=cos y, x + y = 1\},\{x=1,y=2\}); \par
 \par
 \par
  \{X= - 1.8561957251,Y=2.856195584\} \par
 \par
 \par
jacobian; \par
 \par
      [COS(X)  SIN(Y)] \par
      [              ] \par
      [  1       1   ] \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # num_int}

${\footnote \pard\plain \sl240 \fs20 $ num_int}

+{\footnote \pard\plain \sl240 \fs20 + g22:1051}

 K{\footnote \pard\plain \sl240 \fs20 K integration;num_int operator;operator}

}{\b\f2 NUM_INT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
For the numerical evaluation of univariate integrals 
over a finite interval the following strategy is used: 
If }
{\f2\uldb int}{\v\f2 INT} 
{\f2  finds a formal antiderivative 
 which is bounded in the integration interval, this 
 is evaluated and the end points and the difference 
 is returned. 
Otherwise a }
{\f2\uldb Chebyshev fit}{\v\f2 Chebyshev_fit} 
{\f2  is computed, 
 starting with order 20, eventually up to order 80. 
 If that is recognized as sufficiently convergent 
 it is used for computing the integral by directly 
 integrating the coefficient sequence. 
If none of these methods is successful, an 
 adaptive multilevel quadrature algorithm is used. 
\par 
\par 
For multivariate integrals only the adaptive quadrature is used. 
This algorithm tolerates isolated singularities. 
The value }{\f3 iterations} {\f2  here limits the number of 
local interval intersection levels. 
<a> is a measure for the relative total discretization 
error (comparison of order 1 and order 2 approximations). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 num_int} {\f4 (<exp>,<var>=(<l> .. <u>) 
 [,<var>=(<l> .. <u>),...] 
 [,accuracy=<a>][,iterations=<i>]) 
\par 
\par 
}{\f2 \par 
where <exp> is the function to be integrated, 
<var> are the integration variables, 
<l> are the lower bounds, 
<u> are the upper bounds. 
 \par 
\par 
Result is the value of the integral. 
 \par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
num_int(sin x,x=(0 .. 3.1415926)); \par
 \par
  2.0000010334 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # num_odesolve}

${\footnote \pard\plain \sl240 \fs20 $ num_odesolve}

+{\footnote \pard\plain \sl240 \fs20 + g22:1052}

 K{\footnote \pard\plain \sl240 \fs20 K ODE;initial value problem;Runge-Kutta;num_odesolve operator;operator}

}{\b\f2 NUM_ODESOLVE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 Runge-Kutta} {\f2  method of order 3 finds an approximate graph for 
the solution of real }{\f3 ODE initial value problem} {\f2 . 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 num_odesolve} {\f4 (<exp>,<depvar>=<start>, 
 <indep>=(<from> .. <to>) 
 [,accuracy=<a>][,iterations=<i>]) 
\par 
\par 
or 
\par 
\par 
}{\f3 num_odesolve} {\f4 (\{<exp>,<exp>,...\}, 
 \{<depvar>=<start>,<depvar>=<start>,...\} 
 <indep>=(<from> .. <to>) 
 [,accuracy=<a>][,iterations=<i>]) 
\par 
\par 
\par 
\par 
}{\f2 where 
<depvar> and <start> specify the dependent variable(s) 
and the starting point value (vector), 
<indep>, <from> and <to> specify the independent variable 
and the integration interval (starting point and end point), 
<exp> are equations or expressions which 
contain the first derivative of the independent variable 
with respect to the dependent variable. 
 \par 
\par 
The ODEs are converted to an explicit form, which then is 
used for a Runge Kutta iteration over the given range. The 
number of steps is controlled by the value of <i> 
(default: 20). If the steps are too coarse to reach the desired 
accuracy in the neighborhood of the starting point, the number is 
increased automatically. 
 \par 
\par 
Result is a list of pairs, each representing a point of the 
approximate solution of the ODE problem. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
depend(y,x); \par
 \par
num_odesolve(df(y,x)=y,y=1,x=(0 .. 1), iterations=5); \par
 \par
 \par
  ,\{0.2,1.2214\},\{0.4,1.49181796\},\{0.6,1.8221064563\}, \par
    \{0.8,2.2255208258\},\{1.0,2.7182511366\}\} \par
 \par
\pard \sl240 }{\f2 In most cases you must declare the dependency relation 
between the variables explicitly using }
{\f2\uldb depend}{\v\f2 DEPEND} 
{\f2 ; 
otherwise the formal derivative might be converted to zero. 
\par 
\par 
The operator }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  is used to convert the form into 
an explicit ODE. If that process fails or if it has no unique result, 
the evaluation is stopped with an error message. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # bounds}

${\footnote \pard\plain \sl240 \fs20 $ bounds}

+{\footnote \pard\plain \sl240 \fs20 + g22:1053}

 K{\footnote \pard\plain \sl240 \fs20 K bounds operator;operator}

}{\b\f2 BOUNDS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
Upper and lower bounds of a real valued function over an 
}
{\f2\uldb interval}{\v\f2 Interval} 
{\f2  or a rectangular multivariate domain are computed 
by the operator }{\f3 bounds} {\f2 . The algorithmic basis is the computation 
with inequalities: starting from the interval(s) of the 
variables, the bounds are propagated in the expression 
using the rules for inequality computation. Some knowledge 
about the behavior of special functions like ABS, SIN, COS, EXP, LOG, 
fractional exponentials etc. is integrated and can be evaluated 
if the operator }{\f3 bounds} {\f2  is called with rounded mode on 
(otherwise only algebraic evaluation rules are available). 
 \par 
\par 
If }{\f3 bounds} {\f2  finds a singularity within an interval, the evaluation 
is stopped with an error message indicating the problem part 
of the expression. 
 \par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 bounds} {\f4 (<exp>,<var>=(<l> .. <u>) 
 [,<var>=(<l> .. <u>) ...]) 
\par 
\par 
or 
\par 
\par 
}{\f3 bounds} {\f4 (<exp>,\{<var>=(<l> .. <u>) 
 [,<var>=(<l> .. <u>) ...]\}) 
\par 
\par 
\par 
\par 
}{\f2 where <exp> is the function to be investigated, 
<var> are the variables of <exp>, 
<l> and <u> specify the area as set of }
{\f2\uldb interval}{\v\f2 Interval} 
{\f3 s} {\f2 . 
\par 
\par 
}{\f3 bounds} {\f2 computes upper and lower bounds for the expression in the 
given area. An }
{\f2\uldb interval}{\v\f2 Interval} 
{\f2  is returned. 
 \par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
bounds(sin x,x=(1 .. 2)); \par
 \par
  -1 .. 1 \par
 \par
 \par
on rounded; \par
 \par
bounds(sin x,x=(1 .. 2)); \par
 \par
  0.84147098481 .. 1 \par
 \par
 \par
bounds(x**2+x,x=(-0.5 .. 0.5)); \par
 \par
  - 0.25 .. 0.75 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # Chebyshev_fit}

${\footnote \pard\plain \sl240 \fs20 $ Chebyshev_fit}

+{\footnote \pard\plain \sl240 \fs20 + g22:1054}

 K{\footnote \pard\plain \sl240 \fs20 K approximation;Chebyshev fit concept;concept}

}{\b\f2 CHEBYSHEV FIT}{\f2 \par 
\par 
 
 \par 
\par 
The operator family }{\f3 Chebyshev_...} {\f2  implements approximation 
and evaluation of functions by the Chebyshev method. 
Let }{\f3 T(n,a,b,x)} {\f2  be the Chebyshev polynomial of order }{\f3 n} {\f2  
transformed to the interval }{\f3 (a,b)} {\f2 . 
Then a function }{\f3 f(x)} {\f2  can be 
approximated in }{\f3 (a,b)} {\f2  by a series 
\par 
\par 
\pard \tx3420 }{\f4  \par
  for i := 0:n sum c(i)*T(i,a,b,x) \par
\pard \sl240 }{\f2 The operator }{\f3 chebyshev_fit} {\f2  computes this approximation and 
returns a list, which has as first element the sum expressed 
as a polynomial and as second element the sequence 
of Chebyshev coefficients. 
}{\f3 Chebyshev_df} {\f2  and }{\f3 Chebyshev_int} {\f2  transform a Chebyshev 
coefficient list into the coefficients of the corresponding 
derivative or integral respectively. For evaluating a Chebyshev 
approximation at a given point in the basic interval the 
operator }{\f3 Chebyshev_eval} {\f2  can be used. 
}{\f3 Chebyshev_eval} {\f2  is based on a recurrence relation which is 
in general more stable than a direct evaluation of the 
complete polynomial. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 chebyshev_fit} {\f4 (<fcn>,<var>=(<lo> .. <hi>),<n>) 
\par 
\par 
}{\f3 chebyshev_eval} {\f4 (<coeffs>,<var>=(<lo> .. <hi>), 
 <var>=<pt>) 
\par 
\par 
}{\f3 chebyshev_df} {\f4 (<coeffs>,<var>=(<lo> .. <hi>)) 
\par 
\par 
}{\f3 chebyshev_int} {\f4 (<coeffs>,<var>=(<lo> .. <hi>)) 
\par 
\par 
}{\f2 \par 
where <fcn> is an algebraic expression (the target function), 
<var> is the variable of <fcn>, 
<lo> and <hi> are 
numerical real values which describe an }
{\f2\uldb interval}{\v\f2 Interval} 
{\f2  <lo> < <hi>, 
the integer <n> is the approximation order (set to 20 if missing), 
<pt> is a number in the interval and <coeffs> is 
a series of Chebyshev coefficients. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
on rounded; \par
 \par
 \par
w:=chebyshev_fit(sin x/x,x=(1 .. 3),5); \par
 \par
 \par
                 3            2 \par
  w := \{0.03824*x   - 0.2398*x   + 0.06514*x + 0.9778, \par
        \{0.8991,-0.4066,-0.005198,0.009464,-0.00009511\}\}                     \par
 \par
 \par
chebyshev_eval(second w, x=(1 .. 3), x=2.1); \par
 \par
 \par
  0.4111 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # num_fit}

${\footnote \pard\plain \sl240 \fs20 $ num_fit}

+{\footnote \pard\plain \sl240 \fs20 + g22:1055}

 K{\footnote \pard\plain \sl240 \fs20 K least squares;approximation;num_fit operator;operator}

}{\b\f2 NUM_FIT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 num_fit} {\f2  finds for a set of 
points the linear combination of a given set of 
functions (function basis) which approximates the 
points best under the objective of the }{\f3 least squares} {\f2  
criterion (minimum of the sum of the squares of the deviation). 
The solution is found as zero of the 
gradient vector of the sum of squared errors. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 num_fit} {\f4 (<vals>,<basis>,<var>=<pts>) 
\par 
\par 
}{\f2 \par 
where <vals> is a list of numeric values, 
<var> is a variable used for the approximation, 
<pts> is a list of coordinate values which correspond to 
<var>, 
<basis> is a set of functions varying in }{\f3 var} {\f2  which is used 
 for the approximation. 
 \par 
\par 
The result is a list containing as first element the 
function which approximates the given values, and as 
second element a list of coefficients which were used 
to build this function from the basis. 
 \par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
  \par
pts:=for i:=1 step 1 until 5 collect i$ \par
 \par
vals:=for i:=1 step 1 until 5 collect \par
 \par
            for j:=1:i product j$ \par
 \par
num_fit(vals,\{1,x,x**2\},x=pts); \par
 \par
                     2 \par
      \{14.571428571*X   - 61.428571429*X + 54.6,\{54.6, \par
           - 61.428571429,14.571428571\}\} \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # g22}

${\footnote \pard\plain \sl240 \fs20 $ Numeric Package}

+{\footnote \pard\plain \sl240 \fs20 + index:0022}
}{\b\f2 Numeric Package}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb Numeric Package introduction}
{\v\f2 Numeric_Package}{\f2 \par 
}{\f2 \tab}{\f2\uldb Interval type}
{\v\f2 Interval}{\f2 \par 
}{\f2 \tab}{\f2\uldb numeric accuracy concept}
{\v\f2 numeric_accuracy}{\f2 \par 
}{\f2 \tab}{\f2\uldb TRNUMERIC switch}
{\v\f2 TRNUMERIC}{\f2 \par 
}{\f2 \tab}{\f2\uldb num_min operator}
{\v\f2 num_min}{\f2 \par 
}{\f2 \tab}{\f2\uldb num_solve operator}
{\v\f2 num_solve}{\f2 \par 
}{\f2 \tab}{\f2\uldb num_int operator}
{\v\f2 num_int}{\f2 \par 
}{\f2 \tab}{\f2\uldb num_odesolve operator}
{\v\f2 num_odesolve}{\f2 \par 
}{\f2 \tab}{\f2\uldb bounds operator}
{\v\f2 bounds}{\f2 \par 
}{\f2 \tab}{\f2\uldb Chebyshev fit concept}
{\v\f2 Chebyshev_fit}{\f2 \par 
}{\f2 \tab}{\f2\uldb num_fit operator}
{\v\f2 num_fit}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Roots_Package}

${\footnote \pard\plain \sl240 \fs20 $ Roots_Package}

+{\footnote \pard\plain \sl240 \fs20 + g23:1056}

 K{\footnote \pard\plain \sl240 \fs20 K getroot;firstroot;rootval;rootsat-prec;rlrootno;isolater;polynomial;roots;Roots Package introduction;introduction}

}{\b\f2 ROOTS PACKAGE}{\f2 \tab \tab \tab \tab }{\b\f2 introduction}{\f2 \par 
\par 
 
 \par 
\par 
The root finding package is designed so that it can 
be used to find some or all of the roots of univariate 
polynomials with real or complex coefficients, to the accuracy 
specified by the user. 
\par 
\par 
Not all operators of }{\f3 roots package} {\f2  are described here. For using 
the operators 
\par 
\par 
}{\f3 isolater} {\f2 (intervals isolating real roots) 
\par 
\par 
}{\f3 rlrootno} {\f2 (number of real roots in an interval) 
\par 
\par 
}{\f3 rootsat-prec} {\f2 (roots at system precision) 
\par 
\par 
}{\f3 rootval} {\f2 (result in equation form) 
\par 
\par 
}{\f3 firstroot} {\f2 (computing only one root) 
\par 
\par 
}{\f3 getroot} {\f2 (selecting roots from a collection) 
\par 
\par 
please consult the full documentation of the package. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MKPOLY}

${\footnote \pard\plain \sl240 \fs20 $ MKPOLY}

+{\footnote \pard\plain \sl240 \fs20 + g23:1057}

 K{\footnote \pard\plain \sl240 \fs20 K interpolation;roots;polynomial;MKPOLY operator;operator}

}{\b\f2 MKPOLY}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
Given a roots list as returned by }
{\f2\uldb roots}{\v\f2 ROOTS} 
{\f2 , 
the operator }{\f3 mkpoly} {\f2  constructs a 
polynomial which has these numbers as roots. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 mkpoly} {\f4 <rl> 
\par 
\par 
}{\f2 \par 
where <rl> is a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  with equations, which 
all have the same }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2  on their left-hand sides 
and numbers as right-hand sides. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
mkpoly\{x=1,x=-2,x=i,x=-i\}; \par
 \par
  x**4 + x**3 - x**2 + x - 2 \par
 \par
\pard \sl240 }{\f2 Note that this polynomial is unique only up to a numeric 
factor. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # NEARESTROOT}

${\footnote \pard\plain \sl240 \fs20 $ NEARESTROOT}

+{\footnote \pard\plain \sl240 \fs20 + g23:1058}

 K{\footnote \pard\plain \sl240 \fs20 K solve;roots;NEARESTROOT operator;operator}

}{\b\f2 NEARESTROOT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 nearestroot} {\f2  finds one root of a polynomial 
with an iteration using a given starting point. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 nearestroot} {\f4 (<p>,<pt>) 
\par 
\par 
}{\f2 \par 
where <p> is a univariate polynomial 
and <pt> is a number. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
nearestroot(x^2+2,2); \par
 \par
  \{x=1.41421*i\} \par
 \par
\pard \sl240 }{\f2 The minimal accuracy of the result values is controlled by 
}
{\f2\uldb rootacc}{\v\f2 ROOTACC} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # REALROOTS}

${\footnote \pard\plain \sl240 \fs20 $ REALROOTS}

+{\footnote \pard\plain \sl240 \fs20 + g23:1059}

 K{\footnote \pard\plain \sl240 \fs20 K solve;roots;REALROOTS operator;operator}

}{\b\f2 REALROOTS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 realroots} {\f2  finds that real roots of a polynomial 
to an accuracy that is sufficient to separate them and which is 
a minimum of 6 decimal places. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 realroots} {\f4 (<p>) or 
\par 
\par 
}{\f3 realroots} {\f4 (<p>,<from>,<to>) 
\par 
\par 
}{\f2 \par 
where <p> is a univariate polynomial. 
The optional parameters <from> and <to> classify 
an interval: if given, exactly the real roots in this 
interval will be returned. <from> and <to> 
can also take the values }{\f3 infinity} {\f2  or }{\f3 -infinity} {\f2 . 
If omitted all real roots will be returned. 
Result is a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  
of equations which represent the roots of the polynomial at the 
given accuracy. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
realroots(x^5-2); \par
 \par
  \{x=1.1487\} \par
 \par
 \par
realroots(x^3-104*x^2+403*x-300,2,infinity); \par
 \par
 \par
  \{x=3.0,x=100.0\} \par
 \par
 \par
realroots(x^3-104*x^2+403*x-300,-infinity,2); \par
 \par
 \par
  \{x=1\} \par
 \par
\pard \sl240 }{\f2 The minimal accuracy of the result values is controlled by 
}
{\f2\uldb rootacc}{\v\f2 ROOTACC} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ROOTACC}

${\footnote \pard\plain \sl240 \fs20 $ ROOTACC}

+{\footnote \pard\plain \sl240 \fs20 + g23:1060}

 K{\footnote \pard\plain \sl240 \fs20 K accuracy;roots;ROOTACC operator;operator}

}{\b\f2 ROOTACC}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 rootacc} {\f2  allows you to set the accuracy 
up to which the roots package computes its results. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 rootacc} {\f4 (<n>) 
\par 
\par 
}{\f2 \par 
Here <n> is an integer value. The internal accuracy of 
the }{\f3 roots} {\f2  package is adjusted to a value of 
}{\f3 max(6,n)} {\f2 . The default value is }{\f3 6} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ROOTS}

${\footnote \pard\plain \sl240 \fs20 $ ROOTS}

+{\footnote \pard\plain \sl240 \fs20 + g23:1061}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;solve;roots;ROOTS operator;operator}

}{\b\f2 ROOTS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 roots} {\f2  
is the main top level function of the roots package. 
It will find all roots, real and complex, of the polynomial p 
to an accuracy that is sufficient to separate them and which is 
a minimum of 6 decimal places. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 roots} {\f4 (<p>) 
\par 
\par 
}{\f2 \par 
where <p> is a univariate polynomial. Result is a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  
of equations which represent the roots of the polynomial at the 
given accuracy. In addition, }{\f3 roots} {\f2  stores 
separate lists of real roots and complex roots in the global 
variables }
{\f2\uldb rootsreal}{\v\f2 ROOTSREAL} 
{\f2  and }
{\f2\uldb rootscomplex}{\v\f2 ROOTSCOMPLEX} 
{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
roots(x^5-2); \par
 \par
  \{x=-0.929316 + 0.675188*i, \par
    x=-0.929316 - 0.675188*i, \par
    x=0.354967 + 1.09248*i, \par
    x=0.354967 - 1.09248*i,  \par
    x=1.1487\} \par
 \par
\pard \sl240 }{\f2 The minimal accuracy of the result values is controlled by 
}
{\f2\uldb rootacc}{\v\f2 ROOTACC} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ROOT\_VAL}

${\footnote \pard\plain \sl240 \fs20 $ ROOT_VAL}

+{\footnote \pard\plain \sl240 \fs20 + g23:1062}

 K{\footnote \pard\plain \sl240 \fs20 K polynomial;solve;roots;ROOT_VAL operator;operator}

}{\b\f2 ROOT\_VAL}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The operator }{\f3 root_val} {\f2  computes the roots of a 
univariate polynomial at system precision 
(or greater if required for root separation) and presents 
its result as a list of numbers. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 roots} {\f4 (<p>) 
\par 
\par 
}{\f2 \par 
where <p> is a univariate polynomial. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
root_val(x^5-2); \par
 \par
  \{-0.929316490603 + 0.6751879524*i, \par
   -0.929316490603 - 0.6751879524*i, \par
   0.354967313105 + 1.09247705578*i, \par
   0.354967313105 - 1.09247705578*i, \par
   1.148698355\} \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # ROOTSCOMPLEX}

${\footnote \pard\plain \sl240 \fs20 $ ROOTSCOMPLEX}

+{\footnote \pard\plain \sl240 \fs20 + g23:1063}

 K{\footnote \pard\plain \sl240 \fs20 K complex;roots;ROOTSCOMPLEX variable;variable}

}{\b\f2 ROOTSCOMPLEX}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
When the operator }
{\f2\uldb roots}{\v\f2 ROOTS} 
{\f2  is called the complex 
roots are collected in the global variable }{\f3 rootscomplex} {\f2  
as }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ROOTSREAL}

${\footnote \pard\plain \sl240 \fs20 $ ROOTSREAL}

+{\footnote \pard\plain \sl240 \fs20 + g23:1064}

 K{\footnote \pard\plain \sl240 \fs20 K complex;roots;ROOTSREAL variable;variable}

}{\b\f2 ROOTSREAL}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
When the operator }
{\f2\uldb roots}{\v\f2 ROOTS} 
{\f2  is called the real 
roots are collected in the global variable }{\f3 rootreal} {\f2  
as }
{\f2\uldb list}{\v\f2 LIST} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g23}

${\footnote \pard\plain \sl240 \fs20 $ Roots Package}

+{\footnote \pard\plain \sl240 \fs20 + index:0023}
}{\b\f2 Roots Package}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb Roots Package introduction}
{\v\f2 Roots_Package}{\f2 \par 
}{\f2 \tab}{\f2\uldb MKPOLY operator}
{\v\f2 MKPOLY}{\f2 \par 
}{\f2 \tab}{\f2\uldb NEARESTROOT operator}
{\v\f2 NEARESTROOT}{\f2 \par 
}{\f2 \tab}{\f2\uldb REALROOTS operator}
{\v\f2 REALROOTS}{\f2 \par 
}{\f2 \tab}{\f2\uldb ROOTACC operator}
{\v\f2 ROOTACC}{\f2 \par 
}{\f2 \tab}{\f2\uldb ROOTS operator}
{\v\f2 ROOTS}{\f2 \par 
}{\f2 \tab}{\f2\uldb ROOT\_VAL operator}
{\v\f2 ROOT\_VAL}{\f2 \par 
}{\f2 \tab}{\f2\uldb ROOTSCOMPLEX variable}
{\v\f2 ROOTSCOMPLEX}{\f2 \par 
}{\f2 \tab}{\f2\uldb ROOTSREAL variable}
{\v\f2 ROOTSREAL}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Special_Function_Package}

${\footnote \pard\plain \sl240 \fs20 $ Special_Function_Package}

+{\footnote \pard\plain \sl240 \fs20 + g24:1065}

 K{\footnote \pard\plain \sl240 \fs20 K Special Function Package introduction;introduction}

}{\b\f2 SPECIAL FUNCTION PACKAGE}{\f2 \tab \tab \tab \tab }{\b\f2 introduction}{\f2 \par 
\par 
 
The REDUCE }{\f3 Special Function Package} {\f2  supplies extended 
algebraic and numeric support for a wide class of objects. 
This package was released together with REDUCE 3.5 (October 1993) 
for the first time, a major update is released with REDUCE 3.6. 
\par 
\par 
The functions included in this package are in most cases (unless otherwise 
stated) defined and named like in the book by Abramowitz and Stegun: 
Handbook of Mathematical Functions, Dover Publications. 
\par 
\par 
The aim is to collect as much information on the special functions 
and simplification capabilities as possible, 
i.e. algebraic simplifications and numeric (rounded mode) code, limits 
of the functions together 
with the definitions of the functions, which are in most cases a power 
series, a (definite) integral and/or a differential equation. 
\par 
\par 
What can be found: Some famous constants, a variety of Bessel functions, 
special polynomials, 
the Gamma function, the (Riemann) Zeta function, Elliptic Functions, Elliptic 
Integrals, 3J symbols (Clebsch-Gordan coefficients) and integral functions. 
\par 
\par 
What is missing: Mathieu functions, LerchPhi, etc.. 
The information about the special functions which solve certain 
differential equation is very limited. 
In several cases numerical approximation is restricted to real 
arguments or is missing completely. 
\par 
\par 
The implementation of this package uses REDUCE rule sets to a large extent, 
which guarantees a high 'readability' of the functions definitions in the 
source file directory. It makes extensions to the special 
functions code easy in most cases too. To look at these rules 
it may be convenient to use the showrules operator e.g. 
\par 
\par 
}
{\f2\uldb showrules}{\v\f2 SHOWRULES} 
{\f2 Besseli; 
\par 
\par 
. 
\par 
\par 
Some evaluations are improved if the special function package is loaded, 
e.g. some (infinite) sums and products leading to expressions including 
special functions are known in this case. 
\par 
\par 
Note: The special function package has to be loaded explicitly by calling 
\pard \tx3420 }{\f4  \par
   load_package specfn; \par
\pard \sl240 }{\f2 \par 
\par 
The functions }
{\f2\uldb MeijerG}{\v\f2 MeijerG} 
{\f2  and }
{\f2\uldb hypergeometric}{\v\f2 HYPERGEOMETRIC} 
{\f2  require 
additionally 
\pard \tx3420 }{\f4  \par
   load_package specfn2; \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Constants}

${\footnote \pard\plain \sl240 \fs20 $ Constants}

+{\footnote \pard\plain \sl240 \fs20 + g24:1066}

 K{\footnote \pard\plain \sl240 \fs20 K Golden_Ratio;Khinchin's constant;Catalan's constant;Euler's constant;Constants concept;concept}

}{\b\f2 CONSTANTS}{\f2 \par 
\par 
 
 \par 
\par 
There are a few constants known to the special function package, namely 
\par 
\par 
\tab }{\f3 Euler's constant } {\f2 (which can be computed as -}
{\f2\uldb Psi}{\v\f2 PSI} 
{\f2 (1)) and 
\par 
\tab }{\f3 Khinchin's constant} {\f2  (which is defined in Khinchin's book 
 ``Continued Fractions'') and 
\par 
\tab }{\f3 Golden_Ratio} {\f2  (which can be computed as (1 + sqrt 5)/2) and 
\par 
\tab }{\f3 Catalan's constant} {\f2  (which is known as an infinite sum of reciprocal 
powers) 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded; \par
Euler_Gamma;  \par
 \par
  0.577215664902  \par
 \par
 \par
Khinchin;  \par
 \par
  2.68545200107  \par
 \par
 \par
Catalan  \par
 \par
  0.915965594177  \par
 \par
 \par
Golden_Ratio  \par
 \par
  1.61803398875 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # BERNOULLI}

${\footnote \pard\plain \sl240 \fs20 $ BERNOULLI}

+{\footnote \pard\plain \sl240 \fs20 + g25:1067}

 K{\footnote \pard\plain \sl240 \fs20 K BERNOULLI operator;operator}

}{\b\f2 BERNOULLI}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 bernoulli} {\f2  operator returns the nth Bernoulli number. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Bernoulli} {\f4 (<integer>) 
\par 
\par 
\par 
\par 
}{\f2  \par
examples: \par
\pard \tx3420 }{\f4  \par
bernoulli 20;  \par
 \par
  - 174611 / 330  \par
 \par
 \par
bernoulli 17;  \par
 \par
  0 \par
 \par
\pard \sl240 }{\f2 All Bernoulli numbers with odd indices except for 1 are zero. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # BERNOULLIP}

${\footnote \pard\plain \sl240 \fs20 $ BERNOULLIP}

+{\footnote \pard\plain \sl240 \fs20 + g25:1068}

 K{\footnote \pard\plain \sl240 \fs20 K BERNOULLIP operator;operator}

}{\b\f2 BERNOULLIP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 BernoulliP} {\f2  operator returns the nth Bernoulli Polynomial 
evaluated at x. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 BernoulliP} {\f4 (<integer>,<expression>) 
\par 
\par 
\par 
\par 
}{\f2  \par
examples: \par
\pard \tx3420 }{\f4  \par
BernoulliP(3,z);  \par
 \par
        2 \par
  z*(2*z   - 3*z + 1)/2 \par
 \par
 \par
 \par
BernoulliP(10,3);  \par
 \par
  338585 / 66 \par
 \par
\pard \sl240 }{\f2 The value of the nth Bernoulli Polynomial at 0 is the nth Bernoulli number. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EULER}

${\footnote \pard\plain \sl240 \fs20 $ EULER}

+{\footnote \pard\plain \sl240 \fs20 + g25:1069}

 K{\footnote \pard\plain \sl240 \fs20 K EULER operator;operator}

}{\b\f2 EULER}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 EULER} {\f2  operator returns the nth Euler number. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Euler} {\f4 (<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Euler 20;  \par
 \par
  370371188237525  \par
 \par
 \par
Euler 0;  \par
 \par
  1 \par
 \par
\pard \sl240 }{\f2 The }{\f3 Euler} {\f2  numbers are evaluated by a recursive algorithm which 
makes it hard to compute Euler numbers above say 200. 
\par 
\par 
Euler numbers appear in the coefficients of the power series 
representation of 1/cos(z). 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EULERP}

${\footnote \pard\plain \sl240 \fs20 $ EULERP}

+{\footnote \pard\plain \sl240 \fs20 + g25:1070}

 K{\footnote \pard\plain \sl240 \fs20 K EULERP operator;operator}

}{\b\f2 EULERP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 EulerP} {\f2  operator returns the nth Euler Polynomial. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 EulerP} {\f4 (<integer>,<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
EulerP(2,xx);  \par
 \par
  xx*(xx - 1)  \par
 \par
 \par
EulerP(10,3);  \par
 \par
  2046 \par
 \par
\pard \sl240 }{\f2 The Euler numbers are the values of the Euler Polynomials at 1/2 
multiplied by 2**n. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ZETA}

${\footnote \pard\plain \sl240 \fs20 $ ZETA}

+{\footnote \pard\plain \sl240 \fs20 + g25:1071}

 K{\footnote \pard\plain \sl240 \fs20 K ZETA operator;operator}

}{\b\f2 ZETA}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Zeta} {\f2  operator returns Riemann's Zeta function, 
\par 
\par 
Zeta (z) := sum(1/(k**z),k,1,infinity) 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Zeta} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Zeta(2);  \par
 \par
    2 \par
  pi  / 6  \par
 \par
 \par
on rounded;  \par
 \par
Zeta 1.01;  \par
 \par
  100.577943338 \par
 \par
\pard \sl240 }{\f2 Numerical computation for the Zeta function for arguments close to 1 are 
tedious, because the series is converging very slowly. In this case a formula 
(e.g. found in Bender/Orzag: Advanced Mathematical Methods for 
Scientists and Engineers, McGraw-Hill) is used. 
\par 
\par 
No numerical approximation for complex arguments is done. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g25}

${\footnote \pard\plain \sl240 \fs20 $ Bernoulli Euler Zeta}

+{\footnote \pard\plain \sl240 \fs20 + index:0025}
}{\b\f2 Bernoulli Euler Zeta}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb BERNOULLI operator}
{\v\f2 BERNOULLI}{\f2 \par 
}{\f2 \tab}{\f2\uldb BERNOULLIP operator}
{\v\f2 BERNOULLIP}{\f2 \par 
}{\f2 \tab}{\f2\uldb EULER operator}
{\v\f2 EULER}{\f2 \par 
}{\f2 \tab}{\f2\uldb EULERP operator}
{\v\f2 EULERP}{\f2 \par 
}{\f2 \tab}{\f2\uldb ZETA operator}
{\v\f2 ZETA}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # BESSELJ}

${\footnote \pard\plain \sl240 \fs20 $ BESSELJ}

+{\footnote \pard\plain \sl240 \fs20 + g26:1072}

 K{\footnote \pard\plain \sl240 \fs20 K BESSELJ operator;operator}

}{\b\f2 BESSELJ}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 BesselJ} {\f2  operator returns the Bessel function of the first kind. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 BesselJ} {\f4 (<order>,<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
BesselJ(1/2,pi);  \par
 \par
  0  \par
 \par
 \par
on rounded;  \par
 \par
BesselJ(0,1);  \par
 \par
  0.765197686558   \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # BESSELY}

${\footnote \pard\plain \sl240 \fs20 $ BESSELY}

+{\footnote \pard\plain \sl240 \fs20 + g26:1073}

 K{\footnote \pard\plain \sl240 \fs20 K Weber's function;BESSELY operator;operator}

}{\b\f2 BESSELY}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 BesselY} {\f2  operator returns the Bessel function of the second kind. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 BesselY} {\f4 (<order>,<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
BesselY (1/2,pi);  \par
 \par
  - sqrt(2) / pi  \par
 \par
 \par
on rounded;  \par
 \par
BesselY (1,3);  \par
 \par
  0.324674424792 \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 BesselY} {\f2  is also called Weber's function. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # HANKEL1}

${\footnote \pard\plain \sl240 \fs20 $ HANKEL1}

+{\footnote \pard\plain \sl240 \fs20 + g26:1074}

 K{\footnote \pard\plain \sl240 \fs20 K HANKEL1 operator;operator}

}{\b\f2 HANKEL1}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Hankel1} {\f2  operator returns the Hankel function of the first kind. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Hankel1} {\f4 (<order>,<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on complex;  \par
 \par
Hankel1 (1/2,pi);  \par
 \par
  - i * sqrt(2) / pi  \par
 \par
 \par
Hankel1 (1,pi);  \par
 \par
  besselj(1,pi) + i*bessely(1,pi) \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 Hankel1} {\f2  is also called Bessel function of the third kind. 
There is currently no numeric evaluation of Hankel functions. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # HANKEL2}

${\footnote \pard\plain \sl240 \fs20 $ HANKEL2}

+{\footnote \pard\plain \sl240 \fs20 + g26:1075}

 K{\footnote \pard\plain \sl240 \fs20 K HANKEL2 operator;operator}

}{\b\f2 HANKEL2}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Hankel2} {\f2  operator returns the Hankel function of the second kind. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Hankel2} {\f4 (<order>,<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on complex;  \par
 \par
Hankel2 (1/2,pi);  \par
 \par
  - i * sqrt(2) / pi  \par
 \par
 \par
Hankel2 (1,pi);  \par
 \par
  besselj(1,pi) - i*bessely(1,pi) \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 Hankel2} {\f2  is also called Bessel function of the third kind. 
There is currently no numeric evaluation of Hankel functions. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # BESSELI}

${\footnote \pard\plain \sl240 \fs20 $ BESSELI}

+{\footnote \pard\plain \sl240 \fs20 + g26:1076}

 K{\footnote \pard\plain \sl240 \fs20 K BESSELI operator;operator}

}{\b\f2 BESSELI}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 BesselI} {\f2  operator returns the modified Bessel function I. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 BesselI} {\f4 (<order>,<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on rounded;  \par
 \par
Besseli (1,1);  \par
 \par
  0.565159103992 \par
 \par
\pard \sl240 }{\f2 The knowledge about the operator }{\f3 BesselI} {\f2  is currently fairly limited. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # BESSELK}

${\footnote \pard\plain \sl240 \fs20 $ BESSELK}

+{\footnote \pard\plain \sl240 \fs20 + g26:1077}

 K{\footnote \pard\plain \sl240 \fs20 K BESSELK operator;operator}

}{\b\f2 BESSELK}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 BesselK} {\f2  operator returns the modified Bessel function K. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 BesselK} {\f4 (<order>,<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
df(besselk(0,x),x);  \par
 \par
  - besselk(1,x) \par
 \par
\pard \sl240 }{\f2 There is currently no numeric support for the operator }{\f3 BesselK} {\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # StruveH}

${\footnote \pard\plain \sl240 \fs20 $ StruveH}

+{\footnote \pard\plain \sl240 \fs20 + g26:1078}

 K{\footnote \pard\plain \sl240 \fs20 K StruveH operator;operator}

}{\b\f2 STRUVEH}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 StruveH} {\f2  operator returns Struve's H function. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 StruveH} {\f4 (<order>,<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
struveh(-3/2,x);  \par
 \par
  - besselj(3/2,x) / i \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # StruveL}

${\footnote \pard\plain \sl240 \fs20 $ StruveL}

+{\footnote \pard\plain \sl240 \fs20 + g26:1079}

 K{\footnote \pard\plain \sl240 \fs20 K StruveL operator;operator}

}{\b\f2 STRUVEL}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 StruveL} {\f2  operator returns the modified Struve L function . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 StruveL} {\f4 (<order>,<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
struvel(-3/2,x);  \par
 \par
  besseli(3/2,x) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # KummerM}

${\footnote \pard\plain \sl240 \fs20 $ KummerM}

+{\footnote \pard\plain \sl240 \fs20 + g26:1080}

 K{\footnote \pard\plain \sl240 \fs20 K Confluent Hypergeometric function;KummerM operator;operator}

}{\b\f2 KUMMERM}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 KummerM} {\f2  operator returns Kummer's M function. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 KummerM} {\f4 (<parameter>,<parameter>,<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
kummerm(1,1,x);  \par
 \par
   x \par
  e   \par
 \par
 \par
on rounded;  \par
 \par
kummerm(1,3,1.3);  \par
 \par
  1.62046942914 \par
 \par
\pard \sl240 }{\f2 Kummer's M function is one of the Confluent Hypergeometric functions. 
For reference see the }
{\f2\uldb hypergeometric}{\v\f2 HYPERGEOMETRIC} 
{\f2  operator. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # KummerU}

${\footnote \pard\plain \sl240 \fs20 $ KummerU}

+{\footnote \pard\plain \sl240 \fs20 + g26:1081}

 K{\footnote \pard\plain \sl240 \fs20 K Confluent Hypergeometric function;KummerU operator;operator}

}{\b\f2 KUMMERU}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 KummerU} {\f2  operator returns Kummer's U function. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 KummerU} {\f4 (<parameter>,<parameter>,<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
df(kummeru(1,1,x),x)  \par
 \par
  - kummeru(2,2,x) \par
 \par
\pard \sl240 }{\f2 Kummer's U function is one of the Confluent Hypergeometric functions. 
For reference see the }
{\f2\uldb hypergeometric}{\v\f2 HYPERGEOMETRIC} 
{\f2  operator. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # WhittakerW}

${\footnote \pard\plain \sl240 \fs20 $ WhittakerW}

+{\footnote \pard\plain \sl240 \fs20 + g26:1082}

 K{\footnote \pard\plain \sl240 \fs20 K Confluent Hypergeometric function;WhittakerW operator;operator}

}{\b\f2 WHITTAKERW}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 WhittakerW} {\f2  operator returns Whittaker's W function. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 WhittakerW} {\f4 (<parameter>,<parameter>,<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
WhittakerW(2,2,2);  \par
 \par
                    1 \par
  4*sqrt(2)*kummeru(-,5,2) \par
                    2 \par
  ------------------------- \par
             e \par
 \par
\pard \sl240 }{\f2 Whittaker's W function is one of the Confluent Hypergeometric functions. 
For reference see the }
{\f2\uldb hypergeometric}{\v\f2 HYPERGEOMETRIC} 
{\f2  operator. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g26}

${\footnote \pard\plain \sl240 \fs20 $ Bessel Functions}

+{\footnote \pard\plain \sl240 \fs20 + index:0026}
}{\b\f2 Bessel Functions}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb BESSELJ operator}
{\v\f2 BESSELJ}{\f2 \par 
}{\f2 \tab}{\f2\uldb BESSELY operator}
{\v\f2 BESSELY}{\f2 \par 
}{\f2 \tab}{\f2\uldb HANKEL1 operator}
{\v\f2 HANKEL1}{\f2 \par 
}{\f2 \tab}{\f2\uldb HANKEL2 operator}
{\v\f2 HANKEL2}{\f2 \par 
}{\f2 \tab}{\f2\uldb BESSELI operator}
{\v\f2 BESSELI}{\f2 \par 
}{\f2 \tab}{\f2\uldb BESSELK operator}
{\v\f2 BESSELK}{\f2 \par 
}{\f2 \tab}{\f2\uldb StruveH operator}
{\v\f2 StruveH}{\f2 \par 
}{\f2 \tab}{\f2\uldb StruveL operator}
{\v\f2 StruveL}{\f2 \par 
}{\f2 \tab}{\f2\uldb KummerM operator}
{\v\f2 KummerM}{\f2 \par 
}{\f2 \tab}{\f2\uldb KummerU operator}
{\v\f2 KummerU}{\f2 \par 
}{\f2 \tab}{\f2\uldb WhittakerW operator}
{\v\f2 WhittakerW}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Airy_Ai}

${\footnote \pard\plain \sl240 \fs20 $ Airy_Ai}

+{\footnote \pard\plain \sl240 \fs20 + g27:1083}

 K{\footnote \pard\plain \sl240 \fs20 K Airy_Ai operator;operator}

}{\b\f2 AIRY_AI}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Airy_Ai} {\f2  operator returns the Airy Ai function for a given argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Airy_Ai} {\f4 (<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
on complex; \par
on rounded; \par
Airy_Ai(0);  \par
 \par
 \par
  0.355028053888           \par
 \par
 \par
Airy_Ai(3.45 + 17.97i);  \par
 \par
  - 5.5561528511e+9 - 8.80397899932e+9*i   \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # Airy_Bi}

${\footnote \pard\plain \sl240 \fs20 $ Airy_Bi}

+{\footnote \pard\plain \sl240 \fs20 + g27:1084}

 K{\footnote \pard\plain \sl240 \fs20 K Airy_Bi operator;operator}

}{\b\f2 AIRY_BI}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Airy_Bi} {\f2  operator returns the Airy Bi function for a given 
argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Airy_Bi} {\f4 (<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Airy_Bi(0);  \par
 \par
  0.614926627446           \par
 \par
 \par
Airy_Bi(3.45 + 17.97i);  \par
 \par
  8.80397899932e+9 - 5.5561528511e+9*i    \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # Airy_Aiprime}

${\footnote \pard\plain \sl240 \fs20 $ Airy_Aiprime}

+{\footnote \pard\plain \sl240 \fs20 + g27:1085}

 K{\footnote \pard\plain \sl240 \fs20 K Airy_Aiprime operator;operator}

}{\b\f2 AIRY_AIPRIME}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Airy_Aiprime} {\f2  operator returns the Airy Aiprime function for a 
given argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Airy_Aiprime} {\f4 (<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Airy_Aiprime(0);  \par
 \par
  - 0.258819403793            \par
 \par
 \par
Airy_Aiprime(3.45+17.97i); \par
 \par
  - 3.83386421824e+19 + 2.16608828136e+19*i  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # Airy_Biprime}

${\footnote \pard\plain \sl240 \fs20 $ Airy_Biprime}

+{\footnote \pard\plain \sl240 \fs20 + g27:1086}

 K{\footnote \pard\plain \sl240 \fs20 K Airy_Biprime operator;operator}

}{\b\f2 AIRY_BIPRIME}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Airy_Biprime} {\f2  operator returns the Airy Biprime function for a 
given argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Airy_Biprime} {\f4 (<argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Airy_Biprime(0);  \par
 \par
 \par
Airy_Biprime(3.45 + 17.97i);  \par
 \par
  3.84251916792e+19 - 2.18006297399e+19*i \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # g27}

${\footnote \pard\plain \sl240 \fs20 $ Airy Functions}

+{\footnote \pard\plain \sl240 \fs20 + index:0027}
}{\b\f2 Airy Functions}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb Airy_Ai operator}
{\v\f2 Airy_Ai}{\f2 \par 
}{\f2 \tab}{\f2\uldb Airy_Bi operator}
{\v\f2 Airy_Bi}{\f2 \par 
}{\f2 \tab}{\f2\uldb Airy_Aiprime operator}
{\v\f2 Airy_Aiprime}{\f2 \par 
}{\f2 \tab}{\f2\uldb Airy_Biprime operator}
{\v\f2 Airy_Biprime}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiSN}

${\footnote \pard\plain \sl240 \fs20 $ JacobiSN}

+{\footnote \pard\plain \sl240 \fs20 + g28:1087}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiSN operator;operator}

}{\b\f2 JACOBISN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Jacobisn} {\f2  operator returns the Jacobi Elliptic function sn. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Jacobisn} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Jacobisn(0.672, 0.36)  \par
 \par
  0.609519691792  \par
 \par
 \par
Jacobisn(1,0.9)  \par
 \par
  0.770085724907881  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiCN}

${\footnote \pard\plain \sl240 \fs20 $ JacobiCN}

+{\footnote \pard\plain \sl240 \fs20 + g28:1088}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiCN operator;operator}

}{\b\f2 JACOBICN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Jacobicn} {\f2  operator returns the Jacobi Elliptic function cn. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Jacobicn} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Jacobicn(7.2, 0.6)  \par
 \par
  0.837288298482018   \par
 \par
 \par
Jacobicn(0.11, 19)  \par
 \par
  0.994403862690043 - 1.6219006985556e-16*i   \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiDN}

${\footnote \pard\plain \sl240 \fs20 $ JacobiDN}

+{\footnote \pard\plain \sl240 \fs20 + g28:1089}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiDN operator;operator}

}{\b\f2 JACOBIDN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Jacobidn} {\f2  operator returns the Jacobi Elliptic function dn. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Jacobidn} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Jacobidn(15, 0.683)  \par
 \par
  0.640574162024592  \par
 \par
 \par
Jacobidn(0,0)  \par
 \par
  1  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiCD}

${\footnote \pard\plain \sl240 \fs20 $ JacobiCD}

+{\footnote \pard\plain \sl240 \fs20 + g28:1090}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiCD operator;operator}

}{\b\f2 JACOBICD}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Jacobicd} {\f2  operator returns the Jacobi Elliptic function cd. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Jacobicd} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Jacobicd(1, 0.34)  \par
 \par
  0.657683337805273  \par
 \par
 \par
Jacobicd(0.8,0.8)  \par
 \par
  0.925587311582301  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiSD}

${\footnote \pard\plain \sl240 \fs20 $ JacobiSD}

+{\footnote \pard\plain \sl240 \fs20 + g28:1091}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiSD operator;operator}

}{\b\f2 JACOBISD}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Jacobisd} {\f2  operator returns the Jacobi Elliptic function sd. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Jacobisd} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Jacobisd(12, 0.4)  \par
 \par
  0.357189729437272     \par
 \par
 \par
Jacobisd(0.35,1)  \par
 \par
  - 1.17713873203043   \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiND}

${\footnote \pard\plain \sl240 \fs20 $ JacobiND}

+{\footnote \pard\plain \sl240 \fs20 + g28:1092}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiND operator;operator}

}{\b\f2 JACOBIND}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Jacobind} {\f2  operator returns the Jacobi Elliptic function nd. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Jacobind} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Jacobind(0.2, 17)  \par
 \par
  1.46553203037507 + 0.0000000000334032759313703*i  \par
 \par
 \par
Jacobind(30, 0.001)  \par
 \par
  1.00048958438   \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiDC}

${\footnote \pard\plain \sl240 \fs20 $ JacobiDC}

+{\footnote \pard\plain \sl240 \fs20 + g28:1093}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiDC operator;operator}

}{\b\f2 JACOBIDC}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Jacobidc} {\f2  operator returns the Jacobi Elliptic function dc. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Jacobidc} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Jacobidc(0.003,1)  \par
 \par
  1  \par
 \par
 \par
Jacobidc(2, 0.75)  \par
 \par
  6.43472885111   \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiNC}

${\footnote \pard\plain \sl240 \fs20 $ JacobiNC}

+{\footnote \pard\plain \sl240 \fs20 + g28:1094}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiNC operator;operator}

}{\b\f2 JACOBINC}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Jacobinc} {\f2  operator returns the Jacobi Elliptic function nc. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Jacobinc} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Jacobinc(1,0)  \par
 \par
  1.85081571768093  \par
 \par
 \par
Jacobinc(56, 0.4387)  \par
 \par
  39.304842663512   \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiSC}

${\footnote \pard\plain \sl240 \fs20 $ JacobiSC}

+{\footnote \pard\plain \sl240 \fs20 + g28:1095}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiSC operator;operator}

}{\b\f2 JACOBISC}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Jacobisc} {\f2  operator returns the Jacobi Elliptic function sc. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Jacobisc} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Jacobisc(9, 0.88)  \par
 \par
  - 1.16417697982095   \par
 \par
 \par
Jacobisc(0.34, 7)  \par
 \par
  0.305851938390775 - 9.8768100944891e-12*i  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiNS}

${\footnote \pard\plain \sl240 \fs20 $ JacobiNS}

+{\footnote \pard\plain \sl240 \fs20 + g28:1096}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiNS operator;operator}

}{\b\f2 JACOBINS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Jacobins} {\f2  operator returns the Jacobi Elliptic function ns. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Jacobins} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Jacobins(3, 0.9)  \par
 \par
  1.00945801599785  \par
 \par
 \par
Jacobins(0.887, 15)  \par
 \par
  0.683578280513975 - 0.85023411082469*i  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiDS}

${\footnote \pard\plain \sl240 \fs20 $ JacobiDS}

+{\footnote \pard\plain \sl240 \fs20 + g28:1097}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiDS operator;operator}

}{\b\f2 JACOBIDS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Jacobisn} {\f2  operator returns the Jacobi Elliptic function ds. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Jacobids} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Jacobids(98,0.223)  \par
 \par
  - 1.061253961477  \par
 \par
 \par
Jacobids(0.36,0.6)  \par
 \par
  2.76693172243692  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiCS}

${\footnote \pard\plain \sl240 \fs20 $ JacobiCS}

+{\footnote \pard\plain \sl240 \fs20 + g28:1098}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiCS operator;operator}

}{\b\f2 JACOBICS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Jacobics} {\f2  operator returns the Jacobi Elliptic function cs. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Jacobics} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Jacobics(0, 0.767)  \par
 \par
  infinity    \par
 \par
 \par
Jacobics(1.43, 0)  \par
 \par
  0.141734127352112  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiAMPLITUDE}

${\footnote \pard\plain \sl240 \fs20 $ JacobiAMPLITUDE}

+{\footnote \pard\plain \sl240 \fs20 + g28:1099}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiAMPLITUDE operator;operator}

}{\b\f2 JACOBIAMPLITUDE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 JacobiAmplitude} {\f2  operator returns the amplitude of u. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 JacobiAmplitude} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
JacobiAmplitude(7.239, 0.427)  \par
 \par
  0.0520978301448978  \par
 \par
 \par
JacobiAmplitude(0,0.1)  \par
 \par
  0  \par
 \par
\pard \sl240 }{\f2 Amplitude u = asin(}{\f3 Jacobisn(u,m)} {\f2 ) 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # AGM_FUNCTION}

${\footnote \pard\plain \sl240 \fs20 $ AGM_FUNCTION}

+{\footnote \pard\plain \sl240 \fs20 + g28:1100}

 K{\footnote \pard\plain \sl240 \fs20 K AGM_FUNCTION operator;operator}

}{\b\f2 AGM_FUNCTION}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 AGM_function} {\f2  operator returns a list of (N, AGM, 
 list of aNtoa0, list of bNtob0, list of cNtoc0) where a0, b0 and c0 
are the initial values; N is the index number of the last term 
used to generate the AGM. AGM is the Arithmetic Geometric Mean. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 AGM_function} {\f4 (<integer>,<integer>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
AGM_function(1,1,1)  \par
 \par
  1,1,1,1,1,1,0,1   \par
 \par
 \par
AGM_function(1, 0.1, 1.3)  \par
 \par
  \{6, \par
   2.27985615996629,  \par
   \{2.27985615996629, 2.27985615996629, \par
    2.2798561599706, 2.2798624278857,  \par
    2.28742283656583, 2.55, 1\}, \par
   \{2.27985615996629, 2.27985615996629, \par
    2.27985615996198, 2.2798498920555,  \par
    2.27230201920557, 2.02484567313166, 4.1\}, \par
   \{0, 4.30803136219904e-12, 0.0000062679151007581, \par
    0.00756040868012758, 0.262577163434171, - 1.55, 5.9\}\} \par
 \par
\pard \sl240 }{\f2 The other Jacobi functions use this function with initial values 
a0=1, b0=sqrt(1-m), c0=sqrt(m). 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LANDENTRANS}

${\footnote \pard\plain \sl240 \fs20 $ LANDENTRANS}

+{\footnote \pard\plain \sl240 \fs20 + g28:1101}

 K{\footnote \pard\plain \sl240 \fs20 K LANDENTRANS operator;operator}

}{\b\f2 LANDENTRANS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 landentrans} {\f2  operator generates the descending landen 
transformation of the given imput values, returning a list of these 
values; initial to final in each case. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 landentrans} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
landentrans(0,0.1)  \par
 \par
  \{\{0,0,0,0,0\},\{0.1,0.0025041751943776,  \par
 \par
 \par
  \par
 \par
  0.00000156772498954046,6.1444078 9914461e-13,0\}\}   \par
 \par
\pard \sl240 }{\f2 The first list ascends in value, and the second descends in value. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EllipticF}

${\footnote \pard\plain \sl240 \fs20 $ EllipticF}

+{\footnote \pard\plain \sl240 \fs20 + g28:1102}

 K{\footnote \pard\plain \sl240 \fs20 K EllipticF operator;operator}

}{\b\f2 ELLIPTICF}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 EllipticF} {\f2  operator returns the Elliptic Integral of the 
First Kind. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 EllitpicF} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
EllipticF(0.3, 8.222)  \par
 \par
  0.3  \par
 \par
 \par
EllipticF(7.396, 0.1)  \par
 \par
  7.58123216114307  \par
 \par
\pard \sl240 }{\f2 The Complete Elliptic Integral of the First Kind can be found by 
putting the first argument to pi/2 or by using }{\f3 EllipticK} {\f2  
and the second argument. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EllipticK}

${\footnote \pard\plain \sl240 \fs20 $ EllipticK}

+{\footnote \pard\plain \sl240 \fs20 + g28:1103}

 K{\footnote \pard\plain \sl240 \fs20 K EllipticK operator;operator}

}{\b\f2 ELLIPTICK}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 EllipticK} {\f2  operator returns the Elliptic value K. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 EllipticK} {\f4 (<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
EllipticK(0.2)  \par
 \par
  1.65962359861053    \par
 \par
 \par
EllipticK(4.3)  \par
 \par
  0.808442364282734 - 1.05562492399206*i   \par
 \par
 \par
EllipticK(0.000481)  \par
 \par
  1.57098526617635     \par
 \par
\pard \sl240 }{\f2 The }{\f3 EllipticK} {\f2  function is the Complete Elliptic Integral of 
the First Kind. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EllipticKprime}

${\footnote \pard\plain \sl240 \fs20 $ EllipticKprime}

+{\footnote \pard\plain \sl240 \fs20 + g28:1104}

 K{\footnote \pard\plain \sl240 \fs20 K EllipticKprime operator;operator}

}{\b\f2 ELLIPTICKPRIME}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 EllipticK'} {\f2  operator returns the Elliptic value K(m). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 EllipticKprime} {\f4 (<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
EllipticKprime(0.2)  \par
 \par
  2.25720532682085  \par
 \par
 \par
EllipticKprime(4.3)  \par
 \par
  1.05562492399206  \par
 \par
 \par
EllipticKprime(0.000481)  \par
 \par
  5.206621921966    \par
 \par
\pard \sl240 }{\f2 The }{\f3 EllipticKprime} {\f2  function is the Complete Elliptic Integral of 
the First Kind of (1-m). 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EllipticE}

${\footnote \pard\plain \sl240 \fs20 $ EllipticE}

+{\footnote \pard\plain \sl240 \fs20 + g28:1105}

 K{\footnote \pard\plain \sl240 \fs20 K EllipticE operator;operator}

}{\b\f2 ELLIPTICE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 EllipticE} {\f2  operator used with two arguments 
returns the Elliptic Integral of the Second Kind. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 EllipticE} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
EllipticE(1.2,0.22)  \par
 \par
  1.15094019180949  \par
 \par
 \par
EllipticE(0,4.35)  \par
 \par
  0                 \par
 \par
 \par
EllipticE(9,0.00719)  \par
 \par
  8.98312465929145   \par
 \par
\pard \sl240 }{\f2 The Complete Elliptic Integral of the Second Kind can be obtained by 
using just the second argument, or by using pi/2 as the first argument. 
\par 
\par 
\par 
The }{\f3 EllipticE} {\f2  operator used with one argument 
returns the Elliptic value E. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 EllipticE} {\f4 (<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
EllipticE(0.22)  \par
 \par
  1.48046637439519   \par
 \par
 \par
EllipticE(pi/2, 0.22)  \par
 \par
  1.48046637439519   \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # EllipticTHETA}

${\footnote \pard\plain \sl240 \fs20 $ EllipticTHETA}

+{\footnote \pard\plain \sl240 \fs20 + g28:1106}

 K{\footnote \pard\plain \sl240 \fs20 K EllipticTHETA operator;operator}

}{\b\f2 ELLIPTICTHETA}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 EllipticTheta} {\f2  operator returns one of the four Theta 
functions. It cannot except any number other than 1,2,3 or 4 as 
its first argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 EllipticTheta} {\f4 (<integer>,<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
EllipticTheta(1, 1.4, 0.72)  \par
 \par
  0.91634775373   \par
 \par
 \par
EllipticTheta(2, 3.9, 6.1 )  \par
 \par
  -48.0202736969 + 20.9881034377 i  \par
 \par
 \par
EllipticTheta(3, 0.67, 0.2)  \par
 \par
  1.0083077448    \par
 \par
 \par
EllipticTheta(4, 8, 0.75)  \par
 \par
  0.894963369304  \par
 \par
 \par
EllipticTheta(5, 1, 0.1)  \par
 \par
  ***** In EllipticTheta(a,u,m); a = 1,2,3 or 4.    \par
 \par
\pard \sl240 }{\f2 Theta functions are important because every one of the Jacobian 
Elliptic functions can be expressed as the ratio of two theta functions. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiZETA}

${\footnote \pard\plain \sl240 \fs20 $ JacobiZETA}

+{\footnote \pard\plain \sl240 \fs20 + g28:1107}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiZETA operator;operator}

}{\b\f2 JACOBIZETA}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 JacobiZeta} {\f2  operator returns the Jacobian function Zeta. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 JacobiZeta} {\f4 (<expression>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
JacobiZeta(3.2, 0.8)  \par
 \par
  - 0.254536403439  \par
 \par
 \par
JacobiZeta(0.2, 1.6)  \par
 \par
  0.171766095970451 - 0.0717028569800147*i   \par
 \par
\pard \sl240 }{\f2 The Jacobian function Zeta is related to the Jacobian function Theta. 
But it is significantly different from Riemann's Zeta Function }
{\f2\uldb Zeta}{\v\f2 ZETA} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g28}

${\footnote \pard\plain \sl240 \fs20 $ Jacobi's Elliptic Functions and Elliptic Integrals}

+{\footnote \pard\plain \sl240 \fs20 + index:0028}
}{\b\f2 Jacobi's Elliptic Functions and Elliptic Integrals}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb JacobiSN operator}
{\v\f2 JacobiSN}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiCN operator}
{\v\f2 JacobiCN}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiDN operator}
{\v\f2 JacobiDN}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiCD operator}
{\v\f2 JacobiCD}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiSD operator}
{\v\f2 JacobiSD}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiND operator}
{\v\f2 JacobiND}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiDC operator}
{\v\f2 JacobiDC}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiNC operator}
{\v\f2 JacobiNC}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiSC operator}
{\v\f2 JacobiSC}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiNS operator}
{\v\f2 JacobiNS}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiDS operator}
{\v\f2 JacobiDS}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiCS operator}
{\v\f2 JacobiCS}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiAMPLITUDE operator}
{\v\f2 JacobiAMPLITUDE}{\f2 \par 
}{\f2 \tab}{\f2\uldb AGM_FUNCTION operator}
{\v\f2 AGM_FUNCTION}{\f2 \par 
}{\f2 \tab}{\f2\uldb LANDENTRANS operator}
{\v\f2 LANDENTRANS}{\f2 \par 
}{\f2 \tab}{\f2\uldb EllipticF operator}
{\v\f2 EllipticF}{\f2 \par 
}{\f2 \tab}{\f2\uldb EllipticK operator}
{\v\f2 EllipticK}{\f2 \par 
}{\f2 \tab}{\f2\uldb EllipticKprime operator}
{\v\f2 EllipticKprime}{\f2 \par 
}{\f2 \tab}{\f2\uldb EllipticE operator}
{\v\f2 EllipticE}{\f2 \par 
}{\f2 \tab}{\f2\uldb EllipticTHETA operator}
{\v\f2 EllipticTHETA}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiZETA operator}
{\v\f2 JacobiZETA}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # POCHHAMMER}

${\footnote \pard\plain \sl240 \fs20 $ POCHHAMMER}

+{\footnote \pard\plain \sl240 \fs20 + g29:1108}

 K{\footnote \pard\plain \sl240 \fs20 K POCHHAMMER operator;operator}

}{\b\f2 POCHHAMMER}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
The }{\f3 Pochhammer} {\f2  operator implements the Pochhammer notation 
(shifted factorial). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Pochhammer} {\f4 (<expression>,<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
pochhammer(17,4);  \par
 \par
  116280  \par
 \par
 \par
 \par
pochhammer(1/2,z);  \par
 \par
    factorial(2*z) \par
  -------------------- \par
    2*z \par
  (2   *factorial(z)) \par
 \par
\pard \sl240 }{\f2 A number of complex rules for }{\f3 Pochhammer} {\f2  are inactive, because they 
cause a huge system load in algebraic mode. If one wants to use more rules 
for the simplification of Pochhammer's notation, one can do: 
\par 
\par 
let special!*pochhammer!*rules; 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # GAMMA}

${\footnote \pard\plain \sl240 \fs20 $ GAMMA}

+{\footnote \pard\plain \sl240 \fs20 + g29:1109}

 K{\footnote \pard\plain \sl240 \fs20 K GAMMA operator;operator}

}{\b\f2 GAMMA}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Gamma} {\f2  operator returns the Gamma function. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Gamma} {\f4 (<expression>) 
\par 
\par 
\par 
\par 
}{\f2  \par
examples: \par
\pard \tx3420 }{\f4  \par
gamma(10);  \par
 \par
  362880     \par
 \par
 \par
gamma(1/2);  \par
 \par
  sqrt(pi) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # BETA}

${\footnote \pard\plain \sl240 \fs20 $ BETA}

+{\footnote \pard\plain \sl240 \fs20 + g29:1110}

 K{\footnote \pard\plain \sl240 \fs20 K BETA operator;operator}

}{\b\f2 BETA}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Beta} {\f2  operator returns the Beta function defined by 
\par 
\par 
Beta (z,w) := defint(t**(z-1)* (1 - t)**(w-1),t,0,1) . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Beta} {\f4 (<expression>,<expression>) 
\par 
\par 
\par 
\par 
}{\f2  \par
examples: \par
\pard \tx3420 }{\f4  \par
Beta(2,2);  \par
 \par
  1 / 6  \par
 \par
 \par
Beta(x,y);  \par
 \par
  gamma(x)*gamma(y) / gamma(x + y) \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 Beta} {\f2  is simplified towards the }
{\f2\uldb GAMMA}{\v\f2 GAMMA} 
{\f2  operator. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PSI}

${\footnote \pard\plain \sl240 \fs20 $ PSI}

+{\footnote \pard\plain \sl240 \fs20 + g29:1111}

 K{\footnote \pard\plain \sl240 \fs20 K Euler's constant;PSI operator;operator}

}{\b\f2 PSI}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 Psi} {\f2  operator returns the Psi (or DiGamma) function. 
\par 
\par 
Psi(x) := df(Gamma(z),z)/ Gamma (z) 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Gamma} {\f4 (<expression>) 
\par 
\par 
\par 
\par 
}{\f2  \par
examples: \par
\pard \tx3420 }{\f4  \par
Psi(3);  \par
 \par
  (2*log(2) + psi(1/2) + psi(1) + 3)/2  \par
 \par
 \par
on rounded;  \par
 \par
- Psi(1);  \par
 \par
  0.577215664902 \par
 \par
\pard \sl240 }{\f2 Euler's constant can be found as - Psi(1). 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # POLYGAMMA}

${\footnote \pard\plain \sl240 \fs20 $ POLYGAMMA}

+{\footnote \pard\plain \sl240 \fs20 + g29:1112}

 K{\footnote \pard\plain \sl240 \fs20 K POLYGAMMA operator;operator}

}{\b\f2 POLYGAMMA}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Polygamma} {\f2  operator returns the Polygamma function. 
\par 
\par 
Polygamma(n,x) := df(Psi(z),z,n); 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Polygamma} {\f4 (<integer>,<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 Polygamma(1,2);  \par
 \par
     2 \par
  (pi   - 6) / 6 \par
 \par
 \par
on rounded;  \par
 \par
Polygamma(1,2.35);  \par
 \par
  0.52849689109 \par
 \par
\pard \sl240 }{\f2 The Polygamma function is used for simplification of the }
{\f2\uldb ZETA}{\v\f2 ZETA} 
{\f2  
function for some arguments. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g29}

${\footnote \pard\plain \sl240 \fs20 $ Gamma and Related Functions}

+{\footnote \pard\plain \sl240 \fs20 + index:0029}
}{\b\f2 Gamma and Related Functions}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb POCHHAMMER operator}
{\v\f2 POCHHAMMER}{\f2 \par 
}{\f2 \tab}{\f2\uldb GAMMA operator}
{\v\f2 GAMMA}{\f2 \par 
}{\f2 \tab}{\f2\uldb BETA operator}
{\v\f2 BETA}{\f2 \par 
}{\f2 \tab}{\f2\uldb PSI operator}
{\v\f2 PSI}{\f2 \par 
}{\f2 \tab}{\f2\uldb POLYGAMMA operator}
{\v\f2 POLYGAMMA}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DILOG_extended}

${\footnote \pard\plain \sl240 \fs20 $ DILOG_extended}

+{\footnote \pard\plain \sl240 \fs20 + g30:1113}

 K{\footnote \pard\plain \sl240 \fs20 K dilogarithm function;Spence's Integral;DILOG extended operator;operator}

}{\b\f2 DILOG EXTENDED}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The package }{\f3 specfn} {\f2  supplies an extended support for the 
}
{\f2\uldb dilog}{\v\f2 DILOG} 
{\f2  operator which implements the }{\f3 dilogarithm function} {\f2 . 
\par 
\par 
dilog(x) := - defint(log(t)/(t - 1),t,1,x); 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Dilog} {\f4 (<order>,<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
defint(log(t)/(t - 1),t,1,x);  \par
 \par
  - dilog (x)  \par
 \par
 \par
dilog 2;  \par
 \par
      2 \par
  - pi  /12  \par
 \par
 \par
 \par
on rounded;  \par
 \par
Dilog 20;  \par
 \par
  - 5.92783972438 \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 Dilog} {\f2  is sometimes called Spence's Integral for n = 2. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Lambert\_W_function}

${\footnote \pard\plain \sl240 \fs20 $ Lambert_W_function}

+{\footnote \pard\plain \sl240 \fs20 + g30:1114}

 K{\footnote \pard\plain \sl240 \fs20 K Lambert_W function operator;operator}

}{\b\f2 LAMBERT\_W FUNCTION}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
Lambert's W function is the inverse of the function w * e**w. 
It is used in the }
{\f2\uldb solve}{\v\f2 SOLVE} 
{\f2  package for equations containing 
exponentials and logarithms. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Lambert_W} {\f4 (<z>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Lambert_W(-1/e);  \par
 \par
  -1  \par
 \par
 \par
solve(w + log(w),w);  \par
 \par
  w=lambert_w(1) \par
 \par
 \par
on rounded;  \par
 \par
Lambert_W(-0.05);  \par
 \par
  - 0.0527059835515 \par
 \par
\pard \sl240 }{\f2 The current implementation will compute the principal branch in 
rounded mode only. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g30}

${\footnote \pard\plain \sl240 \fs20 $ Miscellaneous Functions}

+{\footnote \pard\plain \sl240 \fs20 + index:0030}
}{\b\f2 Miscellaneous Functions}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb DILOG extended operator}
{\v\f2 DILOG_extended}{\f2 \par 
}{\f2 \tab}{\f2\uldb Lambert\_W function operator}
{\v\f2 Lambert\_W_function}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ChebyshevT}

${\footnote \pard\plain \sl240 \fs20 $ ChebyshevT}

+{\footnote \pard\plain \sl240 \fs20 + g31:1115}

 K{\footnote \pard\plain \sl240 \fs20 K ChebyshevT operator;operator}

}{\b\f2 CHEBYSHEVT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 ChebyshevT} {\f2  operator computes the nth Chebyshev T Polynomial (of the 
first kind). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 ChebyshevT} {\f4 (<integer>,<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
ChebyshevT(3,xx);  \par
 \par
          2 \par
  xx*(4*xx   - 3)  \par
 \par
 \par
 \par
ChebyshevT(3,4);  \par
 \par
  244 \par
 \par
\pard \sl240 }{\f2 Chebyshev's T polynomials are computed using the recurrence relation: 
\par 
\par 
ChebyshevT(n,x) := 2x*ChebyshevT(n-1,x) - ChebyshevT(n-2,x) with 
\par 
\par 
ChebyshevT(0,x) := 0 and ChebyshevT(1,x) := x 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ChebyshevU}

${\footnote \pard\plain \sl240 \fs20 $ ChebyshevU}

+{\footnote \pard\plain \sl240 \fs20 + g31:1116}

 K{\footnote \pard\plain \sl240 \fs20 K ChebyshevU operator;operator}

}{\b\f2 CHEBYSHEVU}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 ChebyshevU} {\f2  operator returns the nth Chebyshev U Polynomial (of the 
second kind). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 ChebyshevU} {\f4 (<integer>,<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
ChebyshevU(3,xx);  \par
 \par
          2 \par
  4*x*(2*x   - 1)  \par
 \par
 \par
 \par
ChebyshevU(3,4);  \par
 \par
  496 \par
 \par
\pard \sl240 }{\f2 Chebyshev's U polynomials are computed using the recurrence relation: 
\par 
\par 
ChebyshevU(n,x) := 2x*ChebyshevU(n-1,x) - ChebyshevU(n-2,x) with 
\par 
\par 
ChebyshevU(0,x) := 0 and ChebyshevU(1,x) := 2x 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # HermiteP}

${\footnote \pard\plain \sl240 \fs20 $ HermiteP}

+{\footnote \pard\plain \sl240 \fs20 + g31:1117}

 K{\footnote \pard\plain \sl240 \fs20 K HermiteP operator;operator}

}{\b\f2 HERMITEP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 HermiteP} {\f2  operator returns the nth Hermite Polynomial. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 HermiteP} {\f4 (<integer>,<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
HermiteP(3,xx);  \par
 \par
            2 \par
  4*xx*(2*xx   - 3)  \par
 \par
 \par
HermiteP(3,4);  \par
 \par
  464 \par
 \par
\pard \sl240 }{\f2 Hermite polynomials are computed using the recurrence relation: 
 \par 
\par 
HermiteP(n,x) := 2x*HermiteP(n-1,x) - 2*(n-1)*HermiteP(n-2,x) with 
\par 
\par 
HermiteP(0,x) := 1 and HermiteP(1,x) := 2x 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LaguerreP}

${\footnote \pard\plain \sl240 \fs20 $ LaguerreP}

+{\footnote \pard\plain \sl240 \fs20 + g31:1118}

 K{\footnote \pard\plain \sl240 \fs20 K LaguerreP operator;operator}

}{\b\f2 LAGUERREP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 LaguerreP} {\f2  operator computes the nth Laguerre Polynomial. 
The two argument call of LaguerreP is a (common) abbreviation of 
LaguerreP(n,0,x). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 LaguerreP} {\f4 (<integer>,<expression>) or 
\par 
\par 
}{\f3 LaguerreP} {\f4 (<integer>,<expression>,<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
LaguerreP(3,xx);  \par
 \par
       3        2 \par
  (- xx   + 9*xx   - 18*xx + 6)/6 \par
 \par
 \par
 \par
LaguerreP(2,3,4);  \par
 \par
  -2 \par
 \par
\pard \sl240 }{\f2 Laguerre polynomials are computed using the recurrence relation: 
\par 
\par 
LaguerreP(n,a,x) := (2n+a-1-x)/n*LaguerreP(n-1,a,x) - 
 (n+a-1) * LaguerreP(n-2,a,x) with 
\par 
\par 
LaguerreP(0,a,x) := 1 and LaguerreP(2,a,x) := -x+1+a 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LegendreP}

${\footnote \pard\plain \sl240 \fs20 $ LegendreP}

+{\footnote \pard\plain \sl240 \fs20 + g31:1119}

 K{\footnote \pard\plain \sl240 \fs20 K LegendreP operator;operator}

}{\b\f2 LEGENDREP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The binary }{\f3 LegendreP} {\f2  operator computes the nth Legendre 
Polynomial which is 
a special case of the nth Jacobi Polynomial with 
\par 
\par 
LegendreP(n,x) := JacobiP(n,0,0,x) 
\par 
\par 
The ternary form returns the associated Legendre Polynomial (see below). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 LegendreP} {\f4 (<integer>,<expression>) or 
\par 
\par 
}{\f3 LegendreP} {\f4 (<integer>,<expression>,<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
LegendreP(3,xx);  \par
 \par
          2 \par
  xx*(5*xx   - 3) \par
  ---------------- \par
         2 \par
 \par
 \par
 \par
LegendreP(3,2,xx);  \par
 \par
              2 \par
  15*xx*( - xx   + 1) \par
 \par
\pard \sl240 }{\f2 The ternary form of the operator }{\f3 LegendreP} {\f2  is the associated 
Legendre Polynomial defined as 
 \par 
\par 
P(n,m,x) = (-1)**m * (1-x**2)**(m/2) * df(LegendreP(n,x),x,m) 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # JacobiP}

${\footnote \pard\plain \sl240 \fs20 $ JacobiP}

+{\footnote \pard\plain \sl240 \fs20 + g31:1120}

 K{\footnote \pard\plain \sl240 \fs20 K JacobiP operator;operator}

}{\b\f2 JACOBIP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 JacobiP} {\f2  operator computes the nth Jacobi Polynomial. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 JacobiP} {\f4 (<integer>,<expression>,<expression>, 
 <expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
JacobiP(3,4,5,xx);  \par
 \par
          3         2 \par
  7*(65*xx   - 13*xx   - 13*xx + 1) \par
  ---------------------------------- \par
                  8 \par
 \par
 \par
 \par
JacobiP(3,4,5,6);  \par
 \par
  94465/8 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # GegenbauerP}

${\footnote \pard\plain \sl240 \fs20 $ GegenbauerP}

+{\footnote \pard\plain \sl240 \fs20 + g31:1121}

 K{\footnote \pard\plain \sl240 \fs20 K ultraspherical polynomials;GegenbauerP operator;operator}

}{\b\f2 GEGENBAUERP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 GegenbauerP} {\f2  operator computes Gegenbauer's (ultraspherical) 
polynomials. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 GegenbauerP} {\f4 (<integer>,<expression>,<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
GegenbauerP(3,2,xx);  \par
 \par
            2 \par
  4*xx*(8*xx   - 3) \par
 \par
 \par
 \par
GegenbauerP(3,2,4);  \par
 \par
  2000 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # SolidHarmonicY}

${\footnote \pard\plain \sl240 \fs20 $ SolidHarmonicY}

+{\footnote \pard\plain \sl240 \fs20 + g31:1122}

 K{\footnote \pard\plain \sl240 \fs20 K Solid harmonic polynomials;SolidHarmonicY operator;operator}

}{\b\f2 SOLIDHARMONICY}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 SolidHarmonicY} {\f2  operator computes Solid harmonic (Laplace) 
polynomials. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 SolidHarmonicY} {\f4 (<integer>,<integer>, 
<expression>,<expression>,<expression>,<expression>) 
\par 
\par 
\par 
\par 
}{\f2  \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
SolidHarmonicY(3,-2,x,y,z,r2);  \par
 \par
                           2    2 \par
  sqrt(105)*z*(-2*i*x*y + x  - y ) \par
  --------------------------------- \par
         4*sqrt(pi)*sqrt(2) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # SphericalHarmonicY}

${\footnote \pard\plain \sl240 \fs20 $ SphericalHarmonicY}

+{\footnote \pard\plain \sl240 \fs20 + g31:1123}

 K{\footnote \pard\plain \sl240 \fs20 K Spherical harmonic polynomials;SphericalHarmonicY operator;operator}

}{\b\f2 SPHERICALHARMONICY}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 SphericalHarmonicY} {\f2  operator computes Spherical harmonic (Laplace) 
polynomials. These are special cases of the 
solid harmonic polynomials, }
{\f2\uldb SolidHarmonicY}{\v\f2 SolidHarmonicY} 
{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 SphericalHarmonicY} {\f4 (<integer>,<integer>, 
<expression>,<expression>) 
\par 
\par 
\par 
\par 
}{\f2  \par
examples: \par
\pard \tx3420 }{\f4  \par
SphericalHarmonicY(3,2,theta,phi);  \par
 \par
 \par
                                 2          2                               2 \par
  sqrt(105)*cos(theta)*sin(theta) *(cos(phi) +2*cos(phi)*sin(phi)*i-sin(phi) ) \par
  ----------------------------------------------------------------------------- \par
                               4*sqrt(pi)*sqrt(2) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # g31}

${\footnote \pard\plain \sl240 \fs20 $ Orthogonal Polynomials}

+{\footnote \pard\plain \sl240 \fs20 + index:0031}
}{\b\f2 Orthogonal Polynomials}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb ChebyshevT operator}
{\v\f2 ChebyshevT}{\f2 \par 
}{\f2 \tab}{\f2\uldb ChebyshevU operator}
{\v\f2 ChebyshevU}{\f2 \par 
}{\f2 \tab}{\f2\uldb HermiteP operator}
{\v\f2 HermiteP}{\f2 \par 
}{\f2 \tab}{\f2\uldb LaguerreP operator}
{\v\f2 LaguerreP}{\f2 \par 
}{\f2 \tab}{\f2\uldb LegendreP operator}
{\v\f2 LegendreP}{\f2 \par 
}{\f2 \tab}{\f2\uldb JacobiP operator}
{\v\f2 JacobiP}{\f2 \par 
}{\f2 \tab}{\f2\uldb GegenbauerP operator}
{\v\f2 GegenbauerP}{\f2 \par 
}{\f2 \tab}{\f2\uldb SolidHarmonicY operator}
{\v\f2 SolidHarmonicY}{\f2 \par 
}{\f2 \tab}{\f2\uldb SphericalHarmonicY operator}
{\v\f2 SphericalHarmonicY}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Si}

${\footnote \pard\plain \sl240 \fs20 $ Si}

+{\footnote \pard\plain \sl240 \fs20 + g32:1124}

 K{\footnote \pard\plain \sl240 \fs20 K integral function;Sine integral function;Si operator;operator}

}{\b\f2 SI}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 Si} {\f2  operator returns the Sine Integral function. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Si} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
limit(Si(x),x,infinity);  \par
 \par
  pi / 2  \par
 \par
 \par
on rounded;  \par
 \par
Si(0.35);  \par
 \par
  0.347626790989 \par
 \par
\pard \sl240 }{\f2 The numeric values for the operator }{\f3 Si} {\f2  are computed via the 
power series representation, which limits the argument range. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Shi}

${\footnote \pard\plain \sl240 \fs20 $ Shi}

+{\footnote \pard\plain \sl240 \fs20 + g32:1125}

 K{\footnote \pard\plain \sl240 \fs20 K integral function;hyperbolic sine integral function;Shi operator;operator}

}{\b\f2 SHI}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 Shi} {\f2  operator returns the hyperbolic Sine Integral function. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Shi} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
df(shi(x),x);  \par
 \par
  sinh(x) / x  \par
 \par
 \par
on rounded;  \par
 \par
Shi(0.35);  \par
 \par
  0.352390716351 \par
 \par
\pard \sl240 }{\f2 The numeric values for the operator }{\f3 Shi} {\f2  are computed via the 
power series representation, which limits the argument range. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # s_i}

${\footnote \pard\plain \sl240 \fs20 $ s_i}

+{\footnote \pard\plain \sl240 \fs20 + g32:1126}

 K{\footnote \pard\plain \sl240 \fs20 K integral function;sine integral function;s_i operator;operator}

}{\b\f2 S_I}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 s_i} {\f2  operator returns the Sine Integral function si. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 s_i} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
s_i(xx);  \par
 \par
  (2*Si(xx) - pi) / 2  \par
 \par
 \par
df(s_i(x),x);  \par
 \par
  sin(x) / x \par
 \par
\pard \sl240 }{\f2 The operator name }{\f3 s_i} {\f2  is simplified towards }
{\f2\uldb SI}{\v\f2 Si} 
{\f2 . 
Since REDUCE is not case sensitive by default the name ``si'' can't be 
used. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Ci}

${\footnote \pard\plain \sl240 \fs20 $ Ci}

+{\footnote \pard\plain \sl240 \fs20 + g32:1127}

 K{\footnote \pard\plain \sl240 \fs20 K cosine integral function;Ci operator;operator}

}{\b\f2 CI}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 Ci} {\f2  operator returns the Cosine Integral function. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Ci} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
defint(cos(t)/t,t,x,infinity);  \par
 \par
  - ci (x)  \par
 \par
 \par
on rounded;  \par
 \par
Ci(0.35);  \par
 \par
  - 0.50307556932 \par
 \par
\pard \sl240 }{\f2 The numeric values for the operator }{\f3 Ci} {\f2  are computed via the 
power series representation, which limits the argument range. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Chi}

${\footnote \pard\plain \sl240 \fs20 $ Chi}

+{\footnote \pard\plain \sl240 \fs20 + g32:1128}

 K{\footnote \pard\plain \sl240 \fs20 K integral function;hyperbolic cosine integral function;Chi operator;operator}

}{\b\f2 CHI}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 Chi} {\f2  operator returns the Hyperbolic Cosine Integral function. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Chi} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
defint((cosh(t)-1)/t,t,0,x);  \par
 \par
  - log(x) + psi(1) + chi(x) \par
 \par
 \par
on rounded;  \par
 \par
Chi(0.35);  \par
 \par
  - 0.44182471827 \par
 \par
\pard \sl240 }{\f2 The numeric values for the operator }{\f3 Chi} {\f2  are computed via the 
power series representation, which limits the argument range. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ERF_extended}

${\footnote \pard\plain \sl240 \fs20 $ ERF_extended}

+{\footnote \pard\plain \sl240 \fs20 + g32:1129}

 K{\footnote \pard\plain \sl240 \fs20 K error function;ERF extended operator;operator}

}{\b\f2 ERF EXTENDED}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The special function package supplies an extended support for the 
}
{\f2\uldb erf}{\v\f2 ERF} 
{\f2  operator which implements the }{\f3 error function} {\f2  
\par 
\par 
defint(e**(-x**2),x,0,infinity) * 2/sqrt(pi) 
\par 
\par 
. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 erf} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
erf(-x);  \par
 \par
  - erf(x) \par
 \par
 \par
on rounded;  \par
 \par
erf(0.35);  \par
 \par
  0.379382053562 \par
 \par
\pard \sl240 }{\f2 The numeric values for the operator }{\f3 erf} {\f2  are computed via the 
power series representation, which limits the argument range. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # erfc}

${\footnote \pard\plain \sl240 \fs20 $ erfc}

+{\footnote \pard\plain \sl240 \fs20 + g32:1130}

 K{\footnote \pard\plain \sl240 \fs20 K complementary error function;error function;erfc operator;operator}

}{\b\f2 ERFC}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 erfc} {\f2  operator returns the complementary Error function 
\par 
\par 
1 - defint(e**(-x**2),x,0,infinity) * 2/sqrt(pi) 
\par 
\par 
. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 erfc} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
erfc(xx);  \par
 \par
  - erf(xx) + 1 \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 erfc} {\f2  is simplified towards the }
{\f2\uldb erf}{\v\f2 ERF} 
{\f2  operator. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Ei}

${\footnote \pard\plain \sl240 \fs20 $ Ei}

+{\footnote \pard\plain \sl240 \fs20 + g32:1131}

 K{\footnote \pard\plain \sl240 \fs20 K exponential integral function;Ei operator;operator}

}{\b\f2 EI}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 Ei} {\f2  operator returns the Exponential Integral function. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Ei} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
df(ei(x),x);  \par
 \par
   x \par
  e \par
  --- \par
  x \par
 \par
 \par
on rounded;  \par
 \par
Ei(0.35);  \par
 \par
  - 0.0894340019184 \par
 \par
\pard \sl240 }{\f2 The numeric values for the operator }{\f3 Ei} {\f2  are computed via the 
power series representation, which limits the argument range. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Fresnel_C}

${\footnote \pard\plain \sl240 \fs20 $ Fresnel_C}

+{\footnote \pard\plain \sl240 \fs20 + g32:1132}

 K{\footnote \pard\plain \sl240 \fs20 K Fresnel_C operator;operator}

}{\b\f2 FRESNEL_C}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Fresnel_C} {\f2  operator represents Fresnel's Cosine function. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Fresnel_C} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
int(cos(t^2*pi/2),t,0,x);  \par
 \par
  fresnel_c(x)  \par
 \par
 \par
on rounded;  \par
 \par
fresnel_c(2.1);  \par
 \par
  0.581564135061 \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 Fresnel_C} {\f2  has a limited numeric evaluation of 
large values of its argument. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Fresnel_S}

${\footnote \pard\plain \sl240 \fs20 $ Fresnel_S}

+{\footnote \pard\plain \sl240 \fs20 + g32:1133}

 K{\footnote \pard\plain \sl240 \fs20 K Fresnel_S operator;operator}

}{\b\f2 FRESNEL_S}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Fresnel_S} {\f2  operator represents Fresnel's Sine Integral function. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Fresnel_S} {\f4 (<expression>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
int(sin(t^2*pi/2),t,0,x);  \par
 \par
  fresnel_s(x)  \par
 \par
 \par
on rounded;  \par
 \par
fresnel_s(2.1);  \par
 \par
  0.374273359378 \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 Fresnel_S} {\f2  has a limited numeric evaluation of 
large values of its argument. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g32}

${\footnote \pard\plain \sl240 \fs20 $ Integral Functions}

+{\footnote \pard\plain \sl240 \fs20 + index:0032}
}{\b\f2 Integral Functions}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb Si operator}
{\v\f2 Si}{\f2 \par 
}{\f2 \tab}{\f2\uldb Shi operator}
{\v\f2 Shi}{\f2 \par 
}{\f2 \tab}{\f2\uldb s_i operator}
{\v\f2 s_i}{\f2 \par 
}{\f2 \tab}{\f2\uldb Ci operator}
{\v\f2 Ci}{\f2 \par 
}{\f2 \tab}{\f2\uldb Chi operator}
{\v\f2 Chi}{\f2 \par 
}{\f2 \tab}{\f2\uldb ERF extended operator}
{\v\f2 ERF_extended}{\f2 \par 
}{\f2 \tab}{\f2\uldb erfc operator}
{\v\f2 erfc}{\f2 \par 
}{\f2 \tab}{\f2\uldb Ei operator}
{\v\f2 Ei}{\f2 \par 
}{\f2 \tab}{\f2\uldb Fresnel_C operator}
{\v\f2 Fresnel_C}{\f2 \par 
}{\f2 \tab}{\f2\uldb Fresnel_S operator}
{\v\f2 Fresnel_S}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # BINOMIAL}

${\footnote \pard\plain \sl240 \fs20 $ BINOMIAL}

+{\footnote \pard\plain \sl240 \fs20 + g33:1134}

 K{\footnote \pard\plain \sl240 \fs20 K BINOMIAL operator;operator}

}{\b\f2 BINOMIAL}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Binomial} {\f2  operator returns the Binomial coefficient if both 
parameter are integer and expressions involving the Gamma function otherwise. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Binomial} {\f4 (<integer>,<integer>) 
\par 
\par 
\par 
\par 
}{\f2  \par
examples: \par
\pard \tx3420 }{\f4  \par
Binomial(49,6);  \par
 \par
  13983816  \par
 \par
 \par
 \par
Binomial(n,3);  \par
 \par
   gamma(n + 1) \par
  --------------- \par
  6*gamma(n - 2) \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 Binomial} {\f2  evaluates the Binomial coefficients from 
the explicit form and therefore it is not the best algorithm if you 
want to compute many binomial coefficients with big indices in which 
case a recursive algorithm is preferable. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # STIRLING1}

${\footnote \pard\plain \sl240 \fs20 $ STIRLING1}

+{\footnote \pard\plain \sl240 \fs20 + g33:1135}

 K{\footnote \pard\plain \sl240 \fs20 K STIRLING1 operator;operator}

}{\b\f2 STIRLING1}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Stirling1} {\f2  operator returns the Stirling Numbers S(n,m) of the first 
kind, i.e. the number of permutations of n symbols which have exactly m cycles 
(divided by (-1)**(n-m)). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Stirling1} {\f4 (<integer>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Stirling1 (17,4);  \par
 \par
  -87077748875904  \par
 \par
 \par
Stirling1 (n,n-1);  \par
 \par
  -gamma(n+1) \par
  ------------- \par
  2*gamma(n-1) \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 Stirling1} {\f2  evaluates the Stirling numbers of the 
first kind by rulesets for special cases or by a computing the closed 
form, which is a series involving the operators }
{\f2\uldb BINOMIAL}{\v\f2 BINOMIAL} 
{\f2  
and }
{\f2\uldb STIRLING2}{\v\f2 STIRLING2} 
{\f2 . 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # STIRLING2}

${\footnote \pard\plain \sl240 \fs20 $ STIRLING2}

+{\footnote \pard\plain \sl240 \fs20 + g33:1136}

 K{\footnote \pard\plain \sl240 \fs20 K STIRLING2 operator;operator}

}{\b\f2 STIRLING2}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Stirling1} {\f2  operator returns the Stirling Numbers S(n,m) of the 
second kind, i.e. the number of ways of partitioning a set of n elements 
into m non-empty subsets. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Stirling2} {\f4 (<integer>,<integer>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
Stirling2 (17,4);  \par
 \par
  694337290  \par
 \par
 \par
Stirling2 (n,n-1);  \par
 \par
   gamma(n+1) \par
  ------------- \par
  2*gamma(n-1) \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 Stirling2} {\f2  evaluates the Stirling numbers of the 
second kind by rulesets for special cases or by a computing the closed 
form. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g33}

${\footnote \pard\plain \sl240 \fs20 $ Combinatorial Operators}

+{\footnote \pard\plain \sl240 \fs20 + index:0033}
}{\b\f2 Combinatorial Operators}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb BINOMIAL operator}
{\v\f2 BINOMIAL}{\f2 \par 
}{\f2 \tab}{\f2\uldb STIRLING1 operator}
{\v\f2 STIRLING1}{\f2 \par 
}{\f2 \tab}{\f2\uldb STIRLING2 operator}
{\v\f2 STIRLING2}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ThreejSymbol}

${\footnote \pard\plain \sl240 \fs20 $ ThreejSymbol}

+{\footnote \pard\plain \sl240 \fs20 + g34:1137}

 K{\footnote \pard\plain \sl240 \fs20 K ThreejSymbol operator;operator}

}{\b\f2 THREEJSYMBOL}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 ThreejSymbol} {\f2  operator implements the 3j symbol. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 ThreejSymbol} {\f4 (<list of j1,m1>,<list of j2,m2>, 
<list of j3,m3>) 
\par 
\par 
\par 
\par 
}{\f2  \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
ThreejSymbol(\{j+1,m\},\{j+1,-m\},\{1,0\});  \par
 \par
 \par
        j \par
  ( - 1)  *(abs(j - m + 1) - abs(j + m + 1)) \par
  ------------------------------------------- \par
             3       2                    m \par
   2*sqrt(2*j   + 9*j   + 13*j + 6)*( - 1) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # Clebsch_Gordan}

${\footnote \pard\plain \sl240 \fs20 $ Clebsch_Gordan}

+{\footnote \pard\plain \sl240 \fs20 + g34:1138}

 K{\footnote \pard\plain \sl240 \fs20 K Clebsch_Gordan operator;operator}

}{\b\f2 CLEBSCH_GORDAN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 Clebsch_Gordan} {\f2  operator implements the Clebsch_Gordan 
coefficients. This is closely related to the }
{\f2\uldb Threejsymbol}{\v\f2 ThreejSymbol} 
{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Clebsch_Gordan} {\f4 (<list of j1,m1>,<list of j2,m2>, 
<list of j3,m3>) 
\par 
\par 
\par 
\par 
}{\f2  \par
examples: \par
\pard \tx3420 }{\f4  \par
 Clebsch_Gordan(\{2,0\},\{2,0\},\{2,0\});  \par
 \par
 \par
     -2 \par
  --------- \par
  sqrt(14) \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # SixjSymbol}

${\footnote \pard\plain \sl240 \fs20 $ SixjSymbol}

+{\footnote \pard\plain \sl240 \fs20 + g34:1139}

 K{\footnote \pard\plain \sl240 \fs20 K SixjSymbol operator;operator}

}{\b\f2 SIXJSYMBOL}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 SixjSymbol} {\f2  operator implements the 6j symbol. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 SixjSymbol} {\f4 (<list of j1,j2,j3>,<list of l1,l2,l3>) 
\par 
\par 
\par 
\par 
}{\f2  \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
SixjSymbol(\{7,6,3\},\{2,4,6\});  \par
 \par
       1 \par
  ------------- \par
  14*sqrt(858) \par
 \par
\pard \sl240 }{\f2 The operator }{\f3 SixjSymbol} {\f2  uses the }
{\f2\uldb ineq}{\v\f2 INEQ} 
{\f2  package in order 
to find minima and maxima for the summation index. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g34}

${\footnote \pard\plain \sl240 \fs20 $ 3j and 6j symbols}

+{\footnote \pard\plain \sl240 \fs20 + index:0034}
}{\b\f2 3j and  6j symbols}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb ThreejSymbol operator}
{\v\f2 ThreejSymbol}{\f2 \par 
}{\f2 \tab}{\f2\uldb Clebsch_Gordan operator}
{\v\f2 Clebsch_Gordan}{\f2 \par 
}{\f2 \tab}{\f2\uldb SixjSymbol operator}
{\v\f2 SixjSymbol}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # HYPERGEOMETRIC}

${\footnote \pard\plain \sl240 \fs20 $ HYPERGEOMETRIC}

+{\footnote \pard\plain \sl240 \fs20 + g35:1140}

 K{\footnote \pard\plain \sl240 \fs20 K generalized hypergeometric function;hypergeometric function;HYPERGEOMETRIC operator;operator}

}{\b\f2 HYPERGEOMETRIC}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
The }{\f3 Hypergeometric} {\f2  operator provides simplifications for the 
generalized hypergeometric functions. 
The }{\f3 Hypergeometric} {\f2  operator is included in the package specfn2. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 hypergeometric} {\f4 (<list of parameters>,<list of parameters>, 
 <argument>) 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
load specfn2; \par
 \par
hypergeometric (\{1/2,1\},\{3/2\},-x^2);  \par
 \par
 \par
  atan(x) \par
  -------- \par
     x \par
 \par
 \par
hypergeometric (\{\},\{\},z);  \par
 \par
   z \par
  e \par
 \par
\pard \sl240 }{\f2 The special case where the length of the first list is equal to 2 and 
the length of the second list is equal to 1 is often called 
``the hypergeometric function'' (notated as 2F1(a1,a2,b;x)). 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MeijerG}

${\footnote \pard\plain \sl240 \fs20 $ MeijerG}

+{\footnote \pard\plain \sl240 \fs20 + g35:1141}

 K{\footnote \pard\plain \sl240 \fs20 K MeijerG operator;operator}

}{\b\f2 MEIJERG}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The }{\f3 MeijerG} {\f2  operator provides simplifications for Meijer's G 
function. The simplifications are performed towards polynomials, 
elementary or 
special functions or (generalized) }
{\f2\uldb hypergeometric}{\v\f2 HYPERGEOMETRIC} 
{\f2  functions. 
\par 
\par 
The }{\f3 MeijerG} {\f2  operator is included in the package specfn2. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 MeijerG} {\f4 (<list of parameters>,<list of parameters>, 
 <argument>) 
\par 
\par 
}{\f2 \par 
The first element of the lists has to be the list containing the 
first group (mostly called ``m'' and ``n'') of parameters. This passes 
the four parameters of a Meijer's G function implicitly via the 
length of the lists. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
load specfn2; \par
 \par
MeijerG(\{\{\},1\},\{\{0\}\},x);  \par
 \par
  heaviside(-x+1) \par
 \par
 \par
MeijerG(\{\{\}\},\{\{1+1/4\},1-1/4\},(x^2)/4) * sqrt pi; \par
  \par
 \par
 \par
                  2 \par
  sqrt(2)*sin(x)*x \par
  ------------------ \par
      4*sqrt(x) \par
 \par
\pard \sl240 }{\f2 Many well-known functions can be written as G functions, 
e.g. exponentials, logarithms, trigonometric functions, Bessel functions 
and hypergeometric functions. 
The formulae can be found e.g. in 
\par 
\par 
A.P.Prudnikov, Yu.A.Brychkov, O.I.Marichev: 
Integrals and Series, Volume 3: More special functions, 
Gordon and Breach Science Publishers (1990). 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Heaviside}

${\footnote \pard\plain \sl240 \fs20 $ Heaviside}

+{\footnote \pard\plain \sl240 \fs20 + g35:1142}

 K{\footnote \pard\plain \sl240 \fs20 K Heaviside operator;operator}

}{\b\f2 HEAVISIDE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
The }{\f3 Heaviside} {\f2  operator returns the Heaviside function. 
\par 
\par 
Heaviside(~w) => if (w < 0) then 0 else 1 
\par 
\par 
when numberp w; 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 Heaviside} {\f4 (<argument>) 
\par 
\par 
}{\f2 \par 
This operator is often included in the result of the simplification 
of a generalized }
{\f2\uldb hypergeometric}{\v\f2 HYPERGEOMETRIC} 
{\f2  function or a 
}
{\f2\uldb MeijerG}{\v\f2 MeijerG} 
{\f2  function. 
\par 
\par 
No simplification is done for this function. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # erfi}

${\footnote \pard\plain \sl240 \fs20 $ erfi}

+{\footnote \pard\plain \sl240 \fs20 + g35:1143}

 K{\footnote \pard\plain \sl240 \fs20 K erfi operator;operator}

}{\b\f2 ERFI}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
The }{\f3 erfi} {\f2  operator returns the error function of an imaginary argument. 
\par 
\par 
erfi(~x) => 2/sqrt(pi) * defint(e**(t**2),t,0,x); 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 erfi} {\f4 (<argument>) 
\par 
\par 
}{\f2 \par 
This operator is sometimes included in the result of the simplification 
of a generalized }
{\f2\uldb hypergeometric}{\v\f2 HYPERGEOMETRIC} 
{\f2  function or a 
}
{\f2\uldb MeijerG}{\v\f2 MeijerG} 
{\f2  function. 
\par 
\par 
No simplification is done for this function. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g35}

${\footnote \pard\plain \sl240 \fs20 $ Miscellaneous}

+{\footnote \pard\plain \sl240 \fs20 + index:0035}
}{\b\f2 Miscellaneous}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb HYPERGEOMETRIC operator}
{\v\f2 HYPERGEOMETRIC}{\f2 \par 
}{\f2 \tab}{\f2\uldb MeijerG operator}
{\v\f2 MeijerG}{\f2 \par 
}{\f2 \tab}{\f2\uldb Heaviside operator}
{\v\f2 Heaviside}{\f2 \par 
}{\f2 \tab}{\f2\uldb erfi operator}
{\v\f2 erfi}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g24}

${\footnote \pard\plain \sl240 \fs20 $ Special Functions}

+{\footnote \pard\plain \sl240 \fs20 + index:0024}
}{\b\f2 Special Functions}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb Special Function Package introduction}
{\v\f2 Special_Function_Package}{\f2 \par 
}{\f2 \tab}{\f2\uldb Constants concept}
{\v\f2 Constants}{\f2 \par 
}{\f2 \tab}{\f2\uldb Bernoulli Euler Zeta}
{\v\f2 g25}{\f2 \par 
}{\f2 \tab}{\f2\uldb Bessel Functions}
{\v\f2 g26}{\f2 \par 
}{\f2 \tab}{\f2\uldb Airy Functions}
{\v\f2 g27}{\f2 \par 
}{\f2 \tab}{\f2\uldb Jacobi's Elliptic Functions and Elliptic Integrals}
{\v\f2 g28}{\f2 \par 
}{\f2 \tab}{\f2\uldb Gamma and Related Functions}
{\v\f2 g29}{\f2 \par 
}{\f2 \tab}{\f2\uldb Miscellaneous Functions}
{\v\f2 g30}{\f2 \par 
}{\f2 \tab}{\f2\uldb Orthogonal Polynomials}
{\v\f2 g31}{\f2 \par 
}{\f2 \tab}{\f2\uldb Integral Functions}
{\v\f2 g32}{\f2 \par 
}{\f2 \tab}{\f2\uldb Combinatorial Operators}
{\v\f2 g33}{\f2 \par 
}{\f2 \tab}{\f2\uldb 3j and  6j symbols}
{\v\f2 g34}{\f2 \par 
}{\f2 \tab}{\f2\uldb Miscellaneous}
{\v\f2 g35}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TAYLOR_introduction}

${\footnote \pard\plain \sl240 \fs20 $ TAYLOR_introduction}

+{\footnote \pard\plain \sl240 \fs20 + g36:1144}

 K{\footnote \pard\plain \sl240 \fs20 K TAYLOR introduction;introduction}

}{\b\f2 TAYLOR}{\f2 \tab \tab \tab \tab }{\b\f2 introduction}{\f2 \par 
\par 
 
This short note describes a package of REDUCE procedures that allow 
Taylor expansion in one or more variables and efficient manipulation 
of the resulting Taylor series. Capabilities include basic operations 
(addition, subtraction, multiplication and division) and also 
application of certain algebraic and transcendental functions. To a 
certain extent, Laurent expansion can be performed as well. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # taylor}

${\footnote \pard\plain \sl240 \fs20 $ taylor}

+{\footnote \pard\plain \sl240 \fs20 + g36:1145}

 K{\footnote \pard\plain \sl240 \fs20 K taylor operator;operator}

}{\b\f2 TAYLOR}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 The }{\f3 taylor} {\f2  operator is used for expanding an expression into a 
 Taylor series. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 taylor} {\f4 (<expression> 
 }{\f3 ,} {\f4 <var>}{\f3 ,} {\f4  
 <expression>}{\f3 ,} {\f4 <number> 
\par 
\par 
\{}{\f3 ,} {\f4 <var>}{\f3 ,} {\f4  
 <expression>}{\f3 ,} {\f4 <number>\}*) 
 \par 
\par 
}{\f2 \par 
<expression> can be any valid REDUCE algebraic expression. 
 <var> must be a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 , and is the expansion 
 variable. The <expression> following it denotes the point 
 about which the expansion is to take place. <number> must be a 
 non-negative integer and denotes the maximum expansion order. If 
 more than one triple is specified }{\f3 taylor} {\f2  will expand its 
 first argument independently with respect to all the variables. 
 Note that once the expansion has been done it is not possible to 
 calculate higher orders. 
\par 
\par 
Instead of a }
{\f2\uldb kernel}{\v\f2 KERNEL} 
{\f2 , <var> may also be a list of 
 kernels. In this case expansion will take place in a way so that 
 the sum/ of the degrees of the kernels does not exceed the 
 maximum expansion order. If the expansion point evaluates to the 
 special identifier }{\f3 infinity} {\f2 , }{\f3 taylor} {\f2  tries to expand in 
 a series in 1/<var>. 
\par 
\par 
The expansion is performed variable per variable, i.e. in the 
 example above by first expanding 
 exp(x^2+y^2) 
 with respect to 
 }{\f3 x} {\f2  and then expanding every coefficient with respect to }{\f3 y} {\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
    taylor(e^(x^2+y^2),x,0,2,y,0,2);  \par
 \par
 \par
       2    2    2  2      2  2 \par
  1 + Y  + X  + Y *X  + O(X ,Y )    \par
 \par
 \par
    taylor(e^(x^2+y^2),\{x,y\},0,2);  \par
 \par
 \par
       2    2       2  2 \par
  1 + Y  + X  + O(\{X ,Y \}) \par
 \par
\pard \sl240 }{\f2 The following example shows the case of a non-analytical function.}{\f4 \pard \tx3420  \par
 \par
    taylor(x*y/(x+y),x,0,2,y,0,2);  \par
 \par
 \par
  ***** Not a unit in argument to QUOTTAYLOR  \par
 \par
\pard \sl240 }{\f2  
\par 
\par 
Note that it is not generally possible to apply the standard 
 reduce operators to a Taylor kernel. For example, }
{\f2\uldb part}{\v\f2 PART} 
{\f2 , 
 }
{\f2\uldb coeff}{\v\f2 COEFF} 
{\f2 , or }
{\f2\uldb coeffn}{\v\f2 COEFFN} 
{\f2  cannot be used. Instead, the 
 expression at hand has to be converted to standard form first 
 using the }
{\f2\uldb taylortostandard}{\v\f2 taylortostandard} 
{\f2  operator. 
\par 
\par 
Differentiation of a Taylor expression is possible. If you 
 differentiate with respect to one of the Taylor variables the 
 order will decrease by one. 
\par 
\par 
Substitution is a bit restricted: Taylor variables can only be 
 replaced by other kernels. There is one exception to this rule: 
 you can always substitute a Taylor variable by an expression that 
 evaluates to a constant. Note that REDUCE will not always be able 
 to determine that an expression is constant: an example is 
 sin(acos(4)). 
\par 
\par 
Only simple taylor kernels can be integrated. More complicated 
 expressions that contain Taylor kernels as parts of themselves are 
 automatically converted into a standard representation by means of 
 the }
{\f2\uldb taylortostandard}{\v\f2 taylortostandard} 
{\f2  operator. In this case a suitable 
 warning is printed. 
\par 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # taylorautocombine}

${\footnote \pard\plain \sl240 \fs20 $ taylorautocombine}

+{\footnote \pard\plain \sl240 \fs20 + g36:1146}

 K{\footnote \pard\plain \sl240 \fs20 K taylorautocombine switch;switch}

}{\b\f2 TAYLORAUTOCOMBINE}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 If you set }{\f3 taylorautocombine} {\f2  to }{\f3 on} {\f2 , REDUCE 
 automatically combines Taylor expressions during the simplification 
 process. This is equivalent to applying }
{\f2\uldb taylorcombine}{\v\f2 taylorcombine} 
{\f2  to 
 every expression that contains Taylor kernels. Default is 
 }{\f3 on} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # taylorautoexpand}

${\footnote \pard\plain \sl240 \fs20 $ taylorautoexpand}

+{\footnote \pard\plain \sl240 \fs20 + g36:1147}

 K{\footnote \pard\plain \sl240 \fs20 K taylorautoexpand switch;switch}

}{\b\f2 TAYLORAUTOEXPAND}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 }{\f3 taylorautoexpand} {\f2  makes Taylor expressions ``contagious'' in 
 the sense that }
{\f2\uldb taylorcombine}{\v\f2 taylorcombine} 
{\f2  tries to Taylor expand all 
 non-Taylor subexpressions and to combine the result with the rest. 
 Default is }{\f3 off} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # taylorcombine}

${\footnote \pard\plain \sl240 \fs20 $ taylorcombine}

+{\footnote \pard\plain \sl240 \fs20 + g36:1148}

 K{\footnote \pard\plain \sl240 \fs20 K taylorcombine operator;operator}

}{\b\f2 TAYLORCOMBINE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 This operator tries to combine all Taylor kernels found in its 
 argument into one. Operations currently possible are: 
 \par 
\par 
\tab Addition, subtraction, multiplication, and division. 
 \par 
\tab Roots, exponentials, and logarithms. 
 \par 
\tab Trigonometric and hyperbolic functions and their inverses. 
 \par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
    hugo := taylor(exp(x),x,0,2);  \par
 \par
                  1  2      3 \par
  HUGO := 1 + X + -*X  + O(X ) \par
                  2 \par
 \par
 \par
    taylorcombine log hugo;  \par
 \par
         3 \par
  X + O(X ) \par
 \par
 \par
    taylorcombine(hugo + x);  \par
 \par
           1  2      3 \par
  (1 + X + -*X  + O(X )) + X \par
           2 \par
 \par
 \par
    on taylorautoexpand;  \par
 \par
    taylorcombine(hugo + x);  \par
 \par
            1  2      3 \par
  1 + 2*X + -*X  + O(X )   \par
            2 \par
 \par
\pard \sl240 }{\f2 Application of unary operators like }{\f3 log} {\f2  and }{\f3 atan} {\f2  
 will nearly always succeed. For binary operations their arguments 
 have to be Taylor kernels with the same template. This means that 
 the expansion variable and the expansion point must match. 
 Expansion order is not so important, different order usually means 
 that one of them is truncated before doing the operation. 
\par 
\par 
If }
{\f2\uldb taylorkeeporiginal}{\v\f2 taylorkeeporiginal} 
{\f2  is set to }{\f3 on} {\f2  and if all 
 Taylor kernels in its argument have their original expressions 
 kept }{\f3 taylorcombine} {\f2  will also combine these and store the 
 result as the original expression of the resulting Taylor kernel. 
 There is also the switch }
{\f2\uldb taylorautoexpand}{\v\f2 taylorautoexpand} 
{\f2 . 
\par 
\par 
There are a few restrictions to avoid mathematically undefined 
 expressions: it is not possible to take the logarithm of a Taylor 
 kernel which has no terms (i.e. is zero), or to divide by such a 
 beast. There are some provisions made to detect singularities 
 during expansion: poles that arise because the denominator has 
 zeros at the expansion point are detected and properly treated, 
 i.e. the Taylor kernel will start with a negative power. (This 
 is accomplished by expanding numerator and denominator separately 
 and combining the results.) Essential singularities of the known 
 functions (see above) are handled correctly. 
 \par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # taylorkeeporiginal}

${\footnote \pard\plain \sl240 \fs20 $ taylorkeeporiginal}

+{\footnote \pard\plain \sl240 \fs20 + g36:1149}

 K{\footnote \pard\plain \sl240 \fs20 K taylorkeeporiginal switch;switch}

}{\b\f2 TAYLORKEEPORIGINAL}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 }{\f3 taylorkeeporiginal} {\f2 , if set to }{\f3 on} {\f2 , forces the 
 }
{\f2\uldb taylor}{\v\f2 taylor} 
{\f2  and all Taylor kernel manipulation operators to 
 keep the original expression, i.e. the expression that was Taylor 
 expanded. All operations performed on the Taylor kernels are also 
 applied to this expression which can be recovered using the operator 
 }
{\f2\uldb taylororiginal}{\v\f2 taylororiginal} 
{\f2 . Default is }{\f3 off} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # taylororiginal}

${\footnote \pard\plain \sl240 \fs20 $ taylororiginal}

+{\footnote \pard\plain \sl240 \fs20 + g36:1150}

 K{\footnote \pard\plain \sl240 \fs20 K taylororiginal operator;operator}

}{\b\f2 TAYLORORIGINAL}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 Recovers the original expression (the one that was expanded) from 
 the Taylor kernel that is given as its argument. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 taylororiginal} {\f4 (<expression>) or 
 }{\f3 taylororiginal} {\f4  <simple_expression> 
 \par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
    hugo := taylor(exp(x),x,0,2);  \par
 \par
                  1  2      3 \par
  HUGO := 1 + X + -*X  + O(X ) \par
                  2 \par
 \par
 \par
    taylororiginal hugo;  \par
 \par
  ***** Taylor kernel doesn't have an original part in TAYLORORIGINAL \par
 \par
 \par
    on taylorkeeporiginal;  \par
 \par
    hugo := taylor(exp(x),x,0,2);  \par
 \par
                  1  2      3 \par
  HUGO := 1 + X + -*X  + O(X ) \par
                  2 \par
 \par
 \par
    taylororiginal hugo;  \par
 \par
   X \par
  E    \par
 \par
\pard \sl240 }{\f2 An error is signalled if the argument is not a Taylor kernel or if 
 the original expression was not kept, i.e. if 
 }
{\f2\uldb taylorkeeporiginal}{\v\f2 taylorkeeporiginal} 
{\f2  was set }{\f3 off} {\f2  during expansion. 
 \par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # taylorprintorder}

${\footnote \pard\plain \sl240 \fs20 $ taylorprintorder}

+{\footnote \pard\plain \sl240 \fs20 + g36:1151}

 K{\footnote \pard\plain \sl240 \fs20 K taylorprintorder switch;switch}

}{\b\f2 TAYLORPRINTORDER}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 }{\f3 taylorprintorder} {\f2 , if set to }{\f3 on} {\f2 , causes the remainder 
 to be printed in big-O notation. Otherwise, three dots are printed. 
 Default is }{\f3 on} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # taylorprintterms}

${\footnote \pard\plain \sl240 \fs20 $ taylorprintterms}

+{\footnote \pard\plain \sl240 \fs20 + g36:1152}

 K{\footnote \pard\plain \sl240 \fs20 K taylorprintterms variable;variable}

}{\b\f2 TAYLORPRINTTERMS}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 Only a certain number of (non-zero) coefficients are printed. If 
 there are more, an expression of the form }{\f3 n terms} {\f2  is printed 
 to indicate how many non-zero terms have been suppressed. The 
 number of terms printed is given by the value of the shared 
 algebraic variable }{\f3 taylorprintterms} {\f2 . Allowed values are 
 integers and the special identifier }{\f3 all} {\f2 . The latter setting 
 specifies that all terms are to be printed. The default setting is 
 5. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
    taylor(e^(x^2+y^2),x,0,4,y,0,4);  \par
 \par
 \par
       2   1  4    2    2  2                              5  5 \par
  1 + Y  + -*Y  + X  + Y *X  +             (4 terms) + O(X ,Y ) \par
           2 \par
 \par
 \par
    taylorprintterms := all;  \par
 \par
  TAYLORPRINTTERMS := ALL  \par
 \par
 \par
    taylor(e^(x^2+y^2),x,0,4,y,0,4);  \par
 \par
 \par
       2   1  4    2    2  2   1  4  2   1  4   1  2  4 \par
  1 + Y  + -*Y  + X  + Y *X  + -*Y *X  + -*X  + -*Y *X \par
           2                   2         2      2 \par
     1  4  4      5  5 \par
   + -*Y *X  + O(X ,Y ) \par
     4 \par
       \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # taylorrevert}

${\footnote \pard\plain \sl240 \fs20 $ taylorrevert}

+{\footnote \pard\plain \sl240 \fs20 + g36:1153}

 K{\footnote \pard\plain \sl240 \fs20 K taylorrevert operator;operator}

}{\b\f2 TAYLORREVERT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 }{\f3 taylorrevert} {\f2  allows reversion of a Taylor series of a 
 function f, i.e., to compute the first terms of the expansion of the 
 inverse of }{\f4 f}{\f2  from the expansion of }{\f4 f}{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 taylorrevert} {\f4 (<expression>}{\f3 ,} {\f4  
 <var>}{\f3 ,} {\f4 <var>) 
 \par 
\par 
}{\f2 \par 
The first argument must evaluate to a Taylor kernel with the second 
 argument being one of its expansion variables. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
    taylor(u - u**2,u,0,5);  \par
 \par
       2      6 \par
  U - U  + O(U )  \par
 \par
 \par
    taylorrevert (ws,u,x);  \par
 \par
       2      3      4       5      6 \par
  X + X  + 2*X  + 5*X  + 14*X  + O(X )   \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # taylorseriesp}

${\footnote \pard\plain \sl240 \fs20 $ taylorseriesp}

+{\footnote \pard\plain \sl240 \fs20 + g36:1154}

 K{\footnote \pard\plain \sl240 \fs20 K taylorseriesp operator;operator}

}{\b\f2 TAYLORSERIESP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 This operator may be used to determine if its argument is a Taylor 
 kernel. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 taylorseriesp} {\f4 (<expression>) or }{\f3 taylorseriesp} {\f4  
 <simple_expression> 
 \par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
    hugo := taylor(exp(x),x,0,2);  \par
 \par
                  1  2      3 \par
  HUGO := 1 + X + -*X  + O(X ) \par
                  2 \par
 \par
 \par
    if taylorseriesp hugo then OK; \par
 \par
  OK  \par
 \par
 \par
    if taylorseriesp(hugo + y) then OK else NO;  \par
 \par
 \par
  NO   \par
 \par
\pard \sl240 }{\f2 Note that this operator is subject to the same restrictions as, 
 e.g., }{\f3 ordp} {\f2  or }{\f3 numberp} {\f2 , i.e. it may only be used in 
 boolean expressions in }{\f3 if} {\f2  or }{\f3 let} {\f2  statements. 
 \par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # taylortemplate}

${\footnote \pard\plain \sl240 \fs20 $ taylortemplate}

+{\footnote \pard\plain \sl240 \fs20 + g36:1155}

 K{\footnote \pard\plain \sl240 \fs20 K taylortemplate operator;operator}

}{\b\f2 TAYLORTEMPLATE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 The template of a Taylor kernel, i.e. the list of all variables 
 with respect to which expansion took place together with expansion 
 point and order can be extracted using 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 taylortemplate} {\f4 (<expression>) or 
 }{\f3 taylortemplate} {\f4  <simple_expression> 
 \par 
\par 
}{\f2 \par 
This returns a list of lists with the three elements 
 (VAR,VAR0,ORDER). An error is signalled if the argument is not a 
 Taylor kernel. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
    hugo := taylor(exp(x),x,0,2);  \par
 \par
                  1  2      3 \par
  HUGO := 1 + X + -*X  + O(X ) \par
                  2 \par
 \par
 \par
    taylortemplate hugo;  \par
 \par
  \{\{X,0,2\}\}   \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # taylortostandard}

${\footnote \pard\plain \sl240 \fs20 $ taylortostandard}

+{\footnote \pard\plain \sl240 \fs20 + g36:1156}

 K{\footnote \pard\plain \sl240 \fs20 K taylortostandard operator;operator}

}{\b\f2 TAYLORTOSTANDARD}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 This operator converts all Taylor kernels in its argument into 
 standard form and resimplifies the result. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 taylortostandard} {\f4 (<expression>) or 
 }{\f3 taylortostandard} {\f4  <simple_expression> 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
    hugo := taylor(exp(x),x,0,2);  \par
 \par
                  1  2      3 \par
  HUGO := 1 + X + -*X  + O(X ) \par
                  2 \par
 \par
 \par
    taylortostandard hugo;  \par
 \par
   2 \par
  X  + 2*X + 2 \par
  ------------   \par
       2 \par
 \par
\pard \sl240 }{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g36}

${\footnote \pard\plain \sl240 \fs20 $ Taylor series}

+{\footnote \pard\plain \sl240 \fs20 + index:0036}
}{\b\f2 Taylor series}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb TAYLOR introduction}
{\v\f2 TAYLOR_introduction}{\f2 \par 
}{\f2 \tab}{\f2\uldb taylor operator}
{\v\f2 taylor}{\f2 \par 
}{\f2 \tab}{\f2\uldb taylorautocombine switch}
{\v\f2 taylorautocombine}{\f2 \par 
}{\f2 \tab}{\f2\uldb taylorautoexpand switch}
{\v\f2 taylorautoexpand}{\f2 \par 
}{\f2 \tab}{\f2\uldb taylorcombine operator}
{\v\f2 taylorcombine}{\f2 \par 
}{\f2 \tab}{\f2\uldb taylorkeeporiginal switch}
{\v\f2 taylorkeeporiginal}{\f2 \par 
}{\f2 \tab}{\f2\uldb taylororiginal operator}
{\v\f2 taylororiginal}{\f2 \par 
}{\f2 \tab}{\f2\uldb taylorprintorder switch}
{\v\f2 taylorprintorder}{\f2 \par 
}{\f2 \tab}{\f2\uldb taylorprintterms variable}
{\v\f2 taylorprintterms}{\f2 \par 
}{\f2 \tab}{\f2\uldb taylorrevert operator}
{\v\f2 taylorrevert}{\f2 \par 
}{\f2 \tab}{\f2\uldb taylorseriesp operator}
{\v\f2 taylorseriesp}{\f2 \par 
}{\f2 \tab}{\f2\uldb taylortemplate operator}
{\v\f2 taylortemplate}{\f2 \par 
}{\f2 \tab}{\f2\uldb taylortostandard operator}
{\v\f2 taylortostandard}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # GNUPLOT_and_REDUCE}

${\footnote \pard\plain \sl240 \fs20 $ GNUPLOT_and_REDUCE}

+{\footnote \pard\plain \sl240 \fs20 + g37:1157}

 K{\footnote \pard\plain \sl240 \fs20 K GNUPLOT and REDUCE introduction;introduction}

}{\b\f2 GNUPLOT AND REDUCE}{\f2 \tab \tab \tab \tab }{\b\f2 introduction}{\f2 \par 
\par 
 
\par 
\par 
The GNUPLOT system provides easy to use graphics output 
for curves or surfaces which are defined by 
formulas and/or data sets. GNUPLOT supports 
a great variety of output devices 
such as X-windows, VGA screen, postscript, picTeX. 
The REDUCE GNUPLOT package lets one use the GNUPLOT 
graphical output directly from inside REDUCE, either for 
the interactive display of curves/surfaces or for the production 
of pictures on paper. 
\par 
\par 
Note that this package may not be supported on all system 
platforms. 
\par 
\par 
For a detailed description you should read the GNUPLOT 
system documentation, available together with the GNUPLOT 
installation material from several servers by anonymous FTP. 
\par 
\par 
The REDUCE developers thank the GNUPLOT people for their permission 
to distribute GNUPLOT together with REDUCE. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Axes_names}

${\footnote \pard\plain \sl240 \fs20 $ Axes_names}

+{\footnote \pard\plain \sl240 \fs20 + g37:1158}

 K{\footnote \pard\plain \sl240 \fs20 K Axes names concept;concept}

}{\b\f2 AXES NAMES}{\f2 \par 
\par 
 
Inside REDUCE the choice of variable names for a graph is completely 
free. For referring to the GNUPLOT axes the names 
X and Y for 2 dimensions, X,Y and Z for 3 dimensions are used 
in the usual schoolbook sense independent from the variables of 
the REDUCE expression. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4 \pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # Pointset}

${\footnote \pard\plain \sl240 \fs20 $ Pointset}

+{\footnote \pard\plain \sl240 \fs20 + g37:1159}

 K{\footnote \pard\plain \sl240 \fs20 K plot;Pointset type;type}

}{\b\f2 POINTSET}{\f2 \tab \tab \tab \tab }{\b\f2 type}{\f2 \par 
\par 
 
 \par 
\par 
A curve can be give as a set of precomputed points (a polygon) 
in 2 or 3 dimensions. Such a point set is a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  
of points, where each point is a }
{\f2\uldb list}{\v\f2 LIST} 
{\f2  2 (or 3) 
numbers. These numbers are interpreted as }{\f3 (x,y)} {\f2  
(or }{\f3 x,y,z} {\f2 ) coordinates. All points of one set must have 
the same dimension. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4 \pard \sl240 }{\f2 Also a surface in 3d can be given by precomputed points, 
but only on a logically orthogonal mesh: the surface is defined 
by a list of curves (in 3d) which must have a uniform length. 
GNUPLOT then will draw an orthogonal mesh by first drawing the 
given lines, and second connecting the 1st point of the 1st curve 
with the 1st point of the 2nd curve, that one with the 1st point 
of the 3rd curve and so on for all curves and for all indexes. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PLOT}

${\footnote \pard\plain \sl240 \fs20 $ PLOT}

+{\footnote \pard\plain \sl240 \fs20 + g37:1160}

 K{\footnote \pard\plain \sl240 \fs20 K plot;graphics;PLOT command;command}

}{\b\f2 PLOT}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
 \par 
\par 
The command }{\f3 plot} {\f2  is the main entry for drawing a 
picture from inside REDUCE. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 plot} {\f4 (<spec>,<spec>,...) 
\par 
\par 
}{\f2 \par 
where <spec> is a <function>, a <range> or an <option>. 
\par 
\par 
<function>: 
\par 
\par 
- an expression depending 
on one unknown (e.g. }{\f3 sin(x)} {\f2  or two unknowns (e.g. 
}{\f3 sin(x+y)} {\f2 , 
\par 
\par 
- an equation with a function on its right-hand 
side and a single name on its left-hand side (e.g. 
}{\f3 z=sin(x+y)} {\f2  where the name on the left-hand side specifies 
the dependent variable. 
\par 
\par 
- a list of functions: 
if in 2 dimensions the picture should have more than one 
curve the expressions can be given as list (e.g. }{\f3 \{sin(x),cos(x)\}} {\f2 ). 
\par 
\par 
- an equation with zero left or right hand side describing 
 an implicit curve in two dimensions (e.g. }{\f3 x**3+x*y**3-9x=0} {\f2 ). 
\par 
\par 
- a point set: the graph can be given 
as point set in 2 dimensions or a }
{\f2\uldb pointset}{\v\f2 Pointset} 
{\f2  or pointset list 
in 3 dimensions. 
\par 
\par 
<range>: 
\par 
\par 
Each dependent and independent variable can be limited 
to an interval by an equation where the left-hand side specifies 
the variable and the right-hand side defines the }
{\f2\uldb interval}{\v\f2 Interval} 
{\f2 , 
e.g. }{\f3 x=( -3 .. 5)} {\f2 . 
\par 
\par 
If omitted the independent variables 
range from -10 to 10 and the dependent variable is limited only 
by the precision of the IEEE floating point arithmetic. 
\par 
\par 
<option>: 
\par 
\par 
An option can be an equation equating a variable 
and a value (in general a string), or a keyword(GNUPLOT switch). 
These have to be included in the gnuplot command arguments directly. 
Strings have to be enclosed in 
string quotes (see }
{\f2\uldb string}{\v\f2 STRING} 
{\f2 ). Available options are: 
\par 
\par 
}
{\f2\uldb title}{\v\f2 title} 
{\f2 : assign a heading (default: empty) 
\par 
\par 
}
{\f2\uldb xlabel}{\v\f2 xlabel} 
{\f2 : set label for the x axis 
\par 
\par 
}
{\f2\uldb ylabel}{\v\f2 ylabel} 
{\f2 : set label for the y axis 
\par 
\par 
}
{\f2\uldb zlabel}{\v\f2 zlabel} 
{\f2 : set label for the z axis 
\par 
\par 
}
{\f2\uldb terminal}{\v\f2 terminal} 
{\f2 : select an output device 
\par 
\par 
}
{\f2\uldb size}{\v\f2 size} 
{\f2 : rescale the picture 
\par 
\par 
}
{\f2\uldb view}{\v\f2 view} 
{\f2 : set a viewpoint 
\par 
\par 
}{\f3 (no)} 
{\f2\uldb contour}{\v\f2 contour} 
{\f2 : 3d: add contour lines 
\par 
\par 
}{\f3 (no)} 
{\f2\uldb surface}{\v\f2 surface} 
{\f2 : 3d: draw surface (default: yes) 
\par 
\par 
}{\f3 (no)} 
{\f2\uldb hidden3d}{\v\f2 hidden3d} 
{\f2 : 3d: remove hidden lines (default: no) 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
plot(cos x); \par
 \par
plot(s=sin phi,phi=(-3 .. 3)); \par
 \par
plot(sin phi,cos phi,phi=(-3 .. 3)); \par
 \par
plot (cos sqrt(x**2 + y**2),x=(-3 .. 3),y=(-3 .. 3),hidden3d); \par
 \par
plot \{\{0,0\},\{0,1\},\{1,1\},\{0,0\},\{1,0\},\{0,1\},\{0.5,1.5\},\{1,1\},\{1,0\}\}; \par
 \par
 \par
 \par
on rounded; \par
 \par
w:=for j:=1:200 collect \{1/j*sin j,1/j*cos j,j/200\}$ \par
 \par
plot w;  \par
\pard \sl240 }{\f2 Additional control of the }{\f3 plot} {\f2  operation: 
}
{\f2\uldb plotrefine}{\v\f2 PLOTREFINE} 
{\f2 , 
}
{\f2\uldb plot_xmesh}{\v\f2 plot_xmesh} 
{\f2 , }
{\f2\uldb plot_ymesh}{\v\f2 plot_ymesh} 
{\f2 , }
{\f2\uldb trplot}{\v\f2 TRPLOT} 
{\f2 , 
}
{\f2\uldb plotkeep}{\v\f2 PLOTKEEP} 
{\f2 , }
{\f2\uldb show_grid}{\v\f2 SHOW_GRID} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PLOTRESET}

${\footnote \pard\plain \sl240 \fs20 $ PLOTRESET}

+{\footnote \pard\plain \sl240 \fs20 + g37:1161}

 K{\footnote \pard\plain \sl240 \fs20 K PLOTRESET command;command}

}{\b\f2 PLOTRESET}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The command }{\f3 plotreset} {\f2  closes the current GNUPLOT windows. 
The next call to }
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2  will create a new one. }{\f3 plotreset} {\f2  
can also be used to reset the system status after technical problems. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 plotreset} {\f4 ; 
\par 
\par 
}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # title}

${\footnote \pard\plain \sl240 \fs20 $ title}

+{\footnote \pard\plain \sl240 \fs20 + g37:1162}

 K{\footnote \pard\plain \sl240 \fs20 K plot;title variable;variable}

}{\b\f2 TITLE}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
}
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2 option: 
Assign a title to the GNUPLOT graph. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 title} {\f4 = <string> 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
title="annual revenue in 1993" \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # xlabel}

${\footnote \pard\plain \sl240 \fs20 $ xlabel}

+{\footnote \pard\plain \sl240 \fs20 + g37:1163}

 K{\footnote \pard\plain \sl240 \fs20 K plot;xlabel variable;variable}

}{\b\f2 XLABEL}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
}
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2 option: 
Assign a name to to the x axis (see }
{\f2\uldb axes names}{\v\f2 Axes_names} 
{\f2 ). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 xlabel} {\f4 = <string> 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
xlabel="month" \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # ylabel}

${\footnote \pard\plain \sl240 \fs20 $ ylabel}

+{\footnote \pard\plain \sl240 \fs20 + g37:1164}

 K{\footnote \pard\plain \sl240 \fs20 K plot;ylabel variable;variable}

}{\b\f2 YLABEL}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
}
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2 option: 
Assign a name to to the x axis (see }
{\f2\uldb axes names}{\v\f2 Axes_names} 
{\f2 ). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 ylabel} {\f4 = <string> 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
ylabel="million forint" \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # zlabel}

${\footnote \pard\plain \sl240 \fs20 $ zlabel}

+{\footnote \pard\plain \sl240 \fs20 + g37:1165}

 K{\footnote \pard\plain \sl240 \fs20 K plot;zlabel variable;variable}

}{\b\f2 ZLABEL}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
}
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2 option: 
Assign a name to to the z axis (see }
{\f2\uldb axes names}{\v\f2 Axes_names} 
{\f2 ). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 zlabel} {\f4 = <string> 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
zlabel="local weight" \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # terminal}

${\footnote \pard\plain \sl240 \fs20 $ terminal}

+{\footnote \pard\plain \sl240 \fs20 + g37:1166}

 K{\footnote \pard\plain \sl240 \fs20 K plot;terminal variable;variable}

}{\b\f2 TERMINAL}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
}
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2 option: 
Select a different output device. The possible values here 
depend highly on the facilities installed for your GNUPLOT 
software. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 terminal} {\f4 = <string> 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
terminal="x11" \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # size}

${\footnote \pard\plain \sl240 \fs20 $ size}

+{\footnote \pard\plain \sl240 \fs20 + g37:1167}

 K{\footnote \pard\plain \sl240 \fs20 K plot;size variable;variable}

}{\b\f2 SIZE}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
}
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2 option: 
Rescale the graph (not the window!) in x and y direction. 
Default is 1.0 (no rescaling). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 size} {\f4 = "<sx>,<sy>" 
\par 
\par 
}{\f2 \par 
where <sx>,<sy> are floating point number not too 
far from 1.0. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
size="0.7,1" \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # view}

${\footnote \pard\plain \sl240 \fs20 $ view}

+{\footnote \pard\plain \sl240 \fs20 + g37:1168}

 K{\footnote \pard\plain \sl240 \fs20 K plot;view variable;variable}

}{\b\f2 VIEW}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
}
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2 option: 
Set a new viewpoint by turning the object around the x and then 
around the z axis (see }
{\f2\uldb axes names}{\v\f2 Axes_names} 
{\f2 ). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 view} {\f4 = "<sx>,<sz>" 
\par 
\par 
}{\f2 \par 
where <sx>,<sz> are floating point number representing 
angles in degrees. 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
view="30,130" \par
\pard \sl240 }{\f2 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # contour}

${\footnote \pard\plain \sl240 \fs20 $ contour}

+{\footnote \pard\plain \sl240 \fs20 + g37:1169}

 K{\footnote \pard\plain \sl240 \fs20 K plot;contour switch;switch}

}{\b\f2 CONTOUR}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
}
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2 option: 
If }{\f3 contour} {\f2  is member of the options for a 3d }
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2  
contour lines are projected to the z=0 plane 
(see }
{\f2\uldb axes names}{\v\f2 Axes_names} 
{\f2 ). The absence of contour lines 
can be selected explicitly by including }{\f3 nocontour} {\f2 . Default 
is }{\f3 nocontour} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # surface}

${\footnote \pard\plain \sl240 \fs20 $ surface}

+{\footnote \pard\plain \sl240 \fs20 + g37:1170}

 K{\footnote \pard\plain \sl240 \fs20 K plot;surface switch;switch}

}{\b\f2 SURFACE}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
}
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2 option: 
If }{\f3 surface} {\f2  is member of the options for a 3d }
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2  
the surface is drawn. The absence of the surface plotting 
can be selected by including }{\f3 nosurface} {\f2 , e.g. if 
only the }
{\f2\uldb contour}{\v\f2 contour} 
{\f2  should be visualized. Default is }{\f3 surface} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # hidden3d}

${\footnote \pard\plain \sl240 \fs20 $ hidden3d}

+{\footnote \pard\plain \sl240 \fs20 + g37:1171}

 K{\footnote \pard\plain \sl240 \fs20 K plot;hidden3d switch;switch}

}{\b\f2 HIDDEN3D}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
}
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2 option: 
If }{\f3 hidden3d} {\f2  is member of the options for a 3d }
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2  
hidden lines are removed from the picture. Otherwise a 
surface is drawn as transparent object. Default is 
}{\f3 nohidden3d} {\f2 . Selecting }{\f3 hidden3d} {\f2  increases the 
computing time substantially. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PLOTKEEP}

${\footnote \pard\plain \sl240 \fs20 $ PLOTKEEP}

+{\footnote \pard\plain \sl240 \fs20 + g37:1172}

 K{\footnote \pard\plain \sl240 \fs20 K plot;PLOTKEEP switch;switch}

}{\b\f2 PLOTKEEP}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
Normally all intermediate data sets are deleted after terminating 
a plot session. If the switch }{\f3 plotkeep} {\f2  is set }
{\f2\uldb on}{\v\f2 ON} 
{\f2 , 
the data sets are kept for eventual post processing independent 
of REDUCE. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PLOTREFINE}

${\footnote \pard\plain \sl240 \fs20 $ PLOTREFINE}

+{\footnote \pard\plain \sl240 \fs20 + g37:1173}

 K{\footnote \pard\plain \sl240 \fs20 K plot;PLOTREFINE switch;switch}

}{\b\f2 PLOTREFINE}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
In general }
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2  tries to generate smooth pictures by evaluating 
the functions at interior points until the distances are fine 
enough. This can require a lot of computing time if the 
single function evaluation is expensive. The refinement is 
controlled by the switch }{\f3 plotrefine} {\f2  which is }
{\f2\uldb on}{\v\f2 ON} 
{\f2  
by default. When you turn it }
{\f2\uldb off}{\v\f2 OFF} 
{\f2  the functions will 
be evaluated only at the basic points (see }
{\f2\uldb plot_xmesh}{\v\f2 plot_xmesh} 
{\f2 , 
}
{\f2\uldb plot_ymesh}{\v\f2 plot_ymesh} 
{\f2 ). 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # plot_xmesh}

${\footnote \pard\plain \sl240 \fs20 $ plot_xmesh}

+{\footnote \pard\plain \sl240 \fs20 + g37:1174}

 K{\footnote \pard\plain \sl240 \fs20 K plot;plot_xmesh variable;variable}

}{\b\f2 PLOT_XMESH}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
The integer value of the global variable }{\f3 plot_xmesh} {\f2  
defines the number of initial function evaluations in x 
direction (see }
{\f2\uldb axes names}{\v\f2 Axes_names} 
{\f2 ) for }
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2 . For 2d graphs additional 
points will be used as long as }
{\f2\uldb plotrefine}{\v\f2 PLOTREFINE} 
{\f2  is }{\f3 on} {\f2 . 
For 3d graphs this number defines also the number of mesh lines 
orthogonal to the x axis. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # plot_ymesh}

${\footnote \pard\plain \sl240 \fs20 $ plot_ymesh}

+{\footnote \pard\plain \sl240 \fs20 + g37:1175}

 K{\footnote \pard\plain \sl240 \fs20 K plot;plot_ymesh variable;variable}

}{\b\f2 PLOT_YMESH}{\f2 \tab \tab \tab \tab }{\b\f2 variable}{\f2 \par 
\par 
 
 \par 
\par 
The integer value of the global variable }{\f3 plot_ymesh} {\f2  
defines for 3d }
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2  calls the number of function evaluations in y 
direction (see }
{\f2\uldb axes names}{\v\f2 Axes_names} 
{\f2 ) and the number of mesh lines 
orthogonal to the y axis. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SHOW_GRID}

${\footnote \pard\plain \sl240 \fs20 $ SHOW_GRID}

+{\footnote \pard\plain \sl240 \fs20 + g37:1176}

 K{\footnote \pard\plain \sl240 \fs20 K plot;SHOW_GRID switch;switch}

}{\b\f2 SHOW_GRID}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
The grid for localizing an implicitly defined curve in }
{\f2\uldb plot}{\v\f2 PLOT} 
{\f2  
consists of triangles. These are computed initially equally distributed 
over the x-y plane controlled by }
{\f2\uldb plot_xmesh}{\v\f2 plot_xmesh} 
{\f2 . The grid is 
refined adaptively in several levels. The final grid can be visualized 
by setting on the switch }{\f3 show_grid} {\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TRPLOT}

${\footnote \pard\plain \sl240 \fs20 $ TRPLOT}

+{\footnote \pard\plain \sl240 \fs20 + g37:1177}

 K{\footnote \pard\plain \sl240 \fs20 K plot;TRPLOT switch;switch}

}{\b\f2 TRPLOT}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
 \par 
\par 
In general the interaction between REDUCE and GNUPLOT is performed 
as silently as possible. However, sometimes it might be useful 
to see the GNUPLOT commands generated by REDUCE, e.g. for a 
postprocessing of generated data sets independent of REDUCE. 
When the switch }{\f3 trplot} {\f2  is set on all GNUPLOT commands will 
be printed to the standard output additionally. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g37}

${\footnote \pard\plain \sl240 \fs20 $ Gnuplot package}

+{\footnote \pard\plain \sl240 \fs20 + index:0037}
}{\b\f2 Gnuplot package}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb GNUPLOT and REDUCE introduction}
{\v\f2 GNUPLOT_and_REDUCE}{\f2 \par 
}{\f2 \tab}{\f2\uldb Axes names concept}
{\v\f2 Axes_names}{\f2 \par 
}{\f2 \tab}{\f2\uldb Pointset type}
{\v\f2 Pointset}{\f2 \par 
}{\f2 \tab}{\f2\uldb PLOT command}
{\v\f2 PLOT}{\f2 \par 
}{\f2 \tab}{\f2\uldb PLOTRESET command}
{\v\f2 PLOTRESET}{\f2 \par 
}{\f2 \tab}{\f2\uldb title variable}
{\v\f2 title}{\f2 \par 
}{\f2 \tab}{\f2\uldb xlabel variable}
{\v\f2 xlabel}{\f2 \par 
}{\f2 \tab}{\f2\uldb ylabel variable}
{\v\f2 ylabel}{\f2 \par 
}{\f2 \tab}{\f2\uldb zlabel variable}
{\v\f2 zlabel}{\f2 \par 
}{\f2 \tab}{\f2\uldb terminal variable}
{\v\f2 terminal}{\f2 \par 
}{\f2 \tab}{\f2\uldb size variable}
{\v\f2 size}{\f2 \par 
}{\f2 \tab}{\f2\uldb view variable}
{\v\f2 view}{\f2 \par 
}{\f2 \tab}{\f2\uldb contour switch}
{\v\f2 contour}{\f2 \par 
}{\f2 \tab}{\f2\uldb surface switch}
{\v\f2 surface}{\f2 \par 
}{\f2 \tab}{\f2\uldb hidden3d switch}
{\v\f2 hidden3d}{\f2 \par 
}{\f2 \tab}{\f2\uldb PLOTKEEP switch}
{\v\f2 PLOTKEEP}{\f2 \par 
}{\f2 \tab}{\f2\uldb PLOTREFINE switch}
{\v\f2 PLOTREFINE}{\f2 \par 
}{\f2 \tab}{\f2\uldb plot_xmesh variable}
{\v\f2 plot_xmesh}{\f2 \par 
}{\f2 \tab}{\f2\uldb plot_ymesh variable}
{\v\f2 plot_ymesh}{\f2 \par 
}{\f2 \tab}{\f2\uldb SHOW_GRID switch}
{\v\f2 SHOW_GRID}{\f2 \par 
}{\f2 \tab}{\f2\uldb TRPLOT switch}
{\v\f2 TRPLOT}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Linear_Algebra_package}

${\footnote \pard\plain \sl240 \fs20 $ Linear_Algebra_package}

+{\footnote \pard\plain \sl240 \fs20 + g38:1178}

 K{\footnote \pard\plain \sl240 \fs20 K Linear Algebra package introduction;introduction}

}{\b\f2 LINEAR ALGEBRA PACKAGE}{\f2 \tab \tab \tab \tab }{\b\f2 introduction}{\f2 \par 
\par 
 
\par 
\par 
This section briefly describes what's available in the Linear Algebra 
package. 
\par 
\par 
Note on examples: In the examples throughout this 
document, the matrix A will be 
\pard \tx3420 }{\f4  \par
     [1  2  3] \par
     [4  5  6] \par
     [7  8  9]. \par
\pard \sl240 }{\f2 \par 
\par 
The functions can be divided into four categories: 
\par 
\par 
Basic matrix handling 
 \par 
\par 
}
{\f2\uldb add_columns}{\v\f2 add_columns} 
{\f2 , 
\par 
\par 
}
{\f2\uldb add_rows}{\v\f2 add_rows} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb add_to_columns}{\v\f2 add_to_columns} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb add_to_rows}{\v\f2 add_to_rows} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb augment_columns}{\v\f2 augment_columns} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb char_poly}{\v\f2 char_poly} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb column_dim}{\v\f2 column_dim} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb copy_into}{\v\f2 copy_into} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb diagonal}{\v\f2 diagonal} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb extend}{\v\f2 extend} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb find_companion}{\v\f2 find_companion} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb get_columns}{\v\f2 get_columns} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb get_rows}{\v\f2 get_rows} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb hermitian_tp}{\v\f2 hermitian_tp} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb matrix_augment}{\v\f2 matrix_augment} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb matrix_stack}{\v\f2 matrix_stack} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb minor}{\v\f2 minor} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb mult_columns}{\v\f2 mult_columns} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb mult_rows}{\v\f2 mult_rows} 
{\f2 , 
\par 
\par 
}
{\f2\uldb pivot}{\v\f2 pivot} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb remove_columns}{\v\f2 remove_columns} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb remove_rows}{\v\f2 remove_rows} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb row_dim}{\v\f2 row_dim} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb rows_pivot}{\v\f2 rows_pivot} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb stack_rows}{\v\f2 stack_rows} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb sub_matrix}{\v\f2 sub_matrix} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb swap_columns}{\v\f2 swap_columns} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb swap_entries}{\v\f2 swap_entries} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb swap_rows}{\v\f2 swap_rows} 
{\f2 . 
\par 
\par 
Constructors -- functions that create matrices 
 \par 
\par 
}
{\f2\uldb band_matrix}{\v\f2 band_matrix} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb block_matrix}{\v\f2 block_matrix} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb char_matrix}{\v\f2 char_matrix} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb coeff_matrix}{\v\f2 coeff_matrix} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb companion}{\v\f2 companion} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb hessian}{\v\f2 hessian} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb hilbert}{\v\f2 hilbert} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb jacobian}{\v\f2 jacobian} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb jordan_block}{\v\f2 jordan_block} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb make_identity}{\v\f2 make_identity} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb random_matrix}{\v\f2 random_matrix} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb toeplitz}{\v\f2 toeplitz} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb vandermonde}{\v\f2 vandermonde} 
{\f2 . 
\par 
\par 
High level algorithms 
 \par 
\par 
}
{\f2\uldb char_poly}{\v\f2 char_poly} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb cholesky}{\v\f2 cholesky} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb gram_schmidt}{\v\f2 gram_schmidt} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb lu_decom}{\v\f2 lu_decom} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb pseudo_inverse}{\v\f2 pseudo_inverse} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb simplex}{\v\f2 simplex} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb svd}{\v\f2 svd} 
{\f2 . 
\par 
\par 
Normal Forms 
\par 
\par 
There is a separate package, NORMFORM, for computing 
the following matrix normal forms in REDUCE: 
\par 
\par 
}
{\f2\uldb smithex}{\v\f2 Smithex} 
{\f2 , 
\par 
\par 
}
{\f2\uldb smithex_int}{\v\f2 Smithex\_int} 
{\f2 , 
\par 
\par 
}
{\f2\uldb frobenius}{\v\f2 Frobenius} 
{\f2 , 
\par 
\par 
}
{\f2\uldb ratjordan}{\v\f2 Ratjordan} 
{\f2 , 
\par 
\par 
}
{\f2\uldb jordansymbolic}{\v\f2 Jordansymbolic} 
{\f2 , 
\par 
\par 
}
{\f2\uldb jordan}{\v\f2 Jordan} 
{\f2 . 
\par 
\par 
Predicates 
\par 
\par 
}
{\f2\uldb matrixp}{\v\f2 matrixp} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb squarep}{\v\f2 squarep} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb symmetricp}{\v\f2 symmetricp} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # fast_la}

${\footnote \pard\plain \sl240 \fs20 $ fast_la}

+{\footnote \pard\plain \sl240 \fs20 + g38:1179}

 K{\footnote \pard\plain \sl240 \fs20 K fast_la switch;switch}

}{\b\f2 FAST_LA}{\f2 \tab \tab \tab \tab }{\b\f2 switch}{\f2 \par 
\par 
 
\par 
\par 
By turning the }{\f3 fast_la} {\f2  switch on, the speed of the following 
functions will be increased: 
\par 
\par 
}
{\f2\uldb add_columns}{\v\f2 add_columns} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb add_rows}{\v\f2 add_rows} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb augment_columns}{\v\f2 augment_columns} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb column_dim}{\v\f2 column_dim} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb copy_into}{\v\f2 copy_into} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb make_identity}{\v\f2 make_identity} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb matrix_augment}{\v\f2 matrix_augment} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb matrix_stack}{\v\f2 matrix_stack} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb minor}{\v\f2 minor} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb mult_columns}{\v\f2 mult_columns} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb mult_rows}{\v\f2 mult_rows} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb pivot}{\v\f2 pivot} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb remove_columns}{\v\f2 remove_columns} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb remove_rows}{\v\f2 remove_rows} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb rows_pivot}{\v\f2 rows_pivot} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb squarep}{\v\f2 squarep} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb stack_rows}{\v\f2 stack_rows} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb sub_matrix}{\v\f2 sub_matrix} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb swap_columns}{\v\f2 swap_columns} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb swap_entries}{\v\f2 swap_entries} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb swap_rows}{\v\f2 swap_rows} 
{\f2 , 
 \par 
\par 
}
{\f2\uldb symmetricp}{\v\f2 symmetricp} 
{\f2 . 
 \par 
\par 
The increase in speed will be negligible unless you are making a 
significant number (i.e. thousands) of calls. When using this switch, 
error checking is minimized. This means that illegal input may give 
strange error messages. Beware. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # add_columns}

${\footnote \pard\plain \sl240 \fs20 $ add_columns}

+{\footnote \pard\plain \sl240 \fs20 + g38:1180}

 K{\footnote \pard\plain \sl240 \fs20 K add_columns operator;operator}

}{\b\f2 ADD_COLUMNS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
Add columns, add rows: 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 add_columns} {\f4 (<matrix>,<c1>,<c2>,<expr>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
\par 
\par 
<c1>,<c2> :- positive integers. 
\par 
\par 
<expr> :- a scalar expression. 
\par 
\par 
The Operator }{\f3 add_columns} {\f2  replaces column <\meta\{c2>\} of 
<matrix> by <expr> * column(<matrix>,<c1>) + 
column(<matrix>,<c2>). 
\par 
\par 
}{\f3 add_rows} {\f2 performs the equivalent task on the rows of 
<matrix>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
add_columns(A,1,2,x);  \par
 \par
  [1   x + 2   3] \par
  [             ] \par
  [4  4*x + 5  6] \par
  [             ] \par
  [7  7*x + 8  9] \par
 \par
 \par
 \par
add_rows(A,2,3,5);  \par
 \par
  [1   2   3 ] \par
  [          ] \par
  [4   5   6 ] \par
  [          ] \par
  [27  33  39] \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb add_to_columns}{\v\f2 add_to_columns} 
{\f2 , 
}
{\f2\uldb add_to_rows}{\v\f2 add_to_rows} 
{\f2 , }
{\f2\uldb mult_columns}{\v\f2 mult_columns} 
{\f2 , 
}
{\f2\uldb mult_rows}{\v\f2 mult_rows} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # add_rows}

${\footnote \pard\plain \sl240 \fs20 $ add_rows}

+{\footnote \pard\plain \sl240 \fs20 + g38:1181}

 K{\footnote \pard\plain \sl240 \fs20 K add_rows operator;operator}

}{\b\f2 ADD_ROWS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 see: }
{\f2\uldb add_columns}{\v\f2 add_columns} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # add_to_columns}

${\footnote \pard\plain \sl240 \fs20 $ add_to_columns}

+{\footnote \pard\plain \sl240 \fs20 + g38:1182}

 K{\footnote \pard\plain \sl240 \fs20 K add_to_columns operator;operator}

}{\b\f2 ADD_TO_COLUMNS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
Add to columns, add to rows: 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 add_to_columns} {\f4 (<matrix>,<column\_list>,<expr>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a matrix. 
\par 
\par 
<column\_list> :- a positive integer or a list of positive 
 integers. 
\par 
\par 
<expr> :- a scalar expression. 
\par 
\par 
}{\f3 add_to_columns} {\f2 adds <expr> to each column specified in 
<column\_list> of <matrix>. 
\par 
\par 
}{\f3 add_to_rows} {\f2 performs the equivalent task on the rows of 
<matrix>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
add_to_columns(A,\{1,2\},10);  \par
 \par
  [11  12  3] \par
  [         ] \par
  [14  15  6] \par
  [         ] \par
  [17  18  9] \par
 \par
 \par
 \par
add_to_rows(A,2,-x)  \par
 \par
    \par
  [   1         2         3    ] \par
  [                            ] \par
  [ - x + 4   - x + 5   - x + 6] \par
  [                            ] \par
  [   7         8         9    ] \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb add_columns}{\v\f2 add_columns} 
{\f2 , }
{\f2\uldb add_rows}{\v\f2 add_rows} 
{\f2 , }
{\f2\uldb mult_rows}{\v\f2 mult_rows} 
{\f2 , 
}
{\f2\uldb mult_columns}{\v\f2 mult_columns} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # add_to_rows}

${\footnote \pard\plain \sl240 \fs20 $ add_to_rows}

+{\footnote \pard\plain \sl240 \fs20 + g38:1183}

 K{\footnote \pard\plain \sl240 \fs20 K add_to_rows operator;operator}

}{\b\f2 ADD_TO_ROWS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 see: }
{\f2\uldb add_to_columns}{\v\f2 add_to_columns} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # augment_columns}

${\footnote \pard\plain \sl240 \fs20 $ augment_columns}

+{\footnote \pard\plain \sl240 \fs20 + g38:1184}

 K{\footnote \pard\plain \sl240 \fs20 K augment_columns operator;operator}

}{\b\f2 AUGMENT_COLUMNS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
Augment columns, stack rows: 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 augment_columns} {\f4 (<matrix>,<column\_list>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a matrix. 
\par 
\par 
<column\_list> :- either a positive integer or a list of positive 
 integers. 
\par 
\par 
}{\f3 augment_columns} {\f2 gets hold of the columns of <matrix> 
specified in }{\f3 column_list} {\f2  and sticks them together. 
\par 
\par 
}{\f3 stack_rows} {\f2 performs the same task on rows of <matrix>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
augment_columns(A,\{1,2\})  \par
 \par
    \par
  [1  2] \par
  [    ] \par
  [4  5] \par
  [    ] \par
  [7  8] \par
 \par
 \par
 \par
stack_rows(A,\{1,3\})  \par
 \par
  [1  2  3] \par
  [       ] \par
  [7  8  9] \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb get_columns}{\v\f2 get_columns} 
{\f2 , }
{\f2\uldb get_rows}{\v\f2 get_rows} 
{\f2 , }
{\f2\uldb sub_matrix}{\v\f2 sub_matrix} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # band_matrix}

${\footnote \pard\plain \sl240 \fs20 $ band_matrix}

+{\footnote \pard\plain \sl240 \fs20 + g38:1185}

 K{\footnote \pard\plain \sl240 \fs20 K band_matrix operator;operator}

}{\b\f2 BAND_MATRIX}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 band_matrix} {\f4 (<expr\_list>,<square\_size>) 
\par 
\par 
}{\f2 \par 
<expr\_list> :- either a single scalar expression or a list of 
 an odd number of scalar expressions. 
\par 
\par 
<square\_size> :- a positive integer. 
\par 
\par 
}{\f3 band_matrix} {\f2 creates a square matrix of dimension 
<square\_size>. The diagonal consists of the middle expression 
of the <expr\_list>. The expressions to the left of this fill 
the required number of sub_diagonals and the expressions to the right 
the super_diagonals. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
band_matrix(\{x,y,z\},6)  \par
 \par
  [y  z  0  0  0  0] \par
  [                ] \par
  [x  y  z  0  0  0] \par
  [                ] \par
  [0  x  y  z  0  0] \par
  [                ] \par
  [0  0  x  y  z  0] \par
  [                ] \par
  [0  0  0  x  y  z] \par
  [                ] \par
  [0  0  0  0  x  y] \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb diagonal}{\v\f2 diagonal} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # block_matrix}

${\footnote \pard\plain \sl240 \fs20 $ block_matrix}

+{\footnote \pard\plain \sl240 \fs20 + g38:1186}

 K{\footnote \pard\plain \sl240 \fs20 K block_matrix operator;operator}

}{\b\f2 BLOCK_MATRIX}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 block_matrix} {\f4 (<r>,<c>,<matrix\_list>) 
\par 
\par 
}{\f2 \par 
<r>,<c> :- positive integers. 
\par 
\par 
<matrix\_list> :- a list of matrices. 
\par 
\par 
}{\f3 block_matrix} {\f2 creates a matrix that consists of <r> by 
<c> matrices filled from the <matrix\_list> row wise. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
B := make_identity(2);  \par
 \par
       [1  0] \par
  b := [    ] \par
       [0  1] \par
 \par
 \par
 \par
C := mat((5),(5));  \par
 \par
       [5] \par
  c := [ ] \par
       [5] \par
 \par
 \par
 \par
D := mat((22,33),(44,55));  \par
 \par
       [22  33] \par
  d := [      ] \par
       [44  55] \par
 \par
 \par
 \par
block_matrix(2,3,\{B,C,D,D,C,B\});  \par
 \par
 \par
  [1   0   5  22  33] \par
  [                 ] \par
  [0   1   5  44  55] \par
  [                 ] \par
  [22  33  5  1   0 ] \par
  [                 ] \par
  [44  55  5  0   1 ] \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # char_matrix}

${\footnote \pard\plain \sl240 \fs20 $ char_matrix}

+{\footnote \pard\plain \sl240 \fs20 + g38:1187}

 K{\footnote \pard\plain \sl240 \fs20 K char_matrix operator;operator}

}{\b\f2 CHAR_MATRIX}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 char_matrix} {\f4 (<matrix>,<lambda>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a square matrix. 
<lambda> :- a symbol or algebraic expression. 
\par 
\par 
<char\_matrix> creates the characteristic matrix C of 
<matrix>. 
\par 
\par 
This is C = <lambda> * Id - A. 
Id is the identity matrix. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
char_matrix(A,x);  \par
 \par
  [x - 1   -2     -3  ] \par
  [                   ] \par
  [ -4    x - 5   -6  ] \par
  [                   ] \par
  [ -7     -8    x - 9] \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb char_poly}{\v\f2 char_poly} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # char_poly}

${\footnote \pard\plain \sl240 \fs20 $ char_poly}

+{\footnote \pard\plain \sl240 \fs20 + g38:1188}

 K{\footnote \pard\plain \sl240 \fs20 K char_poly operator;operator}

}{\b\f2 CHAR_POLY}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 char_poly} {\f4 (<matrix>,<lambda>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a square matrix. 
\par 
\par 
<lambda> :- a symbol or algebraic expression. 
\par 
\par 
}{\f3 char_poly} {\f2 finds the characteristic polynomial of <matrix>. 
This is the determinant of <lambda> * Id - A. 
Id is the identity matrix. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
char_poly(A,x);  \par
 \par
   3     2 \par
  x -15*x -18*x \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb char_matrix}{\v\f2 char_matrix} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # cholesky}

${\footnote \pard\plain \sl240 \fs20 $ cholesky}

+{\footnote \pard\plain \sl240 \fs20 + g38:1189}

 K{\footnote \pard\plain \sl240 \fs20 K cholesky operator;operator}

}{\b\f2 CHOLESKY}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 cholesky} {\f4 (<matrix>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a positive definite matrix containing numeric entries. 
\par 
\par 
}{\f3 cholesky} {\f2 computes the cholesky decomposition of <matrix>. 
\par 
\par 
It returns \{L,U\} where L is a lower matrix, U is an upper matrix, 
A = LU, and U = }{\f4 L^T}{\f2 . 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
F := mat((1,1,0),(1,3,1),(0,1,1));  \par
 \par
 \par
       [1  1  0] \par
       [       ] \par
  f := [1  3  1] \par
       [       ] \par
       [0  1  1] \par
 \par
 \par
 \par
on rounded;  \par
 \par
cholesky(F);  \par
 \par
  \{ \par
   [1        0               0       ] \par
   [                                 ] \par
   [1  1.41421356237         0       ] \par
   [                                 ] \par
   [0  0.707106781187  0.707106781187] \par
   , \par
   [1        1              0       ] \par
   [                                ] \par
   [0  1.41421356237  0.707106781187] \par
   [                                ] \par
   [0        0        0.707106781187] \par
  \} \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb lu_decom}{\v\f2 lu_decom} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # coeff_matrix}

${\footnote \pard\plain \sl240 \fs20 $ coeff_matrix}

+{\footnote \pard\plain \sl240 \fs20 + g38:1190}

 K{\footnote \pard\plain \sl240 \fs20 K coeff_matrix operator;operator}

}{\b\f2 COEFF_MATRIX}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 coeff_matrix} {\f4 (\{<lineq\_list>\}) 
\par 
\par 
}{\f2 \par 
(If you are feeling lazy then the braces can be omitted.) 
\par 
\par 
<lineq\_list> :- linear equations. Can be of the form equation = number 
or just equation. 
\par 
\par 
}{\f3 coeff_matrix} {\f2 creates the coefficient matrix C of the linear 
equations. 
\par 
\par 
It returns \{C,X,B\} such that CX = B. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
coeff_matrix(\{x+y+4*z=10,y+x-z=20,x+y+4\});  \par
 \par
 \par
  \{ \par
   [4   1  1] \par
   [        ] \par
   [-1  1  1] \par
   [        ] \par
   [0   1  1] \par
   , \par
   [z] \par
   [ ] \par
   [y] \par
   [ ] \par
   [x] \par
   , \par
   [10] \par
   [  ] \par
   [20] \par
   [  ] \par
   [-4] \par
  \} \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # column_dim}

${\footnote \pard\plain \sl240 \fs20 $ column_dim}

+{\footnote \pard\plain \sl240 \fs20 + g38:1191}

 K{\footnote \pard\plain \sl240 \fs20 K column_dim operator;operator}

}{\b\f2 COLUMN_DIM}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
Column dimension, row dimension: 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 column_dim} {\f4 (<matrix>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a matrix. 
\par 
\par 
}{\f3 column_dim} {\f2 finds the column dimension of <matrix>. 
\par 
\par 
}{\f3 row_dim} {\f2 finds the row dimension of <matrix>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
column_dim(A);  \par
 \par
  3  \par
 \par
 \par
row_dim(A);  \par
 \par
  3  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # companion}

${\footnote \pard\plain \sl240 \fs20 $ companion}

+{\footnote \pard\plain \sl240 \fs20 + g38:1192}

 K{\footnote \pard\plain \sl240 \fs20 K companion operator;operator}

}{\b\f2 COMPANION}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 companion} {\f4 (<poly>,<x>) 
\par 
\par 
}{\f2 \par 
<poly> :- a monic univariate polynomial in <x>. 
\par 
\par 
<x> :- the variable. 
\par 
\par 
}{\f3 companion} {\f2 creates the companion matrix C of <poly>. 
\par 
\par 
This is the square matrix of dimension n, where n is the degree of 
<poly> w.r.t. <x>. 
\par 
\par 
The entries of C are: 
\par 
\par 
C(i,n) = -coeffn(<poly>,<x>,i-1) for i = 1 
 ... n, C(i,i-1) = 1 for i = 2 ... n and 
 the rest are 0. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
companion(x^4+17*x^3-9*x^2+11,x);  \par
 \par
 \par
  [0  0  0  -11] \par
  [            ] \par
  [1  0  0   0 ] \par
  [            ] \par
  [0  1  0   9 ] \par
  [            ] \par
  [0  0  1  -17] \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb find_companion}{\v\f2 find_companion} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # copy_into}

${\footnote \pard\plain \sl240 \fs20 $ copy_into}

+{\footnote \pard\plain \sl240 \fs20 + g38:1193}

 K{\footnote \pard\plain \sl240 \fs20 K copy_into operator;operator}

}{\b\f2 COPY_INTO}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 copy_into} {\f4 (<A>,<B>,<r>,<c>) 
\par 
\par 
}{\f2 \par 
<A>,<B> :- matrices. 
\par 
\par 
<r>,<c> :- positive integers. 
\par 
\par 
}{\f3 copy_into} {\f2 copies matrix <matrix> into <B> with 
<matrix>(1,1) at <B>(<r>,<c>). 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4   \par
 \par
G := mat((0,0,0,0,0),(0,0,0,0,0),(0,0,0,0,0),(0,0,0,0,0),(0,0,0,0,0));  \par
 \par
 \par
       [0  0  0  0  0] \par
       [             ] \par
       [0  0  0  0  0] \par
       [             ] \par
  g := [0  0  0  0  0] \par
       [             ] \par
       [0  0  0  0  0] \par
       [             ] \par
       [0  0  0  0  0] \par
 \par
 \par
 \par
copy_into(A,G,1,2);  \par
 \par
  [0  1  2  3  0] \par
  [             ] \par
  [0  4  5  6  0] \par
  [             ] \par
  [0  7  8  9  0] \par
  [             ] \par
  [0  0  0  0  0] \par
  [             ] \par
  [0  0  0  0  0] \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb augment_columns}{\v\f2 augment_columns} 
{\f2 , }
{\f2\uldb extend}{\v\f2 extend} 
{\f2 , }
{\f2\uldb matrix_augment}{\v\f2 matrix_augment} 
{\f2 , 
}
{\f2\uldb matrix_stack}{\v\f2 matrix_stack} 
{\f2 , }
{\f2\uldb stack_rows}{\v\f2 stack_rows} 
{\f2 , }
{\f2\uldb sub_matrix}{\v\f2 sub_matrix} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # diagonal}

${\footnote \pard\plain \sl240 \fs20 $ diagonal}

+{\footnote \pard\plain \sl240 \fs20 + g38:1194}

 K{\footnote \pard\plain \sl240 \fs20 K diagonal operator;operator}

}{\b\f2 DIAGONAL}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 diagonal} {\f4 (\{<mat\_list>\}) 
\par 
\par 
}{\f2 \par 
(If you are feeling lazy then the braces can be omitted.) 
\par 
\par 
<mat\_list> :- each can be either a scalar expression or a 
square }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
\par 
\par 
}{\f3 diagonal} {\f2 creates a matrix that contains the input on the 
diagonal. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
H := mat((66,77),(88,99));  \par
 \par
       [66  77] \par
  h := [      ] \par
       [88  99] \par
 \par
 \par
 \par
diagonal(\{A,x,H\});  \par
 \par
  [1  2  3  0  0   0 ] \par
  [                  ] \par
  [4  5  6  0  0   0 ] \par
  [                  ] \par
  [7  8  9  0  0   0 ] \par
  [                  ] \par
  [0  0  0  x  0   0 ] \par
  [                  ] \par
  [0  0  0  0  66  77] \par
  [                  ] \par
  [0  0  0  0  88  99] \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb jordan_block}{\v\f2 jordan_block} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # extend}

${\footnote \pard\plain \sl240 \fs20 $ extend}

+{\footnote \pard\plain \sl240 \fs20 + g38:1195}

 K{\footnote \pard\plain \sl240 \fs20 K extend operator;operator}

}{\b\f2 EXTEND}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 extend} {\f4 (<matrix>,<r>,<c>,<expr>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
\par 
\par 
<r>,<c> :- positive integers. 
\par 
\par 
<expr> :- algebraic expression or symbol. 
\par 
\par 
}{\f3 extend} {\f2 returns a copy of <matrix> that has been extended by 
<r> rows and <c> columns. The new entries are made equal to 
<expr>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
extend(A,1,2,x);  \par
 \par
  [1  2  3  x  x] \par
  [             ] \par
  [4  5  6  x  x] \par
  [             ] \par
  [7  8  9  x  x] \par
  [             ] \par
  [x  x  x  x  x] \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb copy_into}{\v\f2 copy_into} 
{\f2 , }
{\f2\uldb matrix_augment}{\v\f2 matrix_augment} 
{\f2 , }
{\f2\uldb matrix_stack}{\v\f2 matrix_stack} 
{\f2 , 
}
{\f2\uldb remove_columns}{\v\f2 remove_columns} 
{\f2 , }
{\f2\uldb remove_rows}{\v\f2 remove_rows} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # find_companion}

${\footnote \pard\plain \sl240 \fs20 $ find_companion}

+{\footnote \pard\plain \sl240 \fs20 + g38:1196}

 K{\footnote \pard\plain \sl240 \fs20 K find_companion operator;operator}

}{\b\f2 FIND_COMPANION}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 find_companion} {\f4 (<matrix>,<x>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
\par 
\par 
<x> :- the variable. 
\par 
\par 
Given a companion matrix, }{\f3 find_companion} {\f2  finds the polynomial 
from which it was made. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
C := companion(x^4+17*x^3-9*x^2+11,x);  \par
 \par
 \par
       [0  0  0  -11] \par
       [            ] \par
       [1  0  0   0 ] \par
  c := [            ] \par
       [0  1  0   9 ] \par
       [            ] \par
       [0  0  1  -17] \par
 \par
 \par
 \par
find_companion(C,x);  \par
 \par
   4     3    2 \par
  x +17*x -9*x +11 \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb companion}{\v\f2 companion} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # get_columns}

${\footnote \pard\plain \sl240 \fs20 $ get_columns}

+{\footnote \pard\plain \sl240 \fs20 + g38:1197}

 K{\footnote \pard\plain \sl240 \fs20 K get_columns operator;operator}

}{\b\f2 GET_COLUMNS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
Get columns, get rows: 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 get_columns} {\f4 (<matrix>,<column\_list>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
\par 
\par 
<c> :- either a positive integer or a list of positive 
 integers. 
\par 
\par 
}{\f3 get_columns} {\f2 removes the columns of <matrix> specified in 
<column\_list> and returns them as a list of column matrices. 
\par 
\par 
}{\f3 get_rows} {\f2 performs the same task on the rows of <matrix>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
get_columns(A,\{1,3\});  \par
 \par
  \{ \par
   [1] \par
   [ ] \par
   [4] \par
   [ ] \par
   [7] \par
   , \par
   [3] \par
   [ ] \par
   [6] \par
   [ ] \par
   [9] \par
  \} \par
 \par
 \par
 \par
get_rows(A,2);  \par
 \par
  \{ \par
   [4  5  6] \par
  \} \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb augment_columns}{\v\f2 augment_columns} 
{\f2 , }
{\f2\uldb stack_rows}{\v\f2 stack_rows} 
{\f2 , }
{\f2\uldb sub_matrix}{\v\f2 sub_matrix} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # get_rows}

${\footnote \pard\plain \sl240 \fs20 $ get_rows}

+{\footnote \pard\plain \sl240 \fs20 + g38:1198}

 K{\footnote \pard\plain \sl240 \fs20 K get_rows operator;operator}

}{\b\f2 GET_ROWS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
see: }
{\f2\uldb get_columns}{\v\f2 get_columns} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # gram_schmidt}

${\footnote \pard\plain \sl240 \fs20 $ gram_schmidt}

+{\footnote \pard\plain \sl240 \fs20 + g38:1199}

 K{\footnote \pard\plain \sl240 \fs20 K gram_schmidt operator;operator}

}{\b\f2 GRAM_SCHMIDT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 gram_schmidt} {\f4 (\{<vec\_list>\}) 
\par 
\par 
}{\f2 \par 
(If you are feeling lazy then the braces can be omitted.) 
\par 
\par 
<vec\_list> :- linearly independent vectors. Each vector must be 
written as a list, eg:\{1,0,0\}. 
\par 
\par 
}{\f3 gram_schmidt} {\f2 performs the gram_schmidt orthonormalization on 
the input vectors. 
\par 
\par 
It returns a list of orthogonal normalized vectors. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
gram_schmidt(\{\{1,0,0\},\{1,1,0\},\{1,1,1\}\});  \par
 \par
 \par
  \{\{1,0,0\},\{0,1,0\},\{0,0,1\}\}  \par
 \par
 \par
 \par
gram_schmidt(\{\{1,2\},\{3,4\}\});  \par
 \par
 \par
        1         2        2*sqrt(5)   -sqrt(5) \par
  \{\{ ------- , ------- \},\{ --------- , -------- \}\} \par
     sqrt(5)   sqrt(5)         5          5 \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # hermitian_tp}

${\footnote \pard\plain \sl240 \fs20 $ hermitian_tp}

+{\footnote \pard\plain \sl240 \fs20 + g38:1200}

 K{\footnote \pard\plain \sl240 \fs20 K hermitian_tp operator;operator}

}{\b\f2 HERMITIAN_TP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3  hermitian_tp} {\f4 (<matrix>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
\par 
\par 
}{\f3 hermitian_tp} {\f2 computes the hermitian transpose of <matrix>. 
\par 
\par 
This is a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  in which the (i,j)'th entry is the conjugate 
of the (j,i)'th entry of <matrix>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
J := mat((i+1,i+2,i+3),(4,5,2),(1,i,0));  \par
 \par
 \par
       [i + 1  i + 2  i + 3] \par
       [                   ] \par
  j := [  4      5      2  ] \par
       [                   ] \par
       [  1      i      0  ] \par
 \par
 \par
 \par
hermitian_tp(j);  \par
 \par
  [ - i + 1  4   1  ] \par
  [                 ] \par
  [ - i + 2  5   - i] \par
  [                 ] \par
  [ - i + 3  2   0  ] \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb tp}{\v\f2 TP} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # hessian}

${\footnote \pard\plain \sl240 \fs20 $ hessian}

+{\footnote \pard\plain \sl240 \fs20 + g38:1201}

 K{\footnote \pard\plain \sl240 \fs20 K hessian operator;operator}

}{\b\f2 HESSIAN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 hessian} {\f4 (<expr>,<variable\_list>) 
\par 
\par 
}{\f2 \par 
<expr> :- a scalar expression. 
\par 
\par 
<variable\_list> :- either a single variable or a list of 
 variables. 
\par 
\par 
}{\f3 hessian} {\f2 computes the hessian matrix of <expr> w.r.t. the 
variables in <variable\_list>. 
\par 
\par 
This is an n by n matrix where n is the number of variables and the 
(i,j)'th entry is }
{\f2\uldb df}{\v\f2 DF} 
{\f2 (<expr>,<variable\_list>(i), 
<variable\_list>(j)). 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
hessian(x*y*z+x^2,\{w,x,y,z\});  \par
 \par
  [0  0  0  0] \par
  [          ] \par
  [0  2  z  y] \par
  [          ] \par
  [0  z  0  x] \par
  [          ] \par
  [0  y  x  0] \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb df}{\v\f2 DF} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # hilbert}

${\footnote \pard\plain \sl240 \fs20 $ hilbert}

+{\footnote \pard\plain \sl240 \fs20 + g38:1202}

 K{\footnote \pard\plain \sl240 \fs20 K hilbert operator;operator}

}{\b\f2 HILBERT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 hilbert} {\f4 (<square\_size>,<expr>) 
\par 
\par 
}{\f2 \par 
<square\_size> :- a positive integer. 
\par 
\par 
<expr> :- an algebraic expression. 
\par 
\par 
}{\f3 hilbert} {\f2 computes the square hilbert matrix of dimension 
<square\_size>. 
\par 
\par 
This is the symmetric matrix in which the (i,j)'th entry is 
1/(i+j-<expr>). 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
hilbert(3,y+x);  \par
 \par
  [    - 1          - 1          - 1    ] \par
  [-----------  -----------  -----------] \par
  [ x + y - 2    x + y - 3    x + y - 4 ] \par
  [                                     ] \par
  [    - 1          - 1          - 1    ] \par
  [-----------  -----------  -----------] \par
  [ x + y - 3    x + y - 4    x + y - 5 ] \par
  [                                     ] \par
  [    - 1          - 1          - 1    ] \par
  [-----------  -----------  -----------] \par
  [ x + y - 4    x + y - 5    x + y - 6 ] \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # jacobian}

${\footnote \pard\plain \sl240 \fs20 $ jacobian}

+{\footnote \pard\plain \sl240 \fs20 + g38:1203}

 K{\footnote \pard\plain \sl240 \fs20 K jacobian operator;operator}

}{\b\f2 JACOBIAN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 jacobian} {\f4 (<expr\_list>,<variable\_list>) 
\par 
\par 
}{\f2 \par 
<expr\_list> :- either a single algebraic expression or a list 
 of algebraic expressions. 
\par 
\par 
<variable\_list> :- either a single variable or a list of 
 variables. 
\par 
\par 
}{\f3 jacobian} {\f2 computes the jacobian matrix of <expr\_list> 
w.r.t. <variable\_list>. 
\par 
\par 
This is a matrix whose (i,j)'th entry is }
{\f2\uldb df}{\v\f2 DF} 
{\f2 (<expr\_list> 
(i),<variable\_list>(j)). 
\par 
\par 
The matrix is n by m where n is the number of variables and m the number 
of expressions. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
  \par
jacobian(\{x^4,x*y^2,x*y*z^3\},\{w,x,y,z\});  \par
 \par
 \par
  [      3                 ] \par
  [0  4*x     0       0    ] \par
  [                        ] \par
  [     2                  ] \par
  [0   y    2*x*y     0    ] \par
  [                        ] \par
  [      3     3          2] \par
  [0  y*z   x*z    3*x*y*z ] \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb hessian}{\v\f2 hessian} 
{\f2 , }
{\f2\uldb df}{\v\f2 DF} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # jordan_block}

${\footnote \pard\plain \sl240 \fs20 $ jordan_block}

+{\footnote \pard\plain \sl240 \fs20 + g38:1204}

 K{\footnote \pard\plain \sl240 \fs20 K jordan_block operator;operator}

}{\b\f2 JORDAN_BLOCK}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 jordan_block} {\f4 (<expr>,<square\_size>) 
\par 
\par 
}{\f2 \par 
<expr> :- an algebraic expression or symbol. 
\par 
\par 
<square\_size> :- a positive integer. 
\par 
\par 
}{\f3 jordan_block} {\f2 computes the square jordan block matrix J of 
dimension <square\_size>. 
\par 
\par 
The entries of J are: 
\par 
\par 
J(i,i) = <expr> for i=1 
 ... n, J(i,i+1) = 1 for i=1 
 ... n-1, and all other entries are 0. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
jordan\_block(x,5);  \par
 \par
  [x  1  0  0  0] \par
  [             ] \par
  [0  x  1  0  0] \par
  [             ] \par
  [0  0  x  1  0] \par
  [             ] \par
  [0  0  0  x  1] \par
  [             ] \par
  [0  0  0  0  x] \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb diagonal}{\v\f2 diagonal} 
{\f2 , }
{\f2\uldb companion}{\v\f2 companion} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # lu_decom}

${\footnote \pard\plain \sl240 \fs20 $ lu_decom}

+{\footnote \pard\plain \sl240 \fs20 + g38:1205}

 K{\footnote \pard\plain \sl240 \fs20 K lu_decom operator;operator}

}{\b\f2 LU_DECOM}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 lu_decom} {\f4 (<matrix>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  containing either numeric entries 
 or imaginary entries with numeric coefficients. 
\par 
\par 
}{\f3 lu_decom} {\f2 performs LU decomposition on <matrix>, ie: it 
returns \{L,U\} where L is a lower diagonal }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 , U an 
upper diagonal }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  and A = LU. 
\par 
\par 
Caution: 
\par 
\par 
The algorithm used can swap the rows of <matrix> during the 
calculation. This means that LU does not equal <matrix> but a row 
equivalent of it. Due to this, }{\f3 lu_decom} {\f2  returns \{L,U,vec\}. 
The call }{\f3 convert(meta\{matrix} {\f2 ,vec)\} will return the matrix that has 
been decomposed, i.e: LU = convert(<matrix>,vec). 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
K := mat((1,3,5),(-4,3,7),(8,6,4));  \par
 \par
 \par
       [1   3  5] \par
       [        ] \par
  k := [-4  3  7] \par
       [        ] \par
       [8   6  4] \par
 \par
 \par
 \par
on rounded; \par
 \par
lu :=  lu_decom(K);  \par
 \par
  lu := \{ \par
         [8    0      0  ] \par
         [               ] \par
         [-4  6.0     0  ] \par
         [               ] \par
         [1   2.25  1.125] \par
         , \par
         [1  0.75  0.5] \par
         [            ] \par
         [0   1    1.5] \par
         [            ] \par
         [0   0     1 ] \par
         , \par
         [3 2 3]\} \par
 \par
 \par
 \par
first lu * second lu;  \par
 \par
  [8   6.0  4.0] \par
  [            ] \par
  [-4  3.0  7.0] \par
  [            ] \par
  [1   3.0  5.0] \par
 \par
 \par
 \par
convert(K,third lu);  \par
 \par
  P := mat((i+1,i+2,i+3),(4,5,2),(1,i,0)); \tab  \par
       [i + 1  i + 2  i + 3] \par
       [                   ] \par
  p := [  4      5      2  ] \par
       [                   ] \par
       [  1      i      0  ] \par
 \par
 \par
lu :=  lu_decom(P);  \par
 \par
  lu := \{ \par
         [  1        0                      0                ] \par
         [                                                   ] \par
         [  4     - 4*i + 5                 0                ] \par
         [                                                   ] \par
         [i + 1      3       0.414634146341*i + 2.26829268293] \par
         , \par
         [1  i                 0                ] \par
         [                                      ] \par
         [0  1  0.19512195122*i + 0.243902439024] \par
         [                                      ] \par
         [0  0                 1                ] \par
         , \par
         [3 2 3]\} \par
 \par
 \par
 \par
first lu * second lu;  \par
 \par
  [  1      i       0   ] \par
  [                     ] \par
  [  4      5      2.0  ] \par
  [                     ] \par
  [i + 1  i + 2  i + 3.0] \par
 \par
 \par
 \par
convert(P,third lu);  \par
 \par
  [  1      i      0  ] \par
  [                   ] \par
  [  4      5      2  ] \par
  [                   ] \par
  [i + 1  i + 2  i + 3] \par
 \par
\pard \sl240 }{\f2  
\par 
\par 
Related functions: }
{\f2\uldb cholesky}{\v\f2 cholesky} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # make_identity}

${\footnote \pard\plain \sl240 \fs20 $ make_identity}

+{\footnote \pard\plain \sl240 \fs20 + g38:1206}

 K{\footnote \pard\plain \sl240 \fs20 K make_identity operator;operator}

}{\b\f2 MAKE_IDENTITY}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 make_identity} {\f4 (<square\_size>) 
\par 
\par 
}{\f2 \par 
<square\_size> :- a positive integer. 
\par 
\par 
}{\f3 make_identity} {\f2 creates the identity matrix of dimension 
<square\_size>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
make_identity(4);  \par
 \par
  [1  0  0  0] \par
  [          ] \par
  [0  1  0  0] \par
  [          ] \par
  [0  0  1  0] \par
  [          ] \par
  [0  0  0  1] \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb diagonal}{\v\f2 diagonal} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # matrix_augment}

${\footnote \pard\plain \sl240 \fs20 $ matrix_augment}

+{\footnote \pard\plain \sl240 \fs20 + g38:1207}

 K{\footnote \pard\plain \sl240 \fs20 K matrix_augment operator;operator}

}{\b\f2 MATRIX_AUGMENT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
Matrix augment, matrix stack: 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 matrix_augment} {\f4 \{<matrix\_list>\} 
\par 
\par 
}{\f2 \par 
(If you are feeling lazy then the braces can be omitted.) 
\par 
\par 
<matrix\_list> :- matrices. 
\par 
\par 
}{\f3 matrix_augment} {\f2 sticks the matrices in <matrix\_list> 
together horizontally. 
\par 
\par 
}{\f3 matrix_stack} {\f2 sticks the matrices in <matrix\_list> 
together vertically. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
matrix_augment(\{A,A\});  \par
 \par
  [1  2  3  1  2  3] \par
  [                ] \par
  [4  5  6  4  5  6] \par
  [                ] \par
  [7  8  9  7  8  9] \par
 \par
 \par
 \par
matrix_stack(A,A);  \par
 \par
  [1  2  3] \par
  [       ] \par
  [4  5  6] \par
  [       ] \par
  [7  8  9] \par
  [       ] \par
  [1  2  3] \par
  [       ] \par
  [4  5  6] \par
  [       ] \par
  [7  8  9] \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb augment_columns}{\v\f2 augment_columns} 
{\f2 , }
{\f2\uldb stack_rows}{\v\f2 stack_rows} 
{\f2 , }
{\f2\uldb sub_matrix}{\v\f2 sub_matrix} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # matrixp}

${\footnote \pard\plain \sl240 \fs20 $ matrixp}

+{\footnote \pard\plain \sl240 \fs20 + g38:1208}

 K{\footnote \pard\plain \sl240 \fs20 K matrixp operator;operator}

}{\b\f2 MATRIXP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 matrixp} {\f4 (<test\_input>) 
\par 
\par 
}{\f2 \par 
<test\_input> :- anything you like. 
\par 
\par 
}{\f3 matrixp} {\f2 is a boolean function that returns t if the input is a 
matrix and nil otherwise. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
matrixp A;  \par
 \par
  t  \par
 \par
 \par
matrixp(doodlesackbanana); \par
 \par
  nil  \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb squarep}{\v\f2 squarep} 
{\f2 , }
{\f2\uldb symmetricp}{\v\f2 symmetricp} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # matrix_stack}

${\footnote \pard\plain \sl240 \fs20 $ matrix_stack}

+{\footnote \pard\plain \sl240 \fs20 + g38:1209}

 K{\footnote \pard\plain \sl240 \fs20 K matrix_stack operator;operator}

}{\b\f2 MATRIX_STACK}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
see: }
{\f2\uldb matrix_augment}{\v\f2 matrix_augment} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # minor}

${\footnote \pard\plain \sl240 \fs20 $ minor}

+{\footnote \pard\plain \sl240 \fs20 + g38:1210}

 K{\footnote \pard\plain \sl240 \fs20 K minor operator;operator}

}{\b\f2 MINOR}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 minor} {\f4 (<matrix>,<r>,<c>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
<r>,<c> :- positive integers. 
\par 
\par 
}{\f3 minor} {\f2 computes the (<r>,<c>)'th minor of <matrix>. 
This is created by removing the <r>'th row and the <c>'th 
column from <matrix>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
minor(A,1,3);  \par
 \par
  [4  5] \par
  [    ] \par
  [7  8] \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb remove_columns}{\v\f2 remove_columns} 
{\f2 , }
{\f2\uldb remove_rows}{\v\f2 remove_rows} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # mult_columns}

${\footnote \pard\plain \sl240 \fs20 $ mult_columns}

+{\footnote \pard\plain \sl240 \fs20 + g38:1211}

 K{\footnote \pard\plain \sl240 \fs20 K mult_columns operator;operator}

}{\b\f2 MULT_COLUMNS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
Mult columns, mult rows: 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 mult_columns} {\f4 (<matrix>,<column\_list>,<expr>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
\par 
\par 
<column\_list> :- a positive integer or a list of positive 
 integers. 
\par 
\par 
<expr> :- an algebraic expression. 
\par 
\par 
}{\f3 mult_columns} {\f2 returns a copy of <matrix> in which the 
columns specified in <column\_list> have been multiplied by 
<expr>. 
\par 
\par 
}{\f3 mult_rows} {\f2 performs the same task on the rows of <matrix>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
mult_columns(A,\{1,3\},x);  \par
 \par
  [ x   2  3*x] \par
  [           ] \par
  [4*x  5  6*x] \par
  [           ] \par
  [7*x  8  9*x] \par
 \par
 \par
 \par
mult_rows(A,2,10);  \par
 \par
  [1   2   3 ] \par
  [          ] \par
  [40  50  60] \par
  [          ] \par
  [7   8   9 ] \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb add_to_columns}{\v\f2 add_to_columns} 
{\f2 , }
{\f2\uldb add_to_rows}{\v\f2 add_to_rows} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # mult_rows}

${\footnote \pard\plain \sl240 \fs20 $ mult_rows}

+{\footnote \pard\plain \sl240 \fs20 + g38:1212}

 K{\footnote \pard\plain \sl240 \fs20 K mult_rows operator;operator}

}{\b\f2 MULT_ROWS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
see: }
{\f2\uldb mult_columns}{\v\f2 mult_columns} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # pivot}

${\footnote \pard\plain \sl240 \fs20 $ pivot}

+{\footnote \pard\plain \sl240 \fs20 + g38:1213}

 K{\footnote \pard\plain \sl240 \fs20 K pivot operator;operator}

}{\b\f2 PIVOT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 pivot} {\f4 (<matrix>,<r>,<c>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a matrix. 
\par 
\par 
<r>,<c> :- positive integers such that <matrix>(<r>, 
 <c>) neq 0. 
\par 
\par 
}{\f3 pivot} {\f2 pivots <matrix> about it's (<r>,<c>)'th 
entry. 
 \par 
\par 
To do this, multiples of the <r>'th row are added to every other 
row in the matrix. 
\par 
\par 
This means that the <c>'th column will be 0 except for the 
(<r>,<c>)'th entry. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
pivot(A,2,3);  \par
 \par
  [      - 1    ] \par
  [-1  ------  0] \par
  [      2      ] \par
  [             ] \par
  [4     5     6] \par
  [             ] \par
  [      1      ] \par
  [1    ---    0] \par
  [      2      ] \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb rows_pivot}{\v\f2 rows_pivot} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # pseudo_inverse}

${\footnote \pard\plain \sl240 \fs20 $ pseudo_inverse}

+{\footnote \pard\plain \sl240 \fs20 + g38:1214}

 K{\footnote \pard\plain \sl240 \fs20 K pseudo_inverse operator;operator}

}{\b\f2 PSEUDO_INVERSE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 pseudo_inverse} {\f4 (<matrix>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
\par 
\par 
}{\f3 pseudo_inverse} {\f2 , also known as the Moore-Penrose inverse, 
computes the pseudo inverse of <matrix>. 
\par 
\par 
Given the singular value decomposition of <matrix>, i.e: 
A = }{\f4 U*P*V^T}{\f2 , then the pseudo inverse }{\f4 A^-1}{\f2  is defined by 
}{\f4 A^-1 = V^T*P^-1*U}{\f2 . 
\par 
\par 
Thus <matrix> * pseudo_inverse(A) = Id. 
(Id is the identity matrix). 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
R := mat((1,2,3,4),(9,8,7,6));  \par
 \par
       [1  2  3  4] \par
  r := [          ] \par
       [9  8  7  6] \par
 \par
 \par
 \par
on rounded;  \par
 \par
pseudo_inverse(R);  \par
 \par
  [ - 0.199999999996      0.100000000013   ] \par
  [                                        ] \par
  [ - 0.0499999999988    0.0500000000037   ] \par
  [                                        ] \par
  [ 0.0999999999982     - 5.57825497203e-12] \par
  [                                        ] \par
  [  0.249999999995      - 0.0500000000148 ] \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb svd}{\v\f2 svd} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # random_matrix}

${\footnote \pard\plain \sl240 \fs20 $ random_matrix}

+{\footnote \pard\plain \sl240 \fs20 + g38:1215}

 K{\footnote \pard\plain \sl240 \fs20 K random_matrix operator;operator}

}{\b\f2 RANDOM_MATRIX}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 random_matrix} {\f4 (<r>,<c>,<limit>) 
\par 
\par 
}{\f2 \par 
<r>,<c>,<limit> :- positive integers. 
\par 
\par 
}{\f3 random_matrix} {\f2 creates an <r> by <c> matrix with random 
entries in the range -limit < entry < limit. 
\par 
\par 
Switches: 
\par 
\par 
}{\f3 imaginary} {\f2 :- if on then matrix entries are x+i*y where -limit < x,y 
 < <limit>. 
\par 
\par 
}{\f3 not_negative} {\f2 :- if on then 0 < entry < <limit>. In the imaginary 
 case we have 0 < x,y < <limit>. 
\par 
\par 
}{\f3 only_integer} {\f2 :- if on then each entry is an integer. In the imaginary 
		 case x and y are integers. 
\par 
\par 
}{\f3 symmetric} {\f2 :- if on then the matrix is symmetric. 
\par 
\par 
}{\f3 upper_matrix} {\f2 :- if on then the matrix is upper triangular. 
\par 
\par 
}{\f3 lower_matrix} {\f2 :- if on then the matrix is lower triangular. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
on rounded;  \par
 \par
random_matrix(3,3,10);  \par
 \par
  [ - 8.11911717343    - 5.71677292768   0.620580830035 ] \par
  [                                                     ] \par
  [ - 0.032596262422    7.1655452861     5.86742633837  ] \par
  [                                                     ] \par
  [ - 9.37155438255    - 7.55636708637   - 8.88618627557] \par
 \par
 \par
 \par
on only_integer, not_negative, upper_matrix, imaginary;  \par
 \par
random_matrix(4,4,10);  \par
 \par
  [70*i + 15  28*i + 8   2*i + 79   27*i + 44] \par
  [                                          ] \par
  [    0      46*i + 95  9*i + 63   95*i + 50] \par
  [                                          ] \par
  [    0          0      31*i + 75  14*i + 65] \par
  [                                          ] \par
  [    0          0          0      5*i + 52 ] \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # remove_columns}

${\footnote \pard\plain \sl240 \fs20 $ remove_columns}

+{\footnote \pard\plain \sl240 \fs20 + g38:1216}

 K{\footnote \pard\plain \sl240 \fs20 K remove_columns operator;operator}

}{\b\f2 REMOVE_COLUMNS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
Remove columns, remove rows: 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 remove_columns} {\f4 (<matrix>,<column\_list>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
<column\_list> :- either a positive integer or a list of positive 
 integers. 
\par 
\par 
}{\f3 remove_columns} {\f2 removes the columns specified in 
<column\_list> from <matrix>. 
\par 
\par 
}{\f3 remove_rows} {\f2 performs the same task on the rows of <matrix>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4   \par
 \par
remove_columns(A,2);  \par
 \par
  [1  3] \par
  [    ] \par
  [4  6] \par
  [    ] \par
  [7  9] \par
 \par
 \par
 \par
remove_rows(A,\{1,3\});  \par
 \par
  [4  5  6] \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb minor}{\v\f2 minor} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # remove_rows}

${\footnote \pard\plain \sl240 \fs20 $ remove_rows}

+{\footnote \pard\plain \sl240 \fs20 + g38:1217}

 K{\footnote \pard\plain \sl240 \fs20 K remove_rows operator;operator}

}{\b\f2 REMOVE_ROWS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
see: }
{\f2\uldb remove_columns}{\v\f2 remove_columns} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # row_dim}

${\footnote \pard\plain \sl240 \fs20 $ row_dim}

+{\footnote \pard\plain \sl240 \fs20 + g38:1218}

 K{\footnote \pard\plain \sl240 \fs20 K row_dim operator;operator}

}{\b\f2 ROW_DIM}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
see: }
{\f2\uldb column_dim}{\v\f2 column_dim} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # rows_pivot}

${\footnote \pard\plain \sl240 \fs20 $ rows_pivot}

+{\footnote \pard\plain \sl240 \fs20 + g38:1219}

 K{\footnote \pard\plain \sl240 \fs20 K rows_pivot operator;operator}

}{\b\f2 ROWS_PIVOT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 rows_pivot} {\f4 (<matrix>,<r>,<c>,\{<row\_list>\}) 
\par 
\par 
}{\f2 \par 
<matrix> :- a namerefmatrix. 
\par 
\par 
<r>,<c> :- positive integers such that <matrix>(<r>, 
 <c>) neq 0. 
\par 
\par 
<row\_list> :- positive integer or a list of positive integers. 
\par 
\par 
}{\f3 rows_pivot} {\f2 performs the same task as }{\f3 pivot} {\f2  but applies 
the pivot only to the rows specified in <row\_list>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
N := mat((1,2,3),(4,5,6),(7,8,9),(1,2,3),(4,5,6));  \par
 \par
 \par
       [1  2  3] \par
       [       ] \par
       [4  5  6] \par
       [       ] \par
  n := [7  8  9] \par
       [       ] \par
       [1  2  3] \par
       [       ] \par
       [4  5  6] \par
 \par
 \par
 \par
rows_pivot(N,2,3,\{4,5\});  \par
 \par
  [1     2     3] \par
  [             ] \par
  [4     5     6] \par
  [             ] \par
  [7     8     9] \par
  [             ] \par
  [      - 1    ] \par
  [-1  ------  0] \par
  [      2      ] \par
  [             ] \par
  [0     0     0] \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb pivot}{\v\f2 pivot} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # simplex}

${\footnote \pard\plain \sl240 \fs20 $ simplex}

+{\footnote \pard\plain \sl240 \fs20 + g38:1220}

 K{\footnote \pard\plain \sl240 \fs20 K simplex operator;operator}

}{\b\f2 SIMPLEX}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 simplex} {\f4 (<max/min>,<objective function>, 
\{<linear inequalities>\}) 
\par 
\par 
}{\f2 \par 
<max/min> :- either max or min (signifying maximize and 
			 minimize). 
\par 
\par 
<objective function> :- the function you are maximizing or 
			 minimizing. 
\par 
\par 
<linear inequalities> :- the constraint inequalities. Each one must 
 be of the form sum of variables ( 
 <=,=,>=) number. 
\par 
\par 
}{\f3 simplex} {\f2 applies the revised simplex algorithm to find the 
optimal(either maximum or minimum) value of the 
<objective function> under the linear inequality constraints. 
\par 
\par 
It returns \{optimal value,\{ values of variables at this optimal\}\}. 
\par 
\par 
The algorithm implies that all the variables are non-negative. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
 simplex(max,x+y,\{x>=10,y>=20,x+y<=25\});  \par
 \par
 \par
   ***** Error in simplex: Problem has no feasible solution \par
 \par
 \par
 \par
simplex(max,10x+5y+5.5z,\{5x+3z<=200,x+0.1y+0.5z<=12, \par
0.1x+0.2y+0.3z<=9, 30x+10y+50z<=1500\});  \par
 \par
 \par
  \{525.0,\{x=40.0,y=25.0,z=0\}\} \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # squarep}

${\footnote \pard\plain \sl240 \fs20 $ squarep}

+{\footnote \pard\plain \sl240 \fs20 + g38:1221}

 K{\footnote \pard\plain \sl240 \fs20 K squarep operator;operator}

}{\b\f2 SQUAREP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 squarep} {\f4 (<matrix>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
\par 
\par 
}{\f3 squarep} {\f2 is a predicate that returns t if the <matrix> is 
square and nil otherwise. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
squarep(mat((1,3,5)));  \par
 \par
  nil  \par
 \par
 \par
squarep(A); \par
t \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb matrixp}{\v\f2 matrixp} 
{\f2 , }
{\f2\uldb symmetricp}{\v\f2 symmetricp} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # stack_rows}

${\footnote \pard\plain \sl240 \fs20 $ stack_rows}

+{\footnote \pard\plain \sl240 \fs20 + g38:1222}

 K{\footnote \pard\plain \sl240 \fs20 K stack_rows operator;operator}

}{\b\f2 STACK_ROWS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
see: }
{\f2\uldb augment_columns}{\v\f2 augment_columns} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # sub_matrix}

${\footnote \pard\plain \sl240 \fs20 $ sub_matrix}

+{\footnote \pard\plain \sl240 \fs20 + g38:1223}

 K{\footnote \pard\plain \sl240 \fs20 K sub_matrix operator;operator}

}{\b\f2 SUB_MATRIX}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 sub_matrix} {\f4 (<matrix>,<row\_list>,<column\_list>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a matrix. 
<row\_list>, <column\_list> :- either a positive integer or a 
 list of positive integers. 
\par 
\par 
namesub_matrix produces the matrix consisting of the intersection of 
the rows specified in <row\_list> and the columns specified in 
<column\_list>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
sub_matrix(A,\{1,3\},\{2,3\});  \par
 \par
  [2  3] \par
  [    ] \par
  [8  9] \par
 \par
\pard \sl240 }{\f2 Related functions: 
}
{\f2\uldb augment_columns}{\v\f2 augment_columns} 
{\f2 , }
{\f2\uldb stack_rows}{\v\f2 stack_rows} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # svd}

${\footnote \pard\plain \sl240 \fs20 $ svd}

+{\footnote \pard\plain \sl240 \fs20 + g38:1224}

 K{\footnote \pard\plain \sl240 \fs20 K singular value decomposition;svd operator;operator}

}{\b\f2 SVD}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
 \par 
\par 
Singular value decomposition: 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 svd} {\f4 (<matrix>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  containing only numeric entries. 
\par 
\par 
}{\f3 svd} {\f2 computes the singular value decomposition of <matrix>. 
\par 
\par 
It returns 
\par 
\par 
\{U,P,V\} 
\par 
\par 
where A = }{\f4 U*P*V^T}{\f2  
\par 
\par 
and P = diag(sigma(1) ... sigma(n)). 
\par 
\par 
sigma(i) for i= 1 ... n are the singular values of 
<matrix>. 
\par 
\par 
n is the column dimension of <matrix>. 
\par 
\par 
The singular values of <matrix> are the non-negative square roots 
of the eigenvalues of }{\f4 A^T*A}{\f2 . 
\par 
\par 
U and V are such that }{\f4 U*U^T = V*V^T = V^T*V}{\f2  = Id. 
Id is the identity matrix. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
Q := mat((1,3),(-4,3));  \par
 \par
       [1   3] \par
  q := [     ] \par
       [-4  3] \par
 \par
 \par
 \par
on rounded;  \par
 \par
svd(Q);  \par
 \par
  \{ \par
   [ 0.289784137735    0.957092029805] \par
   [                                 ] \par
   [ - 0.957092029805  0.289784137735] \par
   , \par
   [5.1491628629       0      ] \par
   [                          ] \par
   [     0        2.9130948854] \par
   , \par
   [ - 0.687215403194   0.726453707825  ] \par
   [                                    ] \par
   [ - 0.726453707825   - 0.687215403194] \par
  \} \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # swap_columns}

${\footnote \pard\plain \sl240 \fs20 $ swap_columns}

+{\footnote \pard\plain \sl240 \fs20 + g38:1225}

 K{\footnote \pard\plain \sl240 \fs20 K swap_columns operator;operator}

}{\b\f2 SWAP_COLUMNS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
Swap columns, swap rows: 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 swap_columns} {\f4 (<matrix>,<c1>,<c2>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
\par 
\par 
<c1>,<c1> :- positive integers. 
 \par 
\par 
}{\f3 swap_columns} {\f2 swaps column <c1> of <matrix> with 
column <c2>. 
\par 
\par 
}{\f3 swap_rows} {\f2 performs the same task on two rows of <matrix>. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
swap_columns(A,2,3);  \par
 \par
  [1  3  2] \par
  [       ] \par
  [4  6  5] \par
  [       ] \par
  [7  9  8] \par
 \par
 \par
 \par
swap_rows(A,1,3);  \par
 \par
  [7  8  9] \par
  [       ] \par
  [4  5  6] \par
  [       ] \par
  [1  2  3] \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb swap_entries}{\v\f2 swap_entries} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # swap_entries}

${\footnote \pard\plain \sl240 \fs20 $ swap_entries}

+{\footnote \pard\plain \sl240 \fs20 + g38:1226}

 K{\footnote \pard\plain \sl240 \fs20 K swap_entries operator;operator}

}{\b\f2 SWAP_ENTRIES}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 swap_entries} {\f4 (<matrix>,\{<r1>,<c1>\},\{<r2>, 
<c2>\}) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
\par 
\par 
<r1>,<c1>,<r2>,<c2> :- positive integers. 
\par 
\par 
}{\f3 swap_entries} {\f2 swaps <matrix>(<r1>,<c1>) with 
<matrix>(<r2>,<c2>). 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
swap_entries(A,\{1,1\},\{3,3\});  \par
 \par
  [9  2  3] \par
  [       ] \par
  [4  5  6] \par
  [       ] \par
  [7  8  1] \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb swap_columns}{\v\f2 swap_columns} 
{\f2 , }
{\f2\uldb swap_rows}{\v\f2 swap_rows} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # swap_rows}

${\footnote \pard\plain \sl240 \fs20 $ swap_rows}

+{\footnote \pard\plain \sl240 \fs20 + g38:1227}

 K{\footnote \pard\plain \sl240 \fs20 K swap_rows operator;operator}

}{\b\f2 SWAP_ROWS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
see: }
{\f2\uldb swap_columns}{\v\f2 swap_columns} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # symmetricp}

${\footnote \pard\plain \sl240 \fs20 $ symmetricp}

+{\footnote \pard\plain \sl240 \fs20 + g38:1228}

 K{\footnote \pard\plain \sl240 \fs20 K symmetricp operator;operator}

}{\b\f2 SYMMETRICP}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 symmetricp} {\f4 (<matrix>) 
\par 
\par 
}{\f2 \par 
<matrix> :- a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2 . 
\par 
\par 
}{\f3 symmetricp} {\f2 is a predicate that returns t if the matrix is symmetric 
and nil otherwise. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
symmetricp(make_identity(11));  \par
 \par
  t  \par
 \par
 \par
symmetricp(A);  \par
 \par
  nil \par
 \par
\pard \sl240 }{\f2 Related functions: }
{\f2\uldb matrixp}{\v\f2 matrixp} 
{\f2 , }
{\f2\uldb squarep}{\v\f2 squarep} 
{\f2 . 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # toeplitz}

${\footnote \pard\plain \sl240 \fs20 $ toeplitz}

+{\footnote \pard\plain \sl240 \fs20 + g38:1229}

 K{\footnote \pard\plain \sl240 \fs20 K toeplitz operator;operator}

}{\b\f2 TOEPLITZ}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 toeplitz} {\f4 (<expr\_list>) 
\par 
\par 
}{\f2 \par 
(If you are feeling lazy then the braces can be omitted.) 
\par 
\par 
<expr\_list> :- list of algebraic expressions. 
\par 
\par 
}{\f3 toeplitz} {\f2 creates the toeplitz matrix from the <expr\_list>. 
\par 
\par 
This is a square symmetric matrix in which the first expression is 
placed on the diagonal and the i'th expression is placed on the (i-1)'th 
sub and super diagonals. 
\par 
\par 
It has dimension n where n is the number of expressions. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
toeplitz(\{w,x,y,z\});  \par
 \par
  [w  x  y  z] \par
  [          ] \par
  [x  w  x  y] \par
  [          ] \par
  [y  x  w  x] \par
  [          ] \par
  [z  y  x  w] \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # vandermonde}

${\footnote \pard\plain \sl240 \fs20 $ vandermonde}

+{\footnote \pard\plain \sl240 \fs20 + g38:1230}

 K{\footnote \pard\plain \sl240 \fs20 K vandermonde operator;operator}

}{\b\f2 VANDERMONDE}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 vandermonde} {\f4 (\{<expr\_list>\}) 
\par 
\par 
}{\f2 \par 
(If you are feeling lazy then the braces can be omitted.) 
\par 
\par 
<expr\_list> :- list of algebraic expressions. 
\par 
\par 
}{\f3 vandermonde} {\f2 creates the vandermonde matrix from the 
<expr\_list>. 
\par 
\par 
This is the square matrix in which the (i,j)'th entry is 
<expr\_list>}{\f4 (i)^(j-1)}{\f2 . 
\par 
\par 
It has dimension n where n is the number of expressions. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4               \par
vandermonde(\{x,2*y,3*z\});  \par
 \par
 \par
  [          2 ] \par
  [1   x    x  ] \par
  [            ] \par
  [           2] \par
  [1  2*y  4*y ] \par
  [            ] \par
  [           2] \par
  [1  3*z  9*z ] \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # g38}

${\footnote \pard\plain \sl240 \fs20 $ Linear Algebra package}

+{\footnote \pard\plain \sl240 \fs20 + index:0038}
}{\b\f2 Linear Algebra package}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb Linear Algebra package introduction}
{\v\f2 Linear_Algebra_package}{\f2 \par 
}{\f2 \tab}{\f2\uldb fast_la switch}
{\v\f2 fast_la}{\f2 \par 
}{\f2 \tab}{\f2\uldb add_columns operator}
{\v\f2 add_columns}{\f2 \par 
}{\f2 \tab}{\f2\uldb add_rows operator}
{\v\f2 add_rows}{\f2 \par 
}{\f2 \tab}{\f2\uldb add_to_columns operator}
{\v\f2 add_to_columns}{\f2 \par 
}{\f2 \tab}{\f2\uldb add_to_rows operator}
{\v\f2 add_to_rows}{\f2 \par 
}{\f2 \tab}{\f2\uldb augment_columns operator}
{\v\f2 augment_columns}{\f2 \par 
}{\f2 \tab}{\f2\uldb band_matrix operator}
{\v\f2 band_matrix}{\f2 \par 
}{\f2 \tab}{\f2\uldb block_matrix operator}
{\v\f2 block_matrix}{\f2 \par 
}{\f2 \tab}{\f2\uldb char_matrix operator}
{\v\f2 char_matrix}{\f2 \par 
}{\f2 \tab}{\f2\uldb char_poly operator}
{\v\f2 char_poly}{\f2 \par 
}{\f2 \tab}{\f2\uldb cholesky operator}
{\v\f2 cholesky}{\f2 \par 
}{\f2 \tab}{\f2\uldb coeff_matrix operator}
{\v\f2 coeff_matrix}{\f2 \par 
}{\f2 \tab}{\f2\uldb column_dim operator}
{\v\f2 column_dim}{\f2 \par 
}{\f2 \tab}{\f2\uldb companion operator}
{\v\f2 companion}{\f2 \par 
}{\f2 \tab}{\f2\uldb copy_into operator}
{\v\f2 copy_into}{\f2 \par 
}{\f2 \tab}{\f2\uldb diagonal operator}
{\v\f2 diagonal}{\f2 \par 
}{\f2 \tab}{\f2\uldb extend operator}
{\v\f2 extend}{\f2 \par 
}{\f2 \tab}{\f2\uldb find_companion operator}
{\v\f2 find_companion}{\f2 \par 
}{\f2 \tab}{\f2\uldb get_columns operator}
{\v\f2 get_columns}{\f2 \par 
}{\f2 \tab}{\f2\uldb get_rows operator}
{\v\f2 get_rows}{\f2 \par 
}{\f2 \tab}{\f2\uldb gram_schmidt operator}
{\v\f2 gram_schmidt}{\f2 \par 
}{\f2 \tab}{\f2\uldb hermitian_tp operator}
{\v\f2 hermitian_tp}{\f2 \par 
}{\f2 \tab}{\f2\uldb hessian operator}
{\v\f2 hessian}{\f2 \par 
}{\f2 \tab}{\f2\uldb hilbert operator}
{\v\f2 hilbert}{\f2 \par 
}{\f2 \tab}{\f2\uldb jacobian operator}
{\v\f2 jacobian}{\f2 \par 
}{\f2 \tab}{\f2\uldb jordan_block operator}
{\v\f2 jordan_block}{\f2 \par 
}{\f2 \tab}{\f2\uldb lu_decom operator}
{\v\f2 lu_decom}{\f2 \par 
}{\f2 \tab}{\f2\uldb make_identity operator}
{\v\f2 make_identity}{\f2 \par 
}{\f2 \tab}{\f2\uldb matrix_augment operator}
{\v\f2 matrix_augment}{\f2 \par 
}{\f2 \tab}{\f2\uldb matrixp operator}
{\v\f2 matrixp}{\f2 \par 
}{\f2 \tab}{\f2\uldb matrix_stack operator}
{\v\f2 matrix_stack}{\f2 \par 
}{\f2 \tab}{\f2\uldb minor operator}
{\v\f2 minor}{\f2 \par 
}{\f2 \tab}{\f2\uldb mult_columns operator}
{\v\f2 mult_columns}{\f2 \par 
}{\f2 \tab}{\f2\uldb mult_rows operator}
{\v\f2 mult_rows}{\f2 \par 
}{\f2 \tab}{\f2\uldb pivot operator}
{\v\f2 pivot}{\f2 \par 
}{\f2 \tab}{\f2\uldb pseudo_inverse operator}
{\v\f2 pseudo_inverse}{\f2 \par 
}{\f2 \tab}{\f2\uldb random_matrix operator}
{\v\f2 random_matrix}{\f2 \par 
}{\f2 \tab}{\f2\uldb remove_columns operator}
{\v\f2 remove_columns}{\f2 \par 
}{\f2 \tab}{\f2\uldb remove_rows operator}
{\v\f2 remove_rows}{\f2 \par 
}{\f2 \tab}{\f2\uldb row_dim operator}
{\v\f2 row_dim}{\f2 \par 
}{\f2 \tab}{\f2\uldb rows_pivot operator}
{\v\f2 rows_pivot}{\f2 \par 
}{\f2 \tab}{\f2\uldb simplex operator}
{\v\f2 simplex}{\f2 \par 
}{\f2 \tab}{\f2\uldb squarep operator}
{\v\f2 squarep}{\f2 \par 
}{\f2 \tab}{\f2\uldb stack_rows operator}
{\v\f2 stack_rows}{\f2 \par 
}{\f2 \tab}{\f2\uldb sub_matrix operator}
{\v\f2 sub_matrix}{\f2 \par 
}{\f2 \tab}{\f2\uldb svd operator}
{\v\f2 svd}{\f2 \par 
}{\f2 \tab}{\f2\uldb swap_columns operator}
{\v\f2 swap_columns}{\f2 \par 
}{\f2 \tab}{\f2\uldb swap_entries operator}
{\v\f2 swap_entries}{\f2 \par 
}{\f2 \tab}{\f2\uldb swap_rows operator}
{\v\f2 swap_rows}{\f2 \par 
}{\f2 \tab}{\f2\uldb symmetricp operator}
{\v\f2 symmetricp}{\f2 \par 
}{\f2 \tab}{\f2\uldb toeplitz operator}
{\v\f2 toeplitz}{\f2 \par 
}{\f2 \tab}{\f2\uldb vandermonde operator}
{\v\f2 vandermonde}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Smithex}

${\footnote \pard\plain \sl240 \fs20 $ Smithex}

+{\footnote \pard\plain \sl240 \fs20 + g39:1231}

 K{\footnote \pard\plain \sl240 \fs20 K Smithex operator;operator}

}{\b\f2 SMITHEX}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The operator }{\f3 smithex} {\f2  computes the Smith normal form S of a 
}
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  A (say). It returns \{S,P,}{\f4 P^-1}{\f2 \} where }{\f4 P*S*P^-1 = A}{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 smithex} {\f4 (<matrix>,<variable>) 
\par 
\par 
<matrix> :- a rectangular }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f4  of univariate polynomials in 
 <variable>. 
<variable> :- the variable. 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 a := mat((x,x+1),(0,3*x^2));  \par
 \par
        [x  x + 1] \par
        [        ] \par
   a := [      2 ] \par
        [0  3*x  ] \par
 \par
 \par
 \par
 smithex(a,x);  \par
 \par
     [1  0 ]    [1    0]    [x   x + 1] \par
  \{  [     ],   [      ],   [         ]  \} \par
     [    3]    [   2  ]    [         ] \par
     [0  x ]    [3*x  1]    [-3    -3 ] \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # Smithex\_int}

${\footnote \pard\plain \sl240 \fs20 $ Smithex_int}

+{\footnote \pard\plain \sl240 \fs20 + g39:1232}

 K{\footnote \pard\plain \sl240 \fs20 K Smithex_int operator;operator}

}{\b\f2 SMITHEX\_INT}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The operator }{\f3 smithex_int} {\f2  performs the same task as }{\f3 smithex} {\f2  
but on matrices containing only integer entries. Namely, 
}{\f3 smithex_int} {\f2  returns \{S,P,}{\f4 P^-1}{\f2 \} where S is the smith normal 
form of the input }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  (A say), and }{\f4 P*S*P^-1 = A}{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 smithex_int} {\f4 (<matrix>) 
\par 
\par 
<matrix> :- a rectangular }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f4  of integer entries. 
\par 
\par 
}{\f2 \par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 a := mat((9,-36,30),(-36,192,-180),(30,-180,180));  \par
 \par
 \par
       [ 9   -36    30 ] \par
       [               ] \par
  a := [-36  192   -180] \par
       [               ] \par
       [30   -180  180 ] \par
 \par
 \par
 \par
 smithex_int(a);  \par
 \par
    [3  0   0 ]    [-17  -5   -4 ]    [1   -24  30 ] \par
    [         ]    [             ]    [            ] \par
  \{ [0  12  0 ],   [64   19   15 ],   [-1  25   -30] \} \par
    [         ]    [             ]    [            ]  \par
    [0  0   60]    [-50  -15  -12]    [0   -1    1 ]  \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # Frobenius}

${\footnote \pard\plain \sl240 \fs20 $ Frobenius}

+{\footnote \pard\plain \sl240 \fs20 + g39:1233}

 K{\footnote \pard\plain \sl240 \fs20 K Frobenius operator;operator}

}{\b\f2 FROBENIUS}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The operator }{\f3 frobenius} {\f2  computes the }{\f3 frobenius} {\f2  normal form F of a 
}
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  (A say). It returns \{F,P,}{\f4 P^-1}{\f2 \} where }{\f4 P*F*P^-1 = A}{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 frobenius} {\f4 (<matrix>) 
\par 
\par 
<matrix> :- a square }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f4 . 
\par 
\par 
}{\f2 \par 
Field Extensions: 
\par 
\par 
By default, calculations are performed in the rational numbers. To 
extend this field the }
{\f2\uldb arnum}{\v\f2 ARNUM} 
{\f2  package can be used. The package must 
first be loaded by load_package arnum;. The field can now be extended 
by using the defpoly command. For example, defpoly sqrt2**2-2; will 
extend the field to include the square root of 2 (now defined by sqrt2). 
\par 
\par 
Modular Arithmetic: 
\par 
\par 
}{\f3 Frobenius} {\f2 can also be calculated in a modular base. To do this 
first type on modular;. Then setmod p; (where p is a prime) will set 
the modular base of calculation to p. By further typing on balanced_mod 
the answer will appear using a symmetric modular representation. See 
}
{\f2\uldb ratjordan}{\v\f2 Ratjordan} 
{\f2  for an example. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 a := mat((x,x^2),(3,5*x));  \par
 \par
       [    2 ] \par
       [x  x  ] \par
  a := [      ] \par
       [3  5*x] \par
 \par
 \par
 frobenius(a); \par
 \par
     [         2]    [1  x]    [       - x ] \par
  \{  [0   - 2*x ],   [    ],   [1     -----]  \} \par
     [          ]    [0  3]    [        3  ] \par
     [1    6*x  ]              [           ] \par
                               [        1  ] \par
                               [0      --- ] \par
                               [        3  ] \par
 \par
 \par
 load\_package arnum; \par
 \par
 defpoly sqrt2**2-2; \par
 \par
 a := mat((sqrt2,5),(7*sqrt2,sqrt2)); \par
 \par
 \par
       [ sqrt2     5  ] \par
  a := [              ] \par
       [7*sqrt2  sqrt2] \par
 \par
 \par
 \par
 frobenius(a);  \par
 \par
    [0  35*sqrt2 - 2]    [1   sqrt2 ]    [           1  ] \par
  \{ [               ],   [          ],   [1       - --- ]  \} \par
    [1    2*sqrt2   ]    [1  7*sqrt2]    [           7  ] \par
                                         [              ] \par
                                         [     1        ] \par
                                         [0   ----*sqrt2] \par
                                         [     14       ] \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # Ratjordan}

${\footnote \pard\plain \sl240 \fs20 $ Ratjordan}

+{\footnote \pard\plain \sl240 \fs20 + g39:1234}

 K{\footnote \pard\plain \sl240 \fs20 K Ratjordan operator;operator}

}{\b\f2 RATJORDAN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The operator }{\f3 ratjordan} {\f2  computes the rational Jordan normal form R 
of a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  (A say). It returns \{R,P,}{\f4 P^-1}{\f2 \} where }{\f4 P*R*P^-1 = A}{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 ratjordan} {\f4 (<matrix>) 
\par 
\par 
<matrix> :- a square }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f4 . 
\par 
\par 
}{\f2 \par 
Field Extensions: 
\par 
\par 
By default, calculations are performed in the rational numbers. To 
extend this field the }{\f3 arnum} {\f2  package can be used. The package must 
first be loaded by load_package arnum;. The field can now be extended 
by using the defpoly command. For example, defpoly sqrt2**2-2; will 
extend the field to include the square root of 2 (now defined by sqrt2). 
See }
{\f2\uldb frobenius}{\v\f2 Frobenius} 
{\f2  for an example. 
\par 
\par 
Modular Arithmetic: 
\par 
\par 
}{\f3 ratjordan} {\f2 can also be calculated in a modular base. To do this 
first type on modular;. Then setmod p; (where p is a prime) will set 
the modular base of calculation to p. By further typing on balanced_mod 
the answer will appear using a symmetric modular representation. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 a := mat((5,4*x),(2,x^2)); \par
 \par
       [5  4*x] \par
       [      ] \par
  a := [    2 ] \par
       [2  x  ] \par
 \par
 \par
 \par
 ratjordan(a);  \par
 \par
    [0  x*( - 5*x + 8)]   [1  5]    [        -5 ]   \par
  \{ [                 ],  [    ],   [1     -----] \} \par
    [        2        ]   [0  2]    [        2  ] \par
    [1      x  + 5    ]             [           ] \par
                                    [        1  ] \par
                                    [0     -----] \par
                                    [        2  ] \par
 \par
 \par
 on modular;  \par
 \par
 setmod 23;  \par
 \par
 a := mat((12,34),(56,78));  \par
 \par
       [12  11] \par
  a := [      ] \par
       [10  9 ] \par
 \par
 \par
 \par
 ratjordan(a);  \par
 \par
    [15  0]   [16  8]   [1  21] \par
  \{ [     ],  [     ],  [     ]  \} \par
    [0   6]   [19  4]   [1  4 ] \par
 \par
 \par
 \par
 on balanced\_mod; \par
 \par
 ratjordan(a); \par
 \par
    [- 8  0]   [ - 7  8]   [1  - 2] \par
  \{ [      ],  [       ],  [      ]  \} \par
    [ 0   6]   [ - 4  4]   [1   4 ] \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # Jordansymbolic}

${\footnote \pard\plain \sl240 \fs20 $ Jordansymbolic}

+{\footnote \pard\plain \sl240 \fs20 + g39:1235}

 K{\footnote \pard\plain \sl240 \fs20 K Jordansymbolic operator;operator}

}{\b\f2 JORDANSYMBOLIC}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The operator }{\f3 jordansymbolic} {\f2  computes the Jordan normal form J 
of a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  (A say). It returns \{J,L,P,}{\f4 P^-1}{\f2 \} where 
}{\f4 P*J*P^-1 = A}{\f2 . L = \{ll,mm\} where mm is a name and ll is a list of 
irreducible factors of p(mm). 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 jordansymbolic} {\f4 (<matrix>) 
\par 
\par 
<matrix> :- a square }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f4 . 
\par 
\par 
}{\f2 \par 
Field Extensions: 
\par 
\par 
By default, calculations are performed in the rational numbers. To 
extend this field the }
{\f2\uldb arnum}{\v\f2 ARNUM} 
{\f2  package can be used. The package must 
first be loaded by load_package arnum;. The field can now be extended 
by using the defpoly command. For example, defpoly sqrt2**2-2; will 
extend the field to include the square root of 2 (now defined by sqrt2). 
See }
{\f2\uldb frobenius}{\v\f2 Frobenius} 
{\f2  for an example. 
\par 
\par 
Modular Arithmetic: 
\par 
\par 
}{\f3 jordansymbolic} {\f2 can also be calculated in a modular base. To do this 
first type on modular;. Then setmod p; (where p is a prime) will set 
the modular base of calculation to p. By further typing on balanced_mod 
the answer will appear using a symmetric modular representation. See 
}
{\f2\uldb ratjordan}{\v\f2 Ratjordan} 
{\f2  for an example. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
 a := mat((1,y),(2,5*y));  \par
 \par
       [1   y ] \par
  a := [      ] \par
       [2  5*y] \par
 \par
 \par
 \par
 jordansymbolic(a);  \par
 \par
  \{ \par
   [lambda11     0    ] \par
   [                  ] \par
   [   0      lambda12] \par
   , \par
           2 \par
   lambda  - 5*lambda*y - lambda + 3*y,lambda, \par
   [lambda11 - 5*y  lambda12 - 5*y] \par
   [                              ] \par
   [      2               2       ] \par
   , \par
   [ 2*lambda11 - 5*y - 1    5*lambda11*y - lambda11 - y + 1 ] \par
   [----------------------  ---------------------------------] \par
   [       2                              2                  ] \par
   [   25*y  - 2*y + 1             2*(25*y  - 2*y + 1)       ] \par
   [                                                         ] \par
   [ 2*lambda12 - 5*y - 1    5*lambda12*y - lambda12 - y + 1 ] \par
   [----------------------  ---------------------------------] \par
   [       2                              2                  ] \par
   [   25*y  - 2*y + 1             2*(25*y  - 2*y + 1)       ] \par
   \} \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # Jordan}

${\footnote \pard\plain \sl240 \fs20 $ Jordan}

+{\footnote \pard\plain \sl240 \fs20 + g39:1236}

 K{\footnote \pard\plain \sl240 \fs20 K Jordan operator;operator}

}{\b\f2 JORDAN}{\f2 \tab \tab \tab \tab }{\b\f2 operator}{\f2 \par 
\par 
 
The operator }{\f3 jordan} {\f2  computes the Jordan normal form J 
of a }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f2  (A say). It returns \{J,P,}{\f4 P^-1}{\f2 \} where }{\f4 P*J*P^-1 = A}{\f2 . 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 jordan} {\f4 (<matrix>) 
\par 
\par 
<matrix> :- a square }
{\f2\uldb matrix}{\v\f2 MATRIX} 
{\f4 . 
\par 
\par 
}{\f2 \par 
Field Extensions: 
By default, calculations are performed in the rational numbers. To 
extend this field the }{\f3 arnum} {\f2  package can be used. The package must 
first be loaded by load_package arnum;. The field can now be extended 
by using the defpoly command. For example, defpoly sqrt2**2-2; will 
extend the field to include the square root of 2 (now defined by sqrt2). 
See }
{\f2\uldb frobenius}{\v\f2 Frobenius} 
{\f2  for an example. 
\par 
\par 
Modular Arithmetic: 
}{\f3 Jordan} {\f2  can also be calculated in a modular base. To do this 
first type on modular;. Then setmod p; (where p is a prime) will set 
the modular base of calculation to p. By further typing on balanced_mod 
the answer will appear using a symmetric modular representation. See 
}
{\f2\uldb ratjordan}{\v\f2 Ratjordan} 
{\f2  for an example. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4  \par
 \par
 a := mat((1,x),(0,x));  \par
 \par
       [1  x] \par
  a := [    ] \par
       [0  x] \par
 \par
 \par
 \par
 jordan(a); \par
 \par
  \{ \par
   [1  0] \par
   [    ] \par
   [0  x] \par
   , \par
   [   1           x       ] \par
   [-------  --------------] \par
   [ x - 1     2           ] \par
   [          x  - 2*x + 1 ] \par
   [                       ] \par
   [               1       ] \par
   [   0        -------    ] \par
   [             x - 1     ] \par
   , \par
   [x - 1   - x ] \par
   [            ] \par
   [  0    x - 1] \par
   \} \par
 \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # g39}

${\footnote \pard\plain \sl240 \fs20 $ Matrix Normal Forms}

+{\footnote \pard\plain \sl240 \fs20 + index:0039}
}{\b\f2 Matrix Normal Forms}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb Smithex operator}
{\v\f2 Smithex}{\f2 \par 
}{\f2 \tab}{\f2\uldb Smithex\_int operator}
{\v\f2 Smithex\_int}{\f2 \par 
}{\f2 \tab}{\f2\uldb Frobenius operator}
{\v\f2 Frobenius}{\f2 \par 
}{\f2 \tab}{\f2\uldb Ratjordan operator}
{\v\f2 Ratjordan}{\f2 \par 
}{\f2 \tab}{\f2\uldb Jordansymbolic operator}
{\v\f2 Jordansymbolic}{\f2 \par 
}{\f2 \tab}{\f2\uldb Jordan operator}
{\v\f2 Jordan}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # Miscellaneous_Packages}

${\footnote \pard\plain \sl240 \fs20 $ Miscellaneous_Packages}

+{\footnote \pard\plain \sl240 \fs20 + g40:1237}

 K{\footnote \pard\plain \sl240 \fs20 K Miscellaneous Packages introduction;introduction}

}{\b\f2 MISCELLANEOUS PACKAGES}{\f2 \tab \tab \tab \tab }{\b\f2 introduction}{\f2 \par 
\par 
 
REDUCE includes a large number of packages that have been contributed by 
users from various fields. Some of these, together with their relevant 
commands, switches and so on (e.g., the NUMERIC package), have 
been described elsewhere. This section describes those packages for which 
no separate help material exists. Each has its own switches, commands, 
and operators, and some redefine special characters to aid in their 
notation. However, the brief descriptions given here do not include all 
such information. Readers are referred to the general package 
documentation in this case, which can be found, along with the source 
code, under the subdirectories }{\f3 doc} {\f2  and }{\f3 src} {\f2  in the 
}{\f3 reduce} {\f2  directory. The }
{\f2\uldb load_package}{\v\f2 LOAD\_PACKAGE} 
{\f2  command is used to 
load the files you wish into your system. There will be a short delay 
while the package is loaded. A package cannot be unloaded. Once it 
is in your system, it stays there until you end the session. Each package 
also has a test file, which you will find under its name in the 
}{\f3 $reduce/xmpl} {\f2  directory. 
\par 
\par 
Finally, it should be mentioned that such user-contributed packages are 
unsupported; any questions or problems should be directed to their 
authors. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ALGINT_package}

${\footnote \pard\plain \sl240 \fs20 $ ALGINT_package}

+{\footnote \pard\plain \sl240 \fs20 + g40:1238}

 K{\footnote \pard\plain \sl240 \fs20 K integration of square roots;integration;ALGINT package;package}

}{\b\f2 ALGINT}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: James H. Davenport 
\par 
\par 
The }{\f3 algint} {\f2  package provides indefinite integration of square roots. 
This package, which is an extension of the basic integration package 
distributed with REDUCE, will analytically integrate a wide range of 
expressions involving square roots. The }
{\f2\uldb algint}{\v\f2 ALGINT} 
{\f2  switch provides for 
the use of the facilities given by the package, and is automatically turned 
on when the package is loaded. If you want to return to the standard 
integration algorithms, turn }
{\f2\uldb algint}{\v\f2 ALGINT} 
{\f2  off. An error message is given 
if you try to turn the }
{\f2\uldb algint}{\v\f2 ALGINT} 
{\f2  switch on when its package is not 
loaded. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # APPLYSYM}

${\footnote \pard\plain \sl240 \fs20 $ APPLYSYM}

+{\footnote \pard\plain \sl240 \fs20 + g40:1239}

 K{\footnote \pard\plain \sl240 \fs20 K symmetries;differential equations;APPLYSYM package;package}

}{\b\f2 APPLYSYM}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Thomas Wolf 
\par 
\par 
This package provides programs APPLYSYM, QUASILINPDE and DETRAFO for 
computing with infinitesimal symmetries of differential equations. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ARNUM}

${\footnote \pard\plain \sl240 \fs20 $ ARNUM}

+{\footnote \pard\plain \sl240 \fs20 + g40:1240}

 K{\footnote \pard\plain \sl240 \fs20 K algebraic numbers;ARNUM package;package}

}{\b\f2 ARNUM}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Eberhard Schruefer 
\par 
\par 
This package provides facilities for handling algebraic numbers as polynomial 
coefficients in REDUCE calculations. It includes facilities for introducing 
indeterminates to represent algebraic numbers, for calculating splitting 
fields, and for factoring and finding greatest common divisors in such 
domains. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ASSIST}

${\footnote \pard\plain \sl240 \fs20 $ ASSIST}

+{\footnote \pard\plain \sl240 \fs20 + g40:1241}

 K{\footnote \pard\plain \sl240 \fs20 K utilities;ASSIST package;package}

}{\b\f2 ASSIST}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Hubert Caprasse 
\par 
\par 
ASSIST contains a large number of additional general purpose functions 
that allow a user to better adapt REDUCE to various calculational 
strategies and to make the programming task more straightforward and more 
efficient. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # AVECTOR}

${\footnote \pard\plain \sl240 \fs20 $ AVECTOR}

+{\footnote \pard\plain \sl240 \fs20 + g40:1242}

 K{\footnote \pard\plain \sl240 \fs20 K dot product;cross product;vector algebra;AVECTOR package;package}

}{\b\f2 AVECTOR}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: David Harper 
\par 
\par 
This package provides REDUCE with the ability to perform vector algebra 
using the same notation as scalar algebra. The basic algebraic operations 
are supported, as are differentiation and integration of vectors with 
respect to scalar variables, cross product and dot product, component 
manipulation and application of scalar functions (e.g. cosine) to a vector 
to yield a vector result. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # BOOLEAN}

${\footnote \pard\plain \sl240 \fs20 $ BOOLEAN}

+{\footnote \pard\plain \sl240 \fs20 + g40:1243}

 K{\footnote \pard\plain \sl240 \fs20 K boolean expressions;BOOLEAN package;package}

}{\b\f2 BOOLEAN}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Herbert Melenk 
\par 
\par 
This package supports the computation with boolean expressions in the 
propositional calculus. The data objects are composed from algebraic 
expressions connected by the infix boolean operators and, or, 
 implies, equiv, and the unary prefix operator not. 
 Boolean allows you to simplify expressions built from these 
operators, and to test properties like equivalence, subset property etc. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CALI}

${\footnote \pard\plain \sl240 \fs20 $ CALI}

+{\footnote \pard\plain \sl240 \fs20 + g40:1244}

 K{\footnote \pard\plain \sl240 \fs20 K commutative algebra;Groebner;polynomial;CALI package;package}

}{\b\f2 CALI}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Hans-Gert Gr"abe 
\par 
\par 
This package contains algorithms for computations in commutative algebra 
closely related to the Groebner algorithm for ideals and modules. Its 
heart is a new implementation of the Groebner algorithm that also allows 
for the computation of syzygies. This implementation is also applicable to 
submodules of free modules with generators represented as rows of a matrix. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CAMAL}

${\footnote \pard\plain \sl240 \fs20 $ CAMAL}

+{\footnote \pard\plain \sl240 \fs20 + g40:1245}

 K{\footnote \pard\plain \sl240 \fs20 K Fourier series;celestial mechanics;CAMAL package;package}

}{\b\f2 CAMAL}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: John P. Fitch 
\par 
\par 
This package implements in REDUCE the Fourier transform procedures of the 
CAMAL package for celestial mechanics. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CHANGEVR}

${\footnote \pard\plain \sl240 \fs20 $ CHANGEVR}

+{\footnote \pard\plain \sl240 \fs20 + g40:1246}

 K{\footnote \pard\plain \sl240 \fs20 K CHANGEVR package;package}

}{\b\f2 CHANGEVR}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
Author: G. Ucoluk 
\par 
\par 
This package provides facilities for changing the independent variables in 
a differential equation. It is basically the application of the chain rule. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # COMPACT}

${\footnote \pard\plain \sl240 \fs20 $ COMPACT}

+{\footnote \pard\plain \sl240 \fs20 + g40:1247}

 K{\footnote \pard\plain \sl240 \fs20 K simplification;COMPACT package;package}

}{\b\f2 COMPACT}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Anthony C. Hearn 
\par 
\par 
COMPACT is a package of functions for the reduction of a polynomial in the 
presence of side relations. COMPACT applies the side relations to the 
polynomial so that an equivalent expression results with as few terms as 
possible. For example, the evaluation of 
\par 
\par 
\pard \tx3420 }{\f4  \par
     compact(s*(1-sin x^2)+c*(1-cos x^2)+sin x^2+cos x^2, \par
             \{cos x^2+sin x^2=1\}); \par
 \par
\pard \sl240 }{\f2 yields the result 
\pard \tx3420 }{\f4  \par
 \par
              2           2 \par
        SIN(X) *C + COS(X) *S + 1 \par
\pard \sl240 }{\f2 \par 
\par 
The first argument to the operator }{\f3 compact} {\f2  is the expression 
and the second is a list of side relations that can be 
equations or simple expressions (implicitly equated to zero). The 
kernels in the side relations may also be free variables with the 
same meaning as in rules, e.g. 
\pard \tx3420 }{\f4  \par
     sin_cos_identity :=  \{cos ~w^2+sin ~w^2=1\}$ \par
     compact(u,in_cos_identity); \par
\pard \sl240 }{\f2 \par 
\par 
Also the full rule syntax with the replacement operator is allowed here. 
 \par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CRACK}

${\footnote \pard\plain \sl240 \fs20 $ CRACK}

+{\footnote \pard\plain \sl240 \fs20 + g40:1248}

 K{\footnote \pard\plain \sl240 \fs20 K differential equation;CRACK package;package}

}{\b\f2 CRACK}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Authors: Andreas Brand, Thomas Wolf 
\par 
\par 
CRACK is a package for solving overdetermined systems of partial or 
ordinary differential equations (PDEs, ODEs). Examples of programs which 
make use of CRACK for investigating ODEs (finding symmetries, first 
integrals, an equivalent Lagrangian or a ``differential factorization'') are 
included. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # CVIT}

${\footnote \pard\plain \sl240 \fs20 $ CVIT}

+{\footnote \pard\plain \sl240 \fs20 + g40:1249}

 K{\footnote \pard\plain \sl240 \fs20 K Dirac algebra;CVIT package;package}

}{\b\f2 CVIT}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Authors: V.Ilyin, A.Kryukov, A.Rodionov, A.Taranov 
\par 
\par 
This package provides an alternative method for computing traces of Dirac 
gamma matrices, based on an algorithm by Cvitanovich that treats gamma 
matrices as 3-j symbols. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DEFINT}

${\footnote \pard\plain \sl240 \fs20 $ DEFINT}

+{\footnote \pard\plain \sl240 \fs20 + g40:1250}

 K{\footnote \pard\plain \sl240 \fs20 K definite integration;DEFINT package;package}

}{\b\f2 DEFINT}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Authors: Kerry Gaskell, Stanley M. Kameny, Winfried Neun 
\par 
\par 
This package finds the definite integral of an expression in a stated 
interval. It uses several techniques, including an innovative approach 
based on the Meijer G-function, and contour integration. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DESIR}

${\footnote \pard\plain \sl240 \fs20 $ DESIR}

+{\footnote \pard\plain \sl240 \fs20 + g40:1251}

 K{\footnote \pard\plain \sl240 \fs20 K differential equation;DESIR package;package}

}{\b\f2 DESIR}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Authors: C. Dicrescenzo, F. Richard-Jung, E. Tournier 
\par 
\par 
This package enables the basis of formal solutions to be computed for an 
ordinary homogeneous differential equation with polynomial coefficients 
over Q of any order, in the neighborhood of zero (regular or irregular 
singular point, or ordinary point). 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DFPART}

${\footnote \pard\plain \sl240 \fs20 $ DFPART}

+{\footnote \pard\plain \sl240 \fs20 + g40:1252}

 K{\footnote \pard\plain \sl240 \fs20 K partial derivative;DFPART package;package}

}{\b\f2 DFPART}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Herbert Melenk 
\par 
\par 
This package supports computations with total and partial derivatives of 
formal function objects. Such computations can be useful in the context 
of differential equations or power series expansions. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # DUMMY}

${\footnote \pard\plain \sl240 \fs20 $ DUMMY}

+{\footnote \pard\plain \sl240 \fs20 + g40:1253}

 K{\footnote \pard\plain \sl240 \fs20 K dummy variable;DUMMY package;package}

}{\b\f2 DUMMY}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Alain Dresse 
\par 
\par 
This package allows a user to find the canonical form of expressions 
involving dummy variables. In that way, the simplification of 
polynomial expressions can be fully done. The indeterminates are general 
operator objects endowed with as few properties as possible. In that way 
the package may be used in a large spectrum of applications. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EXCALC}

${\footnote \pard\plain \sl240 \fs20 $ EXCALC}

+{\footnote \pard\plain \sl240 \fs20 + g40:1254}

 K{\footnote \pard\plain \sl240 \fs20 K differential form;differential calculus;exterior calculus;EXCALC package;package}

}{\b\f2 EXCALC}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Eberhard Schruefer 
\par 
\par 
The }{\f3 excalc} {\f2  package is designed for easy use by all who are familiar 
with the calculus of Modern Differential Geometry. The program is currently 
able to handle scalar-valued exterior forms, vectors and operations between 
them, as well as non-scalar valued forms (indexed forms). It is thus an ideal 
tool for studying differential equations, doing calculations in general 
relativity and field theories, or doing simple things such as calculating the 
Laplacian of a tensor field for an arbitrary given frame. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FPS}

${\footnote \pard\plain \sl240 \fs20 $ FPS}

+{\footnote \pard\plain \sl240 \fs20 + g40:1255}

 K{\footnote \pard\plain \sl240 \fs20 K Laurent-Puiseux series;power series;FPS package;package}

}{\b\f2 FPS}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Authors: Wolfram Koepf, Winfried Neun 
\par 
\par 
This package can expand a specific class of functions into their 
corresponding Laurent-Puiseux series. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # FIDE}

${\footnote \pard\plain \sl240 \fs20 $ FIDE}

+{\footnote \pard\plain \sl240 \fs20 + g40:1256}

 K{\footnote \pard\plain \sl240 \fs20 K FIDE package;package}

}{\b\f2 FIDE}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
Author: Richard Liska 
\par 
\par 
This package performs automation of the process of numerically 
solving partial differential equations systems (PDES) by means of 
computer algebra. For PDES solving, the finite difference method is applied. 
The computer algebra system REDUCE and the numerical programming 
language FORTRAN are used in the presented methodology. The main aim of 
this methodology is to speed up the process of preparing numerical 
programs for solving PDES. This process is quite often, especially for 
complicated systems, a tedious and time consuming task. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # GENTRAN}

${\footnote \pard\plain \sl240 \fs20 $ GENTRAN}

+{\footnote \pard\plain \sl240 \fs20 + g40:1257}

 K{\footnote \pard\plain \sl240 \fs20 K C;FORTRAN;code generation;GENTRAN package;package}

}{\b\f2 GENTRAN}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Barbara L. Gates 
\par 
\par 
This package is an automatic code GENerator and TRANslator. It constructs 
complete numerical programs based on sets of algorithmic specifications and 
symbolic expressions. Formatted FORTRAN, RATFOR or C code can be generated 
through a series of interactive commands or under the control of a template 
processing routine. Large expressions can be automatically segmented into 
subexpressions of manageable size, and a special file-handling mechanism 
maintains stacks of open I/O channels to allow output to be sent to any 
number of files simultaneously and to facilitate recursive invocation of the 
whole code generation process. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # IDEALS}

${\footnote \pard\plain \sl240 \fs20 $ IDEALS}

+{\footnote \pard\plain \sl240 \fs20 + g40:1258}

 K{\footnote \pard\plain \sl240 \fs20 K ideal;commutative algebra;Groebner;polynomial;IDEALS package;package}

}{\b\f2 IDEALS}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Herbert Melenk 
\par 
\par 
This package implements the basic arithmetic for polynomial ideals by 
exploiting the Groebner bases package of REDUCE. In order to save 
computing time all intermediate Groebner bases are stored internally such 
that time consuming repetitions are inhibited. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # INEQ}

${\footnote \pard\plain \sl240 \fs20 $ INEQ}

+{\footnote \pard\plain \sl240 \fs20 + g40:1259}

 K{\footnote \pard\plain \sl240 \fs20 K inequality;INEQ package;package}

}{\b\f2 INEQ}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Herbert Melenk 
\par 
\par 
This package supports the operator }{\f3 ineq_solve} {\f2  that 
attempts to solve single inequalities and sets of coupled inequalities. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # INVBASE}

${\footnote \pard\plain \sl240 \fs20 $ INVBASE}

+{\footnote \pard\plain \sl240 \fs20 + g40:1260}

 K{\footnote \pard\plain \sl240 \fs20 K INVBASE package;package}

}{\b\f2 INVBASE}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
Authors: A.Yu. Zharkov and Yu.A. Blinkov 
\par 
\par 
Involutive bases are a new tool for solving problems in connection with 
multivariate polynomials, such as solving systems of polynomial equations 
and analyzing polynomial ideals. An involutive basis of a polynomial ideal 
is nothing more than a special form of a redundant Groebner basis. The 
construction of involutive bases reduces the problem of solving polynomial 
systems to simple linear algebra. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LAPLACE}

${\footnote \pard\plain \sl240 \fs20 $ LAPLACE}

+{\footnote \pard\plain \sl240 \fs20 + g40:1261}

 K{\footnote \pard\plain \sl240 \fs20 K transform;LAPLACE package;package}

}{\b\f2 LAPLACE}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Authors: C. Kazasov, M. Spiridonova, V. Tomov 
\par 
\par 
This package can calculate ordinary and inverse Laplace transforms of 
expressions. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # LIE}

${\footnote \pard\plain \sl240 \fs20 $ LIE}

+{\footnote \pard\plain \sl240 \fs20 + g40:1262}

 K{\footnote \pard\plain \sl240 \fs20 K LIE package;package}

}{\b\f2 LIE}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
Authors: Carsten and Franziska Sch"obel 
\par 
\par 
}{\f3 Lie} {\f2 is a package of functions for the classification of real 
n-dimensional Lie algebras. It consists of two modules: }{\f3 liendmc1} {\f2  
and }{\f3 lie1234} {\f2 . With the help of the functions in the }{\f3 liendmcl} {\f2  
module, real n-dimensional Lie algebras }{\f4 L}{\f2  with a derived algebra 
}{\f4 L^(1)}{\f2  of dimension 1 can be classified. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # MODSR}

${\footnote \pard\plain \sl240 \fs20 $ MODSR}

+{\footnote \pard\plain \sl240 \fs20 + g40:1263}

 K{\footnote \pard\plain \sl240 \fs20 K modular polynomial;MODSR package;package}

}{\b\f2 MODSR}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Herbert Melenk 
\par 
\par 
This package supports solve (M_SOLVE) and roots (M_ROOTS) operators for 
modular polynomials and modular polynomial systems. The moduli need not 
be primes. M_SOLVE requires a modulus to be set. M_ROOTS takes the 
modulus as a second argument. For example: 
\par 
\par 
\pard \tx3420 }{\f4  \par
on modular; setmod 8; \par
m_solve(2x=4);            ->  \{\{X=2\},\{X=6\}\} \par
m_solve(\{x^2-y^3=3\}); \par
    ->  \{\{X=0,Y=5\}, \{X=2,Y=1\}, \{X=4,Y=5\}, \{X=6,Y=1\}\} \par
m_solve(\{x=2,x^2-y^3=3\}); ->  \{\{X=2,Y=1\}\} \par
off modular; \par
m_roots(x^2-1,8);         ->  \{1,3,5,7\} \par
m_roots(x^3-x,7);         ->  \{0,1,6\} \par
\pard \sl240 }{\f2 

\page


#{\footnote \pard\plain \sl240 \fs20 # NCPOLY}

${\footnote \pard\plain \sl240 \fs20 $ NCPOLY}

+{\footnote \pard\plain \sl240 \fs20 + g40:1264}

 K{\footnote \pard\plain \sl240 \fs20 K non-commutativity;NCPOLY package;package}

}{\b\f2 NCPOLY}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Authors: Herbert Melenk, Joachim Apel 
\par 
\par 
This package allows the user to set up automatically a consistent 
environment for computing in an algebra where the non--commutativity is 
defined by Lie-bracket commutators. The package uses the REDUCE 
}{\f3 noncom} {\f2  mechanism for elementary polynomial arithmetic; the commutator 
rules are automatically computed from the Lie brackets. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ORTHOVEC}

${\footnote \pard\plain \sl240 \fs20 $ ORTHOVEC}

+{\footnote \pard\plain \sl240 \fs20 + g40:1265}

 K{\footnote \pard\plain \sl240 \fs20 K curl;grad;div;dot product;cross product;Taylor;Laplacian;vector calculus;vector algebra;ORTHOVEC package;package}

}{\b\f2 ORTHOVEC}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: James W. Eastwood 
\par 
\par 
}{\f3 orthovec} {\f2 is a collection of REDUCE procedures and operations which 
provide a simple-to-use environment for the manipulation of scalars and 
vectors. Operations include addition, subtraction, dot and cross 
products, division, modulus, div, grad, curl, laplacian, differentiation, 
integration, and Taylor expansion. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PHYSOP}

${\footnote \pard\plain \sl240 \fs20 $ PHYSOP}

+{\footnote \pard\plain \sl240 \fs20 + g40:1266}

 K{\footnote \pard\plain \sl240 \fs20 K PHYSOP package;package}

}{\b\f2 PHYSOP}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
Author: Mathias Warns 
\par 
\par 
This package has been designed to meet the requirements of theoretical 
physicists looking for a computer algebra tool to perform complicated 
calculations in quantum theory with expressions containing operators. 
These operations consist mainly of the calculation of commutators between 
operator expressions and in the evaluations of operator matrix elements in 
some abstract space. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # PM}

${\footnote \pard\plain \sl240 \fs20 $ PM}

+{\footnote \pard\plain \sl240 \fs20 + g40:1267}

 K{\footnote \pard\plain \sl240 \fs20 K pattern matching;PM package;package}

}{\b\f2 PM}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Kevin McIsaac 
\par 
\par 
PM is a general pattern matcher similar in style to those found in systems 
such as SMP and Mathematica, and is based on the pattern matcher described 
in Kevin McIsaac, ``Pattern Matching Algebraic Identities'', SIGSAM Bulletin, 
19 (1985), 4-13. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RANDPOLY}

${\footnote \pard\plain \sl240 \fs20 $ RANDPOLY}

+{\footnote \pard\plain \sl240 \fs20 + g40:1268}

 K{\footnote \pard\plain \sl240 \fs20 K random polynomial;RANDPOLY package;package}

}{\b\f2 RANDPOLY}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Francis J. Wright 
\par 
\par 
This package is based on a port of the Maple random polynomial 
generator together with some support facilities for the generation 
of random numbers and anonymous procedures. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # REACTEQN}

${\footnote \pard\plain \sl240 \fs20 $ REACTEQN}

+{\footnote \pard\plain \sl240 \fs20 + g40:1269}

 K{\footnote \pard\plain \sl240 \fs20 K chemical reaction;REACTEQN package;package}

}{\b\f2 REACTEQN}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Herbert Melenk 
\par 
\par 
This package allows a user to transform chemical reaction systems into 
ordinary differential equation systems (ODE) corresponding to the laws of 
pure mass action. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RESET}

${\footnote \pard\plain \sl240 \fs20 $ RESET}

+{\footnote \pard\plain \sl240 \fs20 + g40:1270}

 K{\footnote \pard\plain \sl240 \fs20 K RESET package;package}

}{\b\f2 RESET}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
Author: John Fitch 
\par 
\par 
This package defines a command command RESETREDUCE that works through the 
history of previous commands, and clears any values which have been 
assigned, plus any rules, arrays and the like. It also sets the various 
switches to their initial values. It is not complete, but does work for 
most things that cause a gradual loss of space. It would be relatively 
easy to make it interactive, so allowing for selective resetting. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RESIDUE}

${\footnote \pard\plain \sl240 \fs20 $ RESIDUE}

+{\footnote \pard\plain \sl240 \fs20 + g40:1271}

 K{\footnote \pard\plain \sl240 \fs20 K RESIDUE package;package}

}{\b\f2 RESIDUE}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
Author: Wolfram Koepf 
\par 
\par 
This package supports the calculation of residues of arbitrary 
expressions. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # RLFI}

${\footnote \pard\plain \sl240 \fs20 $ RLFI}

+{\footnote \pard\plain \sl240 \fs20 + g40:1272}

 K{\footnote \pard\plain \sl240 \fs20 K TEX;output;RLFI package;package}

}{\b\f2 RLFI}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Richard Liska 
\par 
\par 
This package 
adds LaTeX syntax 
to REDUCE. Text generated by REDUCE in this mode can be directly 
used in LaTeX source 
documents. Various 
mathematical constructions are supported by the interface including 
subscripts, superscripts, font changing, Greek letters, divide-bars, 
integral and sum signs, derivatives, and so on. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SCOPE}

${\footnote \pard\plain \sl240 \fs20 $ SCOPE}

+{\footnote \pard\plain \sl240 \fs20 + g40:1273}

 K{\footnote \pard\plain \sl240 \fs20 K optimization;code generation;SCOPE package;package}

}{\b\f2 SCOPE}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: J.A. van Hulzen 
\par 
\par 
SCOPE is a package for the production of an optimized form of a set of 
expressions. It applies an heuristic search for common (sub)expressions 
to almost any set of proper REDUCE assignment statements. The output is 
obtained as a sequence of assignment statements. }{\f3 gentran} {\f2  is used to 
facilitate expression output. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SETS}

${\footnote \pard\plain \sl240 \fs20 $ SETS}

+{\footnote \pard\plain \sl240 \fs20 + g40:1274}

 K{\footnote \pard\plain \sl240 \fs20 K SETS package;package}

}{\b\f2 SETS}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
Author: Francis J. Wright 
\par 
\par 
The SETS package provides algebraic-mode support for set operations on 
lists regarded as sets (or representing explicit sets) and on implicit 
sets represented by identifiers. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SPDE}

${\footnote \pard\plain \sl240 \fs20 $ SPDE}

+{\footnote \pard\plain \sl240 \fs20 + g40:1275}

 K{\footnote \pard\plain \sl240 \fs20 K Lie symmetry;differential equation;SPDE package;package}

}{\b\f2 SPDE}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Fritz Schwartz 
\par 
\par 
The package }{\f3 spde} {\f2  provides a set of functions which may be used to 
determine the symmetry group of Lie- or point-symmetries of a given system of 
partial differential equations. In many cases the determining system is 
solved completely automatically. In other cases the user has to provide 
additional input information for the solution algorithm to terminate. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # SYMMETRY}

${\footnote \pard\plain \sl240 \fs20 $ SYMMETRY}

+{\footnote \pard\plain \sl240 \fs20 + g40:1276}

 K{\footnote \pard\plain \sl240 \fs20 K SYMMETRY package;package}

}{\b\f2 SYMMETRY}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
Author: Karin Gatermann 
\par 
\par 
This package computes symmetry-adapted bases and block diagonal forms of 
matrices which have the symmetry of a group. The package is the 
implementation of the theory of linear representations for small finite 
groups such as the dihedral groups. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TPS}

${\footnote \pard\plain \sl240 \fs20 $ TPS}

+{\footnote \pard\plain \sl240 \fs20 + g40:1277}

 K{\footnote \pard\plain \sl240 \fs20 K Taylor series;power series;TPS package;package}

}{\b\f2 TPS}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Authors: Alan Barnes, Julian Padget 
\par 
\par 
This package implements formal Laurent series expansions in one variable 
using the domain mechanism of REDUCE. This means that power series 
objects can be added, multiplied, differentiated etc., like other first 
class objects in the system. A lazy evaluation scheme is used and thus 
terms of the series are not evaluated until they are required for printing 
or for use in calculating terms in other power series. The series are 
extendible giving the user the impression that the full infinite series is 
being manipulated. The errors that can sometimes occur using series that 
are truncated at some fixed depth (for example when a term in the required 
series depends on terms of an intermediate series beyond the truncation 
depth) are thus avoided. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TRI}

${\footnote \pard\plain \sl240 \fs20 $ TRI}

+{\footnote \pard\plain \sl240 \fs20 + g40:1278}

 K{\footnote \pard\plain \sl240 \fs20 K TEX;output;TRI package;package}

}{\b\f2 TRI}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Werner Antweiler 
\par 
\par 
This package provides facilities written in REDUCE-Lisp for typesetting 
REDUCE formulas 
using TeX. The 
TeX-REDUCE-Interface incorporates three levels 
of TeX output: 
without line breaking, with line breaking, and 
with line breaking plus indentation. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # TRIGSIMP}

${\footnote \pard\plain \sl240 \fs20 $ TRIGSIMP}

+{\footnote \pard\plain \sl240 \fs20 + g40:1279}

 K{\footnote \pard\plain \sl240 \fs20 K simplification;TRIGSIMP package;package}

}{\b\f2 TRIGSIMP}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Wolfram Koepf 
\par 
\par 
TRIGSIMP is a useful tool for all kinds of trigonometric and hyperbolic 
simplification and factorization. There are three procedures included in 
TRIGSIMP: }{\f3 trigsimp} {\f2 , }{\f3 trigfactorize} {\f2  and }{\f3 triggcd} {\f2 . The 
first is for finding simplifications of trigonometric or hyperbolic 
expressions with many options, the second for factorizing them and the 
third for finding the greatest common divisor of two trigonometric or 
hyperbolic polynomials. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # XCOLOR}

${\footnote \pard\plain \sl240 \fs20 $ XCOLOR}

+{\footnote \pard\plain \sl240 \fs20 + g40:1280}

 K{\footnote \pard\plain \sl240 \fs20 K high energy physics;XCOLOR package;package}

}{\b\f2 XCOLOR}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: A. Kryukov 
\par 
\par 
This package calculates the color factor in non-abelian gauge field 
theories using an algorithm due to Cvitanovich. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # XIDEAL}

${\footnote \pard\plain \sl240 \fs20 $ XIDEAL}

+{\footnote \pard\plain \sl240 \fs20 + g40:1281}

 K{\footnote \pard\plain \sl240 \fs20 K Groebner basis;XIDEAL package;package}

}{\b\f2 XIDEAL}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: David Hartley 
\par 
\par 
}{\f3 xideal} {\f2 constructs Groebner bases for solving the left ideal 
membership problem: Groebner left ideal bases or GLIBs. For graded 
ideals, where each form is homogeneous in degree, the distinction between 
left and right ideals vanishes. Furthermore, if the generating forms are 
all homogeneous, then the Groebner bases for the non-graded and graded 
ideals are identical. In this case, }{\f3 xideal} {\f2  is able to save time by 
truncating the Groebner basis at some maximum degree if desired. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # WU}

${\footnote \pard\plain \sl240 \fs20 $ WU}

+{\footnote \pard\plain \sl240 \fs20 + g40:1282}

 K{\footnote \pard\plain \sl240 \fs20 K Wu-Wen-Tsun algorithm;polynomial;WU package;package}

}{\b\f2 WU}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Author: Russell Bradford 
\par 
\par 
This is a simple implementation of the Wu algorithm implemented in REDUCE 
working directly from ``A Zero Structure Theorem for 
Polynomial-Equations-Solving,'' Wu Wen-tsun, Institute of Systems Science, 
Academia Sinica, Beijing. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ZEILBERG}

${\footnote \pard\plain \sl240 \fs20 $ ZEILBERG}

+{\footnote \pard\plain \sl240 \fs20 + g40:1283}

 K{\footnote \pard\plain \sl240 \fs20 K summation;ZEILBERG package;package}

}{\b\f2 ZEILBERG}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
 \par 
\par 
Authors: Gregor St"olting and Wolfram Koepf 
\par 
\par 
This package is a careful implementation of the Gosper and Zeilberger 
algorithms for indefinite and definite summation of hypergeometric terms, 
respectively. Extensions of these algorithms are also included that are 
valid for ratios of products of powers, 
factorials, gamma function 
terms, binomial coefficients, and shifted factorials that are 
rational-linear in their arguments. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ZTRANS}

${\footnote \pard\plain \sl240 \fs20 $ ZTRANS}

+{\footnote \pard\plain \sl240 \fs20 + g40:1284}

 K{\footnote \pard\plain \sl240 \fs20 K ZTRANS package;package}

}{\b\f2 ZTRANS}{\f2 \tab \tab \tab \tab }{\b\f2 package}{\f2 \par 
\par 
 
Authors: Wolfram Koepf, Lisa Temme 
\par 
\par 
This package is an implementation of the Z-transform of a sequence. 
This is the discrete analogue of the Laplace Transform. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g40}

${\footnote \pard\plain \sl240 \fs20 $ Miscellaneous Packages}

+{\footnote \pard\plain \sl240 \fs20 + index:0040}
}{\b\f2 Miscellaneous Packages}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb Miscellaneous Packages introduction}
{\v\f2 Miscellaneous_Packages}{\f2 \par 
}{\f2 \tab}{\f2\uldb ALGINT package}
{\v\f2 ALGINT_package}{\f2 \par 
}{\f2 \tab}{\f2\uldb APPLYSYM package}
{\v\f2 APPLYSYM}{\f2 \par 
}{\f2 \tab}{\f2\uldb ARNUM package}
{\v\f2 ARNUM}{\f2 \par 
}{\f2 \tab}{\f2\uldb ASSIST package}
{\v\f2 ASSIST}{\f2 \par 
}{\f2 \tab}{\f2\uldb AVECTOR package}
{\v\f2 AVECTOR}{\f2 \par 
}{\f2 \tab}{\f2\uldb BOOLEAN package}
{\v\f2 BOOLEAN}{\f2 \par 
}{\f2 \tab}{\f2\uldb CALI package}
{\v\f2 CALI}{\f2 \par 
}{\f2 \tab}{\f2\uldb CAMAL package}
{\v\f2 CAMAL}{\f2 \par 
}{\f2 \tab}{\f2\uldb CHANGEVR package}
{\v\f2 CHANGEVR}{\f2 \par 
}{\f2 \tab}{\f2\uldb COMPACT package}
{\v\f2 COMPACT}{\f2 \par 
}{\f2 \tab}{\f2\uldb CRACK package}
{\v\f2 CRACK}{\f2 \par 
}{\f2 \tab}{\f2\uldb CVIT package}
{\v\f2 CVIT}{\f2 \par 
}{\f2 \tab}{\f2\uldb DEFINT package}
{\v\f2 DEFINT}{\f2 \par 
}{\f2 \tab}{\f2\uldb DESIR package}
{\v\f2 DESIR}{\f2 \par 
}{\f2 \tab}{\f2\uldb DFPART package}
{\v\f2 DFPART}{\f2 \par 
}{\f2 \tab}{\f2\uldb DUMMY package}
{\v\f2 DUMMY}{\f2 \par 
}{\f2 \tab}{\f2\uldb EXCALC package}
{\v\f2 EXCALC}{\f2 \par 
}{\f2 \tab}{\f2\uldb FPS package}
{\v\f2 FPS}{\f2 \par 
}{\f2 \tab}{\f2\uldb FIDE package}
{\v\f2 FIDE}{\f2 \par 
}{\f2 \tab}{\f2\uldb GENTRAN package}
{\v\f2 GENTRAN}{\f2 \par 
}{\f2 \tab}{\f2\uldb IDEALS package}
{\v\f2 IDEALS}{\f2 \par 
}{\f2 \tab}{\f2\uldb INEQ package}
{\v\f2 INEQ}{\f2 \par 
}{\f2 \tab}{\f2\uldb INVBASE package}
{\v\f2 INVBASE}{\f2 \par 
}{\f2 \tab}{\f2\uldb LAPLACE package}
{\v\f2 LAPLACE}{\f2 \par 
}{\f2 \tab}{\f2\uldb LIE package}
{\v\f2 LIE}{\f2 \par 
}{\f2 \tab}{\f2\uldb MODSR package}
{\v\f2 MODSR}{\f2 \par 
}{\f2 \tab}{\f2\uldb NCPOLY package}
{\v\f2 NCPOLY}{\f2 \par 
}{\f2 \tab}{\f2\uldb ORTHOVEC package}
{\v\f2 ORTHOVEC}{\f2 \par 
}{\f2 \tab}{\f2\uldb PHYSOP package}
{\v\f2 PHYSOP}{\f2 \par 
}{\f2 \tab}{\f2\uldb PM package}
{\v\f2 PM}{\f2 \par 
}{\f2 \tab}{\f2\uldb RANDPOLY package}
{\v\f2 RANDPOLY}{\f2 \par 
}{\f2 \tab}{\f2\uldb REACTEQN package}
{\v\f2 REACTEQN}{\f2 \par 
}{\f2 \tab}{\f2\uldb RESET package}
{\v\f2 RESET}{\f2 \par 
}{\f2 \tab}{\f2\uldb RESIDUE package}
{\v\f2 RESIDUE}{\f2 \par 
}{\f2 \tab}{\f2\uldb RLFI package}
{\v\f2 RLFI}{\f2 \par 
}{\f2 \tab}{\f2\uldb SCOPE package}
{\v\f2 SCOPE}{\f2 \par 
}{\f2 \tab}{\f2\uldb SETS package}
{\v\f2 SETS}{\f2 \par 
}{\f2 \tab}{\f2\uldb SPDE package}
{\v\f2 SPDE}{\f2 \par 
}{\f2 \tab}{\f2\uldb SYMMETRY package}
{\v\f2 SYMMETRY}{\f2 \par 
}{\f2 \tab}{\f2\uldb TPS package}
{\v\f2 TPS}{\f2 \par 
}{\f2 \tab}{\f2\uldb TRI package}
{\v\f2 TRI}{\f2 \par 
}{\f2 \tab}{\f2\uldb TRIGSIMP package}
{\v\f2 TRIGSIMP}{\f2 \par 
}{\f2 \tab}{\f2\uldb XCOLOR package}
{\v\f2 XCOLOR}{\f2 \par 
}{\f2 \tab}{\f2\uldb XIDEAL package}
{\v\f2 XIDEAL}{\f2 \par 
}{\f2 \tab}{\f2\uldb WU package}
{\v\f2 WU}{\f2 \par 
}{\f2 \tab}{\f2\uldb ZEILBERG package}
{\v\f2 ZEILBERG}{\f2 \par 
}{\f2 \tab}{\f2\uldb ZTRANS package}
{\v\f2 ZTRANS}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # ED}

${\footnote \pard\plain \sl240 \fs20 $ ED}

+{\footnote \pard\plain \sl240 \fs20 + g41:1285}

 K{\footnote \pard\plain \sl240 \fs20 K ED command;command}

}{\b\f2 ED}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
The }{\f3 ed} {\f2  command invokes a simple line editor for REDUCE input 
statements. 
\par 
\par 
 \par
syntax: \par
}{\f4 }{\f3 ed} {\f4 <integer> or }{\f3 ed} {\f4  
\par 
\par 
}{\f2 \par 
}{\f3 ed} {\f2 called with no argument edits the last input statement. If 
<integer> is greater than or equal to the current line number, an error 
message is printed. Reenter a proper }{\f3 ed} {\f2  command or return to the 
top level with a semicolon. 
\par 
\par 
The editor formats REDUCE's version of the desired input statement, 
dividing it into lines at semicolons and dollar signs. The statement is 
printed at the beginning of the edit session. The editor works on one 
line at a time, and has a pointer (shown by }{\f3 ^} {\f2 ) to the current 
character of that line. When the session begins, the pointer is at the 
left hand side of the first line. The editing prompt is }{\f3 >} {\f2 . 
\par 
\par 
The following commands are available. They may be entered in either upper 
or lower case. All commands are activated by the carriage return, which 
also prints out the current line after changes. Several commands can be 
placed on a single line, except that commands terminated by an }{\f3 ESC} {\f2  
must be the last command before the carriage return. 
\par 
\par 
\tab b 
Move pointer to beginning of current line. 
\par 
\par 
\tab d<digit> 
Delete current character and next (digit-1) characters. An error message 
is printed if anything other than a single digit follows d. If there are 
fewer than <digit> characters left on the line, all but the final 
dollar sign or semicolon is removed. To delete a line completely, use the 
k command. 
\par 
\par 
\tab e 
End the current session, causing the edited expression to be reparsed by 
REDUCE. 
\par 
\par 
\tab f<char> 
Find the next occurrence of the character <char> to the right of the 
pointer on the current line and move the pointer to it. If the character is 
not found, an error message is printed and the pointer remains in its 
original position. Other lines are not searched. The f command is not 
case-sensitive. 
\par 
\par 
\tab i<string>}{\f3 ESC} {\f2  
Insert <string> in front of pointer. The }{\f3 ESC} {\f2  key is your 
delimiter for the input string. No other command may follow this one on 
the same line. 
\par 
\par 
\tab k 
Kill rest of the current line, including the semicolon or dollar sign 
terminator. If there are characters remaining on the current line, and it 
is the last line of the input statement, a semicolon is added to the line 
as a terminator for REDUCE. If the current line is now empty, one of the 
following actions is performed: If there is a following line, it becomes 
the current line and the pointer is placed at its first character. If the 
current line was the final line of the statement, and there is a previous 
line, the previous line becomes the current line. If the current line was 
the only line of the statement, and it is empty, a single semicolon is 
inserted for REDUCE to parse. 
\par 
\par 
\tab l 
Finish editing this line and move to the last previous line. An error message 
is printed if there is no previous line. 
\par 
\par 
\tab n 
Finish editing this line and move to the next line. An error message is 
printed if there is no next line. 
\par 
\par 
\tab p 
Print out all the lines of the statement. Then a dotted line is printed, and 
the current line is reprinted, with the pointer under it. 
\par 
\par 
\tab q 
Quit the editing session without saving the changes. If a semicolon is 
entered after q, a new line prompt is given, otherwise REDUCE prompts you 
for another command. Whatever you type in to the prompt appearing after 
the q is entered is stored as the input for the line number in which you 
called the edit. Thus if you enter a semicolon, neither }
{\f2\uldb input}{\v\f2 INPUT} 
{\f2  
}{\f3 ed} {\f2  will find anything under the current number. 
\par 
\par 
\tab r<char> 
Replace the character at the pointer by <char>. 
\par 
\par 
\tab s<string>}{\f3 ESC} {\f2  
Search for the first occurrence of <string> to the right of the 
pointer on the current line and move the pointer to its first character. 
The }{\f3 ESC} {\f2  key is your delimiter for the input string. The s function 
does not search other lines of the statement. If the string is not found, 
an error message is printed and the pointer remains in its original 
position. The s command is not case-sensitive. No other command may 
follow this one on the same line. 
\par 
\par 
\tab x <or space> 
Move the pointer one character to the right. If the pointer is already at 
the end of the line, an error message is printed. 
\par 
\par 
\tab - <(minus)> 
Move the pointer one character to the left. If the pointer is already at the 
beginning of the line, an error message is printed. 
\par 
\par 
\tab ? 
Display the Help menu, showing the commands and their actions. 
\par 
\par 
 \par
examples: \par
\pard \tx3420 }{\f4 \pard \sl240 }{\f2 (Line numbers are shown in the following examples)}{\f4 \pard \tx3420   \par
 \par
2: >>x**2 + y;  \par
 \par
X^\{2\} + Y  \par
 \par
3: >>ed 2;  \par
 \par
  X**2 + Y;  \par
 \par
  ^  \par
 \par
For help, type '?'  \par
 \par
?-                  (Enter three spaces and \key\{Return\})  \par
 \par
  X**2 + Y;  \par
 \par
     ^  \par
 \par
?- r5  \par
 \par
  X**5 + Y;  \par
 \par
     ^  \par
 \par
?- fY  \par
 \par
  X**5 + Y;  \par
 \par
	 ^  \par
 \par
?- iabc (Terminate with \key\{ESC\} and \key\{Return\})  \par
 \par
  X**5 + abcY;  \par
 \par
	    ^  \par
 \par
?- ----  \par
 \par
  X**5 + abcY;  \par
 \par
	^  \par
 \par
?- fbd2  \par
 \par
  X**5 + aY;  \par
 \par
	  ^  \par
 \par
?- b  \par
 \par
  X**5 + aY;  \par
 \par
  ^  \par
 \par
?- e  \par
 \par
AY + X^\{5\}  \par
 \par
4: >>procedure dumb(a);  \par
 \par
>>write a;  \par
 \par
DUMB  \par
 \par
5: >>dumb(17);  \par
 \par
17  \par
 \par
6: >>ed 4;  \par
 \par
  PROCEDURE DUMB (A);  \par
 \par
  ^  \par
 \par
WRITE A;  \par
 \par
?- fArBn  \par
 \par
  WRITE A;  \par
 \par
  ^  \par
 \par
?- ibegin scalar a; a := b + 10; (Type a space, \key\{ESC\}, and \key\{Return\})  \par
 \par
  begin scalar a; a := b + 10; WRITE A;  \par
 \par
?- f;i end \key\{ESC\}, \key\{Return\}  \par
 \par
  begin scalar b; b := a + 10; WRITE A end;  \par
 \par
					  ^  \par
 \par
?- p  \par
 \par
 PROCEDURE DUMB (B);  \par
 \par
 begin scalar b; b := a + 10; WRITE A end;  \par
 \par
 -  -  -  -  -  -  -  -  -  -  \par
 \par
  begin scalar b; b := a + 10; WRITE A end;  \par
 \par
					  ^  \par
 \par
?- e  \par
 \par
DUMB  \par
 \par
7: >>dumb(17);  \par
 \par
27  \par
 \par
8: >>  \par
 \par
\pard \sl240 }{\f2  
\par 
\par 
Note that REDUCE reparsed the procedure }{\f3 dumb} {\f2  and updated the 
definition. 
\par 
\par 
Since REDUCE divides the expression to be edited into lines at semicolons or 
dollar sign terminators, some lines may occupy more than one line of screen 
space. If the pointer is directly beneath the last line of text, it 
refers to the top line of text. If there is a blank line between the 
last line of text and the pointer, it refers to the second line 
of text, and likewise for cases of greater than two lines of text. In other 
words, the entire REDUCE statement up to the next terminator is printed, even 
if it runs to several lines, then the pointer line is printed. 
\par 
\par 
You can insert new statements which contain semicolons of their own into the 
current line. They are run into the current line where you placed them 
until you edit the statement again. REDUCE will understand the set of 
statements if the syntax is correct. 
\par 
\par 
If you leave out needed closing brackets when you exit the editor, a message 
is printed allowing you to redo the edit (you can edit the previous line 
number and return to where you were). If you leave out a closing 
double-quotation mark, an error message is printed, and the editing must be 
redone from the original version; the edited version has been destroyed. 
Most syntax errors which you inadvertently leave in an edited statement are 
caught as usual by the REDUCE parser, and you will be able to re-edit the 
statement. 
\par 
\par 
When the editor processes a previous statement for your editing, escape 
characters are removed. Most special characters that you may use in 
identifiers are printed in legal fashion, prefixed by the exclamation 
point. Be sure to treat the special character and its escape as a pair in 
your editing. The characters }{\f3 ( ) # ; ' `} {\f2  are different. Since 
they have special meaning in Lisp, they are double-escaped in the editor. 
It is unwise to use these characters inside identifiers anyway, due to the 
probability of confusion. 
\par 
\par 
If you see a Lisp error message during editing, the edit has been aborted. 
Enter a semicolon and you will see a new line prompt. 
\par 
\par 
Since the editor has no dependence on any window system, it can be used if you 
are running REDUCE without windows. 
\par 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # EDITDEF}

${\footnote \pard\plain \sl240 \fs20 $ EDITDEF}

+{\footnote \pard\plain \sl240 \fs20 + g41:1286}

 K{\footnote \pard\plain \sl240 \fs20 K Top;Outmoded Operations;EDITDEF command;command}

}{\b\f2 EDITDEF}{\f2 \tab \tab \tab \tab }{\b\f2 command}{\f2 \par 
\par 
 
\par 
\par 
The interactive editor }
{\f2\uldb ed}{\v\f2 ED} 
{\f2  may be used to edit a user-defined 
procedure that has not been compiled. 
 \par
syntax: \par
}{\f4 \par 
\par 
}{\f3 editdef} {\f4 (}{\f3 identifier} {\f4 ) 
\par 
\par 
}{\f2 \par 
where }{\f3 identifier} {\f2  is the name of the procedure. When }{\f3 editdef} {\f2  
is invoked, the procedure definition will be displayed in editing mode, 
and may then be edited and redefined on exiting from the editor using 
standard }
{\f2\uldb ed}{\v\f2 ED} 
{\f2  commands. 
\par 
\par 


\page


#{\footnote \pard\plain \sl240 \fs20 # g41}

${\footnote \pard\plain \sl240 \fs20 $ Outmoded Operations}

+{\footnote \pard\plain \sl240 \fs20 + index:0041}
}{\b\f2 Outmoded Operations}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb ED command}
{\v\f2 ED}{\f2 \par 
}{\f2 \tab}{\f2\uldb EDITDEF command}
{\v\f2 EDITDEF}{\f2 \par 


\page


#{\footnote \pard\plain \sl240 \fs20 # main_index}

${\footnote \pard\plain \sl240 \fs20 $ Top}

+{\footnote \pard\plain \sl240 \fs20 + index:0001}
}{\b\f2 Top}{\f2 \par }\pard \sl240 {\f2 \par }
{\f2 \tab}{\f2\uldb Concepts}
{\v\f2 g2}{\f2 \par 
}{\f2 \tab}{\f2\uldb Variables}
{\v\f2 g3}{\f2 \par 
}{\f2 \tab}{\f2\uldb Syntax}
{\v\f2 g4}{\f2 \par 
}{\f2 \tab}{\f2\uldb Arithmetic Operations}
{\v\f2 g5}{\f2 \par 
}{\f2 \tab}{\f2\uldb Boolean Operators}
{\v\f2 g6}{\f2 \par 
}{\f2 \tab}{\f2\uldb General Commands}
{\v\f2 g7}{\f2 \par 
}{\f2 \tab}{\f2\uldb Algebraic Operators}
{\v\f2 g8}{\f2 \par 
}{\f2 \tab}{\f2\uldb Declarations}
{\v\f2 g9}{\f2 \par 
}{\f2 \tab}{\f2\uldb Input and Output}
{\v\f2 g10}{\f2 \par 
}{\f2 \tab}{\f2\uldb Elementary Functions}
{\v\f2 g11}{\f2 \par 
}{\f2 \tab}{\f2\uldb General Switches}
{\v\f2 g12}{\f2 \par 
}{\f2 \tab}{\f2\uldb Matrix Operations}
{\v\f2 g13}{\f2 \par 
}{\f2 \tab}{\f2\uldb Groebner package}
{\v\f2 g14}{\f2 \par 
}{\f2 \tab}{\f2\uldb High Energy Physics}
{\v\f2 g21}{\f2 \par 
}{\f2 \tab}{\f2\uldb Numeric Package}
{\v\f2 g22}{\f2 \par 
}{\f2 \tab}{\f2\uldb Roots Package}
{\v\f2 g23}{\f2 \par 
}{\f2 \tab}{\f2\uldb Special Functions}
{\v\f2 g24}{\f2 \par 
}{\f2 \tab}{\f2\uldb Taylor series}
{\v\f2 g36}{\f2 \par 
}{\f2 \tab}{\f2\uldb Gnuplot package}
{\v\f2 g37}{\f2 \par 
}{\f2 \tab}{\f2\uldb Linear Algebra package}
{\v\f2 g38}{\f2 \par 
}{\f2 \tab}{\f2\uldb Matrix Normal Forms}
{\v\f2 g39}{\f2 \par 
}{\f2 \tab}{\f2\uldb Miscellaneous Packages}
{\v\f2 g40}{\f2 \par 
}{\f2 \tab}{\f2\uldb Outmoded Operations}
{\v\f2 g41}{\f2 \par 


\page

}}
